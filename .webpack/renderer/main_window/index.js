/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/ansi-html-community/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ansi-html-community/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = ansiHTML;\n\n// Reference to https://github.com/sindresorhus/ansi-regex\nvar _regANSI = /(?:(?:\\u001b\\[)|\\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\\u001b[A-M]/;\nvar _defColors = {\n  reset: ['fff', '000'],\n  // [FOREGROUD_COLOR, BACKGROUND_COLOR]\n  black: '000',\n  red: 'ff0000',\n  green: '209805',\n  yellow: 'e8bf03',\n  blue: '0000ff',\n  magenta: 'ff00ff',\n  cyan: '00ffee',\n  lightgrey: 'f0f0f0',\n  darkgrey: '888'\n};\nvar _styles = {\n  30: 'black',\n  31: 'red',\n  32: 'green',\n  33: 'yellow',\n  34: 'blue',\n  35: 'magenta',\n  36: 'cyan',\n  37: 'lightgrey'\n};\nvar _openTags = {\n  '1': 'font-weight:bold',\n  // bold\n  '2': 'opacity:0.5',\n  // dim\n  '3': '<i>',\n  // italic\n  '4': '<u>',\n  // underscore\n  '8': 'display:none',\n  // hidden\n  '9': '<del>' // delete\n};\nvar _closeTags = {\n  '23': '</i>',\n  // reset italic\n  '24': '</u>',\n  // reset underscore\n  '29': '</del>' // reset delete\n};\n[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {\n  _closeTags[n] = '</span>';\n});\n\n/**\n * Converts text with ANSI color codes to HTML markup.\n * @param {String} text\n * @returns {*}\n */\nfunction ansiHTML(text) {\n  // Returns the text if the string has no ANSI escape code.\n  if (!_regANSI.test(text)) {\n    return text;\n  }\n\n  // Cache opened sequence.\n  var ansiCodes = [];\n  // Replace with markup.\n  var ret = text.replace(/\\033\\[(\\d+)m/g, function (match, seq) {\n    var ot = _openTags[seq];\n    if (ot) {\n      // If current sequence has been opened, close it.\n      if (!!~ansiCodes.indexOf(seq)) {\n        // eslint-disable-line no-extra-boolean-cast\n        ansiCodes.pop();\n        return '</span>';\n      }\n      // Open tag.\n      ansiCodes.push(seq);\n      return ot[0] === '<' ? ot : '<span style=\"' + ot + ';\">';\n    }\n    var ct = _closeTags[seq];\n    if (ct) {\n      // Pop sequence\n      ansiCodes.pop();\n      return ct;\n    }\n    return '';\n  });\n\n  // Make sure tags are closed.\n  var l = ansiCodes.length;\n  l > 0 && (ret += Array(l + 1).join('</span>'));\n  return ret;\n}\n\n/**\n * Customize colors.\n * @param {Object} colors reference to _defColors\n */\nansiHTML.setColors = function (colors) {\n  if (typeof colors !== 'object') {\n    throw new Error('`colors` parameter must be an Object.');\n  }\n  var _finalColors = {};\n  for (var key in _defColors) {\n    var hex = colors.hasOwnProperty(key) ? colors[key] : null;\n    if (!hex) {\n      _finalColors[key] = _defColors[key];\n      continue;\n    }\n    if ('reset' === key) {\n      if (typeof hex === 'string') {\n        hex = [hex];\n      }\n      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {\n        return typeof h !== 'string';\n      })) {\n        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000');\n      }\n      var defHexColor = _defColors[key];\n      if (!hex[0]) {\n        hex[0] = defHexColor[0];\n      }\n      if (hex.length === 1 || !hex[1]) {\n        hex = [hex[0]];\n        hex.push(defHexColor[1]);\n      }\n      hex = hex.slice(0, 2);\n    } else if (typeof hex !== 'string') {\n      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000');\n    }\n    _finalColors[key] = hex;\n  }\n  _setTags(_finalColors);\n};\n\n/**\n * Reset colors.\n */\nansiHTML.reset = function () {\n  _setTags(_defColors);\n};\n\n/**\n * Expose tags, including open and close.\n * @type {Object}\n */\nansiHTML.tags = {};\nif (Object.defineProperty) {\n  Object.defineProperty(ansiHTML.tags, 'open', {\n    get: function () {\n      return _openTags;\n    }\n  });\n  Object.defineProperty(ansiHTML.tags, 'close', {\n    get: function () {\n      return _closeTags;\n    }\n  });\n} else {\n  ansiHTML.tags.open = _openTags;\n  ansiHTML.tags.close = _closeTags;\n}\nfunction _setTags(colors) {\n  // reset all\n  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1];\n  // inverse\n  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0];\n  // dark grey\n  _openTags['90'] = 'color:#' + colors.darkgrey;\n  for (var code in _styles) {\n    var color = _styles[code];\n    var oriColor = colors[color] || '000';\n    _openTags[code] = 'color:#' + oriColor;\n    code = parseInt(code);\n    _openTags[(code + 10).toString()] = 'background:#' + oriColor;\n  }\n}\nansiHTML.reset();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5zaS1odG1sLWNvbW11bml0eS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBLG1EQUFtRCxJQUFJLFNBQVMsTUFBTSxJQUFJO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxVQUFVLCtCQUErQjtBQUNoRjtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlfYXBwLy4vbm9kZV9tb2R1bGVzL2Fuc2ktaHRtbC1jb21tdW5pdHkvaW5kZXguanM/YzQyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gYW5zaUhUTUw7XG5cbi8vIFJlZmVyZW5jZSB0byBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2Fuc2ktcmVnZXhcbnZhciBfcmVnQU5TSSA9IC8oPzooPzpcXHUwMDFiXFxbKXxcXHUwMDliKSg/Oig/OlswLTldezEsM30pPyg/Oig/OjtbMC05XXswLDN9KSopP1tBLU18Zi1tXSl8XFx1MDAxYltBLU1dLztcbnZhciBfZGVmQ29sb3JzID0ge1xuICByZXNldDogWydmZmYnLCAnMDAwJ10sXG4gIC8vIFtGT1JFR1JPVURfQ09MT1IsIEJBQ0tHUk9VTkRfQ09MT1JdXG4gIGJsYWNrOiAnMDAwJyxcbiAgcmVkOiAnZmYwMDAwJyxcbiAgZ3JlZW46ICcyMDk4MDUnLFxuICB5ZWxsb3c6ICdlOGJmMDMnLFxuICBibHVlOiAnMDAwMGZmJyxcbiAgbWFnZW50YTogJ2ZmMDBmZicsXG4gIGN5YW46ICcwMGZmZWUnLFxuICBsaWdodGdyZXk6ICdmMGYwZjAnLFxuICBkYXJrZ3JleTogJzg4OCdcbn07XG52YXIgX3N0eWxlcyA9IHtcbiAgMzA6ICdibGFjaycsXG4gIDMxOiAncmVkJyxcbiAgMzI6ICdncmVlbicsXG4gIDMzOiAneWVsbG93JyxcbiAgMzQ6ICdibHVlJyxcbiAgMzU6ICdtYWdlbnRhJyxcbiAgMzY6ICdjeWFuJyxcbiAgMzc6ICdsaWdodGdyZXknXG59O1xudmFyIF9vcGVuVGFncyA9IHtcbiAgJzEnOiAnZm9udC13ZWlnaHQ6Ym9sZCcsXG4gIC8vIGJvbGRcbiAgJzInOiAnb3BhY2l0eTowLjUnLFxuICAvLyBkaW1cbiAgJzMnOiAnPGk+JyxcbiAgLy8gaXRhbGljXG4gICc0JzogJzx1PicsXG4gIC8vIHVuZGVyc2NvcmVcbiAgJzgnOiAnZGlzcGxheTpub25lJyxcbiAgLy8gaGlkZGVuXG4gICc5JzogJzxkZWw+JyAvLyBkZWxldGVcbn07XG52YXIgX2Nsb3NlVGFncyA9IHtcbiAgJzIzJzogJzwvaT4nLFxuICAvLyByZXNldCBpdGFsaWNcbiAgJzI0JzogJzwvdT4nLFxuICAvLyByZXNldCB1bmRlcnNjb3JlXG4gICcyOSc6ICc8L2RlbD4nIC8vIHJlc2V0IGRlbGV0ZVxufTtcblswLCAyMSwgMjIsIDI3LCAyOCwgMzksIDQ5XS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gIF9jbG9zZVRhZ3Nbbl0gPSAnPC9zcGFuPic7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0ZXh0IHdpdGggQU5TSSBjb2xvciBjb2RlcyB0byBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gYW5zaUhUTUwodGV4dCkge1xuICAvLyBSZXR1cm5zIHRoZSB0ZXh0IGlmIHRoZSBzdHJpbmcgaGFzIG5vIEFOU0kgZXNjYXBlIGNvZGUuXG4gIGlmICghX3JlZ0FOU0kudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgLy8gQ2FjaGUgb3BlbmVkIHNlcXVlbmNlLlxuICB2YXIgYW5zaUNvZGVzID0gW107XG4gIC8vIFJlcGxhY2Ugd2l0aCBtYXJrdXAuXG4gIHZhciByZXQgPSB0ZXh0LnJlcGxhY2UoL1xcMDMzXFxbKFxcZCspbS9nLCBmdW5jdGlvbiAobWF0Y2gsIHNlcSkge1xuICAgIHZhciBvdCA9IF9vcGVuVGFnc1tzZXFdO1xuICAgIGlmIChvdCkge1xuICAgICAgLy8gSWYgY3VycmVudCBzZXF1ZW5jZSBoYXMgYmVlbiBvcGVuZWQsIGNsb3NlIGl0LlxuICAgICAgaWYgKCEhfmFuc2lDb2Rlcy5pbmRleE9mKHNlcSkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRyYS1ib29sZWFuLWNhc3RcbiAgICAgICAgYW5zaUNvZGVzLnBvcCgpO1xuICAgICAgICByZXR1cm4gJzwvc3Bhbj4nO1xuICAgICAgfVxuICAgICAgLy8gT3BlbiB0YWcuXG4gICAgICBhbnNpQ29kZXMucHVzaChzZXEpO1xuICAgICAgcmV0dXJuIG90WzBdID09PSAnPCcgPyBvdCA6ICc8c3BhbiBzdHlsZT1cIicgKyBvdCArICc7XCI+JztcbiAgICB9XG4gICAgdmFyIGN0ID0gX2Nsb3NlVGFnc1tzZXFdO1xuICAgIGlmIChjdCkge1xuICAgICAgLy8gUG9wIHNlcXVlbmNlXG4gICAgICBhbnNpQ29kZXMucG9wKCk7XG4gICAgICByZXR1cm4gY3Q7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSk7XG5cbiAgLy8gTWFrZSBzdXJlIHRhZ3MgYXJlIGNsb3NlZC5cbiAgdmFyIGwgPSBhbnNpQ29kZXMubGVuZ3RoO1xuICBsID4gMCAmJiAocmV0ICs9IEFycmF5KGwgKyAxKS5qb2luKCc8L3NwYW4+JykpO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEN1c3RvbWl6ZSBjb2xvcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29sb3JzIHJlZmVyZW5jZSB0byBfZGVmQ29sb3JzXG4gKi9cbmFuc2lIVE1MLnNldENvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgaWYgKHR5cGVvZiBjb2xvcnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgY29sb3JzYCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBPYmplY3QuJyk7XG4gIH1cbiAgdmFyIF9maW5hbENvbG9ycyA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gX2RlZkNvbG9ycykge1xuICAgIHZhciBoZXggPSBjb2xvcnMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNvbG9yc1trZXldIDogbnVsbDtcbiAgICBpZiAoIWhleCkge1xuICAgICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBfZGVmQ29sb3JzW2tleV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCdyZXNldCcgPT09IGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhleCA9IFtoZXhdO1xuICAgICAgfVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGhleCkgfHwgaGV4Lmxlbmd0aCA9PT0gMCB8fCBoZXguc29tZShmdW5jdGlvbiAoaCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGggIT09ICdzdHJpbmcnO1xuICAgICAgfSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGFuIEFycmF5IGFuZCBlYWNoIGl0ZW0gY291bGQgb25seSBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpO1xuICAgICAgfVxuICAgICAgdmFyIGRlZkhleENvbG9yID0gX2RlZkNvbG9yc1trZXldO1xuICAgICAgaWYgKCFoZXhbMF0pIHtcbiAgICAgICAgaGV4WzBdID0gZGVmSGV4Q29sb3JbMF07XG4gICAgICB9XG4gICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMSB8fCAhaGV4WzFdKSB7XG4gICAgICAgIGhleCA9IFtoZXhbMF1dO1xuICAgICAgICBoZXgucHVzaChkZWZIZXhDb2xvclsxXSk7XG4gICAgICB9XG4gICAgICBoZXggPSBoZXguc2xpY2UoMCwgMik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJyk7XG4gICAgfVxuICAgIF9maW5hbENvbG9yc1trZXldID0gaGV4O1xuICB9XG4gIF9zZXRUYWdzKF9maW5hbENvbG9ycyk7XG59O1xuXG4vKipcbiAqIFJlc2V0IGNvbG9ycy5cbiAqL1xuYW5zaUhUTUwucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIF9zZXRUYWdzKF9kZWZDb2xvcnMpO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgdGFncywgaW5jbHVkaW5nIG9wZW4gYW5kIGNsb3NlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuYW5zaUhUTUwudGFncyA9IHt9O1xuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ29wZW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX29wZW5UYWdzO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbnNpSFRNTC50YWdzLCAnY2xvc2UnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2Nsb3NlVGFncztcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgYW5zaUhUTUwudGFncy5vcGVuID0gX29wZW5UYWdzO1xuICBhbnNpSFRNTC50YWdzLmNsb3NlID0gX2Nsb3NlVGFncztcbn1cbmZ1bmN0aW9uIF9zZXRUYWdzKGNvbG9ycykge1xuICAvLyByZXNldCBhbGxcbiAgX29wZW5UYWdzWycwJ10gPSAnZm9udC13ZWlnaHQ6bm9ybWFsO29wYWNpdHk6MTtjb2xvcjojJyArIGNvbG9ycy5yZXNldFswXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFsxXTtcbiAgLy8gaW52ZXJzZVxuICBfb3BlblRhZ3NbJzcnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5yZXNldFsxXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFswXTtcbiAgLy8gZGFyayBncmV5XG4gIF9vcGVuVGFnc1snOTAnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5kYXJrZ3JleTtcbiAgZm9yICh2YXIgY29kZSBpbiBfc3R5bGVzKSB7XG4gICAgdmFyIGNvbG9yID0gX3N0eWxlc1tjb2RlXTtcbiAgICB2YXIgb3JpQ29sb3IgPSBjb2xvcnNbY29sb3JdIHx8ICcwMDAnO1xuICAgIF9vcGVuVGFnc1tjb2RlXSA9ICdjb2xvcjojJyArIG9yaUNvbG9yO1xuICAgIGNvZGUgPSBwYXJzZUludChjb2RlKTtcbiAgICBfb3BlblRhZ3NbKGNvZGUgKyAxMCkudG9TdHJpbmcoKV0gPSAnYmFja2dyb3VuZDojJyArIG9yaUNvbG9yO1xuICB9XG59XG5hbnNpSFRNTC5yZXNldCgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ansi-html-community/index.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzRkFBc0YscUJBQXFCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpREFBaUQscUJBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teV9hcHAvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzhlNmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107XG5cbiAgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07XG5cbiAgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBsaXN0O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    return [content].concat([sourceMapping]).join(\"\\n\");\n  }\n  return [content].join(\"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzPzIyZGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/sourceMaps.js\n");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function () {\n    return defaultMaxListeners;\n  },\n  set: function (arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\nEventEmitter.init = function () {\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = type === 'error';\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n  var handler = events[type];\n  if (handler === undefined) return false;\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n  }\n  return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  checkListener(listener);\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n  return target;\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0) return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\nfunction _onceWrap(target, type, listener) {\n  var state = {\n    fired: false,\n    wrapFn: undefined,\n    target: target,\n    type: type,\n    listener: listener\n  };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  checkListener(listener);\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  checkListener(listener);\n  events = this._events;\n  if (events === undefined) return this;\n  list = events[type];\n  if (list === undefined) return this;\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n    if (position < 0) return this;\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n    if (list.length === 1) events[type] = list[0];\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n  return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n  events = this._events;\n  if (events === undefined) return this;\n\n  // not listening for removeListener, no need to emit\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n  listeners = events[type];\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n  return this;\n};\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n  if (events === undefined) return [];\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n  if (events !== undefined) {\n    var evlistener = events[type];\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n  return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i) copy[i] = arr[i];\n  return copy;\n}\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n  list.pop();\n}\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    }\n    ;\n    eventTargetAgnosticAddListener(emitter, name, resolver, {\n      once: true\n    });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, {\n        once: true\n      });\n    }\n  });\n}\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzP2YwZjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbDtcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nID8gUi5hcHBseSA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbn07XG52YXIgUmVmbGVjdE93bktleXM7XG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzO1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCkuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn07XG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHwgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gdHlwZSA9PT0gJ2Vycm9yJztcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSBkb0Vycm9yID0gZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZDtlbHNlIGlmICghZG9FcnJvcikgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgKyBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICsgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICsgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID0gZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xufTtcbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICBmaXJlZDogZmFsc2UsXG4gICAgd3JhcEZuOiB1bmRlZmluZWQsXG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgdHlwZTogdHlwZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9IGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XG4gIGxpc3QgPSBldmVudHNbdHlwZV07XG4gIGlmIChsaXN0ID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtlbHNlIHtcbiAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcG9zaXRpb24gPSAtMTtcbiAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwb3NpdGlvbiA8IDApIHJldHVybiB0aGlzO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gMCkgbGlzdC5zaGlmdCgpO2Vsc2Uge1xuICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICB9XG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZCkgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtlbHNlIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgIHZhciBrZXk7XG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiBbXTtcbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpIHJldHVybiBbXTtcbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG4gIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH1cbiAgICA7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7XG4gICAgICBvbmNlOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/events/events.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/html-entities/lib/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar named_references_1 = __webpack_require__(/*! ./named-references */ \"./node_modules/html-entities/lib/named-references.js\");\nvar numeric_unicode_map_1 = __webpack_require__(/*! ./numeric-unicode-map */ \"./node_modules/html-entities/lib/numeric-unicode-map.js\");\nvar surrogate_pairs_1 = __webpack_require__(/*! ./surrogate-pairs */ \"./node_modules/html-entities/lib/surrogate-pairs.js\");\nvar allNamedReferences = __assign(__assign({}, named_references_1.namedReferences), {\n  all: named_references_1.namedReferences.html5\n});\nfunction replaceUsingRegExp(macroText, macroRegExp, macroReplacer) {\n  macroRegExp.lastIndex = 0;\n  var replaceMatch = macroRegExp.exec(macroText);\n  var replaceResult;\n  if (replaceMatch) {\n    replaceResult = \"\";\n    var replaceLastIndex = 0;\n    do {\n      if (replaceLastIndex !== replaceMatch.index) {\n        replaceResult += macroText.substring(replaceLastIndex, replaceMatch.index);\n      }\n      var replaceInput = replaceMatch[0];\n      replaceResult += macroReplacer(replaceInput);\n      replaceLastIndex = replaceMatch.index + replaceInput.length;\n    } while (replaceMatch = macroRegExp.exec(macroText));\n    if (replaceLastIndex !== macroText.length) {\n      replaceResult += macroText.substring(replaceLastIndex);\n    }\n  } else {\n    replaceResult = macroText;\n  }\n  return replaceResult;\n}\nvar encodeRegExps = {\n  specialChars: /[<>'\"&]/g,\n  nonAscii: /[<>'\"&\\u0080-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g,\n  nonAsciiPrintable: /[<>'\"&\\x01-\\x08\\x11-\\x15\\x17-\\x1F\\x7f-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g,\n  nonAsciiPrintableOnly: /[\\x01-\\x08\\x11-\\x15\\x17-\\x1F\\x7f-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g,\n  extensive: /[\\x01-\\x0c\\x0e-\\x1f\\x21-\\x2c\\x2e-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7d\\x7f-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g\n};\nvar defaultEncodeOptions = {\n  mode: \"specialChars\",\n  level: \"all\",\n  numeric: \"decimal\"\n};\nfunction encode(text, _a) {\n  var _b = _a === void 0 ? defaultEncodeOptions : _a,\n    _c = _b.mode,\n    mode = _c === void 0 ? \"specialChars\" : _c,\n    _d = _b.numeric,\n    numeric = _d === void 0 ? \"decimal\" : _d,\n    _e = _b.level,\n    level = _e === void 0 ? \"all\" : _e;\n  if (!text) {\n    return \"\";\n  }\n  var encodeRegExp = encodeRegExps[mode];\n  var references = allNamedReferences[level].characters;\n  var isHex = numeric === \"hexadecimal\";\n  return replaceUsingRegExp(text, encodeRegExp, function (input) {\n    var result = references[input];\n    if (!result) {\n      var code = input.length > 1 ? surrogate_pairs_1.getCodePoint(input, 0) : input.charCodeAt(0);\n      result = (isHex ? \"&#x\" + code.toString(16) : \"&#\" + code) + \";\";\n    }\n    return result;\n  });\n}\nexports.encode = encode;\nvar defaultDecodeOptions = {\n  scope: \"body\",\n  level: \"all\"\n};\nvar strict = /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);/g;\nvar attribute = /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;\nvar baseDecodeRegExps = {\n  xml: {\n    strict: strict,\n    attribute: attribute,\n    body: named_references_1.bodyRegExps.xml\n  },\n  html4: {\n    strict: strict,\n    attribute: attribute,\n    body: named_references_1.bodyRegExps.html4\n  },\n  html5: {\n    strict: strict,\n    attribute: attribute,\n    body: named_references_1.bodyRegExps.html5\n  }\n};\nvar decodeRegExps = __assign(__assign({}, baseDecodeRegExps), {\n  all: baseDecodeRegExps.html5\n});\nvar fromCharCode = String.fromCharCode;\nvar outOfBoundsChar = fromCharCode(65533);\nvar defaultDecodeEntityOptions = {\n  level: \"all\"\n};\nfunction getDecodedEntity(entity, references, isAttribute, isStrict) {\n  var decodeResult = entity;\n  var decodeEntityLastChar = entity[entity.length - 1];\n  if (isAttribute && decodeEntityLastChar === \"=\") {\n    decodeResult = entity;\n  } else if (isStrict && decodeEntityLastChar !== \";\") {\n    decodeResult = entity;\n  } else {\n    var decodeResultByReference = references[entity];\n    if (decodeResultByReference) {\n      decodeResult = decodeResultByReference;\n    } else if (entity[0] === \"&\" && entity[1] === \"#\") {\n      var decodeSecondChar = entity[2];\n      var decodeCode = decodeSecondChar == \"x\" || decodeSecondChar == \"X\" ? parseInt(entity.substr(3), 16) : parseInt(entity.substr(2));\n      decodeResult = decodeCode >= 1114111 ? outOfBoundsChar : decodeCode > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode] || decodeCode);\n    }\n  }\n  return decodeResult;\n}\nfunction decodeEntity(entity, _a) {\n  var _b = (_a === void 0 ? defaultDecodeEntityOptions : _a).level,\n    level = _b === void 0 ? \"all\" : _b;\n  if (!entity) {\n    return \"\";\n  }\n  return getDecodedEntity(entity, allNamedReferences[level].entities, false, false);\n}\nexports.decodeEntity = decodeEntity;\nfunction decode(text, _a) {\n  var _b = _a === void 0 ? defaultDecodeOptions : _a,\n    _c = _b.level,\n    level = _c === void 0 ? \"all\" : _c,\n    _d = _b.scope,\n    scope = _d === void 0 ? level === \"xml\" ? \"strict\" : \"body\" : _d;\n  if (!text) {\n    return \"\";\n  }\n  var decodeRegExp = decodeRegExps[level][scope];\n  var references = allNamedReferences[level].entities;\n  var isAttribute = scope === \"attribute\";\n  var isStrict = scope === \"strict\";\n  return replaceUsingRegExp(text, decodeRegExp, function (entity) {\n    return getDecodedEntity(entity, references, isAttribute, isStrict);\n  });\n}\nexports.decode = decode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseUJBQXlCLG1CQUFPLENBQUMsZ0ZBQW9CO0FBQ3JELDRCQUE0QixtQkFBTyxDQUFDLHNGQUF1QjtBQUMzRCx3QkFBd0IsbUJBQU8sQ0FBQyw4RUFBbUI7QUFDbkQsNkNBQTZDO0FBQzdDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBZ0Q7QUFDcEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlfYXBwLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2luZGV4LmpzPzQ5YmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2Fzc2lnbiA9IHRoaXMgJiYgdGhpcy5fX2Fzc2lnbiB8fCBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9O1xuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIG5hbWVkX3JlZmVyZW5jZXNfMSA9IHJlcXVpcmUoXCIuL25hbWVkLXJlZmVyZW5jZXNcIik7XG52YXIgbnVtZXJpY191bmljb2RlX21hcF8xID0gcmVxdWlyZShcIi4vbnVtZXJpYy11bmljb2RlLW1hcFwiKTtcbnZhciBzdXJyb2dhdGVfcGFpcnNfMSA9IHJlcXVpcmUoXCIuL3N1cnJvZ2F0ZS1wYWlyc1wiKTtcbnZhciBhbGxOYW1lZFJlZmVyZW5jZXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbmFtZWRfcmVmZXJlbmNlc18xLm5hbWVkUmVmZXJlbmNlcyksIHtcbiAgYWxsOiBuYW1lZF9yZWZlcmVuY2VzXzEubmFtZWRSZWZlcmVuY2VzLmh0bWw1XG59KTtcbmZ1bmN0aW9uIHJlcGxhY2VVc2luZ1JlZ0V4cChtYWNyb1RleHQsIG1hY3JvUmVnRXhwLCBtYWNyb1JlcGxhY2VyKSB7XG4gIG1hY3JvUmVnRXhwLmxhc3RJbmRleCA9IDA7XG4gIHZhciByZXBsYWNlTWF0Y2ggPSBtYWNyb1JlZ0V4cC5leGVjKG1hY3JvVGV4dCk7XG4gIHZhciByZXBsYWNlUmVzdWx0O1xuICBpZiAocmVwbGFjZU1hdGNoKSB7XG4gICAgcmVwbGFjZVJlc3VsdCA9IFwiXCI7XG4gICAgdmFyIHJlcGxhY2VMYXN0SW5kZXggPSAwO1xuICAgIGRvIHtcbiAgICAgIGlmIChyZXBsYWNlTGFzdEluZGV4ICE9PSByZXBsYWNlTWF0Y2guaW5kZXgpIHtcbiAgICAgICAgcmVwbGFjZVJlc3VsdCArPSBtYWNyb1RleHQuc3Vic3RyaW5nKHJlcGxhY2VMYXN0SW5kZXgsIHJlcGxhY2VNYXRjaC5pbmRleCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVwbGFjZUlucHV0ID0gcmVwbGFjZU1hdGNoWzBdO1xuICAgICAgcmVwbGFjZVJlc3VsdCArPSBtYWNyb1JlcGxhY2VyKHJlcGxhY2VJbnB1dCk7XG4gICAgICByZXBsYWNlTGFzdEluZGV4ID0gcmVwbGFjZU1hdGNoLmluZGV4ICsgcmVwbGFjZUlucHV0Lmxlbmd0aDtcbiAgICB9IHdoaWxlIChyZXBsYWNlTWF0Y2ggPSBtYWNyb1JlZ0V4cC5leGVjKG1hY3JvVGV4dCkpO1xuICAgIGlmIChyZXBsYWNlTGFzdEluZGV4ICE9PSBtYWNyb1RleHQubGVuZ3RoKSB7XG4gICAgICByZXBsYWNlUmVzdWx0ICs9IG1hY3JvVGV4dC5zdWJzdHJpbmcocmVwbGFjZUxhc3RJbmRleCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcGxhY2VSZXN1bHQgPSBtYWNyb1RleHQ7XG4gIH1cbiAgcmV0dXJuIHJlcGxhY2VSZXN1bHQ7XG59XG52YXIgZW5jb2RlUmVnRXhwcyA9IHtcbiAgc3BlY2lhbENoYXJzOiAvWzw+J1wiJl0vZyxcbiAgbm9uQXNjaWk6IC9bPD4nXCImXFx1MDA4MC1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdL2csXG4gIG5vbkFzY2lpUHJpbnRhYmxlOiAvWzw+J1wiJlxceDAxLVxceDA4XFx4MTEtXFx4MTVcXHgxNy1cXHgxRlxceDdmLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vZyxcbiAgbm9uQXNjaWlQcmludGFibGVPbmx5OiAvW1xceDAxLVxceDA4XFx4MTEtXFx4MTVcXHgxNy1cXHgxRlxceDdmLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vZyxcbiAgZXh0ZW5zaXZlOiAvW1xceDAxLVxceDBjXFx4MGUtXFx4MWZcXHgyMS1cXHgyY1xceDJlLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdkXFx4N2YtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXS9nXG59O1xudmFyIGRlZmF1bHRFbmNvZGVPcHRpb25zID0ge1xuICBtb2RlOiBcInNwZWNpYWxDaGFyc1wiLFxuICBsZXZlbDogXCJhbGxcIixcbiAgbnVtZXJpYzogXCJkZWNpbWFsXCJcbn07XG5mdW5jdGlvbiBlbmNvZGUodGV4dCwgX2EpIHtcbiAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IGRlZmF1bHRFbmNvZGVPcHRpb25zIDogX2EsXG4gICAgX2MgPSBfYi5tb2RlLFxuICAgIG1vZGUgPSBfYyA9PT0gdm9pZCAwID8gXCJzcGVjaWFsQ2hhcnNcIiA6IF9jLFxuICAgIF9kID0gX2IubnVtZXJpYyxcbiAgICBudW1lcmljID0gX2QgPT09IHZvaWQgMCA/IFwiZGVjaW1hbFwiIDogX2QsXG4gICAgX2UgPSBfYi5sZXZlbCxcbiAgICBsZXZlbCA9IF9lID09PSB2b2lkIDAgPyBcImFsbFwiIDogX2U7XG4gIGlmICghdGV4dCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIHZhciBlbmNvZGVSZWdFeHAgPSBlbmNvZGVSZWdFeHBzW21vZGVdO1xuICB2YXIgcmVmZXJlbmNlcyA9IGFsbE5hbWVkUmVmZXJlbmNlc1tsZXZlbF0uY2hhcmFjdGVycztcbiAgdmFyIGlzSGV4ID0gbnVtZXJpYyA9PT0gXCJoZXhhZGVjaW1hbFwiO1xuICByZXR1cm4gcmVwbGFjZVVzaW5nUmVnRXhwKHRleHQsIGVuY29kZVJlZ0V4cCwgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHJlZmVyZW5jZXNbaW5wdXRdO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB2YXIgY29kZSA9IGlucHV0Lmxlbmd0aCA+IDEgPyBzdXJyb2dhdGVfcGFpcnNfMS5nZXRDb2RlUG9pbnQoaW5wdXQsIDApIDogaW5wdXQuY2hhckNvZGVBdCgwKTtcbiAgICAgIHJlc3VsdCA9IChpc0hleCA/IFwiJiN4XCIgKyBjb2RlLnRvU3RyaW5nKDE2KSA6IFwiJiNcIiArIGNvZGUpICsgXCI7XCI7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG52YXIgZGVmYXVsdERlY29kZU9wdGlvbnMgPSB7XG4gIHNjb3BlOiBcImJvZHlcIixcbiAgbGV2ZWw6IFwiYWxsXCJcbn07XG52YXIgc3RyaWN0ID0gLyYoPzojXFxkK3wjW3hYXVtcXGRhLWZBLUZdK3xbMC05YS16QS1aXSspOy9nO1xudmFyIGF0dHJpYnV0ZSA9IC8mKD86I1xcZCt8I1t4WF1bXFxkYS1mQS1GXSt8WzAtOWEtekEtWl0rKVs7PV0/L2c7XG52YXIgYmFzZURlY29kZVJlZ0V4cHMgPSB7XG4gIHhtbDoge1xuICAgIHN0cmljdDogc3RyaWN0LFxuICAgIGF0dHJpYnV0ZTogYXR0cmlidXRlLFxuICAgIGJvZHk6IG5hbWVkX3JlZmVyZW5jZXNfMS5ib2R5UmVnRXhwcy54bWxcbiAgfSxcbiAgaHRtbDQ6IHtcbiAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSxcbiAgICBib2R5OiBuYW1lZF9yZWZlcmVuY2VzXzEuYm9keVJlZ0V4cHMuaHRtbDRcbiAgfSxcbiAgaHRtbDU6IHtcbiAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSxcbiAgICBib2R5OiBuYW1lZF9yZWZlcmVuY2VzXzEuYm9keVJlZ0V4cHMuaHRtbDVcbiAgfVxufTtcbnZhciBkZWNvZGVSZWdFeHBzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGJhc2VEZWNvZGVSZWdFeHBzKSwge1xuICBhbGw6IGJhc2VEZWNvZGVSZWdFeHBzLmh0bWw1XG59KTtcbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyIG91dE9mQm91bmRzQ2hhciA9IGZyb21DaGFyQ29kZSg2NTUzMyk7XG52YXIgZGVmYXVsdERlY29kZUVudGl0eU9wdGlvbnMgPSB7XG4gIGxldmVsOiBcImFsbFwiXG59O1xuZnVuY3Rpb24gZ2V0RGVjb2RlZEVudGl0eShlbnRpdHksIHJlZmVyZW5jZXMsIGlzQXR0cmlidXRlLCBpc1N0cmljdCkge1xuICB2YXIgZGVjb2RlUmVzdWx0ID0gZW50aXR5O1xuICB2YXIgZGVjb2RlRW50aXR5TGFzdENoYXIgPSBlbnRpdHlbZW50aXR5Lmxlbmd0aCAtIDFdO1xuICBpZiAoaXNBdHRyaWJ1dGUgJiYgZGVjb2RlRW50aXR5TGFzdENoYXIgPT09IFwiPVwiKSB7XG4gICAgZGVjb2RlUmVzdWx0ID0gZW50aXR5O1xuICB9IGVsc2UgaWYgKGlzU3RyaWN0ICYmIGRlY29kZUVudGl0eUxhc3RDaGFyICE9PSBcIjtcIikge1xuICAgIGRlY29kZVJlc3VsdCA9IGVudGl0eTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVjb2RlUmVzdWx0QnlSZWZlcmVuY2UgPSByZWZlcmVuY2VzW2VudGl0eV07XG4gICAgaWYgKGRlY29kZVJlc3VsdEJ5UmVmZXJlbmNlKSB7XG4gICAgICBkZWNvZGVSZXN1bHQgPSBkZWNvZGVSZXN1bHRCeVJlZmVyZW5jZTtcbiAgICB9IGVsc2UgaWYgKGVudGl0eVswXSA9PT0gXCImXCIgJiYgZW50aXR5WzFdID09PSBcIiNcIikge1xuICAgICAgdmFyIGRlY29kZVNlY29uZENoYXIgPSBlbnRpdHlbMl07XG4gICAgICB2YXIgZGVjb2RlQ29kZSA9IGRlY29kZVNlY29uZENoYXIgPT0gXCJ4XCIgfHwgZGVjb2RlU2Vjb25kQ2hhciA9PSBcIlhcIiA/IHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMyksIDE2KSA6IHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMikpO1xuICAgICAgZGVjb2RlUmVzdWx0ID0gZGVjb2RlQ29kZSA+PSAxMTE0MTExID8gb3V0T2ZCb3VuZHNDaGFyIDogZGVjb2RlQ29kZSA+IDY1NTM1ID8gc3Vycm9nYXRlX3BhaXJzXzEuZnJvbUNvZGVQb2ludChkZWNvZGVDb2RlKSA6IGZyb21DaGFyQ29kZShudW1lcmljX3VuaWNvZGVfbWFwXzEubnVtZXJpY1VuaWNvZGVNYXBbZGVjb2RlQ29kZV0gfHwgZGVjb2RlQ29kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWNvZGVSZXN1bHQ7XG59XG5mdW5jdGlvbiBkZWNvZGVFbnRpdHkoZW50aXR5LCBfYSkge1xuICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IGRlZmF1bHREZWNvZGVFbnRpdHlPcHRpb25zIDogX2EpLmxldmVsLFxuICAgIGxldmVsID0gX2IgPT09IHZvaWQgMCA/IFwiYWxsXCIgOiBfYjtcbiAgaWYgKCFlbnRpdHkpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICByZXR1cm4gZ2V0RGVjb2RlZEVudGl0eShlbnRpdHksIGFsbE5hbWVkUmVmZXJlbmNlc1tsZXZlbF0uZW50aXRpZXMsIGZhbHNlLCBmYWxzZSk7XG59XG5leHBvcnRzLmRlY29kZUVudGl0eSA9IGRlY29kZUVudGl0eTtcbmZ1bmN0aW9uIGRlY29kZSh0ZXh0LCBfYSkge1xuICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8gZGVmYXVsdERlY29kZU9wdGlvbnMgOiBfYSxcbiAgICBfYyA9IF9iLmxldmVsLFxuICAgIGxldmVsID0gX2MgPT09IHZvaWQgMCA/IFwiYWxsXCIgOiBfYyxcbiAgICBfZCA9IF9iLnNjb3BlLFxuICAgIHNjb3BlID0gX2QgPT09IHZvaWQgMCA/IGxldmVsID09PSBcInhtbFwiID8gXCJzdHJpY3RcIiA6IFwiYm9keVwiIDogX2Q7XG4gIGlmICghdGV4dCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIHZhciBkZWNvZGVSZWdFeHAgPSBkZWNvZGVSZWdFeHBzW2xldmVsXVtzY29wZV07XG4gIHZhciByZWZlcmVuY2VzID0gYWxsTmFtZWRSZWZlcmVuY2VzW2xldmVsXS5lbnRpdGllcztcbiAgdmFyIGlzQXR0cmlidXRlID0gc2NvcGUgPT09IFwiYXR0cmlidXRlXCI7XG4gIHZhciBpc1N0cmljdCA9IHNjb3BlID09PSBcInN0cmljdFwiO1xuICByZXR1cm4gcmVwbGFjZVVzaW5nUmVnRXhwKHRleHQsIGRlY29kZVJlZ0V4cCwgZnVuY3Rpb24gKGVudGl0eSkge1xuICAgIHJldHVybiBnZXREZWNvZGVkRW50aXR5KGVudGl0eSwgcmVmZXJlbmNlcywgaXNBdHRyaWJ1dGUsIGlzU3RyaWN0KTtcbiAgfSk7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/index.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/named-references.js":
/*!************************************************************!*\
  !*** ./node_modules/html-entities/lib/named-references.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.bodyRegExps = {\n  xml: /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);?/g,\n  html4: /&notin;|&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);?/g,\n  html5: /&centerdot;|&copysr;|&divideontimes;|&gtcc;|&gtcir;|&gtdot;|&gtlPar;|&gtquest;|&gtrapprox;|&gtrarr;|&gtrdot;|&gtreqless;|&gtreqqless;|&gtrless;|&gtrsim;|&ltcc;|&ltcir;|&ltdot;|&lthree;|&ltimes;|&ltlarr;|&ltquest;|&ltrPar;|&ltri;|&ltrie;|&ltrif;|&notin;|&notinE;|&notindot;|&notinva;|&notinvb;|&notinvc;|&notni;|&notniva;|&notnivb;|&notnivc;|&parallel;|&timesb;|&timesbar;|&timesd;|&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);?/g\n};\nexports.namedReferences = {\n  xml: {\n    entities: {\n      \"&lt;\": \"<\",\n      \"&gt;\": \">\",\n      \"&quot;\": '\"',\n      \"&apos;\": \"'\",\n      \"&amp;\": \"&\"\n    },\n    characters: {\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      '\"': \"&quot;\",\n      \"'\": \"&apos;\",\n      \"&\": \"&amp;\"\n    }\n  },\n  html4: {\n    entities: {\n      \"&apos;\": \"'\",\n      \"&nbsp\": \"\",\n      \"&nbsp;\": \"\",\n      \"&iexcl\": \"\",\n      \"&iexcl;\": \"\",\n      \"&cent\": \"\",\n      \"&cent;\": \"\",\n      \"&pound\": \"\",\n      \"&pound;\": \"\",\n      \"&curren\": \"\",\n      \"&curren;\": \"\",\n      \"&yen\": \"\",\n      \"&yen;\": \"\",\n      \"&brvbar\": \"\",\n      \"&brvbar;\": \"\",\n      \"&sect\": \"\",\n      \"&sect;\": \"\",\n      \"&uml\": \"\",\n      \"&uml;\": \"\",\n      \"&copy\": \"\",\n      \"&copy;\": \"\",\n      \"&ordf\": \"\",\n      \"&ordf;\": \"\",\n      \"&laquo\": \"\",\n      \"&laquo;\": \"\",\n      \"&not\": \"\",\n      \"&not;\": \"\",\n      \"&shy\": \"\",\n      \"&shy;\": \"\",\n      \"&reg\": \"\",\n      \"&reg;\": \"\",\n      \"&macr\": \"\",\n      \"&macr;\": \"\",\n      \"&deg\": \"\",\n      \"&deg;\": \"\",\n      \"&plusmn\": \"\",\n      \"&plusmn;\": \"\",\n      \"&sup2\": \"\",\n      \"&sup2;\": \"\",\n      \"&sup3\": \"\",\n      \"&sup3;\": \"\",\n      \"&acute\": \"\",\n      \"&acute;\": \"\",\n      \"&micro\": \"\",\n      \"&micro;\": \"\",\n      \"&para\": \"\",\n      \"&para;\": \"\",\n      \"&middot\": \"\",\n      \"&middot;\": \"\",\n      \"&cedil\": \"\",\n      \"&cedil;\": \"\",\n      \"&sup1\": \"\",\n      \"&sup1;\": \"\",\n      \"&ordm\": \"\",\n      \"&ordm;\": \"\",\n      \"&raquo\": \"\",\n      \"&raquo;\": \"\",\n      \"&frac14\": \"\",\n      \"&frac14;\": \"\",\n      \"&frac12\": \"\",\n      \"&frac12;\": \"\",\n      \"&frac34\": \"\",\n      \"&frac34;\": \"\",\n      \"&iquest\": \"\",\n      \"&iquest;\": \"\",\n      \"&Agrave\": \"\",\n      \"&Agrave;\": \"\",\n      \"&Aacute\": \"\",\n      \"&Aacute;\": \"\",\n      \"&Acirc\": \"\",\n      \"&Acirc;\": \"\",\n      \"&Atilde\": \"\",\n      \"&Atilde;\": \"\",\n      \"&Auml\": \"\",\n      \"&Auml;\": \"\",\n      \"&Aring\": \"\",\n      \"&Aring;\": \"\",\n      \"&AElig\": \"\",\n      \"&AElig;\": \"\",\n      \"&Ccedil\": \"\",\n      \"&Ccedil;\": \"\",\n      \"&Egrave\": \"\",\n      \"&Egrave;\": \"\",\n      \"&Eacute\": \"\",\n      \"&Eacute;\": \"\",\n      \"&Ecirc\": \"\",\n      \"&Ecirc;\": \"\",\n      \"&Euml\": \"\",\n      \"&Euml;\": \"\",\n      \"&Igrave\": \"\",\n      \"&Igrave;\": \"\",\n      \"&Iacute\": \"\",\n      \"&Iacute;\": \"\",\n      \"&Icirc\": \"\",\n      \"&Icirc;\": \"\",\n      \"&Iuml\": \"\",\n      \"&Iuml;\": \"\",\n      \"&ETH\": \"\",\n      \"&ETH;\": \"\",\n      \"&Ntilde\": \"\",\n      \"&Ntilde;\": \"\",\n      \"&Ograve\": \"\",\n      \"&Ograve;\": \"\",\n      \"&Oacute\": \"\",\n      \"&Oacute;\": \"\",\n      \"&Ocirc\": \"\",\n      \"&Ocirc;\": \"\",\n      \"&Otilde\": \"\",\n      \"&Otilde;\": \"\",\n      \"&Ouml\": \"\",\n      \"&Ouml;\": \"\",\n      \"&times\": \"\",\n      \"&times;\": \"\",\n      \"&Oslash\": \"\",\n      \"&Oslash;\": \"\",\n      \"&Ugrave\": \"\",\n      \"&Ugrave;\": \"\",\n      \"&Uacute\": \"\",\n      \"&Uacute;\": \"\",\n      \"&Ucirc\": \"\",\n      \"&Ucirc;\": \"\",\n      \"&Uuml\": \"\",\n      \"&Uuml;\": \"\",\n      \"&Yacute\": \"\",\n      \"&Yacute;\": \"\",\n      \"&THORN\": \"\",\n      \"&THORN;\": \"\",\n      \"&szlig\": \"\",\n      \"&szlig;\": \"\",\n      \"&agrave\": \"\",\n      \"&agrave;\": \"\",\n      \"&aacute\": \"\",\n      \"&aacute;\": \"\",\n      \"&acirc\": \"\",\n      \"&acirc;\": \"\",\n      \"&atilde\": \"\",\n      \"&atilde;\": \"\",\n      \"&auml\": \"\",\n      \"&auml;\": \"\",\n      \"&aring\": \"\",\n      \"&aring;\": \"\",\n      \"&aelig\": \"\",\n      \"&aelig;\": \"\",\n      \"&ccedil\": \"\",\n      \"&ccedil;\": \"\",\n      \"&egrave\": \"\",\n      \"&egrave;\": \"\",\n      \"&eacute\": \"\",\n      \"&eacute;\": \"\",\n      \"&ecirc\": \"\",\n      \"&ecirc;\": \"\",\n      \"&euml\": \"\",\n      \"&euml;\": \"\",\n      \"&igrave\": \"\",\n      \"&igrave;\": \"\",\n      \"&iacute\": \"\",\n      \"&iacute;\": \"\",\n      \"&icirc\": \"\",\n      \"&icirc;\": \"\",\n      \"&iuml\": \"\",\n      \"&iuml;\": \"\",\n      \"&eth\": \"\",\n      \"&eth;\": \"\",\n      \"&ntilde\": \"\",\n      \"&ntilde;\": \"\",\n      \"&ograve\": \"\",\n      \"&ograve;\": \"\",\n      \"&oacute\": \"\",\n      \"&oacute;\": \"\",\n      \"&ocirc\": \"\",\n      \"&ocirc;\": \"\",\n      \"&otilde\": \"\",\n      \"&otilde;\": \"\",\n      \"&ouml\": \"\",\n      \"&ouml;\": \"\",\n      \"&divide\": \"\",\n      \"&divide;\": \"\",\n      \"&oslash\": \"\",\n      \"&oslash;\": \"\",\n      \"&ugrave\": \"\",\n      \"&ugrave;\": \"\",\n      \"&uacute\": \"\",\n      \"&uacute;\": \"\",\n      \"&ucirc\": \"\",\n      \"&ucirc;\": \"\",\n      \"&uuml\": \"\",\n      \"&uuml;\": \"\",\n      \"&yacute\": \"\",\n      \"&yacute;\": \"\",\n      \"&thorn\": \"\",\n      \"&thorn;\": \"\",\n      \"&yuml\": \"\",\n      \"&yuml;\": \"\",\n      \"&quot\": '\"',\n      \"&quot;\": '\"',\n      \"&amp\": \"&\",\n      \"&amp;\": \"&\",\n      \"&lt\": \"<\",\n      \"&lt;\": \"<\",\n      \"&gt\": \">\",\n      \"&gt;\": \">\",\n      \"&OElig;\": \"\",\n      \"&oelig;\": \"\",\n      \"&Scaron;\": \"\",\n      \"&scaron;\": \"\",\n      \"&Yuml;\": \"\",\n      \"&circ;\": \"\",\n      \"&tilde;\": \"\",\n      \"&ensp;\": \"\",\n      \"&emsp;\": \"\",\n      \"&thinsp;\": \"\",\n      \"&zwnj;\": \"\",\n      \"&zwj;\": \"\",\n      \"&lrm;\": \"\",\n      \"&rlm;\": \"\",\n      \"&ndash;\": \"\",\n      \"&mdash;\": \"\",\n      \"&lsquo;\": \"\",\n      \"&rsquo;\": \"\",\n      \"&sbquo;\": \"\",\n      \"&ldquo;\": \"\",\n      \"&rdquo;\": \"\",\n      \"&bdquo;\": \"\",\n      \"&dagger;\": \"\",\n      \"&Dagger;\": \"\",\n      \"&permil;\": \"\",\n      \"&lsaquo;\": \"\",\n      \"&rsaquo;\": \"\",\n      \"&euro;\": \"\",\n      \"&fnof;\": \"\",\n      \"&Alpha;\": \"\",\n      \"&Beta;\": \"\",\n      \"&Gamma;\": \"\",\n      \"&Delta;\": \"\",\n      \"&Epsilon;\": \"\",\n      \"&Zeta;\": \"\",\n      \"&Eta;\": \"\",\n      \"&Theta;\": \"\",\n      \"&Iota;\": \"\",\n      \"&Kappa;\": \"\",\n      \"&Lambda;\": \"\",\n      \"&Mu;\": \"\",\n      \"&Nu;\": \"\",\n      \"&Xi;\": \"\",\n      \"&Omicron;\": \"\",\n      \"&Pi;\": \"\",\n      \"&Rho;\": \"\",\n      \"&Sigma;\": \"\",\n      \"&Tau;\": \"\",\n      \"&Upsilon;\": \"\",\n      \"&Phi;\": \"\",\n      \"&Chi;\": \"\",\n      \"&Psi;\": \"\",\n      \"&Omega;\": \"\",\n      \"&alpha;\": \"\",\n      \"&beta;\": \"\",\n      \"&gamma;\": \"\",\n      \"&delta;\": \"\",\n      \"&epsilon;\": \"\",\n      \"&zeta;\": \"\",\n      \"&eta;\": \"\",\n      \"&theta;\": \"\",\n      \"&iota;\": \"\",\n      \"&kappa;\": \"\",\n      \"&lambda;\": \"\",\n      \"&mu;\": \"\",\n      \"&nu;\": \"\",\n      \"&xi;\": \"\",\n      \"&omicron;\": \"\",\n      \"&pi;\": \"\",\n      \"&rho;\": \"\",\n      \"&sigmaf;\": \"\",\n      \"&sigma;\": \"\",\n      \"&tau;\": \"\",\n      \"&upsilon;\": \"\",\n      \"&phi;\": \"\",\n      \"&chi;\": \"\",\n      \"&psi;\": \"\",\n      \"&omega;\": \"\",\n      \"&thetasym;\": \"\",\n      \"&upsih;\": \"\",\n      \"&piv;\": \"\",\n      \"&bull;\": \"\",\n      \"&hellip;\": \"\",\n      \"&prime;\": \"\",\n      \"&Prime;\": \"\",\n      \"&oline;\": \"\",\n      \"&frasl;\": \"\",\n      \"&weierp;\": \"\",\n      \"&image;\": \"\",\n      \"&real;\": \"\",\n      \"&trade;\": \"\",\n      \"&alefsym;\": \"\",\n      \"&larr;\": \"\",\n      \"&uarr;\": \"\",\n      \"&rarr;\": \"\",\n      \"&darr;\": \"\",\n      \"&harr;\": \"\",\n      \"&crarr;\": \"\",\n      \"&lArr;\": \"\",\n      \"&uArr;\": \"\",\n      \"&rArr;\": \"\",\n      \"&dArr;\": \"\",\n      \"&hArr;\": \"\",\n      \"&forall;\": \"\",\n      \"&part;\": \"\",\n      \"&exist;\": \"\",\n      \"&empty;\": \"\",\n      \"&nabla;\": \"\",\n      \"&isin;\": \"\",\n      \"&notin;\": \"\",\n      \"&ni;\": \"\",\n      \"&prod;\": \"\",\n      \"&sum;\": \"\",\n      \"&minus;\": \"\",\n      \"&lowast;\": \"\",\n      \"&radic;\": \"\",\n      \"&prop;\": \"\",\n      \"&infin;\": \"\",\n      \"&ang;\": \"\",\n      \"&and;\": \"\",\n      \"&or;\": \"\",\n      \"&cap;\": \"\",\n      \"&cup;\": \"\",\n      \"&int;\": \"\",\n      \"&there4;\": \"\",\n      \"&sim;\": \"\",\n      \"&cong;\": \"\",\n      \"&asymp;\": \"\",\n      \"&ne;\": \"\",\n      \"&equiv;\": \"\",\n      \"&le;\": \"\",\n      \"&ge;\": \"\",\n      \"&sub;\": \"\",\n      \"&sup;\": \"\",\n      \"&nsub;\": \"\",\n      \"&sube;\": \"\",\n      \"&supe;\": \"\",\n      \"&oplus;\": \"\",\n      \"&otimes;\": \"\",\n      \"&perp;\": \"\",\n      \"&sdot;\": \"\",\n      \"&lceil;\": \"\",\n      \"&rceil;\": \"\",\n      \"&lfloor;\": \"\",\n      \"&rfloor;\": \"\",\n      \"&lang;\": \"\",\n      \"&rang;\": \"\",\n      \"&loz;\": \"\",\n      \"&spades;\": \"\",\n      \"&clubs;\": \"\",\n      \"&hearts;\": \"\",\n      \"&diams;\": \"\"\n    },\n    characters: {\n      \"'\": \"&apos;\",\n      \"\": \"&nbsp;\",\n      \"\": \"&iexcl;\",\n      \"\": \"&cent;\",\n      \"\": \"&pound;\",\n      \"\": \"&curren;\",\n      \"\": \"&yen;\",\n      \"\": \"&brvbar;\",\n      \"\": \"&sect;\",\n      \"\": \"&uml;\",\n      \"\": \"&copy;\",\n      \"\": \"&ordf;\",\n      \"\": \"&laquo;\",\n      \"\": \"&not;\",\n      \"\": \"&shy;\",\n      \"\": \"&reg;\",\n      \"\": \"&macr;\",\n      \"\": \"&deg;\",\n      \"\": \"&plusmn;\",\n      \"\": \"&sup2;\",\n      \"\": \"&sup3;\",\n      \"\": \"&acute;\",\n      \"\": \"&micro;\",\n      \"\": \"&para;\",\n      \"\": \"&middot;\",\n      \"\": \"&cedil;\",\n      \"\": \"&sup1;\",\n      \"\": \"&ordm;\",\n      \"\": \"&raquo;\",\n      \"\": \"&frac14;\",\n      \"\": \"&frac12;\",\n      \"\": \"&frac34;\",\n      \"\": \"&iquest;\",\n      \"\": \"&Agrave;\",\n      \"\": \"&Aacute;\",\n      \"\": \"&Acirc;\",\n      \"\": \"&Atilde;\",\n      \"\": \"&Auml;\",\n      \"\": \"&Aring;\",\n      \"\": \"&AElig;\",\n      \"\": \"&Ccedil;\",\n      \"\": \"&Egrave;\",\n      \"\": \"&Eacute;\",\n      \"\": \"&Ecirc;\",\n      \"\": \"&Euml;\",\n      \"\": \"&Igrave;\",\n      \"\": \"&Iacute;\",\n      \"\": \"&Icirc;\",\n      \"\": \"&Iuml;\",\n      \"\": \"&ETH;\",\n      \"\": \"&Ntilde;\",\n      \"\": \"&Ograve;\",\n      \"\": \"&Oacute;\",\n      \"\": \"&Ocirc;\",\n      \"\": \"&Otilde;\",\n      \"\": \"&Ouml;\",\n      \"\": \"&times;\",\n      \"\": \"&Oslash;\",\n      \"\": \"&Ugrave;\",\n      \"\": \"&Uacute;\",\n      \"\": \"&Ucirc;\",\n      \"\": \"&Uuml;\",\n      \"\": \"&Yacute;\",\n      \"\": \"&THORN;\",\n      \"\": \"&szlig;\",\n      \"\": \"&agrave;\",\n      \"\": \"&aacute;\",\n      \"\": \"&acirc;\",\n      \"\": \"&atilde;\",\n      \"\": \"&auml;\",\n      \"\": \"&aring;\",\n      \"\": \"&aelig;\",\n      \"\": \"&ccedil;\",\n      \"\": \"&egrave;\",\n      \"\": \"&eacute;\",\n      \"\": \"&ecirc;\",\n      \"\": \"&euml;\",\n      \"\": \"&igrave;\",\n      \"\": \"&iacute;\",\n      \"\": \"&icirc;\",\n      \"\": \"&iuml;\",\n      \"\": \"&eth;\",\n      \"\": \"&ntilde;\",\n      \"\": \"&ograve;\",\n      \"\": \"&oacute;\",\n      \"\": \"&ocirc;\",\n      \"\": \"&otilde;\",\n      \"\": \"&ouml;\",\n      \"\": \"&divide;\",\n      \"\": \"&oslash;\",\n      \"\": \"&ugrave;\",\n      \"\": \"&uacute;\",\n      \"\": \"&ucirc;\",\n      \"\": \"&uuml;\",\n      \"\": \"&yacute;\",\n      \"\": \"&thorn;\",\n      \"\": \"&yuml;\",\n      '\"': \"&quot;\",\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      \"\": \"&OElig;\",\n      \"\": \"&oelig;\",\n      \"\": \"&Scaron;\",\n      \"\": \"&scaron;\",\n      \"\": \"&Yuml;\",\n      \"\": \"&circ;\",\n      \"\": \"&tilde;\",\n      \"\": \"&ensp;\",\n      \"\": \"&emsp;\",\n      \"\": \"&thinsp;\",\n      \"\": \"&zwnj;\",\n      \"\": \"&zwj;\",\n      \"\": \"&lrm;\",\n      \"\": \"&rlm;\",\n      \"\": \"&ndash;\",\n      \"\": \"&mdash;\",\n      \"\": \"&lsquo;\",\n      \"\": \"&rsquo;\",\n      \"\": \"&sbquo;\",\n      \"\": \"&ldquo;\",\n      \"\": \"&rdquo;\",\n      \"\": \"&bdquo;\",\n      \"\": \"&dagger;\",\n      \"\": \"&Dagger;\",\n      \"\": \"&permil;\",\n      \"\": \"&lsaquo;\",\n      \"\": \"&rsaquo;\",\n      \"\": \"&euro;\",\n      \"\": \"&fnof;\",\n      \"\": \"&Alpha;\",\n      \"\": \"&Beta;\",\n      \"\": \"&Gamma;\",\n      \"\": \"&Delta;\",\n      \"\": \"&Epsilon;\",\n      \"\": \"&Zeta;\",\n      \"\": \"&Eta;\",\n      \"\": \"&Theta;\",\n      \"\": \"&Iota;\",\n      \"\": \"&Kappa;\",\n      \"\": \"&Lambda;\",\n      \"\": \"&Mu;\",\n      \"\": \"&Nu;\",\n      \"\": \"&Xi;\",\n      \"\": \"&Omicron;\",\n      \"\": \"&Pi;\",\n      \"\": \"&Rho;\",\n      \"\": \"&Sigma;\",\n      \"\": \"&Tau;\",\n      \"\": \"&Upsilon;\",\n      \"\": \"&Phi;\",\n      \"\": \"&Chi;\",\n      \"\": \"&Psi;\",\n      \"\": \"&Omega;\",\n      \"\": \"&alpha;\",\n      \"\": \"&beta;\",\n      \"\": \"&gamma;\",\n      \"\": \"&delta;\",\n      \"\": \"&epsilon;\",\n      \"\": \"&zeta;\",\n      \"\": \"&eta;\",\n      \"\": \"&theta;\",\n      \"\": \"&iota;\",\n      \"\": \"&kappa;\",\n      \"\": \"&lambda;\",\n      \"\": \"&mu;\",\n      \"\": \"&nu;\",\n      \"\": \"&xi;\",\n      \"\": \"&omicron;\",\n      \"\": \"&pi;\",\n      \"\": \"&rho;\",\n      \"\": \"&sigmaf;\",\n      \"\": \"&sigma;\",\n      \"\": \"&tau;\",\n      \"\": \"&upsilon;\",\n      \"\": \"&phi;\",\n      \"\": \"&chi;\",\n      \"\": \"&psi;\",\n      \"\": \"&omega;\",\n      \"\": \"&thetasym;\",\n      \"\": \"&upsih;\",\n      \"\": \"&piv;\",\n      \"\": \"&bull;\",\n      \"\": \"&hellip;\",\n      \"\": \"&prime;\",\n      \"\": \"&Prime;\",\n      \"\": \"&oline;\",\n      \"\": \"&frasl;\",\n      \"\": \"&weierp;\",\n      \"\": \"&image;\",\n      \"\": \"&real;\",\n      \"\": \"&trade;\",\n      \"\": \"&alefsym;\",\n      \"\": \"&larr;\",\n      \"\": \"&uarr;\",\n      \"\": \"&rarr;\",\n      \"\": \"&darr;\",\n      \"\": \"&harr;\",\n      \"\": \"&crarr;\",\n      \"\": \"&lArr;\",\n      \"\": \"&uArr;\",\n      \"\": \"&rArr;\",\n      \"\": \"&dArr;\",\n      \"\": \"&hArr;\",\n      \"\": \"&forall;\",\n      \"\": \"&part;\",\n      \"\": \"&exist;\",\n      \"\": \"&empty;\",\n      \"\": \"&nabla;\",\n      \"\": \"&isin;\",\n      \"\": \"&notin;\",\n      \"\": \"&ni;\",\n      \"\": \"&prod;\",\n      \"\": \"&sum;\",\n      \"\": \"&minus;\",\n      \"\": \"&lowast;\",\n      \"\": \"&radic;\",\n      \"\": \"&prop;\",\n      \"\": \"&infin;\",\n      \"\": \"&ang;\",\n      \"\": \"&and;\",\n      \"\": \"&or;\",\n      \"\": \"&cap;\",\n      \"\": \"&cup;\",\n      \"\": \"&int;\",\n      \"\": \"&there4;\",\n      \"\": \"&sim;\",\n      \"\": \"&cong;\",\n      \"\": \"&asymp;\",\n      \"\": \"&ne;\",\n      \"\": \"&equiv;\",\n      \"\": \"&le;\",\n      \"\": \"&ge;\",\n      \"\": \"&sub;\",\n      \"\": \"&sup;\",\n      \"\": \"&nsub;\",\n      \"\": \"&sube;\",\n      \"\": \"&supe;\",\n      \"\": \"&oplus;\",\n      \"\": \"&otimes;\",\n      \"\": \"&perp;\",\n      \"\": \"&sdot;\",\n      \"\": \"&lceil;\",\n      \"\": \"&rceil;\",\n      \"\": \"&lfloor;\",\n      \"\": \"&rfloor;\",\n      \"\": \"&lang;\",\n      \"\": \"&rang;\",\n      \"\": \"&loz;\",\n      \"\": \"&spades;\",\n      \"\": \"&clubs;\",\n      \"\": \"&hearts;\",\n      \"\": \"&diams;\"\n    }\n  },\n  html5: {\n    entities: {\n      \"&AElig\": \"\",\n      \"&AElig;\": \"\",\n      \"&AMP\": \"&\",\n      \"&AMP;\": \"&\",\n      \"&Aacute\": \"\",\n      \"&Aacute;\": \"\",\n      \"&Abreve;\": \"\",\n      \"&Acirc\": \"\",\n      \"&Acirc;\": \"\",\n      \"&Acy;\": \"\",\n      \"&Afr;\": \"\",\n      \"&Agrave\": \"\",\n      \"&Agrave;\": \"\",\n      \"&Alpha;\": \"\",\n      \"&Amacr;\": \"\",\n      \"&And;\": \"\",\n      \"&Aogon;\": \"\",\n      \"&Aopf;\": \"\",\n      \"&ApplyFunction;\": \"\",\n      \"&Aring\": \"\",\n      \"&Aring;\": \"\",\n      \"&Ascr;\": \"\",\n      \"&Assign;\": \"\",\n      \"&Atilde\": \"\",\n      \"&Atilde;\": \"\",\n      \"&Auml\": \"\",\n      \"&Auml;\": \"\",\n      \"&Backslash;\": \"\",\n      \"&Barv;\": \"\",\n      \"&Barwed;\": \"\",\n      \"&Bcy;\": \"\",\n      \"&Because;\": \"\",\n      \"&Bernoullis;\": \"\",\n      \"&Beta;\": \"\",\n      \"&Bfr;\": \"\",\n      \"&Bopf;\": \"\",\n      \"&Breve;\": \"\",\n      \"&Bscr;\": \"\",\n      \"&Bumpeq;\": \"\",\n      \"&CHcy;\": \"\",\n      \"&COPY\": \"\",\n      \"&COPY;\": \"\",\n      \"&Cacute;\": \"\",\n      \"&Cap;\": \"\",\n      \"&CapitalDifferentialD;\": \"\",\n      \"&Cayleys;\": \"\",\n      \"&Ccaron;\": \"\",\n      \"&Ccedil\": \"\",\n      \"&Ccedil;\": \"\",\n      \"&Ccirc;\": \"\",\n      \"&Cconint;\": \"\",\n      \"&Cdot;\": \"\",\n      \"&Cedilla;\": \"\",\n      \"&CenterDot;\": \"\",\n      \"&Cfr;\": \"\",\n      \"&Chi;\": \"\",\n      \"&CircleDot;\": \"\",\n      \"&CircleMinus;\": \"\",\n      \"&CirclePlus;\": \"\",\n      \"&CircleTimes;\": \"\",\n      \"&ClockwiseContourIntegral;\": \"\",\n      \"&CloseCurlyDoubleQuote;\": \"\",\n      \"&CloseCurlyQuote;\": \"\",\n      \"&Colon;\": \"\",\n      \"&Colone;\": \"\",\n      \"&Congruent;\": \"\",\n      \"&Conint;\": \"\",\n      \"&ContourIntegral;\": \"\",\n      \"&Copf;\": \"\",\n      \"&Coproduct;\": \"\",\n      \"&CounterClockwiseContourIntegral;\": \"\",\n      \"&Cross;\": \"\",\n      \"&Cscr;\": \"\",\n      \"&Cup;\": \"\",\n      \"&CupCap;\": \"\",\n      \"&DD;\": \"\",\n      \"&DDotrahd;\": \"\",\n      \"&DJcy;\": \"\",\n      \"&DScy;\": \"\",\n      \"&DZcy;\": \"\",\n      \"&Dagger;\": \"\",\n      \"&Darr;\": \"\",\n      \"&Dashv;\": \"\",\n      \"&Dcaron;\": \"\",\n      \"&Dcy;\": \"\",\n      \"&Del;\": \"\",\n      \"&Delta;\": \"\",\n      \"&Dfr;\": \"\",\n      \"&DiacriticalAcute;\": \"\",\n      \"&DiacriticalDot;\": \"\",\n      \"&DiacriticalDoubleAcute;\": \"\",\n      \"&DiacriticalGrave;\": \"`\",\n      \"&DiacriticalTilde;\": \"\",\n      \"&Diamond;\": \"\",\n      \"&DifferentialD;\": \"\",\n      \"&Dopf;\": \"\",\n      \"&Dot;\": \"\",\n      \"&DotDot;\": \"\",\n      \"&DotEqual;\": \"\",\n      \"&DoubleContourIntegral;\": \"\",\n      \"&DoubleDot;\": \"\",\n      \"&DoubleDownArrow;\": \"\",\n      \"&DoubleLeftArrow;\": \"\",\n      \"&DoubleLeftRightArrow;\": \"\",\n      \"&DoubleLeftTee;\": \"\",\n      \"&DoubleLongLeftArrow;\": \"\",\n      \"&DoubleLongLeftRightArrow;\": \"\",\n      \"&DoubleLongRightArrow;\": \"\",\n      \"&DoubleRightArrow;\": \"\",\n      \"&DoubleRightTee;\": \"\",\n      \"&DoubleUpArrow;\": \"\",\n      \"&DoubleUpDownArrow;\": \"\",\n      \"&DoubleVerticalBar;\": \"\",\n      \"&DownArrow;\": \"\",\n      \"&DownArrowBar;\": \"\",\n      \"&DownArrowUpArrow;\": \"\",\n      \"&DownBreve;\": \"\",\n      \"&DownLeftRightVector;\": \"\",\n      \"&DownLeftTeeVector;\": \"\",\n      \"&DownLeftVector;\": \"\",\n      \"&DownLeftVectorBar;\": \"\",\n      \"&DownRightTeeVector;\": \"\",\n      \"&DownRightVector;\": \"\",\n      \"&DownRightVectorBar;\": \"\",\n      \"&DownTee;\": \"\",\n      \"&DownTeeArrow;\": \"\",\n      \"&Downarrow;\": \"\",\n      \"&Dscr;\": \"\",\n      \"&Dstrok;\": \"\",\n      \"&ENG;\": \"\",\n      \"&ETH\": \"\",\n      \"&ETH;\": \"\",\n      \"&Eacute\": \"\",\n      \"&Eacute;\": \"\",\n      \"&Ecaron;\": \"\",\n      \"&Ecirc\": \"\",\n      \"&Ecirc;\": \"\",\n      \"&Ecy;\": \"\",\n      \"&Edot;\": \"\",\n      \"&Efr;\": \"\",\n      \"&Egrave\": \"\",\n      \"&Egrave;\": \"\",\n      \"&Element;\": \"\",\n      \"&Emacr;\": \"\",\n      \"&EmptySmallSquare;\": \"\",\n      \"&EmptyVerySmallSquare;\": \"\",\n      \"&Eogon;\": \"\",\n      \"&Eopf;\": \"\",\n      \"&Epsilon;\": \"\",\n      \"&Equal;\": \"\",\n      \"&EqualTilde;\": \"\",\n      \"&Equilibrium;\": \"\",\n      \"&Escr;\": \"\",\n      \"&Esim;\": \"\",\n      \"&Eta;\": \"\",\n      \"&Euml\": \"\",\n      \"&Euml;\": \"\",\n      \"&Exists;\": \"\",\n      \"&ExponentialE;\": \"\",\n      \"&Fcy;\": \"\",\n      \"&Ffr;\": \"\",\n      \"&FilledSmallSquare;\": \"\",\n      \"&FilledVerySmallSquare;\": \"\",\n      \"&Fopf;\": \"\",\n      \"&ForAll;\": \"\",\n      \"&Fouriertrf;\": \"\",\n      \"&Fscr;\": \"\",\n      \"&GJcy;\": \"\",\n      \"&GT\": \">\",\n      \"&GT;\": \">\",\n      \"&Gamma;\": \"\",\n      \"&Gammad;\": \"\",\n      \"&Gbreve;\": \"\",\n      \"&Gcedil;\": \"\",\n      \"&Gcirc;\": \"\",\n      \"&Gcy;\": \"\",\n      \"&Gdot;\": \"\",\n      \"&Gfr;\": \"\",\n      \"&Gg;\": \"\",\n      \"&Gopf;\": \"\",\n      \"&GreaterEqual;\": \"\",\n      \"&GreaterEqualLess;\": \"\",\n      \"&GreaterFullEqual;\": \"\",\n      \"&GreaterGreater;\": \"\",\n      \"&GreaterLess;\": \"\",\n      \"&GreaterSlantEqual;\": \"\",\n      \"&GreaterTilde;\": \"\",\n      \"&Gscr;\": \"\",\n      \"&Gt;\": \"\",\n      \"&HARDcy;\": \"\",\n      \"&Hacek;\": \"\",\n      \"&Hat;\": \"^\",\n      \"&Hcirc;\": \"\",\n      \"&Hfr;\": \"\",\n      \"&HilbertSpace;\": \"\",\n      \"&Hopf;\": \"\",\n      \"&HorizontalLine;\": \"\",\n      \"&Hscr;\": \"\",\n      \"&Hstrok;\": \"\",\n      \"&HumpDownHump;\": \"\",\n      \"&HumpEqual;\": \"\",\n      \"&IEcy;\": \"\",\n      \"&IJlig;\": \"\",\n      \"&IOcy;\": \"\",\n      \"&Iacute\": \"\",\n      \"&Iacute;\": \"\",\n      \"&Icirc\": \"\",\n      \"&Icirc;\": \"\",\n      \"&Icy;\": \"\",\n      \"&Idot;\": \"\",\n      \"&Ifr;\": \"\",\n      \"&Igrave\": \"\",\n      \"&Igrave;\": \"\",\n      \"&Im;\": \"\",\n      \"&Imacr;\": \"\",\n      \"&ImaginaryI;\": \"\",\n      \"&Implies;\": \"\",\n      \"&Int;\": \"\",\n      \"&Integral;\": \"\",\n      \"&Intersection;\": \"\",\n      \"&InvisibleComma;\": \"\",\n      \"&InvisibleTimes;\": \"\",\n      \"&Iogon;\": \"\",\n      \"&Iopf;\": \"\",\n      \"&Iota;\": \"\",\n      \"&Iscr;\": \"\",\n      \"&Itilde;\": \"\",\n      \"&Iukcy;\": \"\",\n      \"&Iuml\": \"\",\n      \"&Iuml;\": \"\",\n      \"&Jcirc;\": \"\",\n      \"&Jcy;\": \"\",\n      \"&Jfr;\": \"\",\n      \"&Jopf;\": \"\",\n      \"&Jscr;\": \"\",\n      \"&Jsercy;\": \"\",\n      \"&Jukcy;\": \"\",\n      \"&KHcy;\": \"\",\n      \"&KJcy;\": \"\",\n      \"&Kappa;\": \"\",\n      \"&Kcedil;\": \"\",\n      \"&Kcy;\": \"\",\n      \"&Kfr;\": \"\",\n      \"&Kopf;\": \"\",\n      \"&Kscr;\": \"\",\n      \"&LJcy;\": \"\",\n      \"&LT\": \"<\",\n      \"&LT;\": \"<\",\n      \"&Lacute;\": \"\",\n      \"&Lambda;\": \"\",\n      \"&Lang;\": \"\",\n      \"&Laplacetrf;\": \"\",\n      \"&Larr;\": \"\",\n      \"&Lcaron;\": \"\",\n      \"&Lcedil;\": \"\",\n      \"&Lcy;\": \"\",\n      \"&LeftAngleBracket;\": \"\",\n      \"&LeftArrow;\": \"\",\n      \"&LeftArrowBar;\": \"\",\n      \"&LeftArrowRightArrow;\": \"\",\n      \"&LeftCeiling;\": \"\",\n      \"&LeftDoubleBracket;\": \"\",\n      \"&LeftDownTeeVector;\": \"\",\n      \"&LeftDownVector;\": \"\",\n      \"&LeftDownVectorBar;\": \"\",\n      \"&LeftFloor;\": \"\",\n      \"&LeftRightArrow;\": \"\",\n      \"&LeftRightVector;\": \"\",\n      \"&LeftTee;\": \"\",\n      \"&LeftTeeArrow;\": \"\",\n      \"&LeftTeeVector;\": \"\",\n      \"&LeftTriangle;\": \"\",\n      \"&LeftTriangleBar;\": \"\",\n      \"&LeftTriangleEqual;\": \"\",\n      \"&LeftUpDownVector;\": \"\",\n      \"&LeftUpTeeVector;\": \"\",\n      \"&LeftUpVector;\": \"\",\n      \"&LeftUpVectorBar;\": \"\",\n      \"&LeftVector;\": \"\",\n      \"&LeftVectorBar;\": \"\",\n      \"&Leftarrow;\": \"\",\n      \"&Leftrightarrow;\": \"\",\n      \"&LessEqualGreater;\": \"\",\n      \"&LessFullEqual;\": \"\",\n      \"&LessGreater;\": \"\",\n      \"&LessLess;\": \"\",\n      \"&LessSlantEqual;\": \"\",\n      \"&LessTilde;\": \"\",\n      \"&Lfr;\": \"\",\n      \"&Ll;\": \"\",\n      \"&Lleftarrow;\": \"\",\n      \"&Lmidot;\": \"\",\n      \"&LongLeftArrow;\": \"\",\n      \"&LongLeftRightArrow;\": \"\",\n      \"&LongRightArrow;\": \"\",\n      \"&Longleftarrow;\": \"\",\n      \"&Longleftrightarrow;\": \"\",\n      \"&Longrightarrow;\": \"\",\n      \"&Lopf;\": \"\",\n      \"&LowerLeftArrow;\": \"\",\n      \"&LowerRightArrow;\": \"\",\n      \"&Lscr;\": \"\",\n      \"&Lsh;\": \"\",\n      \"&Lstrok;\": \"\",\n      \"&Lt;\": \"\",\n      \"&Map;\": \"\",\n      \"&Mcy;\": \"\",\n      \"&MediumSpace;\": \"\",\n      \"&Mellintrf;\": \"\",\n      \"&Mfr;\": \"\",\n      \"&MinusPlus;\": \"\",\n      \"&Mopf;\": \"\",\n      \"&Mscr;\": \"\",\n      \"&Mu;\": \"\",\n      \"&NJcy;\": \"\",\n      \"&Nacute;\": \"\",\n      \"&Ncaron;\": \"\",\n      \"&Ncedil;\": \"\",\n      \"&Ncy;\": \"\",\n      \"&NegativeMediumSpace;\": \"\",\n      \"&NegativeThickSpace;\": \"\",\n      \"&NegativeThinSpace;\": \"\",\n      \"&NegativeVeryThinSpace;\": \"\",\n      \"&NestedGreaterGreater;\": \"\",\n      \"&NestedLessLess;\": \"\",\n      \"&NewLine;\": \"\\n\",\n      \"&Nfr;\": \"\",\n      \"&NoBreak;\": \"\",\n      \"&NonBreakingSpace;\": \"\",\n      \"&Nopf;\": \"\",\n      \"&Not;\": \"\",\n      \"&NotCongruent;\": \"\",\n      \"&NotCupCap;\": \"\",\n      \"&NotDoubleVerticalBar;\": \"\",\n      \"&NotElement;\": \"\",\n      \"&NotEqual;\": \"\",\n      \"&NotEqualTilde;\": \"\",\n      \"&NotExists;\": \"\",\n      \"&NotGreater;\": \"\",\n      \"&NotGreaterEqual;\": \"\",\n      \"&NotGreaterFullEqual;\": \"\",\n      \"&NotGreaterGreater;\": \"\",\n      \"&NotGreaterLess;\": \"\",\n      \"&NotGreaterSlantEqual;\": \"\",\n      \"&NotGreaterTilde;\": \"\",\n      \"&NotHumpDownHump;\": \"\",\n      \"&NotHumpEqual;\": \"\",\n      \"&NotLeftTriangle;\": \"\",\n      \"&NotLeftTriangleBar;\": \"\",\n      \"&NotLeftTriangleEqual;\": \"\",\n      \"&NotLess;\": \"\",\n      \"&NotLessEqual;\": \"\",\n      \"&NotLessGreater;\": \"\",\n      \"&NotLessLess;\": \"\",\n      \"&NotLessSlantEqual;\": \"\",\n      \"&NotLessTilde;\": \"\",\n      \"&NotNestedGreaterGreater;\": \"\",\n      \"&NotNestedLessLess;\": \"\",\n      \"&NotPrecedes;\": \"\",\n      \"&NotPrecedesEqual;\": \"\",\n      \"&NotPrecedesSlantEqual;\": \"\",\n      \"&NotReverseElement;\": \"\",\n      \"&NotRightTriangle;\": \"\",\n      \"&NotRightTriangleBar;\": \"\",\n      \"&NotRightTriangleEqual;\": \"\",\n      \"&NotSquareSubset;\": \"\",\n      \"&NotSquareSubsetEqual;\": \"\",\n      \"&NotSquareSuperset;\": \"\",\n      \"&NotSquareSupersetEqual;\": \"\",\n      \"&NotSubset;\": \"\",\n      \"&NotSubsetEqual;\": \"\",\n      \"&NotSucceeds;\": \"\",\n      \"&NotSucceedsEqual;\": \"\",\n      \"&NotSucceedsSlantEqual;\": \"\",\n      \"&NotSucceedsTilde;\": \"\",\n      \"&NotSuperset;\": \"\",\n      \"&NotSupersetEqual;\": \"\",\n      \"&NotTilde;\": \"\",\n      \"&NotTildeEqual;\": \"\",\n      \"&NotTildeFullEqual;\": \"\",\n      \"&NotTildeTilde;\": \"\",\n      \"&NotVerticalBar;\": \"\",\n      \"&Nscr;\": \"\",\n      \"&Ntilde\": \"\",\n      \"&Ntilde;\": \"\",\n      \"&Nu;\": \"\",\n      \"&OElig;\": \"\",\n      \"&Oacute\": \"\",\n      \"&Oacute;\": \"\",\n      \"&Ocirc\": \"\",\n      \"&Ocirc;\": \"\",\n      \"&Ocy;\": \"\",\n      \"&Odblac;\": \"\",\n      \"&Ofr;\": \"\",\n      \"&Ograve\": \"\",\n      \"&Ograve;\": \"\",\n      \"&Omacr;\": \"\",\n      \"&Omega;\": \"\",\n      \"&Omicron;\": \"\",\n      \"&Oopf;\": \"\",\n      \"&OpenCurlyDoubleQuote;\": \"\",\n      \"&OpenCurlyQuote;\": \"\",\n      \"&Or;\": \"\",\n      \"&Oscr;\": \"\",\n      \"&Oslash\": \"\",\n      \"&Oslash;\": \"\",\n      \"&Otilde\": \"\",\n      \"&Otilde;\": \"\",\n      \"&Otimes;\": \"\",\n      \"&Ouml\": \"\",\n      \"&Ouml;\": \"\",\n      \"&OverBar;\": \"\",\n      \"&OverBrace;\": \"\",\n      \"&OverBracket;\": \"\",\n      \"&OverParenthesis;\": \"\",\n      \"&PartialD;\": \"\",\n      \"&Pcy;\": \"\",\n      \"&Pfr;\": \"\",\n      \"&Phi;\": \"\",\n      \"&Pi;\": \"\",\n      \"&PlusMinus;\": \"\",\n      \"&Poincareplane;\": \"\",\n      \"&Popf;\": \"\",\n      \"&Pr;\": \"\",\n      \"&Precedes;\": \"\",\n      \"&PrecedesEqual;\": \"\",\n      \"&PrecedesSlantEqual;\": \"\",\n      \"&PrecedesTilde;\": \"\",\n      \"&Prime;\": \"\",\n      \"&Product;\": \"\",\n      \"&Proportion;\": \"\",\n      \"&Proportional;\": \"\",\n      \"&Pscr;\": \"\",\n      \"&Psi;\": \"\",\n      \"&QUOT\": '\"',\n      \"&QUOT;\": '\"',\n      \"&Qfr;\": \"\",\n      \"&Qopf;\": \"\",\n      \"&Qscr;\": \"\",\n      \"&RBarr;\": \"\",\n      \"&REG\": \"\",\n      \"&REG;\": \"\",\n      \"&Racute;\": \"\",\n      \"&Rang;\": \"\",\n      \"&Rarr;\": \"\",\n      \"&Rarrtl;\": \"\",\n      \"&Rcaron;\": \"\",\n      \"&Rcedil;\": \"\",\n      \"&Rcy;\": \"\",\n      \"&Re;\": \"\",\n      \"&ReverseElement;\": \"\",\n      \"&ReverseEquilibrium;\": \"\",\n      \"&ReverseUpEquilibrium;\": \"\",\n      \"&Rfr;\": \"\",\n      \"&Rho;\": \"\",\n      \"&RightAngleBracket;\": \"\",\n      \"&RightArrow;\": \"\",\n      \"&RightArrowBar;\": \"\",\n      \"&RightArrowLeftArrow;\": \"\",\n      \"&RightCeiling;\": \"\",\n      \"&RightDoubleBracket;\": \"\",\n      \"&RightDownTeeVector;\": \"\",\n      \"&RightDownVector;\": \"\",\n      \"&RightDownVectorBar;\": \"\",\n      \"&RightFloor;\": \"\",\n      \"&RightTee;\": \"\",\n      \"&RightTeeArrow;\": \"\",\n      \"&RightTeeVector;\": \"\",\n      \"&RightTriangle;\": \"\",\n      \"&RightTriangleBar;\": \"\",\n      \"&RightTriangleEqual;\": \"\",\n      \"&RightUpDownVector;\": \"\",\n      \"&RightUpTeeVector;\": \"\",\n      \"&RightUpVector;\": \"\",\n      \"&RightUpVectorBar;\": \"\",\n      \"&RightVector;\": \"\",\n      \"&RightVectorBar;\": \"\",\n      \"&Rightarrow;\": \"\",\n      \"&Ropf;\": \"\",\n      \"&RoundImplies;\": \"\",\n      \"&Rrightarrow;\": \"\",\n      \"&Rscr;\": \"\",\n      \"&Rsh;\": \"\",\n      \"&RuleDelayed;\": \"\",\n      \"&SHCHcy;\": \"\",\n      \"&SHcy;\": \"\",\n      \"&SOFTcy;\": \"\",\n      \"&Sacute;\": \"\",\n      \"&Sc;\": \"\",\n      \"&Scaron;\": \"\",\n      \"&Scedil;\": \"\",\n      \"&Scirc;\": \"\",\n      \"&Scy;\": \"\",\n      \"&Sfr;\": \"\",\n      \"&ShortDownArrow;\": \"\",\n      \"&ShortLeftArrow;\": \"\",\n      \"&ShortRightArrow;\": \"\",\n      \"&ShortUpArrow;\": \"\",\n      \"&Sigma;\": \"\",\n      \"&SmallCircle;\": \"\",\n      \"&Sopf;\": \"\",\n      \"&Sqrt;\": \"\",\n      \"&Square;\": \"\",\n      \"&SquareIntersection;\": \"\",\n      \"&SquareSubset;\": \"\",\n      \"&SquareSubsetEqual;\": \"\",\n      \"&SquareSuperset;\": \"\",\n      \"&SquareSupersetEqual;\": \"\",\n      \"&SquareUnion;\": \"\",\n      \"&Sscr;\": \"\",\n      \"&Star;\": \"\",\n      \"&Sub;\": \"\",\n      \"&Subset;\": \"\",\n      \"&SubsetEqual;\": \"\",\n      \"&Succeeds;\": \"\",\n      \"&SucceedsEqual;\": \"\",\n      \"&SucceedsSlantEqual;\": \"\",\n      \"&SucceedsTilde;\": \"\",\n      \"&SuchThat;\": \"\",\n      \"&Sum;\": \"\",\n      \"&Sup;\": \"\",\n      \"&Superset;\": \"\",\n      \"&SupersetEqual;\": \"\",\n      \"&Supset;\": \"\",\n      \"&THORN\": \"\",\n      \"&THORN;\": \"\",\n      \"&TRADE;\": \"\",\n      \"&TSHcy;\": \"\",\n      \"&TScy;\": \"\",\n      \"&Tab;\": \"\\t\",\n      \"&Tau;\": \"\",\n      \"&Tcaron;\": \"\",\n      \"&Tcedil;\": \"\",\n      \"&Tcy;\": \"\",\n      \"&Tfr;\": \"\",\n      \"&Therefore;\": \"\",\n      \"&Theta;\": \"\",\n      \"&ThickSpace;\": \"\",\n      \"&ThinSpace;\": \"\",\n      \"&Tilde;\": \"\",\n      \"&TildeEqual;\": \"\",\n      \"&TildeFullEqual;\": \"\",\n      \"&TildeTilde;\": \"\",\n      \"&Topf;\": \"\",\n      \"&TripleDot;\": \"\",\n      \"&Tscr;\": \"\",\n      \"&Tstrok;\": \"\",\n      \"&Uacute\": \"\",\n      \"&Uacute;\": \"\",\n      \"&Uarr;\": \"\",\n      \"&Uarrocir;\": \"\",\n      \"&Ubrcy;\": \"\",\n      \"&Ubreve;\": \"\",\n      \"&Ucirc\": \"\",\n      \"&Ucirc;\": \"\",\n      \"&Ucy;\": \"\",\n      \"&Udblac;\": \"\",\n      \"&Ufr;\": \"\",\n      \"&Ugrave\": \"\",\n      \"&Ugrave;\": \"\",\n      \"&Umacr;\": \"\",\n      \"&UnderBar;\": \"_\",\n      \"&UnderBrace;\": \"\",\n      \"&UnderBracket;\": \"\",\n      \"&UnderParenthesis;\": \"\",\n      \"&Union;\": \"\",\n      \"&UnionPlus;\": \"\",\n      \"&Uogon;\": \"\",\n      \"&Uopf;\": \"\",\n      \"&UpArrow;\": \"\",\n      \"&UpArrowBar;\": \"\",\n      \"&UpArrowDownArrow;\": \"\",\n      \"&UpDownArrow;\": \"\",\n      \"&UpEquilibrium;\": \"\",\n      \"&UpTee;\": \"\",\n      \"&UpTeeArrow;\": \"\",\n      \"&Uparrow;\": \"\",\n      \"&Updownarrow;\": \"\",\n      \"&UpperLeftArrow;\": \"\",\n      \"&UpperRightArrow;\": \"\",\n      \"&Upsi;\": \"\",\n      \"&Upsilon;\": \"\",\n      \"&Uring;\": \"\",\n      \"&Uscr;\": \"\",\n      \"&Utilde;\": \"\",\n      \"&Uuml\": \"\",\n      \"&Uuml;\": \"\",\n      \"&VDash;\": \"\",\n      \"&Vbar;\": \"\",\n      \"&Vcy;\": \"\",\n      \"&Vdash;\": \"\",\n      \"&Vdashl;\": \"\",\n      \"&Vee;\": \"\",\n      \"&Verbar;\": \"\",\n      \"&Vert;\": \"\",\n      \"&VerticalBar;\": \"\",\n      \"&VerticalLine;\": \"|\",\n      \"&VerticalSeparator;\": \"\",\n      \"&VerticalTilde;\": \"\",\n      \"&VeryThinSpace;\": \"\",\n      \"&Vfr;\": \"\",\n      \"&Vopf;\": \"\",\n      \"&Vscr;\": \"\",\n      \"&Vvdash;\": \"\",\n      \"&Wcirc;\": \"\",\n      \"&Wedge;\": \"\",\n      \"&Wfr;\": \"\",\n      \"&Wopf;\": \"\",\n      \"&Wscr;\": \"\",\n      \"&Xfr;\": \"\",\n      \"&Xi;\": \"\",\n      \"&Xopf;\": \"\",\n      \"&Xscr;\": \"\",\n      \"&YAcy;\": \"\",\n      \"&YIcy;\": \"\",\n      \"&YUcy;\": \"\",\n      \"&Yacute\": \"\",\n      \"&Yacute;\": \"\",\n      \"&Ycirc;\": \"\",\n      \"&Ycy;\": \"\",\n      \"&Yfr;\": \"\",\n      \"&Yopf;\": \"\",\n      \"&Yscr;\": \"\",\n      \"&Yuml;\": \"\",\n      \"&ZHcy;\": \"\",\n      \"&Zacute;\": \"\",\n      \"&Zcaron;\": \"\",\n      \"&Zcy;\": \"\",\n      \"&Zdot;\": \"\",\n      \"&ZeroWidthSpace;\": \"\",\n      \"&Zeta;\": \"\",\n      \"&Zfr;\": \"\",\n      \"&Zopf;\": \"\",\n      \"&Zscr;\": \"\",\n      \"&aacute\": \"\",\n      \"&aacute;\": \"\",\n      \"&abreve;\": \"\",\n      \"&ac;\": \"\",\n      \"&acE;\": \"\",\n      \"&acd;\": \"\",\n      \"&acirc\": \"\",\n      \"&acirc;\": \"\",\n      \"&acute\": \"\",\n      \"&acute;\": \"\",\n      \"&acy;\": \"\",\n      \"&aelig\": \"\",\n      \"&aelig;\": \"\",\n      \"&af;\": \"\",\n      \"&afr;\": \"\",\n      \"&agrave\": \"\",\n      \"&agrave;\": \"\",\n      \"&alefsym;\": \"\",\n      \"&aleph;\": \"\",\n      \"&alpha;\": \"\",\n      \"&amacr;\": \"\",\n      \"&amalg;\": \"\",\n      \"&amp\": \"&\",\n      \"&amp;\": \"&\",\n      \"&and;\": \"\",\n      \"&andand;\": \"\",\n      \"&andd;\": \"\",\n      \"&andslope;\": \"\",\n      \"&andv;\": \"\",\n      \"&ang;\": \"\",\n      \"&ange;\": \"\",\n      \"&angle;\": \"\",\n      \"&angmsd;\": \"\",\n      \"&angmsdaa;\": \"\",\n      \"&angmsdab;\": \"\",\n      \"&angmsdac;\": \"\",\n      \"&angmsdad;\": \"\",\n      \"&angmsdae;\": \"\",\n      \"&angmsdaf;\": \"\",\n      \"&angmsdag;\": \"\",\n      \"&angmsdah;\": \"\",\n      \"&angrt;\": \"\",\n      \"&angrtvb;\": \"\",\n      \"&angrtvbd;\": \"\",\n      \"&angsph;\": \"\",\n      \"&angst;\": \"\",\n      \"&angzarr;\": \"\",\n      \"&aogon;\": \"\",\n      \"&aopf;\": \"\",\n      \"&ap;\": \"\",\n      \"&apE;\": \"\",\n      \"&apacir;\": \"\",\n      \"&ape;\": \"\",\n      \"&apid;\": \"\",\n      \"&apos;\": \"'\",\n      \"&approx;\": \"\",\n      \"&approxeq;\": \"\",\n      \"&aring\": \"\",\n      \"&aring;\": \"\",\n      \"&ascr;\": \"\",\n      \"&ast;\": \"*\",\n      \"&asymp;\": \"\",\n      \"&asympeq;\": \"\",\n      \"&atilde\": \"\",\n      \"&atilde;\": \"\",\n      \"&auml\": \"\",\n      \"&auml;\": \"\",\n      \"&awconint;\": \"\",\n      \"&awint;\": \"\",\n      \"&bNot;\": \"\",\n      \"&backcong;\": \"\",\n      \"&backepsilon;\": \"\",\n      \"&backprime;\": \"\",\n      \"&backsim;\": \"\",\n      \"&backsimeq;\": \"\",\n      \"&barvee;\": \"\",\n      \"&barwed;\": \"\",\n      \"&barwedge;\": \"\",\n      \"&bbrk;\": \"\",\n      \"&bbrktbrk;\": \"\",\n      \"&bcong;\": \"\",\n      \"&bcy;\": \"\",\n      \"&bdquo;\": \"\",\n      \"&becaus;\": \"\",\n      \"&because;\": \"\",\n      \"&bemptyv;\": \"\",\n      \"&bepsi;\": \"\",\n      \"&bernou;\": \"\",\n      \"&beta;\": \"\",\n      \"&beth;\": \"\",\n      \"&between;\": \"\",\n      \"&bfr;\": \"\",\n      \"&bigcap;\": \"\",\n      \"&bigcirc;\": \"\",\n      \"&bigcup;\": \"\",\n      \"&bigodot;\": \"\",\n      \"&bigoplus;\": \"\",\n      \"&bigotimes;\": \"\",\n      \"&bigsqcup;\": \"\",\n      \"&bigstar;\": \"\",\n      \"&bigtriangledown;\": \"\",\n      \"&bigtriangleup;\": \"\",\n      \"&biguplus;\": \"\",\n      \"&bigvee;\": \"\",\n      \"&bigwedge;\": \"\",\n      \"&bkarow;\": \"\",\n      \"&blacklozenge;\": \"\",\n      \"&blacksquare;\": \"\",\n      \"&blacktriangle;\": \"\",\n      \"&blacktriangledown;\": \"\",\n      \"&blacktriangleleft;\": \"\",\n      \"&blacktriangleright;\": \"\",\n      \"&blank;\": \"\",\n      \"&blk12;\": \"\",\n      \"&blk14;\": \"\",\n      \"&blk34;\": \"\",\n      \"&block;\": \"\",\n      \"&bne;\": \"=\",\n      \"&bnequiv;\": \"\",\n      \"&bnot;\": \"\",\n      \"&bopf;\": \"\",\n      \"&bot;\": \"\",\n      \"&bottom;\": \"\",\n      \"&bowtie;\": \"\",\n      \"&boxDL;\": \"\",\n      \"&boxDR;\": \"\",\n      \"&boxDl;\": \"\",\n      \"&boxDr;\": \"\",\n      \"&boxH;\": \"\",\n      \"&boxHD;\": \"\",\n      \"&boxHU;\": \"\",\n      \"&boxHd;\": \"\",\n      \"&boxHu;\": \"\",\n      \"&boxUL;\": \"\",\n      \"&boxUR;\": \"\",\n      \"&boxUl;\": \"\",\n      \"&boxUr;\": \"\",\n      \"&boxV;\": \"\",\n      \"&boxVH;\": \"\",\n      \"&boxVL;\": \"\",\n      \"&boxVR;\": \"\",\n      \"&boxVh;\": \"\",\n      \"&boxVl;\": \"\",\n      \"&boxVr;\": \"\",\n      \"&boxbox;\": \"\",\n      \"&boxdL;\": \"\",\n      \"&boxdR;\": \"\",\n      \"&boxdl;\": \"\",\n      \"&boxdr;\": \"\",\n      \"&boxh;\": \"\",\n      \"&boxhD;\": \"\",\n      \"&boxhU;\": \"\",\n      \"&boxhd;\": \"\",\n      \"&boxhu;\": \"\",\n      \"&boxminus;\": \"\",\n      \"&boxplus;\": \"\",\n      \"&boxtimes;\": \"\",\n      \"&boxuL;\": \"\",\n      \"&boxuR;\": \"\",\n      \"&boxul;\": \"\",\n      \"&boxur;\": \"\",\n      \"&boxv;\": \"\",\n      \"&boxvH;\": \"\",\n      \"&boxvL;\": \"\",\n      \"&boxvR;\": \"\",\n      \"&boxvh;\": \"\",\n      \"&boxvl;\": \"\",\n      \"&boxvr;\": \"\",\n      \"&bprime;\": \"\",\n      \"&breve;\": \"\",\n      \"&brvbar\": \"\",\n      \"&brvbar;\": \"\",\n      \"&bscr;\": \"\",\n      \"&bsemi;\": \"\",\n      \"&bsim;\": \"\",\n      \"&bsime;\": \"\",\n      \"&bsol;\": \"\\\\\",\n      \"&bsolb;\": \"\",\n      \"&bsolhsub;\": \"\",\n      \"&bull;\": \"\",\n      \"&bullet;\": \"\",\n      \"&bump;\": \"\",\n      \"&bumpE;\": \"\",\n      \"&bumpe;\": \"\",\n      \"&bumpeq;\": \"\",\n      \"&cacute;\": \"\",\n      \"&cap;\": \"\",\n      \"&capand;\": \"\",\n      \"&capbrcup;\": \"\",\n      \"&capcap;\": \"\",\n      \"&capcup;\": \"\",\n      \"&capdot;\": \"\",\n      \"&caps;\": \"\",\n      \"&caret;\": \"\",\n      \"&caron;\": \"\",\n      \"&ccaps;\": \"\",\n      \"&ccaron;\": \"\",\n      \"&ccedil\": \"\",\n      \"&ccedil;\": \"\",\n      \"&ccirc;\": \"\",\n      \"&ccups;\": \"\",\n      \"&ccupssm;\": \"\",\n      \"&cdot;\": \"\",\n      \"&cedil\": \"\",\n      \"&cedil;\": \"\",\n      \"&cemptyv;\": \"\",\n      \"&cent\": \"\",\n      \"&cent;\": \"\",\n      \"&centerdot;\": \"\",\n      \"&cfr;\": \"\",\n      \"&chcy;\": \"\",\n      \"&check;\": \"\",\n      \"&checkmark;\": \"\",\n      \"&chi;\": \"\",\n      \"&cir;\": \"\",\n      \"&cirE;\": \"\",\n      \"&circ;\": \"\",\n      \"&circeq;\": \"\",\n      \"&circlearrowleft;\": \"\",\n      \"&circlearrowright;\": \"\",\n      \"&circledR;\": \"\",\n      \"&circledS;\": \"\",\n      \"&circledast;\": \"\",\n      \"&circledcirc;\": \"\",\n      \"&circleddash;\": \"\",\n      \"&cire;\": \"\",\n      \"&cirfnint;\": \"\",\n      \"&cirmid;\": \"\",\n      \"&cirscir;\": \"\",\n      \"&clubs;\": \"\",\n      \"&clubsuit;\": \"\",\n      \"&colon;\": \":\",\n      \"&colone;\": \"\",\n      \"&coloneq;\": \"\",\n      \"&comma;\": \",\",\n      \"&commat;\": \"@\",\n      \"&comp;\": \"\",\n      \"&compfn;\": \"\",\n      \"&complement;\": \"\",\n      \"&complexes;\": \"\",\n      \"&cong;\": \"\",\n      \"&congdot;\": \"\",\n      \"&conint;\": \"\",\n      \"&copf;\": \"\",\n      \"&coprod;\": \"\",\n      \"&copy\": \"\",\n      \"&copy;\": \"\",\n      \"&copysr;\": \"\",\n      \"&crarr;\": \"\",\n      \"&cross;\": \"\",\n      \"&cscr;\": \"\",\n      \"&csub;\": \"\",\n      \"&csube;\": \"\",\n      \"&csup;\": \"\",\n      \"&csupe;\": \"\",\n      \"&ctdot;\": \"\",\n      \"&cudarrl;\": \"\",\n      \"&cudarrr;\": \"\",\n      \"&cuepr;\": \"\",\n      \"&cuesc;\": \"\",\n      \"&cularr;\": \"\",\n      \"&cularrp;\": \"\",\n      \"&cup;\": \"\",\n      \"&cupbrcap;\": \"\",\n      \"&cupcap;\": \"\",\n      \"&cupcup;\": \"\",\n      \"&cupdot;\": \"\",\n      \"&cupor;\": \"\",\n      \"&cups;\": \"\",\n      \"&curarr;\": \"\",\n      \"&curarrm;\": \"\",\n      \"&curlyeqprec;\": \"\",\n      \"&curlyeqsucc;\": \"\",\n      \"&curlyvee;\": \"\",\n      \"&curlywedge;\": \"\",\n      \"&curren\": \"\",\n      \"&curren;\": \"\",\n      \"&curvearrowleft;\": \"\",\n      \"&curvearrowright;\": \"\",\n      \"&cuvee;\": \"\",\n      \"&cuwed;\": \"\",\n      \"&cwconint;\": \"\",\n      \"&cwint;\": \"\",\n      \"&cylcty;\": \"\",\n      \"&dArr;\": \"\",\n      \"&dHar;\": \"\",\n      \"&dagger;\": \"\",\n      \"&daleth;\": \"\",\n      \"&darr;\": \"\",\n      \"&dash;\": \"\",\n      \"&dashv;\": \"\",\n      \"&dbkarow;\": \"\",\n      \"&dblac;\": \"\",\n      \"&dcaron;\": \"\",\n      \"&dcy;\": \"\",\n      \"&dd;\": \"\",\n      \"&ddagger;\": \"\",\n      \"&ddarr;\": \"\",\n      \"&ddotseq;\": \"\",\n      \"&deg\": \"\",\n      \"&deg;\": \"\",\n      \"&delta;\": \"\",\n      \"&demptyv;\": \"\",\n      \"&dfisht;\": \"\",\n      \"&dfr;\": \"\",\n      \"&dharl;\": \"\",\n      \"&dharr;\": \"\",\n      \"&diam;\": \"\",\n      \"&diamond;\": \"\",\n      \"&diamondsuit;\": \"\",\n      \"&diams;\": \"\",\n      \"&die;\": \"\",\n      \"&digamma;\": \"\",\n      \"&disin;\": \"\",\n      \"&div;\": \"\",\n      \"&divide\": \"\",\n      \"&divide;\": \"\",\n      \"&divideontimes;\": \"\",\n      \"&divonx;\": \"\",\n      \"&djcy;\": \"\",\n      \"&dlcorn;\": \"\",\n      \"&dlcrop;\": \"\",\n      \"&dollar;\": \"$\",\n      \"&dopf;\": \"\",\n      \"&dot;\": \"\",\n      \"&doteq;\": \"\",\n      \"&doteqdot;\": \"\",\n      \"&dotminus;\": \"\",\n      \"&dotplus;\": \"\",\n      \"&dotsquare;\": \"\",\n      \"&doublebarwedge;\": \"\",\n      \"&downarrow;\": \"\",\n      \"&downdownarrows;\": \"\",\n      \"&downharpoonleft;\": \"\",\n      \"&downharpoonright;\": \"\",\n      \"&drbkarow;\": \"\",\n      \"&drcorn;\": \"\",\n      \"&drcrop;\": \"\",\n      \"&dscr;\": \"\",\n      \"&dscy;\": \"\",\n      \"&dsol;\": \"\",\n      \"&dstrok;\": \"\",\n      \"&dtdot;\": \"\",\n      \"&dtri;\": \"\",\n      \"&dtrif;\": \"\",\n      \"&duarr;\": \"\",\n      \"&duhar;\": \"\",\n      \"&dwangle;\": \"\",\n      \"&dzcy;\": \"\",\n      \"&dzigrarr;\": \"\",\n      \"&eDDot;\": \"\",\n      \"&eDot;\": \"\",\n      \"&eacute\": \"\",\n      \"&eacute;\": \"\",\n      \"&easter;\": \"\",\n      \"&ecaron;\": \"\",\n      \"&ecir;\": \"\",\n      \"&ecirc\": \"\",\n      \"&ecirc;\": \"\",\n      \"&ecolon;\": \"\",\n      \"&ecy;\": \"\",\n      \"&edot;\": \"\",\n      \"&ee;\": \"\",\n      \"&efDot;\": \"\",\n      \"&efr;\": \"\",\n      \"&eg;\": \"\",\n      \"&egrave\": \"\",\n      \"&egrave;\": \"\",\n      \"&egs;\": \"\",\n      \"&egsdot;\": \"\",\n      \"&el;\": \"\",\n      \"&elinters;\": \"\",\n      \"&ell;\": \"\",\n      \"&els;\": \"\",\n      \"&elsdot;\": \"\",\n      \"&emacr;\": \"\",\n      \"&empty;\": \"\",\n      \"&emptyset;\": \"\",\n      \"&emptyv;\": \"\",\n      \"&emsp13;\": \"\",\n      \"&emsp14;\": \"\",\n      \"&emsp;\": \"\",\n      \"&eng;\": \"\",\n      \"&ensp;\": \"\",\n      \"&eogon;\": \"\",\n      \"&eopf;\": \"\",\n      \"&epar;\": \"\",\n      \"&eparsl;\": \"\",\n      \"&eplus;\": \"\",\n      \"&epsi;\": \"\",\n      \"&epsilon;\": \"\",\n      \"&epsiv;\": \"\",\n      \"&eqcirc;\": \"\",\n      \"&eqcolon;\": \"\",\n      \"&eqsim;\": \"\",\n      \"&eqslantgtr;\": \"\",\n      \"&eqslantless;\": \"\",\n      \"&equals;\": \"=\",\n      \"&equest;\": \"\",\n      \"&equiv;\": \"\",\n      \"&equivDD;\": \"\",\n      \"&eqvparsl;\": \"\",\n      \"&erDot;\": \"\",\n      \"&erarr;\": \"\",\n      \"&escr;\": \"\",\n      \"&esdot;\": \"\",\n      \"&esim;\": \"\",\n      \"&eta;\": \"\",\n      \"&eth\": \"\",\n      \"&eth;\": \"\",\n      \"&euml\": \"\",\n      \"&euml;\": \"\",\n      \"&euro;\": \"\",\n      \"&excl;\": \"!\",\n      \"&exist;\": \"\",\n      \"&expectation;\": \"\",\n      \"&exponentiale;\": \"\",\n      \"&fallingdotseq;\": \"\",\n      \"&fcy;\": \"\",\n      \"&female;\": \"\",\n      \"&ffilig;\": \"\",\n      \"&fflig;\": \"\",\n      \"&ffllig;\": \"\",\n      \"&ffr;\": \"\",\n      \"&filig;\": \"\",\n      \"&fjlig;\": \"fj\",\n      \"&flat;\": \"\",\n      \"&fllig;\": \"\",\n      \"&fltns;\": \"\",\n      \"&fnof;\": \"\",\n      \"&fopf;\": \"\",\n      \"&forall;\": \"\",\n      \"&fork;\": \"\",\n      \"&forkv;\": \"\",\n      \"&fpartint;\": \"\",\n      \"&frac12\": \"\",\n      \"&frac12;\": \"\",\n      \"&frac13;\": \"\",\n      \"&frac14\": \"\",\n      \"&frac14;\": \"\",\n      \"&frac15;\": \"\",\n      \"&frac16;\": \"\",\n      \"&frac18;\": \"\",\n      \"&frac23;\": \"\",\n      \"&frac25;\": \"\",\n      \"&frac34\": \"\",\n      \"&frac34;\": \"\",\n      \"&frac35;\": \"\",\n      \"&frac38;\": \"\",\n      \"&frac45;\": \"\",\n      \"&frac56;\": \"\",\n      \"&frac58;\": \"\",\n      \"&frac78;\": \"\",\n      \"&frasl;\": \"\",\n      \"&frown;\": \"\",\n      \"&fscr;\": \"\",\n      \"&gE;\": \"\",\n      \"&gEl;\": \"\",\n      \"&gacute;\": \"\",\n      \"&gamma;\": \"\",\n      \"&gammad;\": \"\",\n      \"&gap;\": \"\",\n      \"&gbreve;\": \"\",\n      \"&gcirc;\": \"\",\n      \"&gcy;\": \"\",\n      \"&gdot;\": \"\",\n      \"&ge;\": \"\",\n      \"&gel;\": \"\",\n      \"&geq;\": \"\",\n      \"&geqq;\": \"\",\n      \"&geqslant;\": \"\",\n      \"&ges;\": \"\",\n      \"&gescc;\": \"\",\n      \"&gesdot;\": \"\",\n      \"&gesdoto;\": \"\",\n      \"&gesdotol;\": \"\",\n      \"&gesl;\": \"\",\n      \"&gesles;\": \"\",\n      \"&gfr;\": \"\",\n      \"&gg;\": \"\",\n      \"&ggg;\": \"\",\n      \"&gimel;\": \"\",\n      \"&gjcy;\": \"\",\n      \"&gl;\": \"\",\n      \"&glE;\": \"\",\n      \"&gla;\": \"\",\n      \"&glj;\": \"\",\n      \"&gnE;\": \"\",\n      \"&gnap;\": \"\",\n      \"&gnapprox;\": \"\",\n      \"&gne;\": \"\",\n      \"&gneq;\": \"\",\n      \"&gneqq;\": \"\",\n      \"&gnsim;\": \"\",\n      \"&gopf;\": \"\",\n      \"&grave;\": \"`\",\n      \"&gscr;\": \"\",\n      \"&gsim;\": \"\",\n      \"&gsime;\": \"\",\n      \"&gsiml;\": \"\",\n      \"&gt\": \">\",\n      \"&gt;\": \">\",\n      \"&gtcc;\": \"\",\n      \"&gtcir;\": \"\",\n      \"&gtdot;\": \"\",\n      \"&gtlPar;\": \"\",\n      \"&gtquest;\": \"\",\n      \"&gtrapprox;\": \"\",\n      \"&gtrarr;\": \"\",\n      \"&gtrdot;\": \"\",\n      \"&gtreqless;\": \"\",\n      \"&gtreqqless;\": \"\",\n      \"&gtrless;\": \"\",\n      \"&gtrsim;\": \"\",\n      \"&gvertneqq;\": \"\",\n      \"&gvnE;\": \"\",\n      \"&hArr;\": \"\",\n      \"&hairsp;\": \"\",\n      \"&half;\": \"\",\n      \"&hamilt;\": \"\",\n      \"&hardcy;\": \"\",\n      \"&harr;\": \"\",\n      \"&harrcir;\": \"\",\n      \"&harrw;\": \"\",\n      \"&hbar;\": \"\",\n      \"&hcirc;\": \"\",\n      \"&hearts;\": \"\",\n      \"&heartsuit;\": \"\",\n      \"&hellip;\": \"\",\n      \"&hercon;\": \"\",\n      \"&hfr;\": \"\",\n      \"&hksearow;\": \"\",\n      \"&hkswarow;\": \"\",\n      \"&hoarr;\": \"\",\n      \"&homtht;\": \"\",\n      \"&hookleftarrow;\": \"\",\n      \"&hookrightarrow;\": \"\",\n      \"&hopf;\": \"\",\n      \"&horbar;\": \"\",\n      \"&hscr;\": \"\",\n      \"&hslash;\": \"\",\n      \"&hstrok;\": \"\",\n      \"&hybull;\": \"\",\n      \"&hyphen;\": \"\",\n      \"&iacute\": \"\",\n      \"&iacute;\": \"\",\n      \"&ic;\": \"\",\n      \"&icirc\": \"\",\n      \"&icirc;\": \"\",\n      \"&icy;\": \"\",\n      \"&iecy;\": \"\",\n      \"&iexcl\": \"\",\n      \"&iexcl;\": \"\",\n      \"&iff;\": \"\",\n      \"&ifr;\": \"\",\n      \"&igrave\": \"\",\n      \"&igrave;\": \"\",\n      \"&ii;\": \"\",\n      \"&iiiint;\": \"\",\n      \"&iiint;\": \"\",\n      \"&iinfin;\": \"\",\n      \"&iiota;\": \"\",\n      \"&ijlig;\": \"\",\n      \"&imacr;\": \"\",\n      \"&image;\": \"\",\n      \"&imagline;\": \"\",\n      \"&imagpart;\": \"\",\n      \"&imath;\": \"\",\n      \"&imof;\": \"\",\n      \"&imped;\": \"\",\n      \"&in;\": \"\",\n      \"&incare;\": \"\",\n      \"&infin;\": \"\",\n      \"&infintie;\": \"\",\n      \"&inodot;\": \"\",\n      \"&int;\": \"\",\n      \"&intcal;\": \"\",\n      \"&integers;\": \"\",\n      \"&intercal;\": \"\",\n      \"&intlarhk;\": \"\",\n      \"&intprod;\": \"\",\n      \"&iocy;\": \"\",\n      \"&iogon;\": \"\",\n      \"&iopf;\": \"\",\n      \"&iota;\": \"\",\n      \"&iprod;\": \"\",\n      \"&iquest\": \"\",\n      \"&iquest;\": \"\",\n      \"&iscr;\": \"\",\n      \"&isin;\": \"\",\n      \"&isinE;\": \"\",\n      \"&isindot;\": \"\",\n      \"&isins;\": \"\",\n      \"&isinsv;\": \"\",\n      \"&isinv;\": \"\",\n      \"&it;\": \"\",\n      \"&itilde;\": \"\",\n      \"&iukcy;\": \"\",\n      \"&iuml\": \"\",\n      \"&iuml;\": \"\",\n      \"&jcirc;\": \"\",\n      \"&jcy;\": \"\",\n      \"&jfr;\": \"\",\n      \"&jmath;\": \"\",\n      \"&jopf;\": \"\",\n      \"&jscr;\": \"\",\n      \"&jsercy;\": \"\",\n      \"&jukcy;\": \"\",\n      \"&kappa;\": \"\",\n      \"&kappav;\": \"\",\n      \"&kcedil;\": \"\",\n      \"&kcy;\": \"\",\n      \"&kfr;\": \"\",\n      \"&kgreen;\": \"\",\n      \"&khcy;\": \"\",\n      \"&kjcy;\": \"\",\n      \"&kopf;\": \"\",\n      \"&kscr;\": \"\",\n      \"&lAarr;\": \"\",\n      \"&lArr;\": \"\",\n      \"&lAtail;\": \"\",\n      \"&lBarr;\": \"\",\n      \"&lE;\": \"\",\n      \"&lEg;\": \"\",\n      \"&lHar;\": \"\",\n      \"&lacute;\": \"\",\n      \"&laemptyv;\": \"\",\n      \"&lagran;\": \"\",\n      \"&lambda;\": \"\",\n      \"&lang;\": \"\",\n      \"&langd;\": \"\",\n      \"&langle;\": \"\",\n      \"&lap;\": \"\",\n      \"&laquo\": \"\",\n      \"&laquo;\": \"\",\n      \"&larr;\": \"\",\n      \"&larrb;\": \"\",\n      \"&larrbfs;\": \"\",\n      \"&larrfs;\": \"\",\n      \"&larrhk;\": \"\",\n      \"&larrlp;\": \"\",\n      \"&larrpl;\": \"\",\n      \"&larrsim;\": \"\",\n      \"&larrtl;\": \"\",\n      \"&lat;\": \"\",\n      \"&latail;\": \"\",\n      \"&late;\": \"\",\n      \"&lates;\": \"\",\n      \"&lbarr;\": \"\",\n      \"&lbbrk;\": \"\",\n      \"&lbrace;\": \"{\",\n      \"&lbrack;\": \"[\",\n      \"&lbrke;\": \"\",\n      \"&lbrksld;\": \"\",\n      \"&lbrkslu;\": \"\",\n      \"&lcaron;\": \"\",\n      \"&lcedil;\": \"\",\n      \"&lceil;\": \"\",\n      \"&lcub;\": \"{\",\n      \"&lcy;\": \"\",\n      \"&ldca;\": \"\",\n      \"&ldquo;\": \"\",\n      \"&ldquor;\": \"\",\n      \"&ldrdhar;\": \"\",\n      \"&ldrushar;\": \"\",\n      \"&ldsh;\": \"\",\n      \"&le;\": \"\",\n      \"&leftarrow;\": \"\",\n      \"&leftarrowtail;\": \"\",\n      \"&leftharpoondown;\": \"\",\n      \"&leftharpoonup;\": \"\",\n      \"&leftleftarrows;\": \"\",\n      \"&leftrightarrow;\": \"\",\n      \"&leftrightarrows;\": \"\",\n      \"&leftrightharpoons;\": \"\",\n      \"&leftrightsquigarrow;\": \"\",\n      \"&leftthreetimes;\": \"\",\n      \"&leg;\": \"\",\n      \"&leq;\": \"\",\n      \"&leqq;\": \"\",\n      \"&leqslant;\": \"\",\n      \"&les;\": \"\",\n      \"&lescc;\": \"\",\n      \"&lesdot;\": \"\",\n      \"&lesdoto;\": \"\",\n      \"&lesdotor;\": \"\",\n      \"&lesg;\": \"\",\n      \"&lesges;\": \"\",\n      \"&lessapprox;\": \"\",\n      \"&lessdot;\": \"\",\n      \"&lesseqgtr;\": \"\",\n      \"&lesseqqgtr;\": \"\",\n      \"&lessgtr;\": \"\",\n      \"&lesssim;\": \"\",\n      \"&lfisht;\": \"\",\n      \"&lfloor;\": \"\",\n      \"&lfr;\": \"\",\n      \"&lg;\": \"\",\n      \"&lgE;\": \"\",\n      \"&lhard;\": \"\",\n      \"&lharu;\": \"\",\n      \"&lharul;\": \"\",\n      \"&lhblk;\": \"\",\n      \"&ljcy;\": \"\",\n      \"&ll;\": \"\",\n      \"&llarr;\": \"\",\n      \"&llcorner;\": \"\",\n      \"&llhard;\": \"\",\n      \"&lltri;\": \"\",\n      \"&lmidot;\": \"\",\n      \"&lmoust;\": \"\",\n      \"&lmoustache;\": \"\",\n      \"&lnE;\": \"\",\n      \"&lnap;\": \"\",\n      \"&lnapprox;\": \"\",\n      \"&lne;\": \"\",\n      \"&lneq;\": \"\",\n      \"&lneqq;\": \"\",\n      \"&lnsim;\": \"\",\n      \"&loang;\": \"\",\n      \"&loarr;\": \"\",\n      \"&lobrk;\": \"\",\n      \"&longleftarrow;\": \"\",\n      \"&longleftrightarrow;\": \"\",\n      \"&longmapsto;\": \"\",\n      \"&longrightarrow;\": \"\",\n      \"&looparrowleft;\": \"\",\n      \"&looparrowright;\": \"\",\n      \"&lopar;\": \"\",\n      \"&lopf;\": \"\",\n      \"&loplus;\": \"\",\n      \"&lotimes;\": \"\",\n      \"&lowast;\": \"\",\n      \"&lowbar;\": \"_\",\n      \"&loz;\": \"\",\n      \"&lozenge;\": \"\",\n      \"&lozf;\": \"\",\n      \"&lpar;\": \"(\",\n      \"&lparlt;\": \"\",\n      \"&lrarr;\": \"\",\n      \"&lrcorner;\": \"\",\n      \"&lrhar;\": \"\",\n      \"&lrhard;\": \"\",\n      \"&lrm;\": \"\",\n      \"&lrtri;\": \"\",\n      \"&lsaquo;\": \"\",\n      \"&lscr;\": \"\",\n      \"&lsh;\": \"\",\n      \"&lsim;\": \"\",\n      \"&lsime;\": \"\",\n      \"&lsimg;\": \"\",\n      \"&lsqb;\": \"[\",\n      \"&lsquo;\": \"\",\n      \"&lsquor;\": \"\",\n      \"&lstrok;\": \"\",\n      \"&lt\": \"<\",\n      \"&lt;\": \"<\",\n      \"&ltcc;\": \"\",\n      \"&ltcir;\": \"\",\n      \"&ltdot;\": \"\",\n      \"&lthree;\": \"\",\n      \"&ltimes;\": \"\",\n      \"&ltlarr;\": \"\",\n      \"&ltquest;\": \"\",\n      \"&ltrPar;\": \"\",\n      \"&ltri;\": \"\",\n      \"&ltrie;\": \"\",\n      \"&ltrif;\": \"\",\n      \"&lurdshar;\": \"\",\n      \"&luruhar;\": \"\",\n      \"&lvertneqq;\": \"\",\n      \"&lvnE;\": \"\",\n      \"&mDDot;\": \"\",\n      \"&macr\": \"\",\n      \"&macr;\": \"\",\n      \"&male;\": \"\",\n      \"&malt;\": \"\",\n      \"&maltese;\": \"\",\n      \"&map;\": \"\",\n      \"&mapsto;\": \"\",\n      \"&mapstodown;\": \"\",\n      \"&mapstoleft;\": \"\",\n      \"&mapstoup;\": \"\",\n      \"&marker;\": \"\",\n      \"&mcomma;\": \"\",\n      \"&mcy;\": \"\",\n      \"&mdash;\": \"\",\n      \"&measuredangle;\": \"\",\n      \"&mfr;\": \"\",\n      \"&mho;\": \"\",\n      \"&micro\": \"\",\n      \"&micro;\": \"\",\n      \"&mid;\": \"\",\n      \"&midast;\": \"*\",\n      \"&midcir;\": \"\",\n      \"&middot\": \"\",\n      \"&middot;\": \"\",\n      \"&minus;\": \"\",\n      \"&minusb;\": \"\",\n      \"&minusd;\": \"\",\n      \"&minusdu;\": \"\",\n      \"&mlcp;\": \"\",\n      \"&mldr;\": \"\",\n      \"&mnplus;\": \"\",\n      \"&models;\": \"\",\n      \"&mopf;\": \"\",\n      \"&mp;\": \"\",\n      \"&mscr;\": \"\",\n      \"&mstpos;\": \"\",\n      \"&mu;\": \"\",\n      \"&multimap;\": \"\",\n      \"&mumap;\": \"\",\n      \"&nGg;\": \"\",\n      \"&nGt;\": \"\",\n      \"&nGtv;\": \"\",\n      \"&nLeftarrow;\": \"\",\n      \"&nLeftrightarrow;\": \"\",\n      \"&nLl;\": \"\",\n      \"&nLt;\": \"\",\n      \"&nLtv;\": \"\",\n      \"&nRightarrow;\": \"\",\n      \"&nVDash;\": \"\",\n      \"&nVdash;\": \"\",\n      \"&nabla;\": \"\",\n      \"&nacute;\": \"\",\n      \"&nang;\": \"\",\n      \"&nap;\": \"\",\n      \"&napE;\": \"\",\n      \"&napid;\": \"\",\n      \"&napos;\": \"\",\n      \"&napprox;\": \"\",\n      \"&natur;\": \"\",\n      \"&natural;\": \"\",\n      \"&naturals;\": \"\",\n      \"&nbsp\": \"\",\n      \"&nbsp;\": \"\",\n      \"&nbump;\": \"\",\n      \"&nbumpe;\": \"\",\n      \"&ncap;\": \"\",\n      \"&ncaron;\": \"\",\n      \"&ncedil;\": \"\",\n      \"&ncong;\": \"\",\n      \"&ncongdot;\": \"\",\n      \"&ncup;\": \"\",\n      \"&ncy;\": \"\",\n      \"&ndash;\": \"\",\n      \"&ne;\": \"\",\n      \"&neArr;\": \"\",\n      \"&nearhk;\": \"\",\n      \"&nearr;\": \"\",\n      \"&nearrow;\": \"\",\n      \"&nedot;\": \"\",\n      \"&nequiv;\": \"\",\n      \"&nesear;\": \"\",\n      \"&nesim;\": \"\",\n      \"&nexist;\": \"\",\n      \"&nexists;\": \"\",\n      \"&nfr;\": \"\",\n      \"&ngE;\": \"\",\n      \"&nge;\": \"\",\n      \"&ngeq;\": \"\",\n      \"&ngeqq;\": \"\",\n      \"&ngeqslant;\": \"\",\n      \"&nges;\": \"\",\n      \"&ngsim;\": \"\",\n      \"&ngt;\": \"\",\n      \"&ngtr;\": \"\",\n      \"&nhArr;\": \"\",\n      \"&nharr;\": \"\",\n      \"&nhpar;\": \"\",\n      \"&ni;\": \"\",\n      \"&nis;\": \"\",\n      \"&nisd;\": \"\",\n      \"&niv;\": \"\",\n      \"&njcy;\": \"\",\n      \"&nlArr;\": \"\",\n      \"&nlE;\": \"\",\n      \"&nlarr;\": \"\",\n      \"&nldr;\": \"\",\n      \"&nle;\": \"\",\n      \"&nleftarrow;\": \"\",\n      \"&nleftrightarrow;\": \"\",\n      \"&nleq;\": \"\",\n      \"&nleqq;\": \"\",\n      \"&nleqslant;\": \"\",\n      \"&nles;\": \"\",\n      \"&nless;\": \"\",\n      \"&nlsim;\": \"\",\n      \"&nlt;\": \"\",\n      \"&nltri;\": \"\",\n      \"&nltrie;\": \"\",\n      \"&nmid;\": \"\",\n      \"&nopf;\": \"\",\n      \"&not\": \"\",\n      \"&not;\": \"\",\n      \"&notin;\": \"\",\n      \"&notinE;\": \"\",\n      \"&notindot;\": \"\",\n      \"&notinva;\": \"\",\n      \"&notinvb;\": \"\",\n      \"&notinvc;\": \"\",\n      \"&notni;\": \"\",\n      \"&notniva;\": \"\",\n      \"&notnivb;\": \"\",\n      \"&notnivc;\": \"\",\n      \"&npar;\": \"\",\n      \"&nparallel;\": \"\",\n      \"&nparsl;\": \"\",\n      \"&npart;\": \"\",\n      \"&npolint;\": \"\",\n      \"&npr;\": \"\",\n      \"&nprcue;\": \"\",\n      \"&npre;\": \"\",\n      \"&nprec;\": \"\",\n      \"&npreceq;\": \"\",\n      \"&nrArr;\": \"\",\n      \"&nrarr;\": \"\",\n      \"&nrarrc;\": \"\",\n      \"&nrarrw;\": \"\",\n      \"&nrightarrow;\": \"\",\n      \"&nrtri;\": \"\",\n      \"&nrtrie;\": \"\",\n      \"&nsc;\": \"\",\n      \"&nsccue;\": \"\",\n      \"&nsce;\": \"\",\n      \"&nscr;\": \"\",\n      \"&nshortmid;\": \"\",\n      \"&nshortparallel;\": \"\",\n      \"&nsim;\": \"\",\n      \"&nsime;\": \"\",\n      \"&nsimeq;\": \"\",\n      \"&nsmid;\": \"\",\n      \"&nspar;\": \"\",\n      \"&nsqsube;\": \"\",\n      \"&nsqsupe;\": \"\",\n      \"&nsub;\": \"\",\n      \"&nsubE;\": \"\",\n      \"&nsube;\": \"\",\n      \"&nsubset;\": \"\",\n      \"&nsubseteq;\": \"\",\n      \"&nsubseteqq;\": \"\",\n      \"&nsucc;\": \"\",\n      \"&nsucceq;\": \"\",\n      \"&nsup;\": \"\",\n      \"&nsupE;\": \"\",\n      \"&nsupe;\": \"\",\n      \"&nsupset;\": \"\",\n      \"&nsupseteq;\": \"\",\n      \"&nsupseteqq;\": \"\",\n      \"&ntgl;\": \"\",\n      \"&ntilde\": \"\",\n      \"&ntilde;\": \"\",\n      \"&ntlg;\": \"\",\n      \"&ntriangleleft;\": \"\",\n      \"&ntrianglelefteq;\": \"\",\n      \"&ntriangleright;\": \"\",\n      \"&ntrianglerighteq;\": \"\",\n      \"&nu;\": \"\",\n      \"&num;\": \"#\",\n      \"&numero;\": \"\",\n      \"&numsp;\": \"\",\n      \"&nvDash;\": \"\",\n      \"&nvHarr;\": \"\",\n      \"&nvap;\": \"\",\n      \"&nvdash;\": \"\",\n      \"&nvge;\": \"\",\n      \"&nvgt;\": \">\",\n      \"&nvinfin;\": \"\",\n      \"&nvlArr;\": \"\",\n      \"&nvle;\": \"\",\n      \"&nvlt;\": \"<\",\n      \"&nvltrie;\": \"\",\n      \"&nvrArr;\": \"\",\n      \"&nvrtrie;\": \"\",\n      \"&nvsim;\": \"\",\n      \"&nwArr;\": \"\",\n      \"&nwarhk;\": \"\",\n      \"&nwarr;\": \"\",\n      \"&nwarrow;\": \"\",\n      \"&nwnear;\": \"\",\n      \"&oS;\": \"\",\n      \"&oacute\": \"\",\n      \"&oacute;\": \"\",\n      \"&oast;\": \"\",\n      \"&ocir;\": \"\",\n      \"&ocirc\": \"\",\n      \"&ocirc;\": \"\",\n      \"&ocy;\": \"\",\n      \"&odash;\": \"\",\n      \"&odblac;\": \"\",\n      \"&odiv;\": \"\",\n      \"&odot;\": \"\",\n      \"&odsold;\": \"\",\n      \"&oelig;\": \"\",\n      \"&ofcir;\": \"\",\n      \"&ofr;\": \"\",\n      \"&ogon;\": \"\",\n      \"&ograve\": \"\",\n      \"&ograve;\": \"\",\n      \"&ogt;\": \"\",\n      \"&ohbar;\": \"\",\n      \"&ohm;\": \"\",\n      \"&oint;\": \"\",\n      \"&olarr;\": \"\",\n      \"&olcir;\": \"\",\n      \"&olcross;\": \"\",\n      \"&oline;\": \"\",\n      \"&olt;\": \"\",\n      \"&omacr;\": \"\",\n      \"&omega;\": \"\",\n      \"&omicron;\": \"\",\n      \"&omid;\": \"\",\n      \"&ominus;\": \"\",\n      \"&oopf;\": \"\",\n      \"&opar;\": \"\",\n      \"&operp;\": \"\",\n      \"&oplus;\": \"\",\n      \"&or;\": \"\",\n      \"&orarr;\": \"\",\n      \"&ord;\": \"\",\n      \"&order;\": \"\",\n      \"&orderof;\": \"\",\n      \"&ordf\": \"\",\n      \"&ordf;\": \"\",\n      \"&ordm\": \"\",\n      \"&ordm;\": \"\",\n      \"&origof;\": \"\",\n      \"&oror;\": \"\",\n      \"&orslope;\": \"\",\n      \"&orv;\": \"\",\n      \"&oscr;\": \"\",\n      \"&oslash\": \"\",\n      \"&oslash;\": \"\",\n      \"&osol;\": \"\",\n      \"&otilde\": \"\",\n      \"&otilde;\": \"\",\n      \"&otimes;\": \"\",\n      \"&otimesas;\": \"\",\n      \"&ouml\": \"\",\n      \"&ouml;\": \"\",\n      \"&ovbar;\": \"\",\n      \"&par;\": \"\",\n      \"&para\": \"\",\n      \"&para;\": \"\",\n      \"&parallel;\": \"\",\n      \"&parsim;\": \"\",\n      \"&parsl;\": \"\",\n      \"&part;\": \"\",\n      \"&pcy;\": \"\",\n      \"&percnt;\": \"%\",\n      \"&period;\": \".\",\n      \"&permil;\": \"\",\n      \"&perp;\": \"\",\n      \"&pertenk;\": \"\",\n      \"&pfr;\": \"\",\n      \"&phi;\": \"\",\n      \"&phiv;\": \"\",\n      \"&phmmat;\": \"\",\n      \"&phone;\": \"\",\n      \"&pi;\": \"\",\n      \"&pitchfork;\": \"\",\n      \"&piv;\": \"\",\n      \"&planck;\": \"\",\n      \"&planckh;\": \"\",\n      \"&plankv;\": \"\",\n      \"&plus;\": \"+\",\n      \"&plusacir;\": \"\",\n      \"&plusb;\": \"\",\n      \"&pluscir;\": \"\",\n      \"&plusdo;\": \"\",\n      \"&plusdu;\": \"\",\n      \"&pluse;\": \"\",\n      \"&plusmn\": \"\",\n      \"&plusmn;\": \"\",\n      \"&plussim;\": \"\",\n      \"&plustwo;\": \"\",\n      \"&pm;\": \"\",\n      \"&pointint;\": \"\",\n      \"&popf;\": \"\",\n      \"&pound\": \"\",\n      \"&pound;\": \"\",\n      \"&pr;\": \"\",\n      \"&prE;\": \"\",\n      \"&prap;\": \"\",\n      \"&prcue;\": \"\",\n      \"&pre;\": \"\",\n      \"&prec;\": \"\",\n      \"&precapprox;\": \"\",\n      \"&preccurlyeq;\": \"\",\n      \"&preceq;\": \"\",\n      \"&precnapprox;\": \"\",\n      \"&precneqq;\": \"\",\n      \"&precnsim;\": \"\",\n      \"&precsim;\": \"\",\n      \"&prime;\": \"\",\n      \"&primes;\": \"\",\n      \"&prnE;\": \"\",\n      \"&prnap;\": \"\",\n      \"&prnsim;\": \"\",\n      \"&prod;\": \"\",\n      \"&profalar;\": \"\",\n      \"&profline;\": \"\",\n      \"&profsurf;\": \"\",\n      \"&prop;\": \"\",\n      \"&propto;\": \"\",\n      \"&prsim;\": \"\",\n      \"&prurel;\": \"\",\n      \"&pscr;\": \"\",\n      \"&psi;\": \"\",\n      \"&puncsp;\": \"\",\n      \"&qfr;\": \"\",\n      \"&qint;\": \"\",\n      \"&qopf;\": \"\",\n      \"&qprime;\": \"\",\n      \"&qscr;\": \"\",\n      \"&quaternions;\": \"\",\n      \"&quatint;\": \"\",\n      \"&quest;\": \"?\",\n      \"&questeq;\": \"\",\n      \"&quot\": '\"',\n      \"&quot;\": '\"',\n      \"&rAarr;\": \"\",\n      \"&rArr;\": \"\",\n      \"&rAtail;\": \"\",\n      \"&rBarr;\": \"\",\n      \"&rHar;\": \"\",\n      \"&race;\": \"\",\n      \"&racute;\": \"\",\n      \"&radic;\": \"\",\n      \"&raemptyv;\": \"\",\n      \"&rang;\": \"\",\n      \"&rangd;\": \"\",\n      \"&range;\": \"\",\n      \"&rangle;\": \"\",\n      \"&raquo\": \"\",\n      \"&raquo;\": \"\",\n      \"&rarr;\": \"\",\n      \"&rarrap;\": \"\",\n      \"&rarrb;\": \"\",\n      \"&rarrbfs;\": \"\",\n      \"&rarrc;\": \"\",\n      \"&rarrfs;\": \"\",\n      \"&rarrhk;\": \"\",\n      \"&rarrlp;\": \"\",\n      \"&rarrpl;\": \"\",\n      \"&rarrsim;\": \"\",\n      \"&rarrtl;\": \"\",\n      \"&rarrw;\": \"\",\n      \"&ratail;\": \"\",\n      \"&ratio;\": \"\",\n      \"&rationals;\": \"\",\n      \"&rbarr;\": \"\",\n      \"&rbbrk;\": \"\",\n      \"&rbrace;\": \"}\",\n      \"&rbrack;\": \"]\",\n      \"&rbrke;\": \"\",\n      \"&rbrksld;\": \"\",\n      \"&rbrkslu;\": \"\",\n      \"&rcaron;\": \"\",\n      \"&rcedil;\": \"\",\n      \"&rceil;\": \"\",\n      \"&rcub;\": \"}\",\n      \"&rcy;\": \"\",\n      \"&rdca;\": \"\",\n      \"&rdldhar;\": \"\",\n      \"&rdquo;\": \"\",\n      \"&rdquor;\": \"\",\n      \"&rdsh;\": \"\",\n      \"&real;\": \"\",\n      \"&realine;\": \"\",\n      \"&realpart;\": \"\",\n      \"&reals;\": \"\",\n      \"&rect;\": \"\",\n      \"&reg\": \"\",\n      \"&reg;\": \"\",\n      \"&rfisht;\": \"\",\n      \"&rfloor;\": \"\",\n      \"&rfr;\": \"\",\n      \"&rhard;\": \"\",\n      \"&rharu;\": \"\",\n      \"&rharul;\": \"\",\n      \"&rho;\": \"\",\n      \"&rhov;\": \"\",\n      \"&rightarrow;\": \"\",\n      \"&rightarrowtail;\": \"\",\n      \"&rightharpoondown;\": \"\",\n      \"&rightharpoonup;\": \"\",\n      \"&rightleftarrows;\": \"\",\n      \"&rightleftharpoons;\": \"\",\n      \"&rightrightarrows;\": \"\",\n      \"&rightsquigarrow;\": \"\",\n      \"&rightthreetimes;\": \"\",\n      \"&ring;\": \"\",\n      \"&risingdotseq;\": \"\",\n      \"&rlarr;\": \"\",\n      \"&rlhar;\": \"\",\n      \"&rlm;\": \"\",\n      \"&rmoust;\": \"\",\n      \"&rmoustache;\": \"\",\n      \"&rnmid;\": \"\",\n      \"&roang;\": \"\",\n      \"&roarr;\": \"\",\n      \"&robrk;\": \"\",\n      \"&ropar;\": \"\",\n      \"&ropf;\": \"\",\n      \"&roplus;\": \"\",\n      \"&rotimes;\": \"\",\n      \"&rpar;\": \")\",\n      \"&rpargt;\": \"\",\n      \"&rppolint;\": \"\",\n      \"&rrarr;\": \"\",\n      \"&rsaquo;\": \"\",\n      \"&rscr;\": \"\",\n      \"&rsh;\": \"\",\n      \"&rsqb;\": \"]\",\n      \"&rsquo;\": \"\",\n      \"&rsquor;\": \"\",\n      \"&rthree;\": \"\",\n      \"&rtimes;\": \"\",\n      \"&rtri;\": \"\",\n      \"&rtrie;\": \"\",\n      \"&rtrif;\": \"\",\n      \"&rtriltri;\": \"\",\n      \"&ruluhar;\": \"\",\n      \"&rx;\": \"\",\n      \"&sacute;\": \"\",\n      \"&sbquo;\": \"\",\n      \"&sc;\": \"\",\n      \"&scE;\": \"\",\n      \"&scap;\": \"\",\n      \"&scaron;\": \"\",\n      \"&sccue;\": \"\",\n      \"&sce;\": \"\",\n      \"&scedil;\": \"\",\n      \"&scirc;\": \"\",\n      \"&scnE;\": \"\",\n      \"&scnap;\": \"\",\n      \"&scnsim;\": \"\",\n      \"&scpolint;\": \"\",\n      \"&scsim;\": \"\",\n      \"&scy;\": \"\",\n      \"&sdot;\": \"\",\n      \"&sdotb;\": \"\",\n      \"&sdote;\": \"\",\n      \"&seArr;\": \"\",\n      \"&searhk;\": \"\",\n      \"&searr;\": \"\",\n      \"&searrow;\": \"\",\n      \"&sect\": \"\",\n      \"&sect;\": \"\",\n      \"&semi;\": \";\",\n      \"&seswar;\": \"\",\n      \"&setminus;\": \"\",\n      \"&setmn;\": \"\",\n      \"&sext;\": \"\",\n      \"&sfr;\": \"\",\n      \"&sfrown;\": \"\",\n      \"&sharp;\": \"\",\n      \"&shchcy;\": \"\",\n      \"&shcy;\": \"\",\n      \"&shortmid;\": \"\",\n      \"&shortparallel;\": \"\",\n      \"&shy\": \"\",\n      \"&shy;\": \"\",\n      \"&sigma;\": \"\",\n      \"&sigmaf;\": \"\",\n      \"&sigmav;\": \"\",\n      \"&sim;\": \"\",\n      \"&simdot;\": \"\",\n      \"&sime;\": \"\",\n      \"&simeq;\": \"\",\n      \"&simg;\": \"\",\n      \"&simgE;\": \"\",\n      \"&siml;\": \"\",\n      \"&simlE;\": \"\",\n      \"&simne;\": \"\",\n      \"&simplus;\": \"\",\n      \"&simrarr;\": \"\",\n      \"&slarr;\": \"\",\n      \"&smallsetminus;\": \"\",\n      \"&smashp;\": \"\",\n      \"&smeparsl;\": \"\",\n      \"&smid;\": \"\",\n      \"&smile;\": \"\",\n      \"&smt;\": \"\",\n      \"&smte;\": \"\",\n      \"&smtes;\": \"\",\n      \"&softcy;\": \"\",\n      \"&sol;\": \"/\",\n      \"&solb;\": \"\",\n      \"&solbar;\": \"\",\n      \"&sopf;\": \"\",\n      \"&spades;\": \"\",\n      \"&spadesuit;\": \"\",\n      \"&spar;\": \"\",\n      \"&sqcap;\": \"\",\n      \"&sqcaps;\": \"\",\n      \"&sqcup;\": \"\",\n      \"&sqcups;\": \"\",\n      \"&sqsub;\": \"\",\n      \"&sqsube;\": \"\",\n      \"&sqsubset;\": \"\",\n      \"&sqsubseteq;\": \"\",\n      \"&sqsup;\": \"\",\n      \"&sqsupe;\": \"\",\n      \"&sqsupset;\": \"\",\n      \"&sqsupseteq;\": \"\",\n      \"&squ;\": \"\",\n      \"&square;\": \"\",\n      \"&squarf;\": \"\",\n      \"&squf;\": \"\",\n      \"&srarr;\": \"\",\n      \"&sscr;\": \"\",\n      \"&ssetmn;\": \"\",\n      \"&ssmile;\": \"\",\n      \"&sstarf;\": \"\",\n      \"&star;\": \"\",\n      \"&starf;\": \"\",\n      \"&straightepsilon;\": \"\",\n      \"&straightphi;\": \"\",\n      \"&strns;\": \"\",\n      \"&sub;\": \"\",\n      \"&subE;\": \"\",\n      \"&subdot;\": \"\",\n      \"&sube;\": \"\",\n      \"&subedot;\": \"\",\n      \"&submult;\": \"\",\n      \"&subnE;\": \"\",\n      \"&subne;\": \"\",\n      \"&subplus;\": \"\",\n      \"&subrarr;\": \"\",\n      \"&subset;\": \"\",\n      \"&subseteq;\": \"\",\n      \"&subseteqq;\": \"\",\n      \"&subsetneq;\": \"\",\n      \"&subsetneqq;\": \"\",\n      \"&subsim;\": \"\",\n      \"&subsub;\": \"\",\n      \"&subsup;\": \"\",\n      \"&succ;\": \"\",\n      \"&succapprox;\": \"\",\n      \"&succcurlyeq;\": \"\",\n      \"&succeq;\": \"\",\n      \"&succnapprox;\": \"\",\n      \"&succneqq;\": \"\",\n      \"&succnsim;\": \"\",\n      \"&succsim;\": \"\",\n      \"&sum;\": \"\",\n      \"&sung;\": \"\",\n      \"&sup1\": \"\",\n      \"&sup1;\": \"\",\n      \"&sup2\": \"\",\n      \"&sup2;\": \"\",\n      \"&sup3\": \"\",\n      \"&sup3;\": \"\",\n      \"&sup;\": \"\",\n      \"&supE;\": \"\",\n      \"&supdot;\": \"\",\n      \"&supdsub;\": \"\",\n      \"&supe;\": \"\",\n      \"&supedot;\": \"\",\n      \"&suphsol;\": \"\",\n      \"&suphsub;\": \"\",\n      \"&suplarr;\": \"\",\n      \"&supmult;\": \"\",\n      \"&supnE;\": \"\",\n      \"&supne;\": \"\",\n      \"&supplus;\": \"\",\n      \"&supset;\": \"\",\n      \"&supseteq;\": \"\",\n      \"&supseteqq;\": \"\",\n      \"&supsetneq;\": \"\",\n      \"&supsetneqq;\": \"\",\n      \"&supsim;\": \"\",\n      \"&supsub;\": \"\",\n      \"&supsup;\": \"\",\n      \"&swArr;\": \"\",\n      \"&swarhk;\": \"\",\n      \"&swarr;\": \"\",\n      \"&swarrow;\": \"\",\n      \"&swnwar;\": \"\",\n      \"&szlig\": \"\",\n      \"&szlig;\": \"\",\n      \"&target;\": \"\",\n      \"&tau;\": \"\",\n      \"&tbrk;\": \"\",\n      \"&tcaron;\": \"\",\n      \"&tcedil;\": \"\",\n      \"&tcy;\": \"\",\n      \"&tdot;\": \"\",\n      \"&telrec;\": \"\",\n      \"&tfr;\": \"\",\n      \"&there4;\": \"\",\n      \"&therefore;\": \"\",\n      \"&theta;\": \"\",\n      \"&thetasym;\": \"\",\n      \"&thetav;\": \"\",\n      \"&thickapprox;\": \"\",\n      \"&thicksim;\": \"\",\n      \"&thinsp;\": \"\",\n      \"&thkap;\": \"\",\n      \"&thksim;\": \"\",\n      \"&thorn\": \"\",\n      \"&thorn;\": \"\",\n      \"&tilde;\": \"\",\n      \"&times\": \"\",\n      \"&times;\": \"\",\n      \"&timesb;\": \"\",\n      \"&timesbar;\": \"\",\n      \"&timesd;\": \"\",\n      \"&tint;\": \"\",\n      \"&toea;\": \"\",\n      \"&top;\": \"\",\n      \"&topbot;\": \"\",\n      \"&topcir;\": \"\",\n      \"&topf;\": \"\",\n      \"&topfork;\": \"\",\n      \"&tosa;\": \"\",\n      \"&tprime;\": \"\",\n      \"&trade;\": \"\",\n      \"&triangle;\": \"\",\n      \"&triangledown;\": \"\",\n      \"&triangleleft;\": \"\",\n      \"&trianglelefteq;\": \"\",\n      \"&triangleq;\": \"\",\n      \"&triangleright;\": \"\",\n      \"&trianglerighteq;\": \"\",\n      \"&tridot;\": \"\",\n      \"&trie;\": \"\",\n      \"&triminus;\": \"\",\n      \"&triplus;\": \"\",\n      \"&trisb;\": \"\",\n      \"&tritime;\": \"\",\n      \"&trpezium;\": \"\",\n      \"&tscr;\": \"\",\n      \"&tscy;\": \"\",\n      \"&tshcy;\": \"\",\n      \"&tstrok;\": \"\",\n      \"&twixt;\": \"\",\n      \"&twoheadleftarrow;\": \"\",\n      \"&twoheadrightarrow;\": \"\",\n      \"&uArr;\": \"\",\n      \"&uHar;\": \"\",\n      \"&uacute\": \"\",\n      \"&uacute;\": \"\",\n      \"&uarr;\": \"\",\n      \"&ubrcy;\": \"\",\n      \"&ubreve;\": \"\",\n      \"&ucirc\": \"\",\n      \"&ucirc;\": \"\",\n      \"&ucy;\": \"\",\n      \"&udarr;\": \"\",\n      \"&udblac;\": \"\",\n      \"&udhar;\": \"\",\n      \"&ufisht;\": \"\",\n      \"&ufr;\": \"\",\n      \"&ugrave\": \"\",\n      \"&ugrave;\": \"\",\n      \"&uharl;\": \"\",\n      \"&uharr;\": \"\",\n      \"&uhblk;\": \"\",\n      \"&ulcorn;\": \"\",\n      \"&ulcorner;\": \"\",\n      \"&ulcrop;\": \"\",\n      \"&ultri;\": \"\",\n      \"&umacr;\": \"\",\n      \"&uml\": \"\",\n      \"&uml;\": \"\",\n      \"&uogon;\": \"\",\n      \"&uopf;\": \"\",\n      \"&uparrow;\": \"\",\n      \"&updownarrow;\": \"\",\n      \"&upharpoonleft;\": \"\",\n      \"&upharpoonright;\": \"\",\n      \"&uplus;\": \"\",\n      \"&upsi;\": \"\",\n      \"&upsih;\": \"\",\n      \"&upsilon;\": \"\",\n      \"&upuparrows;\": \"\",\n      \"&urcorn;\": \"\",\n      \"&urcorner;\": \"\",\n      \"&urcrop;\": \"\",\n      \"&uring;\": \"\",\n      \"&urtri;\": \"\",\n      \"&uscr;\": \"\",\n      \"&utdot;\": \"\",\n      \"&utilde;\": \"\",\n      \"&utri;\": \"\",\n      \"&utrif;\": \"\",\n      \"&uuarr;\": \"\",\n      \"&uuml\": \"\",\n      \"&uuml;\": \"\",\n      \"&uwangle;\": \"\",\n      \"&vArr;\": \"\",\n      \"&vBar;\": \"\",\n      \"&vBarv;\": \"\",\n      \"&vDash;\": \"\",\n      \"&vangrt;\": \"\",\n      \"&varepsilon;\": \"\",\n      \"&varkappa;\": \"\",\n      \"&varnothing;\": \"\",\n      \"&varphi;\": \"\",\n      \"&varpi;\": \"\",\n      \"&varpropto;\": \"\",\n      \"&varr;\": \"\",\n      \"&varrho;\": \"\",\n      \"&varsigma;\": \"\",\n      \"&varsubsetneq;\": \"\",\n      \"&varsubsetneqq;\": \"\",\n      \"&varsupsetneq;\": \"\",\n      \"&varsupsetneqq;\": \"\",\n      \"&vartheta;\": \"\",\n      \"&vartriangleleft;\": \"\",\n      \"&vartriangleright;\": \"\",\n      \"&vcy;\": \"\",\n      \"&vdash;\": \"\",\n      \"&vee;\": \"\",\n      \"&veebar;\": \"\",\n      \"&veeeq;\": \"\",\n      \"&vellip;\": \"\",\n      \"&verbar;\": \"|\",\n      \"&vert;\": \"|\",\n      \"&vfr;\": \"\",\n      \"&vltri;\": \"\",\n      \"&vnsub;\": \"\",\n      \"&vnsup;\": \"\",\n      \"&vopf;\": \"\",\n      \"&vprop;\": \"\",\n      \"&vrtri;\": \"\",\n      \"&vscr;\": \"\",\n      \"&vsubnE;\": \"\",\n      \"&vsubne;\": \"\",\n      \"&vsupnE;\": \"\",\n      \"&vsupne;\": \"\",\n      \"&vzigzag;\": \"\",\n      \"&wcirc;\": \"\",\n      \"&wedbar;\": \"\",\n      \"&wedge;\": \"\",\n      \"&wedgeq;\": \"\",\n      \"&weierp;\": \"\",\n      \"&wfr;\": \"\",\n      \"&wopf;\": \"\",\n      \"&wp;\": \"\",\n      \"&wr;\": \"\",\n      \"&wreath;\": \"\",\n      \"&wscr;\": \"\",\n      \"&xcap;\": \"\",\n      \"&xcirc;\": \"\",\n      \"&xcup;\": \"\",\n      \"&xdtri;\": \"\",\n      \"&xfr;\": \"\",\n      \"&xhArr;\": \"\",\n      \"&xharr;\": \"\",\n      \"&xi;\": \"\",\n      \"&xlArr;\": \"\",\n      \"&xlarr;\": \"\",\n      \"&xmap;\": \"\",\n      \"&xnis;\": \"\",\n      \"&xodot;\": \"\",\n      \"&xopf;\": \"\",\n      \"&xoplus;\": \"\",\n      \"&xotime;\": \"\",\n      \"&xrArr;\": \"\",\n      \"&xrarr;\": \"\",\n      \"&xscr;\": \"\",\n      \"&xsqcup;\": \"\",\n      \"&xuplus;\": \"\",\n      \"&xutri;\": \"\",\n      \"&xvee;\": \"\",\n      \"&xwedge;\": \"\",\n      \"&yacute\": \"\",\n      \"&yacute;\": \"\",\n      \"&yacy;\": \"\",\n      \"&ycirc;\": \"\",\n      \"&ycy;\": \"\",\n      \"&yen\": \"\",\n      \"&yen;\": \"\",\n      \"&yfr;\": \"\",\n      \"&yicy;\": \"\",\n      \"&yopf;\": \"\",\n      \"&yscr;\": \"\",\n      \"&yucy;\": \"\",\n      \"&yuml\": \"\",\n      \"&yuml;\": \"\",\n      \"&zacute;\": \"\",\n      \"&zcaron;\": \"\",\n      \"&zcy;\": \"\",\n      \"&zdot;\": \"\",\n      \"&zeetrf;\": \"\",\n      \"&zeta;\": \"\",\n      \"&zfr;\": \"\",\n      \"&zhcy;\": \"\",\n      \"&zigrarr;\": \"\",\n      \"&zopf;\": \"\",\n      \"&zscr;\": \"\",\n      \"&zwj;\": \"\",\n      \"&zwnj;\": \"\"\n    },\n    characters: {\n      \"\": \"&AElig;\",\n      \"&\": \"&amp;\",\n      \"\": \"&Aacute;\",\n      \"\": \"&Abreve;\",\n      \"\": \"&Acirc;\",\n      \"\": \"&Acy;\",\n      \"\": \"&Afr;\",\n      \"\": \"&Agrave;\",\n      \"\": \"&Alpha;\",\n      \"\": \"&Amacr;\",\n      \"\": \"&And;\",\n      \"\": \"&Aogon;\",\n      \"\": \"&Aopf;\",\n      \"\": \"&af;\",\n      \"\": \"&angst;\",\n      \"\": \"&Ascr;\",\n      \"\": \"&coloneq;\",\n      \"\": \"&Atilde;\",\n      \"\": \"&Auml;\",\n      \"\": \"&ssetmn;\",\n      \"\": \"&Barv;\",\n      \"\": \"&doublebarwedge;\",\n      \"\": \"&Bcy;\",\n      \"\": \"&because;\",\n      \"\": \"&bernou;\",\n      \"\": \"&Beta;\",\n      \"\": \"&Bfr;\",\n      \"\": \"&Bopf;\",\n      \"\": \"&breve;\",\n      \"\": \"&bump;\",\n      \"\": \"&CHcy;\",\n      \"\": \"&copy;\",\n      \"\": \"&Cacute;\",\n      \"\": \"&Cap;\",\n      \"\": \"&DD;\",\n      \"\": \"&Cfr;\",\n      \"\": \"&Ccaron;\",\n      \"\": \"&Ccedil;\",\n      \"\": \"&Ccirc;\",\n      \"\": \"&Cconint;\",\n      \"\": \"&Cdot;\",\n      \"\": \"&cedil;\",\n      \"\": \"&middot;\",\n      \"\": \"&Chi;\",\n      \"\": \"&odot;\",\n      \"\": \"&ominus;\",\n      \"\": \"&oplus;\",\n      \"\": \"&otimes;\",\n      \"\": \"&cwconint;\",\n      \"\": \"&rdquor;\",\n      \"\": \"&rsquor;\",\n      \"\": \"&Proportion;\",\n      \"\": \"&Colone;\",\n      \"\": \"&equiv;\",\n      \"\": \"&DoubleContourIntegral;\",\n      \"\": \"&oint;\",\n      \"\": \"&complexes;\",\n      \"\": \"&coprod;\",\n      \"\": \"&awconint;\",\n      \"\": \"&Cross;\",\n      \"\": \"&Cscr;\",\n      \"\": \"&Cup;\",\n      \"\": \"&asympeq;\",\n      \"\": \"&DDotrahd;\",\n      \"\": \"&DJcy;\",\n      \"\": \"&DScy;\",\n      \"\": \"&DZcy;\",\n      \"\": \"&ddagger;\",\n      \"\": \"&Darr;\",\n      \"\": \"&DoubleLeftTee;\",\n      \"\": \"&Dcaron;\",\n      \"\": \"&Dcy;\",\n      \"\": \"&nabla;\",\n      \"\": \"&Delta;\",\n      \"\": \"&Dfr;\",\n      \"\": \"&acute;\",\n      \"\": \"&dot;\",\n      \"\": \"&dblac;\",\n      \"`\": \"&grave;\",\n      \"\": \"&tilde;\",\n      \"\": \"&diamond;\",\n      \"\": \"&dd;\",\n      \"\": \"&Dopf;\",\n      \"\": \"&uml;\",\n      \"\": \"&DotDot;\",\n      \"\": \"&esdot;\",\n      \"\": \"&dArr;\",\n      \"\": \"&lArr;\",\n      \"\": \"&iff;\",\n      \"\": \"&xlArr;\",\n      \"\": \"&xhArr;\",\n      \"\": \"&xrArr;\",\n      \"\": \"&rArr;\",\n      \"\": \"&vDash;\",\n      \"\": \"&uArr;\",\n      \"\": \"&vArr;\",\n      \"\": \"&spar;\",\n      \"\": \"&downarrow;\",\n      \"\": \"&DownArrowBar;\",\n      \"\": \"&duarr;\",\n      \"\": \"&DownBreve;\",\n      \"\": \"&DownLeftRightVector;\",\n      \"\": \"&DownLeftTeeVector;\",\n      \"\": \"&lhard;\",\n      \"\": \"&DownLeftVectorBar;\",\n      \"\": \"&DownRightTeeVector;\",\n      \"\": \"&rightharpoondown;\",\n      \"\": \"&DownRightVectorBar;\",\n      \"\": \"&top;\",\n      \"\": \"&mapstodown;\",\n      \"\": \"&Dscr;\",\n      \"\": \"&Dstrok;\",\n      \"\": \"&ENG;\",\n      \"\": \"&ETH;\",\n      \"\": \"&Eacute;\",\n      \"\": \"&Ecaron;\",\n      \"\": \"&Ecirc;\",\n      \"\": \"&Ecy;\",\n      \"\": \"&Edot;\",\n      \"\": \"&Efr;\",\n      \"\": \"&Egrave;\",\n      \"\": \"&isinv;\",\n      \"\": \"&Emacr;\",\n      \"\": \"&EmptySmallSquare;\",\n      \"\": \"&EmptyVerySmallSquare;\",\n      \"\": \"&Eogon;\",\n      \"\": \"&Eopf;\",\n      \"\": \"&Epsilon;\",\n      \"\": \"&Equal;\",\n      \"\": \"&esim;\",\n      \"\": \"&rlhar;\",\n      \"\": \"&expectation;\",\n      \"\": \"&Esim;\",\n      \"\": \"&Eta;\",\n      \"\": \"&Euml;\",\n      \"\": \"&exist;\",\n      \"\": \"&exponentiale;\",\n      \"\": \"&Fcy;\",\n      \"\": \"&Ffr;\",\n      \"\": \"&FilledSmallSquare;\",\n      \"\": \"&squf;\",\n      \"\": \"&Fopf;\",\n      \"\": \"&forall;\",\n      \"\": \"&Fscr;\",\n      \"\": \"&GJcy;\",\n      \">\": \"&gt;\",\n      \"\": \"&Gamma;\",\n      \"\": \"&Gammad;\",\n      \"\": \"&Gbreve;\",\n      \"\": \"&Gcedil;\",\n      \"\": \"&Gcirc;\",\n      \"\": \"&Gcy;\",\n      \"\": \"&Gdot;\",\n      \"\": \"&Gfr;\",\n      \"\": \"&ggg;\",\n      \"\": \"&Gopf;\",\n      \"\": \"&geq;\",\n      \"\": \"&gtreqless;\",\n      \"\": \"&geqq;\",\n      \"\": \"&GreaterGreater;\",\n      \"\": \"&gtrless;\",\n      \"\": \"&ges;\",\n      \"\": \"&gtrsim;\",\n      \"\": \"&Gscr;\",\n      \"\": \"&gg;\",\n      \"\": \"&HARDcy;\",\n      \"\": \"&caron;\",\n      \"^\": \"&Hat;\",\n      \"\": \"&Hcirc;\",\n      \"\": \"&Poincareplane;\",\n      \"\": \"&hamilt;\",\n      \"\": \"&quaternions;\",\n      \"\": \"&boxh;\",\n      \"\": \"&Hstrok;\",\n      \"\": \"&bumpeq;\",\n      \"\": \"&IEcy;\",\n      \"\": \"&IJlig;\",\n      \"\": \"&IOcy;\",\n      \"\": \"&Iacute;\",\n      \"\": \"&Icirc;\",\n      \"\": \"&Icy;\",\n      \"\": \"&Idot;\",\n      \"\": \"&imagpart;\",\n      \"\": \"&Igrave;\",\n      \"\": \"&Imacr;\",\n      \"\": \"&ii;\",\n      \"\": \"&Int;\",\n      \"\": \"&int;\",\n      \"\": \"&xcap;\",\n      \"\": \"&ic;\",\n      \"\": \"&it;\",\n      \"\": \"&Iogon;\",\n      \"\": \"&Iopf;\",\n      \"\": \"&Iota;\",\n      \"\": \"&imagline;\",\n      \"\": \"&Itilde;\",\n      \"\": \"&Iukcy;\",\n      \"\": \"&Iuml;\",\n      \"\": \"&Jcirc;\",\n      \"\": \"&Jcy;\",\n      \"\": \"&Jfr;\",\n      \"\": \"&Jopf;\",\n      \"\": \"&Jscr;\",\n      \"\": \"&Jsercy;\",\n      \"\": \"&Jukcy;\",\n      \"\": \"&KHcy;\",\n      \"\": \"&KJcy;\",\n      \"\": \"&Kappa;\",\n      \"\": \"&Kcedil;\",\n      \"\": \"&Kcy;\",\n      \"\": \"&Kfr;\",\n      \"\": \"&Kopf;\",\n      \"\": \"&Kscr;\",\n      \"\": \"&LJcy;\",\n      \"<\": \"&lt;\",\n      \"\": \"&Lacute;\",\n      \"\": \"&Lambda;\",\n      \"\": \"&Lang;\",\n      \"\": \"&lagran;\",\n      \"\": \"&twoheadleftarrow;\",\n      \"\": \"&Lcaron;\",\n      \"\": \"&Lcedil;\",\n      \"\": \"&Lcy;\",\n      \"\": \"&langle;\",\n      \"\": \"&slarr;\",\n      \"\": \"&larrb;\",\n      \"\": \"&lrarr;\",\n      \"\": \"&lceil;\",\n      \"\": \"&lobrk;\",\n      \"\": \"&LeftDownTeeVector;\",\n      \"\": \"&downharpoonleft;\",\n      \"\": \"&LeftDownVectorBar;\",\n      \"\": \"&lfloor;\",\n      \"\": \"&leftrightarrow;\",\n      \"\": \"&LeftRightVector;\",\n      \"\": \"&dashv;\",\n      \"\": \"&mapstoleft;\",\n      \"\": \"&LeftTeeVector;\",\n      \"\": \"&vltri;\",\n      \"\": \"&LeftTriangleBar;\",\n      \"\": \"&trianglelefteq;\",\n      \"\": \"&LeftUpDownVector;\",\n      \"\": \"&LeftUpTeeVector;\",\n      \"\": \"&upharpoonleft;\",\n      \"\": \"&LeftUpVectorBar;\",\n      \"\": \"&lharu;\",\n      \"\": \"&LeftVectorBar;\",\n      \"\": \"&lesseqgtr;\",\n      \"\": \"&leqq;\",\n      \"\": \"&lg;\",\n      \"\": \"&LessLess;\",\n      \"\": \"&les;\",\n      \"\": \"&lsim;\",\n      \"\": \"&Lfr;\",\n      \"\": \"&Ll;\",\n      \"\": \"&lAarr;\",\n      \"\": \"&Lmidot;\",\n      \"\": \"&xlarr;\",\n      \"\": \"&xharr;\",\n      \"\": \"&xrarr;\",\n      \"\": \"&Lopf;\",\n      \"\": \"&swarrow;\",\n      \"\": \"&searrow;\",\n      \"\": \"&lsh;\",\n      \"\": \"&Lstrok;\",\n      \"\": \"&ll;\",\n      \"\": \"&Map;\",\n      \"\": \"&Mcy;\",\n      \"\": \"&MediumSpace;\",\n      \"\": \"&phmmat;\",\n      \"\": \"&Mfr;\",\n      \"\": \"&mp;\",\n      \"\": \"&Mopf;\",\n      \"\": \"&Mu;\",\n      \"\": \"&NJcy;\",\n      \"\": \"&Nacute;\",\n      \"\": \"&Ncaron;\",\n      \"\": \"&Ncedil;\",\n      \"\": \"&Ncy;\",\n      \"\": \"&ZeroWidthSpace;\",\n      \"\\n\": \"&NewLine;\",\n      \"\": \"&Nfr;\",\n      \"\": \"&NoBreak;\",\n      \"\": \"&nbsp;\",\n      \"\": \"&naturals;\",\n      \"\": \"&Not;\",\n      \"\": \"&nequiv;\",\n      \"\": \"&NotCupCap;\",\n      \"\": \"&nspar;\",\n      \"\": \"&notinva;\",\n      \"\": \"&ne;\",\n      \"\": \"&nesim;\",\n      \"\": \"&nexists;\",\n      \"\": \"&ngtr;\",\n      \"\": \"&ngeq;\",\n      \"\": \"&ngeqq;\",\n      \"\": \"&nGtv;\",\n      \"\": \"&ntgl;\",\n      \"\": \"&nges;\",\n      \"\": \"&ngsim;\",\n      \"\": \"&nbump;\",\n      \"\": \"&nbumpe;\",\n      \"\": \"&ntriangleleft;\",\n      \"\": \"&NotLeftTriangleBar;\",\n      \"\": \"&ntrianglelefteq;\",\n      \"\": \"&nlt;\",\n      \"\": \"&nleq;\",\n      \"\": \"&ntlg;\",\n      \"\": \"&nLtv;\",\n      \"\": \"&nles;\",\n      \"\": \"&nlsim;\",\n      \"\": \"&NotNestedGreaterGreater;\",\n      \"\": \"&NotNestedLessLess;\",\n      \"\": \"&nprec;\",\n      \"\": \"&npreceq;\",\n      \"\": \"&nprcue;\",\n      \"\": \"&notniva;\",\n      \"\": \"&ntriangleright;\",\n      \"\": \"&NotRightTriangleBar;\",\n      \"\": \"&ntrianglerighteq;\",\n      \"\": \"&NotSquareSubset;\",\n      \"\": \"&nsqsube;\",\n      \"\": \"&NotSquareSuperset;\",\n      \"\": \"&nsqsupe;\",\n      \"\": \"&vnsub;\",\n      \"\": \"&nsubseteq;\",\n      \"\": \"&nsucc;\",\n      \"\": \"&nsucceq;\",\n      \"\": \"&nsccue;\",\n      \"\": \"&NotSucceedsTilde;\",\n      \"\": \"&vnsup;\",\n      \"\": \"&nsupseteq;\",\n      \"\": \"&nsim;\",\n      \"\": \"&nsimeq;\",\n      \"\": \"&ncong;\",\n      \"\": \"&napprox;\",\n      \"\": \"&nsmid;\",\n      \"\": \"&Nscr;\",\n      \"\": \"&Ntilde;\",\n      \"\": \"&Nu;\",\n      \"\": \"&OElig;\",\n      \"\": \"&Oacute;\",\n      \"\": \"&Ocirc;\",\n      \"\": \"&Ocy;\",\n      \"\": \"&Odblac;\",\n      \"\": \"&Ofr;\",\n      \"\": \"&Ograve;\",\n      \"\": \"&Omacr;\",\n      \"\": \"&ohm;\",\n      \"\": \"&Omicron;\",\n      \"\": \"&Oopf;\",\n      \"\": \"&ldquo;\",\n      \"\": \"&lsquo;\",\n      \"\": \"&Or;\",\n      \"\": \"&Oscr;\",\n      \"\": \"&Oslash;\",\n      \"\": \"&Otilde;\",\n      \"\": \"&Otimes;\",\n      \"\": \"&Ouml;\",\n      \"\": \"&oline;\",\n      \"\": \"&OverBrace;\",\n      \"\": \"&tbrk;\",\n      \"\": \"&OverParenthesis;\",\n      \"\": \"&part;\",\n      \"\": \"&Pcy;\",\n      \"\": \"&Pfr;\",\n      \"\": \"&Phi;\",\n      \"\": \"&Pi;\",\n      \"\": \"&pm;\",\n      \"\": \"&primes;\",\n      \"\": \"&Pr;\",\n      \"\": \"&prec;\",\n      \"\": \"&preceq;\",\n      \"\": \"&preccurlyeq;\",\n      \"\": \"&prsim;\",\n      \"\": \"&Prime;\",\n      \"\": \"&prod;\",\n      \"\": \"&vprop;\",\n      \"\": \"&Pscr;\",\n      \"\": \"&Psi;\",\n      '\"': \"&quot;\",\n      \"\": \"&Qfr;\",\n      \"\": \"&rationals;\",\n      \"\": \"&Qscr;\",\n      \"\": \"&drbkarow;\",\n      \"\": \"&reg;\",\n      \"\": \"&Racute;\",\n      \"\": \"&Rang;\",\n      \"\": \"&twoheadrightarrow;\",\n      \"\": \"&Rarrtl;\",\n      \"\": \"&Rcaron;\",\n      \"\": \"&Rcedil;\",\n      \"\": \"&Rcy;\",\n      \"\": \"&realpart;\",\n      \"\": \"&niv;\",\n      \"\": \"&lrhar;\",\n      \"\": \"&duhar;\",\n      \"\": \"&Rho;\",\n      \"\": \"&rangle;\",\n      \"\": \"&srarr;\",\n      \"\": \"&rarrb;\",\n      \"\": \"&rlarr;\",\n      \"\": \"&rceil;\",\n      \"\": \"&robrk;\",\n      \"\": \"&RightDownTeeVector;\",\n      \"\": \"&downharpoonright;\",\n      \"\": \"&RightDownVectorBar;\",\n      \"\": \"&rfloor;\",\n      \"\": \"&vdash;\",\n      \"\": \"&mapsto;\",\n      \"\": \"&RightTeeVector;\",\n      \"\": \"&vrtri;\",\n      \"\": \"&RightTriangleBar;\",\n      \"\": \"&trianglerighteq;\",\n      \"\": \"&RightUpDownVector;\",\n      \"\": \"&RightUpTeeVector;\",\n      \"\": \"&upharpoonright;\",\n      \"\": \"&RightUpVectorBar;\",\n      \"\": \"&rightharpoonup;\",\n      \"\": \"&RightVectorBar;\",\n      \"\": \"&reals;\",\n      \"\": \"&RoundImplies;\",\n      \"\": \"&rAarr;\",\n      \"\": \"&realine;\",\n      \"\": \"&rsh;\",\n      \"\": \"&RuleDelayed;\",\n      \"\": \"&SHCHcy;\",\n      \"\": \"&SHcy;\",\n      \"\": \"&SOFTcy;\",\n      \"\": \"&Sacute;\",\n      \"\": \"&Sc;\",\n      \"\": \"&Scaron;\",\n      \"\": \"&Scedil;\",\n      \"\": \"&Scirc;\",\n      \"\": \"&Scy;\",\n      \"\": \"&Sfr;\",\n      \"\": \"&uparrow;\",\n      \"\": \"&Sigma;\",\n      \"\": \"&compfn;\",\n      \"\": \"&Sopf;\",\n      \"\": \"&radic;\",\n      \"\": \"&square;\",\n      \"\": \"&sqcap;\",\n      \"\": \"&sqsubset;\",\n      \"\": \"&sqsubseteq;\",\n      \"\": \"&sqsupset;\",\n      \"\": \"&sqsupseteq;\",\n      \"\": \"&sqcup;\",\n      \"\": \"&Sscr;\",\n      \"\": \"&sstarf;\",\n      \"\": \"&Subset;\",\n      \"\": \"&subseteq;\",\n      \"\": \"&succ;\",\n      \"\": \"&succeq;\",\n      \"\": \"&succcurlyeq;\",\n      \"\": \"&succsim;\",\n      \"\": \"&sum;\",\n      \"\": \"&Supset;\",\n      \"\": \"&supset;\",\n      \"\": \"&supseteq;\",\n      \"\": \"&THORN;\",\n      \"\": \"&trade;\",\n      \"\": \"&TSHcy;\",\n      \"\": \"&TScy;\",\n      \"\\t\": \"&Tab;\",\n      \"\": \"&Tau;\",\n      \"\": \"&Tcaron;\",\n      \"\": \"&Tcedil;\",\n      \"\": \"&Tcy;\",\n      \"\": \"&Tfr;\",\n      \"\": \"&therefore;\",\n      \"\": \"&Theta;\",\n      \"\": \"&ThickSpace;\",\n      \"\": \"&thinsp;\",\n      \"\": \"&thksim;\",\n      \"\": \"&simeq;\",\n      \"\": \"&cong;\",\n      \"\": \"&thkap;\",\n      \"\": \"&Topf;\",\n      \"\": \"&tdot;\",\n      \"\": \"&Tscr;\",\n      \"\": \"&Tstrok;\",\n      \"\": \"&Uacute;\",\n      \"\": \"&Uarr;\",\n      \"\": \"&Uarrocir;\",\n      \"\": \"&Ubrcy;\",\n      \"\": \"&Ubreve;\",\n      \"\": \"&Ucirc;\",\n      \"\": \"&Ucy;\",\n      \"\": \"&Udblac;\",\n      \"\": \"&Ufr;\",\n      \"\": \"&Ugrave;\",\n      \"\": \"&Umacr;\",\n      _: \"&lowbar;\",\n      \"\": \"&UnderBrace;\",\n      \"\": \"&bbrk;\",\n      \"\": \"&UnderParenthesis;\",\n      \"\": \"&xcup;\",\n      \"\": \"&uplus;\",\n      \"\": \"&Uogon;\",\n      \"\": \"&Uopf;\",\n      \"\": \"&UpArrowBar;\",\n      \"\": \"&udarr;\",\n      \"\": \"&varr;\",\n      \"\": \"&udhar;\",\n      \"\": \"&perp;\",\n      \"\": \"&mapstoup;\",\n      \"\": \"&nwarrow;\",\n      \"\": \"&nearrow;\",\n      \"\": \"&upsih;\",\n      \"\": \"&Upsilon;\",\n      \"\": \"&Uring;\",\n      \"\": \"&Uscr;\",\n      \"\": \"&Utilde;\",\n      \"\": \"&Uuml;\",\n      \"\": \"&VDash;\",\n      \"\": \"&Vbar;\",\n      \"\": \"&Vcy;\",\n      \"\": \"&Vdash;\",\n      \"\": \"&Vdashl;\",\n      \"\": \"&xvee;\",\n      \"\": \"&Vert;\",\n      \"\": \"&smid;\",\n      \"|\": \"&vert;\",\n      \"\": \"&VerticalSeparator;\",\n      \"\": \"&wreath;\",\n      \"\": \"&hairsp;\",\n      \"\": \"&Vfr;\",\n      \"\": \"&Vopf;\",\n      \"\": \"&Vscr;\",\n      \"\": \"&Vvdash;\",\n      \"\": \"&Wcirc;\",\n      \"\": \"&xwedge;\",\n      \"\": \"&Wfr;\",\n      \"\": \"&Wopf;\",\n      \"\": \"&Wscr;\",\n      \"\": \"&Xfr;\",\n      \"\": \"&Xi;\",\n      \"\": \"&Xopf;\",\n      \"\": \"&Xscr;\",\n      \"\": \"&YAcy;\",\n      \"\": \"&YIcy;\",\n      \"\": \"&YUcy;\",\n      \"\": \"&Yacute;\",\n      \"\": \"&Ycirc;\",\n      \"\": \"&Ycy;\",\n      \"\": \"&Yfr;\",\n      \"\": \"&Yopf;\",\n      \"\": \"&Yscr;\",\n      \"\": \"&Yuml;\",\n      \"\": \"&ZHcy;\",\n      \"\": \"&Zacute;\",\n      \"\": \"&Zcaron;\",\n      \"\": \"&Zcy;\",\n      \"\": \"&Zdot;\",\n      \"\": \"&Zeta;\",\n      \"\": \"&zeetrf;\",\n      \"\": \"&integers;\",\n      \"\": \"&Zscr;\",\n      \"\": \"&aacute;\",\n      \"\": \"&abreve;\",\n      \"\": \"&mstpos;\",\n      \"\": \"&acE;\",\n      \"\": \"&acd;\",\n      \"\": \"&acirc;\",\n      \"\": \"&acy;\",\n      \"\": \"&aelig;\",\n      \"\": \"&afr;\",\n      \"\": \"&agrave;\",\n      \"\": \"&aleph;\",\n      \"\": \"&alpha;\",\n      \"\": \"&amacr;\",\n      \"\": \"&amalg;\",\n      \"\": \"&wedge;\",\n      \"\": \"&andand;\",\n      \"\": \"&andd;\",\n      \"\": \"&andslope;\",\n      \"\": \"&andv;\",\n      \"\": \"&angle;\",\n      \"\": \"&ange;\",\n      \"\": \"&measuredangle;\",\n      \"\": \"&angmsdaa;\",\n      \"\": \"&angmsdab;\",\n      \"\": \"&angmsdac;\",\n      \"\": \"&angmsdad;\",\n      \"\": \"&angmsdae;\",\n      \"\": \"&angmsdaf;\",\n      \"\": \"&angmsdag;\",\n      \"\": \"&angmsdah;\",\n      \"\": \"&angrt;\",\n      \"\": \"&angrtvb;\",\n      \"\": \"&angrtvbd;\",\n      \"\": \"&angsph;\",\n      \"\": \"&angzarr;\",\n      \"\": \"&aogon;\",\n      \"\": \"&aopf;\",\n      \"\": \"&apE;\",\n      \"\": \"&apacir;\",\n      \"\": \"&approxeq;\",\n      \"\": \"&apid;\",\n      \"'\": \"&apos;\",\n      \"\": \"&aring;\",\n      \"\": \"&ascr;\",\n      \"*\": \"&midast;\",\n      \"\": \"&atilde;\",\n      \"\": \"&auml;\",\n      \"\": \"&awint;\",\n      \"\": \"&bNot;\",\n      \"\": \"&bcong;\",\n      \"\": \"&bepsi;\",\n      \"\": \"&bprime;\",\n      \"\": \"&bsim;\",\n      \"\": \"&bsime;\",\n      \"\": \"&barvee;\",\n      \"\": \"&barwedge;\",\n      \"\": \"&bbrktbrk;\",\n      \"\": \"&bcy;\",\n      \"\": \"&ldquor;\",\n      \"\": \"&bemptyv;\",\n      \"\": \"&beta;\",\n      \"\": \"&beth;\",\n      \"\": \"&twixt;\",\n      \"\": \"&bfr;\",\n      \"\": \"&xcirc;\",\n      \"\": \"&xodot;\",\n      \"\": \"&xoplus;\",\n      \"\": \"&xotime;\",\n      \"\": \"&xsqcup;\",\n      \"\": \"&starf;\",\n      \"\": \"&xdtri;\",\n      \"\": \"&xutri;\",\n      \"\": \"&xuplus;\",\n      \"\": \"&rbarr;\",\n      \"\": \"&lozf;\",\n      \"\": \"&utrif;\",\n      \"\": \"&dtrif;\",\n      \"\": \"&ltrif;\",\n      \"\": \"&rtrif;\",\n      \"\": \"&blank;\",\n      \"\": \"&blk12;\",\n      \"\": \"&blk14;\",\n      \"\": \"&blk34;\",\n      \"\": \"&block;\",\n      \"=\": \"&bne;\",\n      \"\": \"&bnequiv;\",\n      \"\": \"&bnot;\",\n      \"\": \"&bopf;\",\n      \"\": \"&bowtie;\",\n      \"\": \"&boxDL;\",\n      \"\": \"&boxDR;\",\n      \"\": \"&boxDl;\",\n      \"\": \"&boxDr;\",\n      \"\": \"&boxH;\",\n      \"\": \"&boxHD;\",\n      \"\": \"&boxHU;\",\n      \"\": \"&boxHd;\",\n      \"\": \"&boxHu;\",\n      \"\": \"&boxUL;\",\n      \"\": \"&boxUR;\",\n      \"\": \"&boxUl;\",\n      \"\": \"&boxUr;\",\n      \"\": \"&boxV;\",\n      \"\": \"&boxVH;\",\n      \"\": \"&boxVL;\",\n      \"\": \"&boxVR;\",\n      \"\": \"&boxVh;\",\n      \"\": \"&boxVl;\",\n      \"\": \"&boxVr;\",\n      \"\": \"&boxbox;\",\n      \"\": \"&boxdL;\",\n      \"\": \"&boxdR;\",\n      \"\": \"&boxdl;\",\n      \"\": \"&boxdr;\",\n      \"\": \"&boxhD;\",\n      \"\": \"&boxhU;\",\n      \"\": \"&boxhd;\",\n      \"\": \"&boxhu;\",\n      \"\": \"&minusb;\",\n      \"\": \"&plusb;\",\n      \"\": \"&timesb;\",\n      \"\": \"&boxuL;\",\n      \"\": \"&boxuR;\",\n      \"\": \"&boxul;\",\n      \"\": \"&boxur;\",\n      \"\": \"&boxv;\",\n      \"\": \"&boxvH;\",\n      \"\": \"&boxvL;\",\n      \"\": \"&boxvR;\",\n      \"\": \"&boxvh;\",\n      \"\": \"&boxvl;\",\n      \"\": \"&boxvr;\",\n      \"\": \"&brvbar;\",\n      \"\": \"&bscr;\",\n      \"\": \"&bsemi;\",\n      \"\\\\\": \"&bsol;\",\n      \"\": \"&bsolb;\",\n      \"\": \"&bsolhsub;\",\n      \"\": \"&bullet;\",\n      \"\": \"&bumpE;\",\n      \"\": \"&cacute;\",\n      \"\": \"&cap;\",\n      \"\": \"&capand;\",\n      \"\": \"&capbrcup;\",\n      \"\": \"&capcap;\",\n      \"\": \"&capcup;\",\n      \"\": \"&capdot;\",\n      \"\": \"&caps;\",\n      \"\": \"&caret;\",\n      \"\": \"&ccaps;\",\n      \"\": \"&ccaron;\",\n      \"\": \"&ccedil;\",\n      \"\": \"&ccirc;\",\n      \"\": \"&ccups;\",\n      \"\": \"&ccupssm;\",\n      \"\": \"&cdot;\",\n      \"\": \"&cemptyv;\",\n      \"\": \"&cent;\",\n      \"\": \"&cfr;\",\n      \"\": \"&chcy;\",\n      \"\": \"&checkmark;\",\n      \"\": \"&chi;\",\n      \"\": \"&cir;\",\n      \"\": \"&cirE;\",\n      \"\": \"&circ;\",\n      \"\": \"&cire;\",\n      \"\": \"&olarr;\",\n      \"\": \"&orarr;\",\n      \"\": \"&oS;\",\n      \"\": \"&oast;\",\n      \"\": \"&ocir;\",\n      \"\": \"&odash;\",\n      \"\": \"&cirfnint;\",\n      \"\": \"&cirmid;\",\n      \"\": \"&cirscir;\",\n      \"\": \"&clubsuit;\",\n      \":\": \"&colon;\",\n      \",\": \"&comma;\",\n      \"@\": \"&commat;\",\n      \"\": \"&complement;\",\n      \"\": \"&congdot;\",\n      \"\": \"&copf;\",\n      \"\": \"&copysr;\",\n      \"\": \"&crarr;\",\n      \"\": \"&cross;\",\n      \"\": \"&cscr;\",\n      \"\": \"&csub;\",\n      \"\": \"&csube;\",\n      \"\": \"&csup;\",\n      \"\": \"&csupe;\",\n      \"\": \"&ctdot;\",\n      \"\": \"&cudarrl;\",\n      \"\": \"&cudarrr;\",\n      \"\": \"&curlyeqprec;\",\n      \"\": \"&curlyeqsucc;\",\n      \"\": \"&curvearrowleft;\",\n      \"\": \"&cularrp;\",\n      \"\": \"&cup;\",\n      \"\": \"&cupbrcap;\",\n      \"\": \"&cupcap;\",\n      \"\": \"&cupcup;\",\n      \"\": \"&cupdot;\",\n      \"\": \"&cupor;\",\n      \"\": \"&cups;\",\n      \"\": \"&curvearrowright;\",\n      \"\": \"&curarrm;\",\n      \"\": \"&cuvee;\",\n      \"\": \"&cuwed;\",\n      \"\": \"&curren;\",\n      \"\": \"&cwint;\",\n      \"\": \"&cylcty;\",\n      \"\": \"&dHar;\",\n      \"\": \"&dagger;\",\n      \"\": \"&daleth;\",\n      \"\": \"&hyphen;\",\n      \"\": \"&rBarr;\",\n      \"\": \"&dcaron;\",\n      \"\": \"&dcy;\",\n      \"\": \"&downdownarrows;\",\n      \"\": \"&eDDot;\",\n      \"\": \"&deg;\",\n      \"\": \"&delta;\",\n      \"\": \"&demptyv;\",\n      \"\": \"&dfisht;\",\n      \"\": \"&dfr;\",\n      \"\": \"&diams;\",\n      \"\": \"&gammad;\",\n      \"\": \"&disin;\",\n      \"\": \"&divide;\",\n      \"\": \"&divonx;\",\n      \"\": \"&djcy;\",\n      \"\": \"&llcorner;\",\n      \"\": \"&dlcrop;\",\n      $: \"&dollar;\",\n      \"\": \"&dopf;\",\n      \"\": \"&eDot;\",\n      \"\": \"&minusd;\",\n      \"\": \"&plusdo;\",\n      \"\": \"&sdotb;\",\n      \"\": \"&lrcorner;\",\n      \"\": \"&drcrop;\",\n      \"\": \"&dscr;\",\n      \"\": \"&dscy;\",\n      \"\": \"&dsol;\",\n      \"\": \"&dstrok;\",\n      \"\": \"&dtdot;\",\n      \"\": \"&triangledown;\",\n      \"\": \"&dwangle;\",\n      \"\": \"&dzcy;\",\n      \"\": \"&dzigrarr;\",\n      \"\": \"&eacute;\",\n      \"\": \"&easter;\",\n      \"\": \"&ecaron;\",\n      \"\": \"&eqcirc;\",\n      \"\": \"&ecirc;\",\n      \"\": \"&eqcolon;\",\n      \"\": \"&ecy;\",\n      \"\": \"&edot;\",\n      \"\": \"&fallingdotseq;\",\n      \"\": \"&efr;\",\n      \"\": \"&eg;\",\n      \"\": \"&egrave;\",\n      \"\": \"&eqslantgtr;\",\n      \"\": \"&egsdot;\",\n      \"\": \"&el;\",\n      \"\": \"&elinters;\",\n      \"\": \"&ell;\",\n      \"\": \"&eqslantless;\",\n      \"\": \"&elsdot;\",\n      \"\": \"&emacr;\",\n      \"\": \"&varnothing;\",\n      \"\": \"&emsp13;\",\n      \"\": \"&emsp14;\",\n      \"\": \"&emsp;\",\n      \"\": \"&eng;\",\n      \"\": \"&ensp;\",\n      \"\": \"&eogon;\",\n      \"\": \"&eopf;\",\n      \"\": \"&epar;\",\n      \"\": \"&eparsl;\",\n      \"\": \"&eplus;\",\n      \"\": \"&epsilon;\",\n      \"\": \"&varepsilon;\",\n      \"=\": \"&equals;\",\n      \"\": \"&questeq;\",\n      \"\": \"&equivDD;\",\n      \"\": \"&eqvparsl;\",\n      \"\": \"&risingdotseq;\",\n      \"\": \"&erarr;\",\n      \"\": \"&escr;\",\n      \"\": \"&eta;\",\n      \"\": \"&eth;\",\n      \"\": \"&euml;\",\n      \"\": \"&euro;\",\n      \"!\": \"&excl;\",\n      \"\": \"&fcy;\",\n      \"\": \"&female;\",\n      \"\": \"&ffilig;\",\n      \"\": \"&fflig;\",\n      \"\": \"&ffllig;\",\n      \"\": \"&ffr;\",\n      \"\": \"&filig;\",\n      fj: \"&fjlig;\",\n      \"\": \"&flat;\",\n      \"\": \"&fllig;\",\n      \"\": \"&fltns;\",\n      \"\": \"&fnof;\",\n      \"\": \"&fopf;\",\n      \"\": \"&pitchfork;\",\n      \"\": \"&forkv;\",\n      \"\": \"&fpartint;\",\n      \"\": \"&half;\",\n      \"\": \"&frac13;\",\n      \"\": \"&frac14;\",\n      \"\": \"&frac15;\",\n      \"\": \"&frac16;\",\n      \"\": \"&frac18;\",\n      \"\": \"&frac23;\",\n      \"\": \"&frac25;\",\n      \"\": \"&frac34;\",\n      \"\": \"&frac35;\",\n      \"\": \"&frac38;\",\n      \"\": \"&frac45;\",\n      \"\": \"&frac56;\",\n      \"\": \"&frac58;\",\n      \"\": \"&frac78;\",\n      \"\": \"&frasl;\",\n      \"\": \"&sfrown;\",\n      \"\": \"&fscr;\",\n      \"\": \"&gtreqqless;\",\n      \"\": \"&gacute;\",\n      \"\": \"&gamma;\",\n      \"\": \"&gtrapprox;\",\n      \"\": \"&gbreve;\",\n      \"\": \"&gcirc;\",\n      \"\": \"&gcy;\",\n      \"\": \"&gdot;\",\n      \"\": \"&gescc;\",\n      \"\": \"&gesdot;\",\n      \"\": \"&gesdoto;\",\n      \"\": \"&gesdotol;\",\n      \"\": \"&gesl;\",\n      \"\": \"&gesles;\",\n      \"\": \"&gfr;\",\n      \"\": \"&gimel;\",\n      \"\": \"&gjcy;\",\n      \"\": \"&glE;\",\n      \"\": \"&gla;\",\n      \"\": \"&glj;\",\n      \"\": \"&gneqq;\",\n      \"\": \"&gnapprox;\",\n      \"\": \"&gneq;\",\n      \"\": \"&gnsim;\",\n      \"\": \"&gopf;\",\n      \"\": \"&gscr;\",\n      \"\": \"&gsime;\",\n      \"\": \"&gsiml;\",\n      \"\": \"&gtcc;\",\n      \"\": \"&gtcir;\",\n      \"\": \"&gtrdot;\",\n      \"\": \"&gtlPar;\",\n      \"\": \"&gtquest;\",\n      \"\": \"&gtrarr;\",\n      \"\": \"&gvnE;\",\n      \"\": \"&hardcy;\",\n      \"\": \"&harrcir;\",\n      \"\": \"&leftrightsquigarrow;\",\n      \"\": \"&plankv;\",\n      \"\": \"&hcirc;\",\n      \"\": \"&heartsuit;\",\n      \"\": \"&mldr;\",\n      \"\": \"&hercon;\",\n      \"\": \"&hfr;\",\n      \"\": \"&searhk;\",\n      \"\": \"&swarhk;\",\n      \"\": \"&hoarr;\",\n      \"\": \"&homtht;\",\n      \"\": \"&larrhk;\",\n      \"\": \"&rarrhk;\",\n      \"\": \"&hopf;\",\n      \"\": \"&horbar;\",\n      \"\": \"&hscr;\",\n      \"\": \"&hstrok;\",\n      \"\": \"&hybull;\",\n      \"\": \"&iacute;\",\n      \"\": \"&icirc;\",\n      \"\": \"&icy;\",\n      \"\": \"&iecy;\",\n      \"\": \"&iexcl;\",\n      \"\": \"&ifr;\",\n      \"\": \"&igrave;\",\n      \"\": \"&qint;\",\n      \"\": \"&tint;\",\n      \"\": \"&iinfin;\",\n      \"\": \"&iiota;\",\n      \"\": \"&ijlig;\",\n      \"\": \"&imacr;\",\n      \"\": \"&inodot;\",\n      \"\": \"&imof;\",\n      \"\": \"&imped;\",\n      \"\": \"&incare;\",\n      \"\": \"&infin;\",\n      \"\": \"&infintie;\",\n      \"\": \"&intercal;\",\n      \"\": \"&intlarhk;\",\n      \"\": \"&iprod;\",\n      \"\": \"&iocy;\",\n      \"\": \"&iogon;\",\n      \"\": \"&iopf;\",\n      \"\": \"&iota;\",\n      \"\": \"&iquest;\",\n      \"\": \"&iscr;\",\n      \"\": \"&isinE;\",\n      \"\": \"&isindot;\",\n      \"\": \"&isins;\",\n      \"\": \"&isinsv;\",\n      \"\": \"&itilde;\",\n      \"\": \"&iukcy;\",\n      \"\": \"&iuml;\",\n      \"\": \"&jcirc;\",\n      \"\": \"&jcy;\",\n      \"\": \"&jfr;\",\n      \"\": \"&jmath;\",\n      \"\": \"&jopf;\",\n      \"\": \"&jscr;\",\n      \"\": \"&jsercy;\",\n      \"\": \"&jukcy;\",\n      \"\": \"&kappa;\",\n      \"\": \"&varkappa;\",\n      \"\": \"&kcedil;\",\n      \"\": \"&kcy;\",\n      \"\": \"&kfr;\",\n      \"\": \"&kgreen;\",\n      \"\": \"&khcy;\",\n      \"\": \"&kjcy;\",\n      \"\": \"&kopf;\",\n      \"\": \"&kscr;\",\n      \"\": \"&lAtail;\",\n      \"\": \"&lBarr;\",\n      \"\": \"&lesseqqgtr;\",\n      \"\": \"&lHar;\",\n      \"\": \"&lacute;\",\n      \"\": \"&laemptyv;\",\n      \"\": \"&lambda;\",\n      \"\": \"&langd;\",\n      \"\": \"&lessapprox;\",\n      \"\": \"&laquo;\",\n      \"\": \"&larrbfs;\",\n      \"\": \"&larrfs;\",\n      \"\": \"&looparrowleft;\",\n      \"\": \"&larrpl;\",\n      \"\": \"&larrsim;\",\n      \"\": \"&leftarrowtail;\",\n      \"\": \"&lat;\",\n      \"\": \"&latail;\",\n      \"\": \"&late;\",\n      \"\": \"&lates;\",\n      \"\": \"&lbarr;\",\n      \"\": \"&lbbrk;\",\n      \"{\": \"&lcub;\",\n      \"[\": \"&lsqb;\",\n      \"\": \"&lbrke;\",\n      \"\": \"&lbrksld;\",\n      \"\": \"&lbrkslu;\",\n      \"\": \"&lcaron;\",\n      \"\": \"&lcedil;\",\n      \"\": \"&lcy;\",\n      \"\": \"&ldca;\",\n      \"\": \"&ldrdhar;\",\n      \"\": \"&ldrushar;\",\n      \"\": \"&ldsh;\",\n      \"\": \"&leq;\",\n      \"\": \"&llarr;\",\n      \"\": \"&lthree;\",\n      \"\": \"&lescc;\",\n      \"\": \"&lesdot;\",\n      \"\": \"&lesdoto;\",\n      \"\": \"&lesdotor;\",\n      \"\": \"&lesg;\",\n      \"\": \"&lesges;\",\n      \"\": \"&ltdot;\",\n      \"\": \"&lfisht;\",\n      \"\": \"&lfr;\",\n      \"\": \"&lgE;\",\n      \"\": \"&lharul;\",\n      \"\": \"&lhblk;\",\n      \"\": \"&ljcy;\",\n      \"\": \"&llhard;\",\n      \"\": \"&lltri;\",\n      \"\": \"&lmidot;\",\n      \"\": \"&lmoustache;\",\n      \"\": \"&lneqq;\",\n      \"\": \"&lnapprox;\",\n      \"\": \"&lneq;\",\n      \"\": \"&lnsim;\",\n      \"\": \"&loang;\",\n      \"\": \"&loarr;\",\n      \"\": \"&xmap;\",\n      \"\": \"&rarrlp;\",\n      \"\": \"&lopar;\",\n      \"\": \"&lopf;\",\n      \"\": \"&loplus;\",\n      \"\": \"&lotimes;\",\n      \"\": \"&lowast;\",\n      \"\": \"&lozenge;\",\n      \"(\": \"&lpar;\",\n      \"\": \"&lparlt;\",\n      \"\": \"&lrhard;\",\n      \"\": \"&lrm;\",\n      \"\": \"&lrtri;\",\n      \"\": \"&lsaquo;\",\n      \"\": \"&lscr;\",\n      \"\": \"&lsime;\",\n      \"\": \"&lsimg;\",\n      \"\": \"&sbquo;\",\n      \"\": \"&lstrok;\",\n      \"\": \"&ltcc;\",\n      \"\": \"&ltcir;\",\n      \"\": \"&ltimes;\",\n      \"\": \"&ltlarr;\",\n      \"\": \"&ltquest;\",\n      \"\": \"&ltrPar;\",\n      \"\": \"&triangleleft;\",\n      \"\": \"&lurdshar;\",\n      \"\": \"&luruhar;\",\n      \"\": \"&lvnE;\",\n      \"\": \"&mDDot;\",\n      \"\": \"&strns;\",\n      \"\": \"&male;\",\n      \"\": \"&maltese;\",\n      \"\": \"&marker;\",\n      \"\": \"&mcomma;\",\n      \"\": \"&mcy;\",\n      \"\": \"&mdash;\",\n      \"\": \"&mfr;\",\n      \"\": \"&mho;\",\n      \"\": \"&micro;\",\n      \"\": \"&midcir;\",\n      \"\": \"&minus;\",\n      \"\": \"&minusdu;\",\n      \"\": \"&mlcp;\",\n      \"\": \"&models;\",\n      \"\": \"&mopf;\",\n      \"\": \"&mscr;\",\n      \"\": \"&mu;\",\n      \"\": \"&mumap;\",\n      \"\": \"&nGg;\",\n      \"\": \"&nGt;\",\n      \"\": \"&nlArr;\",\n      \"\": \"&nhArr;\",\n      \"\": \"&nLl;\",\n      \"\": \"&nLt;\",\n      \"\": \"&nrArr;\",\n      \"\": \"&nVDash;\",\n      \"\": \"&nVdash;\",\n      \"\": \"&nacute;\",\n      \"\": \"&nang;\",\n      \"\": \"&napE;\",\n      \"\": \"&napid;\",\n      \"\": \"&napos;\",\n      \"\": \"&natural;\",\n      \"\": \"&ncap;\",\n      \"\": \"&ncaron;\",\n      \"\": \"&ncedil;\",\n      \"\": \"&ncongdot;\",\n      \"\": \"&ncup;\",\n      \"\": \"&ncy;\",\n      \"\": \"&ndash;\",\n      \"\": \"&neArr;\",\n      \"\": \"&nearhk;\",\n      \"\": \"&nedot;\",\n      \"\": \"&toea;\",\n      \"\": \"&nfr;\",\n      \"\": \"&nleftrightarrow;\",\n      \"\": \"&nhpar;\",\n      \"\": \"&nis;\",\n      \"\": \"&nisd;\",\n      \"\": \"&njcy;\",\n      \"\": \"&nleqq;\",\n      \"\": \"&nleftarrow;\",\n      \"\": \"&nldr;\",\n      \"\": \"&nopf;\",\n      \"\": \"&not;\",\n      \"\": \"&notinE;\",\n      \"\": \"&notindot;\",\n      \"\": \"&notinvb;\",\n      \"\": \"&notinvc;\",\n      \"\": \"&notnivb;\",\n      \"\": \"&notnivc;\",\n      \"\": \"&nparsl;\",\n      \"\": \"&npart;\",\n      \"\": \"&npolint;\",\n      \"\": \"&nrightarrow;\",\n      \"\": \"&nrarrc;\",\n      \"\": \"&nrarrw;\",\n      \"\": \"&nscr;\",\n      \"\": \"&nsub;\",\n      \"\": \"&nsubseteqq;\",\n      \"\": \"&nsup;\",\n      \"\": \"&nsupseteqq;\",\n      \"\": \"&ntilde;\",\n      \"\": \"&nu;\",\n      \"#\": \"&num;\",\n      \"\": \"&numero;\",\n      \"\": \"&numsp;\",\n      \"\": \"&nvDash;\",\n      \"\": \"&nvHarr;\",\n      \"\": \"&nvap;\",\n      \"\": \"&nvdash;\",\n      \"\": \"&nvge;\",\n      \">\": \"&nvgt;\",\n      \"\": \"&nvinfin;\",\n      \"\": \"&nvlArr;\",\n      \"\": \"&nvle;\",\n      \"<\": \"&nvlt;\",\n      \"\": \"&nvltrie;\",\n      \"\": \"&nvrArr;\",\n      \"\": \"&nvrtrie;\",\n      \"\": \"&nvsim;\",\n      \"\": \"&nwArr;\",\n      \"\": \"&nwarhk;\",\n      \"\": \"&nwnear;\",\n      \"\": \"&oacute;\",\n      \"\": \"&ocirc;\",\n      \"\": \"&ocy;\",\n      \"\": \"&odblac;\",\n      \"\": \"&odiv;\",\n      \"\": \"&odsold;\",\n      \"\": \"&oelig;\",\n      \"\": \"&ofcir;\",\n      \"\": \"&ofr;\",\n      \"\": \"&ogon;\",\n      \"\": \"&ograve;\",\n      \"\": \"&ogt;\",\n      \"\": \"&ohbar;\",\n      \"\": \"&olcir;\",\n      \"\": \"&olcross;\",\n      \"\": \"&olt;\",\n      \"\": \"&omacr;\",\n      \"\": \"&omega;\",\n      \"\": \"&omicron;\",\n      \"\": \"&omid;\",\n      \"\": \"&oopf;\",\n      \"\": \"&opar;\",\n      \"\": \"&operp;\",\n      \"\": \"&vee;\",\n      \"\": \"&ord;\",\n      \"\": \"&oscr;\",\n      \"\": \"&ordf;\",\n      \"\": \"&ordm;\",\n      \"\": \"&origof;\",\n      \"\": \"&oror;\",\n      \"\": \"&orslope;\",\n      \"\": \"&orv;\",\n      \"\": \"&oslash;\",\n      \"\": \"&osol;\",\n      \"\": \"&otilde;\",\n      \"\": \"&otimesas;\",\n      \"\": \"&ouml;\",\n      \"\": \"&ovbar;\",\n      \"\": \"&para;\",\n      \"\": \"&parsim;\",\n      \"\": \"&parsl;\",\n      \"\": \"&pcy;\",\n      \"%\": \"&percnt;\",\n      \".\": \"&period;\",\n      \"\": \"&permil;\",\n      \"\": \"&pertenk;\",\n      \"\": \"&pfr;\",\n      \"\": \"&phi;\",\n      \"\": \"&varphi;\",\n      \"\": \"&phone;\",\n      \"\": \"&pi;\",\n      \"\": \"&varpi;\",\n      \"\": \"&planckh;\",\n      \"+\": \"&plus;\",\n      \"\": \"&plusacir;\",\n      \"\": \"&pluscir;\",\n      \"\": \"&plusdu;\",\n      \"\": \"&pluse;\",\n      \"\": \"&plussim;\",\n      \"\": \"&plustwo;\",\n      \"\": \"&pointint;\",\n      \"\": \"&popf;\",\n      \"\": \"&pound;\",\n      \"\": \"&prE;\",\n      \"\": \"&precapprox;\",\n      \"\": \"&prnap;\",\n      \"\": \"&prnE;\",\n      \"\": \"&prnsim;\",\n      \"\": \"&prime;\",\n      \"\": \"&profalar;\",\n      \"\": \"&profline;\",\n      \"\": \"&profsurf;\",\n      \"\": \"&prurel;\",\n      \"\": \"&pscr;\",\n      \"\": \"&psi;\",\n      \"\": \"&puncsp;\",\n      \"\": \"&qfr;\",\n      \"\": \"&qopf;\",\n      \"\": \"&qprime;\",\n      \"\": \"&qscr;\",\n      \"\": \"&quatint;\",\n      \"?\": \"&quest;\",\n      \"\": \"&rAtail;\",\n      \"\": \"&rHar;\",\n      \"\": \"&race;\",\n      \"\": \"&racute;\",\n      \"\": \"&raemptyv;\",\n      \"\": \"&rangd;\",\n      \"\": \"&range;\",\n      \"\": \"&raquo;\",\n      \"\": \"&rarrap;\",\n      \"\": \"&rarrbfs;\",\n      \"\": \"&rarrc;\",\n      \"\": \"&rarrfs;\",\n      \"\": \"&rarrpl;\",\n      \"\": \"&rarrsim;\",\n      \"\": \"&rightarrowtail;\",\n      \"\": \"&rightsquigarrow;\",\n      \"\": \"&ratail;\",\n      \"\": \"&ratio;\",\n      \"\": \"&rbbrk;\",\n      \"}\": \"&rcub;\",\n      \"]\": \"&rsqb;\",\n      \"\": \"&rbrke;\",\n      \"\": \"&rbrksld;\",\n      \"\": \"&rbrkslu;\",\n      \"\": \"&rcaron;\",\n      \"\": \"&rcedil;\",\n      \"\": \"&rcy;\",\n      \"\": \"&rdca;\",\n      \"\": \"&rdldhar;\",\n      \"\": \"&rdsh;\",\n      \"\": \"&rect;\",\n      \"\": \"&rfisht;\",\n      \"\": \"&rfr;\",\n      \"\": \"&rharul;\",\n      \"\": \"&rho;\",\n      \"\": \"&varrho;\",\n      \"\": \"&rrarr;\",\n      \"\": \"&rthree;\",\n      \"\": \"&ring;\",\n      \"\": \"&rlm;\",\n      \"\": \"&rmoustache;\",\n      \"\": \"&rnmid;\",\n      \"\": \"&roang;\",\n      \"\": \"&roarr;\",\n      \"\": \"&ropar;\",\n      \"\": \"&ropf;\",\n      \"\": \"&roplus;\",\n      \"\": \"&rotimes;\",\n      \")\": \"&rpar;\",\n      \"\": \"&rpargt;\",\n      \"\": \"&rppolint;\",\n      \"\": \"&rsaquo;\",\n      \"\": \"&rscr;\",\n      \"\": \"&rtimes;\",\n      \"\": \"&triangleright;\",\n      \"\": \"&rtriltri;\",\n      \"\": \"&ruluhar;\",\n      \"\": \"&rx;\",\n      \"\": \"&sacute;\",\n      \"\": \"&scE;\",\n      \"\": \"&succapprox;\",\n      \"\": \"&scaron;\",\n      \"\": \"&scedil;\",\n      \"\": \"&scirc;\",\n      \"\": \"&succneqq;\",\n      \"\": \"&succnapprox;\",\n      \"\": \"&succnsim;\",\n      \"\": \"&scpolint;\",\n      \"\": \"&scy;\",\n      \"\": \"&sdot;\",\n      \"\": \"&sdote;\",\n      \"\": \"&seArr;\",\n      \"\": \"&sect;\",\n      \";\": \"&semi;\",\n      \"\": \"&tosa;\",\n      \"\": \"&sext;\",\n      \"\": \"&sfr;\",\n      \"\": \"&sharp;\",\n      \"\": \"&shchcy;\",\n      \"\": \"&shcy;\",\n      \"\": \"&shy;\",\n      \"\": \"&sigma;\",\n      \"\": \"&varsigma;\",\n      \"\": \"&simdot;\",\n      \"\": \"&simg;\",\n      \"\": \"&simgE;\",\n      \"\": \"&siml;\",\n      \"\": \"&simlE;\",\n      \"\": \"&simne;\",\n      \"\": \"&simplus;\",\n      \"\": \"&simrarr;\",\n      \"\": \"&smashp;\",\n      \"\": \"&smeparsl;\",\n      \"\": \"&ssmile;\",\n      \"\": \"&smt;\",\n      \"\": \"&smte;\",\n      \"\": \"&smtes;\",\n      \"\": \"&softcy;\",\n      \"/\": \"&sol;\",\n      \"\": \"&solb;\",\n      \"\": \"&solbar;\",\n      \"\": \"&sopf;\",\n      \"\": \"&spadesuit;\",\n      \"\": \"&sqcaps;\",\n      \"\": \"&sqcups;\",\n      \"\": \"&sscr;\",\n      \"\": \"&star;\",\n      \"\": \"&subset;\",\n      \"\": \"&subseteqq;\",\n      \"\": \"&subdot;\",\n      \"\": \"&subedot;\",\n      \"\": \"&submult;\",\n      \"\": \"&subsetneqq;\",\n      \"\": \"&subsetneq;\",\n      \"\": \"&subplus;\",\n      \"\": \"&subrarr;\",\n      \"\": \"&subsim;\",\n      \"\": \"&subsub;\",\n      \"\": \"&subsup;\",\n      \"\": \"&sung;\",\n      \"\": \"&sup1;\",\n      \"\": \"&sup2;\",\n      \"\": \"&sup3;\",\n      \"\": \"&supseteqq;\",\n      \"\": \"&supdot;\",\n      \"\": \"&supdsub;\",\n      \"\": \"&supedot;\",\n      \"\": \"&suphsol;\",\n      \"\": \"&suphsub;\",\n      \"\": \"&suplarr;\",\n      \"\": \"&supmult;\",\n      \"\": \"&supsetneqq;\",\n      \"\": \"&supsetneq;\",\n      \"\": \"&supplus;\",\n      \"\": \"&supsim;\",\n      \"\": \"&supsub;\",\n      \"\": \"&supsup;\",\n      \"\": \"&swArr;\",\n      \"\": \"&swnwar;\",\n      \"\": \"&szlig;\",\n      \"\": \"&target;\",\n      \"\": \"&tau;\",\n      \"\": \"&tcaron;\",\n      \"\": \"&tcedil;\",\n      \"\": \"&tcy;\",\n      \"\": \"&telrec;\",\n      \"\": \"&tfr;\",\n      \"\": \"&theta;\",\n      \"\": \"&vartheta;\",\n      \"\": \"&thorn;\",\n      \"\": \"&times;\",\n      \"\": \"&timesbar;\",\n      \"\": \"&timesd;\",\n      \"\": \"&topbot;\",\n      \"\": \"&topcir;\",\n      \"\": \"&topf;\",\n      \"\": \"&topfork;\",\n      \"\": \"&tprime;\",\n      \"\": \"&utri;\",\n      \"\": \"&trie;\",\n      \"\": \"&tridot;\",\n      \"\": \"&triminus;\",\n      \"\": \"&triplus;\",\n      \"\": \"&trisb;\",\n      \"\": \"&tritime;\",\n      \"\": \"&trpezium;\",\n      \"\": \"&tscr;\",\n      \"\": \"&tscy;\",\n      \"\": \"&tshcy;\",\n      \"\": \"&tstrok;\",\n      \"\": \"&uHar;\",\n      \"\": \"&uacute;\",\n      \"\": \"&ubrcy;\",\n      \"\": \"&ubreve;\",\n      \"\": \"&ucirc;\",\n      \"\": \"&ucy;\",\n      \"\": \"&udblac;\",\n      \"\": \"&ufisht;\",\n      \"\": \"&ufr;\",\n      \"\": \"&ugrave;\",\n      \"\": \"&uhblk;\",\n      \"\": \"&ulcorner;\",\n      \"\": \"&ulcrop;\",\n      \"\": \"&ultri;\",\n      \"\": \"&umacr;\",\n      \"\": \"&uogon;\",\n      \"\": \"&uopf;\",\n      \"\": \"&upsilon;\",\n      \"\": \"&uuarr;\",\n      \"\": \"&urcorner;\",\n      \"\": \"&urcrop;\",\n      \"\": \"&uring;\",\n      \"\": \"&urtri;\",\n      \"\": \"&uscr;\",\n      \"\": \"&utdot;\",\n      \"\": \"&utilde;\",\n      \"\": \"&uuml;\",\n      \"\": \"&uwangle;\",\n      \"\": \"&vBar;\",\n      \"\": \"&vBarv;\",\n      \"\": \"&vangrt;\",\n      \"\": \"&vsubne;\",\n      \"\": \"&vsubnE;\",\n      \"\": \"&vsupne;\",\n      \"\": \"&vsupnE;\",\n      \"\": \"&vcy;\",\n      \"\": \"&veebar;\",\n      \"\": \"&veeeq;\",\n      \"\": \"&vellip;\",\n      \"\": \"&vfr;\",\n      \"\": \"&vopf;\",\n      \"\": \"&vscr;\",\n      \"\": \"&vzigzag;\",\n      \"\": \"&wcirc;\",\n      \"\": \"&wedbar;\",\n      \"\": \"&wedgeq;\",\n      \"\": \"&wp;\",\n      \"\": \"&wfr;\",\n      \"\": \"&wopf;\",\n      \"\": \"&wscr;\",\n      \"\": \"&xfr;\",\n      \"\": \"&xi;\",\n      \"\": \"&xnis;\",\n      \"\": \"&xopf;\",\n      \"\": \"&xscr;\",\n      \"\": \"&yacute;\",\n      \"\": \"&yacy;\",\n      \"\": \"&ycirc;\",\n      \"\": \"&ycy;\",\n      \"\": \"&yen;\",\n      \"\": \"&yfr;\",\n      \"\": \"&yicy;\",\n      \"\": \"&yopf;\",\n      \"\": \"&yscr;\",\n      \"\": \"&yucy;\",\n      \"\": \"&yuml;\",\n      \"\": \"&zacute;\",\n      \"\": \"&zcaron;\",\n      \"\": \"&zcy;\",\n      \"\": \"&zdot;\",\n      \"\": \"&zeta;\",\n      \"\": \"&zfr;\",\n      \"\": \"&zhcy;\",\n      \"\": \"&zigrarr;\",\n      \"\": \"&zopf;\",\n      \"\": \"&zscr;\",\n      \"\": \"&zwj;\",\n      \"\": \"&zwnj;\"\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvbmFtZWQtcmVmZXJlbmNlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixtQkFBbUI7QUFDbkIsZ0RBQWdEO0FBQ2hELGlCQUFpQiwybkJBQTJuQjtBQUM1b0IscUJBQXFCLFNBQVMsZ0JBQWdCLE9BQU8sUUFBUSxRQUFRLFNBQVMsVUFBVSxZQUFZLFNBQVMsU0FBUyxZQUFZLGFBQWEsVUFBVSxTQUFTLE9BQU8sUUFBUSxRQUFRLFNBQVMsU0FBUyxTQUFTLFVBQVUsU0FBUyxPQUFPLFFBQVEsUUFBUSxRQUFRLFNBQVMsV0FBVyxVQUFVLFVBQVUsVUFBVSxRQUFRLFVBQVUsVUFBVSxVQUFVLFdBQVcsU0FBUyxXQUFXLFNBQVMsbXBCQUFtcEI7QUFDemhDO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYLGFBQWE7QUFDYixhQUFhO0FBQ2IsWUFBWTtBQUNaLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLFlBQVk7QUFDWjtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLFlB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YnBhY2s6Ly9teV9hcHAvLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvbmFtZWQtcmVmZXJlbmNlcy5qcz80ZjNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ib2R5UmVnRXhwcyA9IHtcbiAgeG1sOiAvJig/OiNcXGQrfCNbeFhdW1xcZGEtZkEtRl0rfFswLTlhLXpBLVpdKyk7Py9nLFxuICBodG1sNDogLyZub3Rpbjt8Jig/Om5ic3B8aWV4Y2x8Y2VudHxwb3VuZHxjdXJyZW58eWVufGJydmJhcnxzZWN0fHVtbHxjb3B5fG9yZGZ8bGFxdW98bm90fHNoeXxyZWd8bWFjcnxkZWd8cGx1c21ufHN1cDJ8c3VwM3xhY3V0ZXxtaWNyb3xwYXJhfG1pZGRvdHxjZWRpbHxzdXAxfG9yZG18cmFxdW98ZnJhYzE0fGZyYWMxMnxmcmFjMzR8aXF1ZXN0fEFncmF2ZXxBYWN1dGV8QWNpcmN8QXRpbGRlfEF1bWx8QXJpbmd8QUVsaWd8Q2NlZGlsfEVncmF2ZXxFYWN1dGV8RWNpcmN8RXVtbHxJZ3JhdmV8SWFjdXRlfEljaXJjfEl1bWx8RVRIfE50aWxkZXxPZ3JhdmV8T2FjdXRlfE9jaXJjfE90aWxkZXxPdW1sfHRpbWVzfE9zbGFzaHxVZ3JhdmV8VWFjdXRlfFVjaXJjfFV1bWx8WWFjdXRlfFRIT1JOfHN6bGlnfGFncmF2ZXxhYWN1dGV8YWNpcmN8YXRpbGRlfGF1bWx8YXJpbmd8YWVsaWd8Y2NlZGlsfGVncmF2ZXxlYWN1dGV8ZWNpcmN8ZXVtbHxpZ3JhdmV8aWFjdXRlfGljaXJjfGl1bWx8ZXRofG50aWxkZXxvZ3JhdmV8b2FjdXRlfG9jaXJjfG90aWxkZXxvdW1sfGRpdmlkZXxvc2xhc2h8dWdyYXZlfHVhY3V0ZXx1Y2lyY3x1dW1sfHlhY3V0ZXx0aG9ybnx5dW1sfHF1b3R8YW1wfGx0fGd0fCNcXGQrfCNbeFhdW1xcZGEtZkEtRl0rfFswLTlhLXpBLVpdKyk7Py9nLFxuICBodG1sNTogLyZjZW50ZXJkb3Q7fCZjb3B5c3I7fCZkaXZpZGVvbnRpbWVzO3wmZ3RjYzt8Jmd0Y2lyO3wmZ3Rkb3Q7fCZndGxQYXI7fCZndHF1ZXN0O3wmZ3RyYXBwcm94O3wmZ3RyYXJyO3wmZ3RyZG90O3wmZ3RyZXFsZXNzO3wmZ3RyZXFxbGVzczt8Jmd0cmxlc3M7fCZndHJzaW07fCZsdGNjO3wmbHRjaXI7fCZsdGRvdDt8Jmx0aHJlZTt8Jmx0aW1lczt8Jmx0bGFycjt8Jmx0cXVlc3Q7fCZsdHJQYXI7fCZsdHJpO3wmbHRyaWU7fCZsdHJpZjt8Jm5vdGluO3wmbm90aW5FO3wmbm90aW5kb3Q7fCZub3RpbnZhO3wmbm90aW52Yjt8Jm5vdGludmM7fCZub3RuaTt8Jm5vdG5pdmE7fCZub3RuaXZiO3wmbm90bml2Yzt8JnBhcmFsbGVsO3wmdGltZXNiO3wmdGltZXNiYXI7fCZ0aW1lc2Q7fCYoPzpBRWxpZ3xBTVB8QWFjdXRlfEFjaXJjfEFncmF2ZXxBcmluZ3xBdGlsZGV8QXVtbHxDT1BZfENjZWRpbHxFVEh8RWFjdXRlfEVjaXJjfEVncmF2ZXxFdW1sfEdUfElhY3V0ZXxJY2lyY3xJZ3JhdmV8SXVtbHxMVHxOdGlsZGV8T2FjdXRlfE9jaXJjfE9ncmF2ZXxPc2xhc2h8T3RpbGRlfE91bWx8UVVPVHxSRUd8VEhPUk58VWFjdXRlfFVjaXJjfFVncmF2ZXxVdW1sfFlhY3V0ZXxhYWN1dGV8YWNpcmN8YWN1dGV8YWVsaWd8YWdyYXZlfGFtcHxhcmluZ3xhdGlsZGV8YXVtbHxicnZiYXJ8Y2NlZGlsfGNlZGlsfGNlbnR8Y29weXxjdXJyZW58ZGVnfGRpdmlkZXxlYWN1dGV8ZWNpcmN8ZWdyYXZlfGV0aHxldW1sfGZyYWMxMnxmcmFjMTR8ZnJhYzM0fGd0fGlhY3V0ZXxpY2lyY3xpZXhjbHxpZ3JhdmV8aXF1ZXN0fGl1bWx8bGFxdW98bHR8bWFjcnxtaWNyb3xtaWRkb3R8bmJzcHxub3R8bnRpbGRlfG9hY3V0ZXxvY2lyY3xvZ3JhdmV8b3JkZnxvcmRtfG9zbGFzaHxvdGlsZGV8b3VtbHxwYXJhfHBsdXNtbnxwb3VuZHxxdW90fHJhcXVvfHJlZ3xzZWN0fHNoeXxzdXAxfHN1cDJ8c3VwM3xzemxpZ3x0aG9ybnx0aW1lc3x1YWN1dGV8dWNpcmN8dWdyYXZlfHVtbHx1dW1sfHlhY3V0ZXx5ZW58eXVtbHwjXFxkK3wjW3hYXVtcXGRhLWZBLUZdK3xbMC05YS16QS1aXSspOz8vZ1xufTtcbmV4cG9ydHMubmFtZWRSZWZlcmVuY2VzID0ge1xuICB4bWw6IHtcbiAgICBlbnRpdGllczoge1xuICAgICAgXCImbHQ7XCI6IFwiPFwiLFxuICAgICAgXCImZ3Q7XCI6IFwiPlwiLFxuICAgICAgXCImcXVvdDtcIjogJ1wiJyxcbiAgICAgIFwiJmFwb3M7XCI6IFwiJ1wiLFxuICAgICAgXCImYW1wO1wiOiBcIiZcIlxuICAgIH0sXG4gICAgY2hhcmFjdGVyczoge1xuICAgICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgICAgXCI+XCI6IFwiJmd0O1wiLFxuICAgICAgJ1wiJzogXCImcXVvdDtcIixcbiAgICAgIFwiJ1wiOiBcIiZhcG9zO1wiLFxuICAgICAgXCImXCI6IFwiJmFtcDtcIlxuICAgIH1cbiAgfSxcbiAgaHRtbDQ6IHtcbiAgICBlbnRpdGllczoge1xuICAgICAgXCImYXBvcztcIjogXCInXCIsXG4gICAgICBcIiZuYnNwXCI6IFwiwqBcIixcbiAgICAgIFwiJm5ic3A7XCI6IFwiwqBcIixcbiAgICAgIFwiJmlleGNsXCI6IFwiwqFcIixcbiAgICAgIFwiJmlleGNsO1wiOiBcIsKhXCIsXG4gICAgICBcIiZjZW50XCI6IFwiwqJcIixcbiAgICAgIFwiJmNlbnQ7XCI6IFwiwqJcIixcbiAgICAgIFwiJnBvdW5kXCI6IFwiwqNcIixcbiAgICAgIFwiJnBvdW5kO1wiOiBcIsKjXCIsXG4gICAgICBcIiZjdXJyZW5cIjogXCLCpFwiLFxuICAgICAgXCImY3VycmVuO1wiOiBcIsKkXCIsXG4gICAgICBcIiZ5ZW5cIjogXCLCpVwiLFxuICAgICAgXCImeWVuO1wiOiBcIsKlXCIsXG4gICAgICBcIiZicnZiYXJcIjogXCLCplwiLFxuICAgICAgXCImYnJ2YmFyO1wiOiBcIsKmXCIsXG4gICAgICBcIiZzZWN0XCI6IFwiwqdcIixcbiAgICAgIFwiJnNlY3Q7XCI6IFwiwqdcIixcbiAgICAgIFwiJnVtbFwiOiBcIsKoXCIsXG4gICAgICBcIiZ1bWw7XCI6IFwiwqhcIixcbiAgICAgIFwiJmNvcHlcIjogXCLCqVwiLFxuICAgICAgXCImY29weTtcIjogXCLCqVwiLFxuICAgICAgXCImb3JkZlwiOiBcIsKqXCIsXG4gICAgICBcIiZvcmRmO1wiOiBcIsKqXCIsXG4gICAgICBcIiZsYXF1b1wiOiBcIsKrXCIsXG4gICAgICBcIiZsYXF1bztcIjogXCLCq1wiLFxuICAgICAgXCImbm90XCI6IFwiwqxcIixcbiAgICAgIFwiJm5vdDtcIjogXCLCrFwiLFxuICAgICAgXCImc2h5XCI6IFwiwq1cIixcbiAgICAgIFwiJnNoeTtcIjogXCLCrVwiLFxuICAgICAgXCImcmVnXCI6IFwiwq5cIixcbiAgICAgIFwiJnJlZztcIjogXCLCrlwiLFxuICAgICAgXCImbWFjclwiOiBcIsKvXCIsXG4gICAgICBcIiZtYWNyO1wiOiBcIsKvXCIsXG4gICAgICBcIiZkZWdcIjogXCLCsFwiLFxuICAgICAgXCImZGVnO1wiOiBcIsKwXCIsXG4gICAgICBcIiZwbHVzbW5cIjogXCLCsVwiLFxuICAgICAgXCImcGx1c21uO1wiOiBcIsKxXCIsXG4gICAgICBcIiZzdXAyXCI6IFwiwrJcIixcbiAgICAgIFwiJnN1cDI7XCI6IFwiwrJcIixcbiAgICAgIFwiJnN1cDNcIjogXCLCs1wiLFxuICAgICAgXCImc3VwMztcIjogXCLCs1wiLFxuICAgICAgXCImYWN1dGVcIjogXCLCtFwiLFxuICAgICAgXCImYWN1dGU7XCI6IFwiwrRcIixcbiAgICAgIFwiJm1pY3JvXCI6IFwiwrVcIixcbiAgICAgIFwiJm1pY3JvO1wiOiBcIsK1XCIsXG4gICAgICBcIiZwYXJhXCI6IFwiwrZcIixcbiAgICAgIFwiJnBhcmE7XCI6IFwiwrZcIixcbiAgICAgIFwiJm1pZGRvdFwiOiBcIsK3XCIsXG4gICAgICBcIiZtaWRkb3Q7XCI6IFwiwrdcIixcbiAgICAgIFwiJmNlZGlsXCI6IFwiwrhcIixcbiAgICAgIFwiJmNlZGlsO1wiOiBcIsK4XCIsXG4gICAgICBcIiZzdXAxXCI6IFwiwrlcIixcbiAgICAgIFwiJnN1cDE7XCI6IFwiwrlcIixcbiAgICAgIFwiJm9yZG1cIjogXCLCulwiLFxuICAgICAgXCImb3JkbTtcIjogXCLCulwiLFxuICAgICAgXCImcmFxdW9cIjogXCLCu1wiLFxuICAgICAgXCImcmFxdW87XCI6IFwiwrtcIixcbiAgICAgIFwiJmZyYWMxNFwiOiBcIsK8XCIsXG4gICAgICBcIiZmcmFjMTQ7XCI6IFwiwrxcIixcbiAgICAgIFwiJmZyYWMxMlwiOiBcIsK9XCIsXG4gICAgICBcIiZmcmFjMTI7XCI6IFwiwr1cIixcbiAgICAgIFwiJmZyYWMzNFwiOiBcIsK+XCIsXG4gICAgICBcIiZmcmFjMzQ7XCI6IFwiwr5cIixcbiAgICAgIFwiJmlxdWVzdFwiOiBcIsK/XCIsXG4gICAgICBcIiZpcXVlc3Q7XCI6IFwiwr9cIixcbiAgICAgIFwiJkFncmF2ZVwiOiBcIsOAXCIsXG4gICAgICBcIiZBZ3JhdmU7XCI6IFwiw4BcIixcbiAgICAgIFwiJkFhY3V0ZVwiOiBcIsOBXCIsXG4gICAgICBcIiZBYWN1dGU7XCI6IFwiw4FcIixcbiAgICAgIFwiJkFjaXJjXCI6IFwiw4JcIixcbiAgICAgIFwiJkFjaXJjO1wiOiBcIsOCXCIsXG4gICAgICBcIiZBdGlsZGVcIjogXCLDg1wiLFxuICAgICAgXCImQXRpbGRlO1wiOiBcIsODXCIsXG4gICAgICBcIiZBdW1sXCI6IFwiw4RcIixcbiAgICAgIFwiJkF1bWw7XCI6IFwiw4RcIixcbiAgICAgIFwiJkFyaW5nXCI6IFwiw4VcIixcbiAgICAgIFwiJkFyaW5nO1wiOiBcIsOFXCIsXG4gICAgICBcIiZBRWxpZ1wiOiBcIsOGXCIsXG4gICAgICBcIiZBRWxpZztcIjogXCLDhlwiLFxuICAgICAgXCImQ2NlZGlsXCI6IFwiw4dcIixcbiAgICAgIFwiJkNjZWRpbDtcIjogXCLDh1wiLFxuICAgICAgXCImRWdyYXZlXCI6IFwiw4hcIixcbiAgICAgIFwiJkVncmF2ZTtcIjogXCLDiFwiLFxuICAgICAgXCImRWFjdXRlXCI6IFwiw4lcIixcbiAgICAgIFwiJkVhY3V0ZTtcIjogXCLDiVwiLFxuICAgICAgXCImRWNpcmNcIjogXCLDilwiLFxuICAgICAgXCImRWNpcmM7XCI6IFwiw4pcIixcbiAgICAgIFwiJkV1bWxcIjogXCLDi1wiLFxuICAgICAgXCImRXVtbDtcIjogXCLDi1wiLFxuICAgICAgXCImSWdyYXZlXCI6IFwiw4xcIixcbiAgICAgIFwiJklncmF2ZTtcIjogXCLDjFwiLFxuICAgICAgXCImSWFjdXRlXCI6IFwiw41cIixcbiAgICAgIFwiJklhY3V0ZTtcIjogXCLDjVwiLFxuICAgICAgXCImSWNpcmNcIjogXCLDjlwiLFxuICAgICAgXCImSWNpcmM7XCI6IFwiw45cIixcbiAgICAgIFwiJkl1bWxcIjogXCLDj1wiLFxuICAgICAgXCImSXVtbDtcIjogXCLDj1wiLFxuICAgICAgXCImRVRIXCI6IFwiw5BcIixcbiAgICAgIFwiJkVUSDtcIjogXCLDkFwiLFxuICAgICAgXCImTnRpbGRlXCI6IFwiw5FcIixcbiAgICAgIFwiJk50aWxkZTtcIjogXCLDkVwiLFxuICAgICAgXCImT2dyYXZlXCI6IFwiw5JcIixcbiAgICAgIFwiJk9ncmF2ZTtcIjogXCLDklwiLFxuICAgICAgXCImT2FjdXRlXCI6IFwiw5NcIixcbiAgICAgIFwiJk9hY3V0ZTtcIjogXCLDk1wiLFxuICAgICAgXCImT2NpcmNcIjogXCLDlFwiLFxuICAgICAgXCImT2NpcmM7XCI6IFwiw5RcIixcbiAgICAgIFwiJk90aWxkZVwiOiBcIsOVXCIsXG4gICAgICBcIiZPdGlsZGU7XCI6IFwiw5VcIixcbiAgICAgIFwiJk91bWxcIjogXCLDllwiLFxuICAgICAgXCImT3VtbDtcIjogXCLDllwiLFxuICAgICAgXCImdGltZXNcIjogXCLDl1wiLFxuICAgICAgXCImdGltZXM7XCI6IFwiw5dcIixcbiAgICAgIFwiJk9zbGFzaFwiOiBcIsOYXCIsXG4gICAgICBcIiZPc2xhc2g7XCI6IFwiw5hcIixcbiAgICAgIFwiJlVncmF2ZVwiOiBcIsOZXCIsXG4gICAgICBcIiZVZ3JhdmU7XCI6IFwiw5lcIixcbiAgICAgIFwiJlVhY3V0ZVwiOiBcIsOaXCIsXG4gICAgICBcIiZVYWN1dGU7XCI6IFwiw5pcIixcbiAgICAgIFwiJlVjaXJjXCI6IFwiw5tcIixcbiAgICAgIFwiJlVjaXJjO1wiOiBcIsObXCIsXG4gICAgICBcIiZVdW1sXCI6IFwiw5xcIixcbiAgICAgIFwiJlV1bWw7XCI6IFwiw5xcIixcbiAgICAgIFwiJllhY3V0ZVwiOiBcIsOdXCIsXG4gICAgICBcIiZZYWN1dGU7XCI6IFwiw51cIixcbiAgICAgIFwiJlRIT1JOXCI6IFwiw55cIixcbiAgICAgIFwiJlRIT1JOO1wiOiBcIsOeXCIsXG4gICAgICBcIiZzemxpZ1wiOiBcIsOfXCIsXG4gICAgICBcIiZzemxpZztcIjogXCLDn1wiLFxuICAgICAgXCImYWdyYXZlXCI6IFwiw6BcIixcbiAgICAgIFwiJmFncmF2ZTtcIjogXCLDoFwiLFxuICAgICAgXCImYWFjdXRlXCI6IFwiw6FcIixcbiAgICAgIFwiJmFhY3V0ZTtcIjogXCLDoVwiLFxuICAgICAgXCImYWNpcmNcIjogXCLDolwiLFxuICAgICAgXCImYWNpcmM7XCI6IFwiw6JcIixcbiAgICAgIFwiJmF0aWxkZVwiOiBcIsOjXCIsXG4gICAgICBcIiZhdGlsZGU7XCI6IFwiw6NcIixcbiAgICAgIFwiJmF1bWxcIjogXCLDpFwiLFxuICAgICAgXCImYXVtbDtcIjogXCLDpFwiLFxuICAgICAgXCImYXJpbmdcIjogXCLDpVwiLFxuICAgICAgXCImYXJpbmc7XCI6IFwiw6VcIixcbiAgICAgIFwiJmFlbGlnXCI6IFwiw6ZcIixcbiAgICAgIFwiJmFlbGlnO1wiOiBcIsOmXCIsXG4gICAgICBcIiZjY2VkaWxcIjogXCLDp1wiLFxuICAgICAgXCImY2NlZGlsO1wiOiBcIsOnXCIsXG4gICAgICBcIiZlZ3JhdmVcIjogXCLDqFwiLFxuICAgICAgXCImZWdyYXZlO1wiOiBcIsOoXCIsXG4gICAgICBcIiZlYWN1dGVcIjogXCLDqVwiLFxuICAgICAgXCImZWFjdXRlO1wiOiBcIsOpXCIsXG4gICAgICBcIiZlY2lyY1wiOiBcIsOqXCIsXG4gICAgICBcIiZlY2lyYztcIjogXCLDqlwiLFxuICAgICAgXCImZXVtbFwiOiBcIsOrXCIsXG4gICAgICBcIiZldW1sO1wiOiBcIsOrXCIsXG4gICAgICBcIiZpZ3JhdmVcIjogXCLDrFwiLFxuICAgICAgXCImaWdyYXZlO1wiOiBcIsOsXCIsXG4gICAgICBcIiZpYWN1dGVcIjogXCLDrVwiLFxuICAgICAgXCImaWFjdXRlO1wiOiBcIsOtXCIsXG4gICAgICBcIiZpY2lyY1wiOiBcIsOuXCIsXG4gICAgICBcIiZpY2lyYztcIjogXCLDrlwiLFxuICAgICAgXCImaXVtbFwiOiBcIsOvXCIsXG4gICAgICBcIiZpdW1sO1wiOiBcIsOvXCIsXG4gICAgICBcIiZldGhcIjogXCLDsFwiLFxuICAgICAgXCImZXRoO1wiOiBcIsOwXCIsXG4gICAgICBcIiZudGlsZGVcIjogXCLDsVwiLFxuICAgICAgXCImbnRpbGRlO1wiOiBcIsOxXCIsXG4gICAgICBcIiZvZ3JhdmVcIjogXCLDslwiLFxuICAgICAgXCImb2dyYXZlO1wiOiBcIsOyXCIsXG4gICAgICBcIiZvYWN1dGVcIjogXCLDs1wiLFxuICAgICAgXCImb2FjdXRlO1wiOiBcIsOzXCIsXG4gICAgICBcIiZvY2lyY1wiOiBcIsO0XCIsXG4gICAgICBcIiZvY2lyYztcIjogXCLDtFwiLFxuICAgICAgXCImb3RpbGRlXCI6IFwiw7VcIixcbiAgICAgIFwiJm90aWxkZTtcIjogXCLDtVwiLFxuICAgICAgXCImb3VtbFwiOiBcIsO2XCIsXG4gICAgICBcIiZvdW1sO1wiOiBcIsO2XCIsXG4gICAgICBcIiZkaXZpZGVcIjogXCLDt1wiLFxuICAgICAgXCImZGl2aWRlO1wiOiBcIsO3XCIsXG4gICAgICBcIiZvc2xhc2hcIjogXCLDuFwiLFxuICAgICAgXCImb3NsYXNoO1wiOiBcIsO4XCIsXG4gICAgICBcIiZ1Z3JhdmVcIjogXCLDuVwiLFxuICAgICAgXCImdWdyYXZlO1wiOiBcIsO5XCIsXG4gICAgICBcIiZ1YWN1dGVcIjogXCLDulwiLFxuICAgICAgXCImdWFjdXRlO1wiOiBcIsO6XCIsXG4gICAgICBcIiZ1Y2lyY1wiOiBcIsO7XCIsXG4gICAgICBcIiZ1Y2lyYztcIjogXCLDu1wiLFxuICAgICAgXCImdXVtbFwiOiBcIsO8XCIsXG4gICAgICBcIiZ1dW1sO1wiOiBcIsO8XCIsXG4gICAgICBcIiZ5YWN1dGVcIjogXCLDvVwiLFxuICAgICAgXCImeWFjdXRlO1wiOiBcIsO9XCIsXG4gICAgICBcIiZ0aG9yblwiOiBcIsO+XCIsXG4gICAgICBcIiZ0aG9ybjtcIjogXCLDvlwiLFxuICAgICAgXCImeXVtbFwiOiBcIsO/XCIsXG4gICAgICBcIiZ5dW1sO1wiOiBcIsO/XCIsXG4gICAgICBcIiZxdW90XCI6ICdcIicsXG4gICAgICBcIiZxdW90O1wiOiAnXCInLFxuICAgICAgXCImYW1wXCI6IFwiJlwiLFxuICAgICAgXCImYW1wO1wiOiBcIiZcIixcbiAgICAgIFwiJmx0XCI6IFwiPFwiLFxuICAgICAgXCImbHQ7XCI6IFwiPFwiLFxuICAgICAgXCImZ3RcIjogXCI+XCIsXG4gICAgICBcIiZndDtcIjogXCI+XCIsXG4gICAgICBcIiZPRWxpZztcIjogXCLFklwiLFxuICAgICAgXCImb2VsaWc7XCI6IFwixZNcIixcbiAgICAgIFwiJlNjYXJvbjtcIjogXCLFoFwiLFxuICAgICAgXCImc2Nhcm9uO1wiOiBcIsWhXCIsXG4gICAgICBcIiZZdW1sO1wiOiBcIsW4XCIsXG4gICAgICBcIiZjaXJjO1wiOiBcIsuGXCIsXG4gICAgICBcIiZ0aWxkZTtcIjogXCLLnFwiLFxuICAgICAgXCImZW5zcDtcIjogXCLigIJcIixcbiAgICAgIFwiJmVtc3A7XCI6IFwi4oCDXCIsXG4gICAgICBcIiZ0aGluc3A7XCI6IFwi4oCJXCIsXG4gICAgICBcIiZ6d25qO1wiOiBcIuKAjFwiLFxuICAgICAgXCImendqO1wiOiBcIuKAjVwiLFxuICAgICAgXCImbHJtO1wiOiBcIuKAjlwiLFxuICAgICAgXCImcmxtO1wiOiBcIuKAj1wiLFxuICAgICAgXCImbmRhc2g7XCI6IFwi4oCTXCIsXG4gICAgICBcIiZtZGFzaDtcIjogXCLigJRcIixcbiAgICAgIFwiJmxzcXVvO1wiOiBcIuKAmFwiLFxuICAgICAgXCImcnNxdW87XCI6IFwi4oCZXCIsXG4gICAgICBcIiZzYnF1bztcIjogXCLigJpcIixcbiAgICAgIFwiJmxkcXVvO1wiOiBcIuKAnFwiLFxuICAgICAgXCImcmRxdW87XCI6IFwi4oCdXCIsXG4gICAgICBcIiZiZHF1bztcIjogXCLigJ5cIixcbiAgICAgIFwiJmRhZ2dlcjtcIjogXCLigKBcIixcbiAgICAgIFwiJkRhZ2dlcjtcIjogXCLigKFcIixcbiAgICAgIFwiJnBlcm1pbDtcIjogXCLigLBcIixcbiAgICAgIFwiJmxzYXF1bztcIjogXCLigLlcIixcbiAgICAgIFwiJnJzYXF1bztcIjogXCLigLpcIixcbiAgICAgIFwiJmV1cm87XCI6IFwi4oKsXCIsXG4gICAgICBcIiZmbm9mO1wiOiBcIsaSXCIsXG4gICAgICBcIiZBbHBoYTtcIjogXCLOkVwiLFxuICAgICAgXCImQmV0YTtcIjogXCLOklwiLFxuICAgICAgXCImR2FtbWE7XCI6IFwizpNcIixcbiAgICAgIFwiJkRlbHRhO1wiOiBcIs6UXCIsXG4gICAgICBcIiZFcHNpbG9uO1wiOiBcIs6VXCIsXG4gICAgICBcIiZaZXRhO1wiOiBcIs6WXCIsXG4gICAgICBcIiZFdGE7XCI6IFwizpdcIixcbiAgICAgIFwiJlRoZXRhO1wiOiBcIs6YXCIsXG4gICAgICBcIiZJb3RhO1wiOiBcIs6ZXCIsXG4gICAgICBcIiZLYXBwYTtcIjogXCLOmlwiLFxuICAgICAgXCImTGFtYmRhO1wiOiBcIs6bXCIsXG4gICAgICBcIiZNdTtcIjogXCLOnFwiLFxuICAgICAgXCImTnU7XCI6IFwizp1cIixcbiAgICAgIFwiJlhpO1wiOiBcIs6eXCIsXG4gICAgICBcIiZPbWljcm9uO1wiOiBcIs6fXCIsXG4gICAgICBcIiZQaTtcIjogXCLOoFwiLFxuICAgICAgXCImUmhvO1wiOiBcIs6hXCIsXG4gICAgICBcIiZTaWdtYTtcIjogXCLOo1wiLFxuICAgICAgXCImVGF1O1wiOiBcIs6kXCIsXG4gICAgICBcIiZVcHNpbG9uO1wiOiBcIs6lXCIsXG4gICAgICBcIiZQaGk7XCI6IFwizqZcIixcbiAgICAgIFwiJkNoaTtcIjogXCLOp1wiLFxuICAgICAgXCImUHNpO1wiOiBcIs6oXCIsXG4gICAgICBcIiZPbWVnYTtcIjogXCLOqVwiLFxuICAgICAgXCImYWxwaGE7XCI6IFwizrFcIixcbiAgICAgIFwiJmJldGE7XCI6IFwizrJcIixcbiAgICAgIFwiJmdhbW1hO1wiOiBcIs6zXCIsXG4gICAgICBcIiZkZWx0YTtcIjogXCLOtFwiLFxuICAgICAgXCImZXBzaWxvbjtcIjogXCLOtVwiLFxuICAgICAgXCImemV0YTtcIjogXCLOtlwiLFxuICAgICAgXCImZXRhO1wiOiBcIs63XCIsXG4gICAgICBcIiZ0aGV0YTtcIjogXCLOuFwiLFxuICAgICAgXCImaW90YTtcIjogXCLOuVwiLFxuICAgICAgXCIma2FwcGE7XCI6IFwizrpcIixcbiAgICAgIFwiJmxhbWJkYTtcIjogXCLOu1wiLFxuICAgICAgXCImbXU7XCI6IFwizrxcIixcbiAgICAgIFwiJm51O1wiOiBcIs69XCIsXG4gICAgICBcIiZ4aTtcIjogXCLOvlwiLFxuICAgICAgXCImb21pY3JvbjtcIjogXCLOv1wiLFxuICAgICAgXCImcGk7XCI6IFwiz4BcIixcbiAgICAgIFwiJnJobztcIjogXCLPgVwiLFxuICAgICAgXCImc2lnbWFmO1wiOiBcIs+CXCIsXG4gICAgICBcIiZzaWdtYTtcIjogXCLPg1wiLFxuICAgICAgXCImdGF1O1wiOiBcIs+EXCIsXG4gICAgICBcIiZ1cHNpbG9uO1wiOiBcIs+FXCIsXG4gICAgICBcIiZwaGk7XCI6IFwiz4ZcIixcbiAgICAgIFwiJmNoaTtcIjogXCLPh1wiLFxuICAgICAgXCImcHNpO1wiOiBcIs+IXCIsXG4gICAgICBcIiZvbWVnYTtcIjogXCLPiVwiLFxuICAgICAgXCImdGhldGFzeW07XCI6IFwiz5FcIixcbiAgICAgIFwiJnVwc2loO1wiOiBcIs+SXCIsXG4gICAgICBcIiZwaXY7XCI6IFwiz5ZcIixcbiAgICAgIFwiJmJ1bGw7XCI6IFwi4oCiXCIsXG4gICAgICBcIiZoZWxsaXA7XCI6IFwi4oCmXCIsXG4gICAgICBcIiZwcmltZTtcIjogXCLigLJcIixcbiAgICAgIFwiJlByaW1lO1wiOiBcIuKAs1wiLFxuICAgICAgXCImb2xpbmU7XCI6IFwi4oC+XCIsXG4gICAgICBcIiZmcmFzbDtcIjogXCLigYRcIixcbiAgICAgIFwiJndlaWVycDtcIjogXCLihJhcIixcbiAgICAgIFwiJmltYWdlO1wiOiBcIuKEkVwiLFxuICAgICAgXCImcmVhbDtcIjogXCLihJxcIixcbiAgICAgIFwiJnRyYWRlO1wiOiBcIuKEolwiLFxuICAgICAgXCImYWxlZnN5bTtcIjogXCLihLVcIixcbiAgICAgIFwiJmxhcnI7XCI6IFwi4oaQXCIsXG4gICAgICBcIiZ1YXJyO1wiOiBcIuKGkVwiLFxuICAgICAgXCImcmFycjtcIjogXCLihpJcIixcbiAgICAgIFwiJmRhcnI7XCI6IFwi4oaTXCIsXG4gICAgICBcIiZoYXJyO1wiOiBcIuKGlFwiLFxuICAgICAgXCImY3JhcnI7XCI6IFwi4oa1XCIsXG4gICAgICBcIiZsQXJyO1wiOiBcIuKHkFwiLFxuICAgICAgXCImdUFycjtcIjogXCLih5FcIixcbiAgICAgIFwiJnJBcnI7XCI6IFwi4oeSXCIsXG4gICAgICBcIiZkQXJyO1wiOiBcIuKHk1wiLFxuICAgICAgXCImaEFycjtcIjogXCLih5RcIixcbiAgICAgIFwiJmZvcmFsbDtcIjogXCLiiIBcIixcbiAgICAgIFwiJnBhcnQ7XCI6IFwi4oiCXCIsXG4gICAgICBcIiZleGlzdDtcIjogXCLiiINcIixcbiAgICAgIFwiJmVtcHR5O1wiOiBcIuKIhVwiLFxuICAgICAgXCImbmFibGE7XCI6IFwi4oiHXCIsXG4gICAgICBcIiZpc2luO1wiOiBcIuKIiFwiLFxuICAgICAgXCImbm90aW47XCI6IFwi4oiJXCIsXG4gICAgICBcIiZuaTtcIjogXCLiiItcIixcbiAgICAgIFwiJnByb2Q7XCI6IFwi4oiPXCIsXG4gICAgICBcIiZzdW07XCI6IFwi4oiRXCIsXG4gICAgICBcIiZtaW51cztcIjogXCLiiJJcIixcbiAgICAgIFwiJmxvd2FzdDtcIjogXCLiiJdcIixcbiAgICAgIFwiJnJhZGljO1wiOiBcIuKImlwiLFxuICAgICAgXCImcHJvcDtcIjogXCLiiJ1cIixcbiAgICAgIFwiJmluZmluO1wiOiBcIuKInlwiLFxuICAgICAgXCImYW5nO1wiOiBcIuKIoFwiLFxuICAgICAgXCImYW5kO1wiOiBcIuKIp1wiLFxuICAgICAgXCImb3I7XCI6IFwi4oioXCIsXG4gICAgICBcIiZjYXA7XCI6IFwi4oipXCIsXG4gICAgICBcIiZjdXA7XCI6IFwi4oiqXCIsXG4gICAgICBcIiZpbnQ7XCI6IFwi4oirXCIsXG4gICAgICBcIiZ0aGVyZTQ7XCI6IFwi4oi0XCIsXG4gICAgICBcIiZzaW07XCI6IFwi4oi8XCIsXG4gICAgICBcIiZjb25nO1wiOiBcIuKJhVwiLFxuICAgICAgXCImYXN5bXA7XCI6IFwi4omIXCIsXG4gICAgICBcIiZuZTtcIjogXCLiiaBcIixcbiAgICAgIFwiJmVxdWl2O1wiOiBcIuKJoVwiLFxuICAgICAgXCImbGU7XCI6IFwi4omkXCIsXG4gICAgICBcIiZnZTtcIjogXCLiiaVcIixcbiAgICAgIFwiJnN1YjtcIjogXCLiioJcIixcbiAgICAgIFwiJnN1cDtcIjogXCLiioNcIixcbiAgICAgIFwiJm5zdWI7XCI6IFwi4oqEXCIsXG4gICAgICBcIiZzdWJlO1wiOiBcIuKKhlwiLFxuICAgICAgXCImc3VwZTtcIjogXCLiiodcIixcbiAgICAgIFwiJm9wbHVzO1wiOiBcIuKKlVwiLFxuICAgICAgXCImb3RpbWVzO1wiOiBcIuKKl1wiLFxuICAgICAgXCImcGVycDtcIjogXCLiiqVcIixcbiAgICAgIFwiJnNkb3Q7XCI6IFwi4ouFXCIsXG4gICAgICBcIiZsY2VpbDtcIjogXCLijIhcIixcbiAgICAgIFwiJnJjZWlsO1wiOiBcIuKMiVwiLFxuICAgICAgXCImbGZsb29yO1wiOiBcIuKMilwiLFxuICAgICAgXCImcmZsb29yO1wiOiBcIuKMi1wiLFxuICAgICAgXCImbGFuZztcIjogXCLijKlcIixcbiAgICAgIFwiJnJhbmc7XCI6IFwi4oyqXCIsXG4gICAgICBcIiZsb3o7XCI6IFwi4peKXCIsXG4gICAgICBcIiZzcGFkZXM7XCI6IFwi4pmgXCIsXG4gICAgICBcIiZjbHVicztcIjogXCLimaNcIixcbiAgICAgIFwiJmhlYXJ0cztcIjogXCLimaVcIixcbiAgICAgIFwiJmRpYW1zO1wiOiBcIuKZplwiXG4gICAgfSxcbiAgICBjaGFyYWN0ZXJzOiB7XG4gICAgICBcIidcIjogXCImYXBvcztcIixcbiAgICAgIFwiwqBcIjogXCImbmJzcDtcIixcbiAgICAgIFwiwqFcIjogXCImaWV4Y2w7XCIsXG4gICAgICBcIsKiXCI6IFwiJmNlbnQ7XCIsXG4gICAgICBcIsKjXCI6IFwiJnBvdW5kO1wiLFxuICAgICAgXCLCpFwiOiBcIiZjdXJyZW47XCIsXG4gICAgICBcIsKlXCI6IFwiJnllbjtcIixcbiAgICAgIFwiwqZcIjogXCImYnJ2YmFyO1wiLFxuICAgICAgXCLCp1wiOiBcIiZzZWN0O1wiLFxuICAgICAgXCLCqFwiOiBcIiZ1bWw7XCIsXG4gICAgICBcIsKpXCI6IFwiJmNvcHk7XCIsXG4gICAgICBcIsKqXCI6IFwiJm9yZGY7XCIsXG4gICAgICBcIsKrXCI6IFwiJmxhcXVvO1wiLFxuICAgICAgXCLCrFwiOiBcIiZub3Q7XCIsXG4gICAgICBcIsKtXCI6IFwiJnNoeTtcIixcbiAgICAgIFwiwq5cIjogXCImcmVnO1wiLFxuICAgICAgXCLCr1wiOiBcIiZtYWNyO1wiLFxuICAgICAgXCLCsFwiOiBcIiZkZWc7XCIsXG4gICAgICBcIsKxXCI6IFwiJnBsdXNtbjtcIixcbiAgICAgIFwiwrJcIjogXCImc3VwMjtcIixcbiAgICAgIFwiwrNcIjogXCImc3VwMztcIixcbiAgICAgIFwiwrRcIjogXCImYWN1dGU7XCIsXG4gICAgICBcIsK1XCI6IFwiJm1pY3JvO1wiLFxuICAgICAgXCLCtlwiOiBcIiZwYXJhO1wiLFxuICAgICAgXCLCt1wiOiBcIiZtaWRkb3Q7XCIsXG4gICAgICBcIsK4XCI6IFwiJmNlZGlsO1wiLFxuICAgICAgXCLCuVwiOiBcIiZzdXAxO1wiLFxuICAgICAgXCLCulwiOiBcIiZvcmRtO1wiLFxuICAgICAgXCLCu1wiOiBcIiZyYXF1bztcIixcbiAgICAgIFwiwrxcIjogXCImZnJhYzE0O1wiLFxuICAgICAgXCLCvVwiOiBcIiZmcmFjMTI7XCIsXG4gICAgICBcIsK+XCI6IFwiJmZyYWMzNDtcIixcbiAgICAgIFwiwr9cIjogXCImaXF1ZXN0O1wiLFxuICAgICAgXCLDgFwiOiBcIiZBZ3JhdmU7XCIsXG4gICAgICBcIsOBXCI6IFwiJkFhY3V0ZTtcIixcbiAgICAgIFwiw4JcIjogXCImQWNpcmM7XCIsXG4gICAgICBcIsODXCI6IFwiJkF0aWxkZTtcIixcbiAgICAgIFwiw4RcIjogXCImQXVtbDtcIixcbiAgICAgIFwiw4VcIjogXCImQXJpbmc7XCIsXG4gICAgICBcIsOGXCI6IFwiJkFFbGlnO1wiLFxuICAgICAgXCLDh1wiOiBcIiZDY2VkaWw7XCIsXG4gICAgICBcIsOIXCI6IFwiJkVncmF2ZTtcIixcbiAgICAgIFwiw4lcIjogXCImRWFjdXRlO1wiLFxuICAgICAgXCLDilwiOiBcIiZFY2lyYztcIixcbiAgICAgIFwiw4tcIjogXCImRXVtbDtcIixcbiAgICAgIFwiw4xcIjogXCImSWdyYXZlO1wiLFxuICAgICAgXCLDjVwiOiBcIiZJYWN1dGU7XCIsXG4gICAgICBcIsOOXCI6IFwiJkljaXJjO1wiLFxuICAgICAgXCLDj1wiOiBcIiZJdW1sO1wiLFxuICAgICAgXCLDkFwiOiBcIiZFVEg7XCIsXG4gICAgICBcIsORXCI6IFwiJk50aWxkZTtcIixcbiAgICAgIFwiw5JcIjogXCImT2dyYXZlO1wiLFxuICAgICAgXCLDk1wiOiBcIiZPYWN1dGU7XCIsXG4gICAgICBcIsOUXCI6IFwiJk9jaXJjO1wiLFxuICAgICAgXCLDlVwiOiBcIiZPdGlsZGU7XCIsXG4gICAgICBcIsOWXCI6IFwiJk91bWw7XCIsXG4gICAgICBcIsOXXCI6IFwiJnRpbWVzO1wiLFxuICAgICAgXCLDmFwiOiBcIiZPc2xhc2g7XCIsXG4gICAgICBcIsOZXCI6IFwiJlVncmF2ZTtcIixcbiAgICAgIFwiw5pcIjogXCImVWFjdXRlO1wiLFxuICAgICAgXCLDm1wiOiBcIiZVY2lyYztcIixcbiAgICAgIFwiw5xcIjogXCImVXVtbDtcIixcbiAgICAgIFwiw51cIjogXCImWWFjdXRlO1wiLFxuICAgICAgXCLDnlwiOiBcIiZUSE9STjtcIixcbiAgICAgIFwiw59cIjogXCImc3psaWc7XCIsXG4gICAgICBcIsOgXCI6IFwiJmFncmF2ZTtcIixcbiAgICAgIFwiw6FcIjogXCImYWFjdXRlO1wiLFxuICAgICAgXCLDolwiOiBcIiZhY2lyYztcIixcbiAgICAgIFwiw6NcIjogXCImYXRpbGRlO1wiLFxuICAgICAgXCLDpFwiOiBcIiZhdW1sO1wiLFxuICAgICAgXCLDpVwiOiBcIiZhcmluZztcIixcbiAgICAgIFwiw6ZcIjogXCImYWVsaWc7XCIsXG4gICAgICBcIsOnXCI6IFwiJmNjZWRpbDtcIixcbiAgICAgIFwiw6hcIjogXCImZWdyYXZlO1wiLFxuICAgICAgXCLDqVwiOiBcIiZlYWN1dGU7XCIsXG4gICAgICBcIsOqXCI6IFwiJmVjaXJjO1wiLFxuICAgICAgXCLDq1wiOiBcIiZldW1sO1wiLFxuICAgICAgXCLDrFwiOiBcIiZpZ3JhdmU7XCIsXG4gICAgICBcIsOtXCI6IFwiJmlhY3V0ZTtcIixcbiAgICAgIFwiw65cIjogXCImaWNpcmM7XCIsXG4gICAgICBcIsOvXCI6IFwiJml1bWw7XCIsXG4gICAgICBcIsOwXCI6IFwiJmV0aDtcIixcbiAgICAgIFwiw7FcIjogXCImbnRpbGRlO1wiLFxuICAgICAgXCLDslwiOiBcIiZvZ3JhdmU7XCIsXG4gICAgICBcIsOzXCI6IFwiJm9hY3V0ZTtcIixcbiAgICAgIFwiw7RcIjogXCImb2NpcmM7XCIsXG4gICAgICBcIsO1XCI6IFwiJm90aWxkZTtcIixcbiAgICAgIFwiw7ZcIjogXCImb3VtbDtcIixcbiAgICAgIFwiw7dcIjogXCImZGl2aWRlO1wiLFxuICAgICAgXCLDuFwiOiBcIiZvc2xhc2g7XCIsXG4gICAgICBcIsO5XCI6IFwiJnVncmF2ZTtcIixcbiAgICAgIFwiw7pcIjogXCImdWFjdXRlO1wiLFxuICAgICAgXCLDu1wiOiBcIiZ1Y2lyYztcIixcbiAgICAgIFwiw7xcIjogXCImdXVtbDtcIixcbiAgICAgIFwiw71cIjogXCImeWFjdXRlO1wiLFxuICAgICAgXCLDvlwiOiBcIiZ0aG9ybjtcIixcbiAgICAgIFwiw79cIjogXCImeXVtbDtcIixcbiAgICAgICdcIic6IFwiJnF1b3Q7XCIsXG4gICAgICBcIiZcIjogXCImYW1wO1wiLFxuICAgICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgICAgXCI+XCI6IFwiJmd0O1wiLFxuICAgICAgXCLFklwiOiBcIiZPRWxpZztcIixcbiAgICAgIFwixZNcIjogXCImb2VsaWc7XCIsXG4gICAgICBcIsWgXCI6IFwiJlNjYXJvbjtcIixcbiAgICAgIFwixaFcIjogXCImc2Nhcm9uO1wiLFxuICAgICAgXCLFuFwiOiBcIiZZdW1sO1wiLFxuICAgICAgXCLLhlwiOiBcIiZjaXJjO1wiLFxuICAgICAgXCLLnFwiOiBcIiZ0aWxkZTtcIixcbiAgICAgIFwi4oCCXCI6IFwiJmVuc3A7XCIsXG4gICAgICBcIuKAg1wiOiBcIiZlbXNwO1wiLFxuICAgICAgXCLigIlcIjogXCImdGhpbnNwO1wiLFxuICAgICAgXCLigIxcIjogXCImenduajtcIixcbiAgICAgIFwi4oCNXCI6IFwiJnp3ajtcIixcbiAgICAgIFwi4oCOXCI6IFwiJmxybTtcIixcbiAgICAgIFwi4oCPXCI6IFwiJnJsbTtcIixcbiAgICAgIFwi4oCTXCI6IFwiJm5kYXNoO1wiLFxuICAgICAgXCLigJRcIjogXCImbWRhc2g7XCIsXG4gICAgICBcIuKAmFwiOiBcIiZsc3F1bztcIixcbiAgICAgIFwi4oCZXCI6IFwiJnJzcXVvO1wiLFxuICAgICAgXCLigJpcIjogXCImc2JxdW87XCIsXG4gICAgICBcIuKAnFwiOiBcIiZsZHF1bztcIixcbiAgICAgIFwi4oCdXCI6IFwiJnJkcXVvO1wiLFxuICAgICAgXCLigJ5cIjogXCImYmRxdW87XCIsXG4gICAgICBcIuKAoFwiOiBcIiZkYWdnZXI7XCIsXG4gICAgICBcIuKAoVwiOiBcIiZEYWdnZXI7XCIsXG4gICAgICBcIuKAsFwiOiBcIiZwZXJtaWw7XCIsXG4gICAgICBcIuKAuVwiOiBcIiZsc2FxdW87XCIsXG4gICAgICBcIuKAulwiOiBcIiZyc2FxdW87XCIsXG4gICAgICBcIuKCrFwiOiBcIiZldXJvO1wiLFxuICAgICAgXCLGklwiOiBcIiZmbm9mO1wiLFxuICAgICAgXCLOkVwiOiBcIiZBbHBoYTtcIixcbiAgICAgIFwizpJcIjogXCImQmV0YTtcIixcbiAgICAgIFwizpNcIjogXCImR2FtbWE7XCIsXG4gICAgICBcIs6UXCI6IFwiJkRlbHRhO1wiLFxuICAgICAgXCLOlVwiOiBcIiZFcHNpbG9uO1wiLFxuICAgICAgXCLOllwiOiBcIiZaZXRhO1wiLFxuICAgICAgXCLOl1wiOiBcIiZFdGE7XCIsXG4gICAgICBcIs6YXCI6IFwiJlRoZXRhO1wiLFxuICAgICAgXCLOmVwiOiBcIiZJb3RhO1wiLFxuICAgICAgXCLOmlwiOiBcIiZLYXBwYTtcIixcbiAgICAgIFwizptcIjogXCImTGFtYmRhO1wiLFxuICAgICAgXCLOnFwiOiBcIiZNdTtcIixcbiAgICAgIFwizp1cIjogXCImTnU7XCIsXG4gICAgICBcIs6eXCI6IFwiJlhpO1wiLFxuICAgICAgXCLOn1wiOiBcIiZPbWljcm9uO1wiLFxuICAgICAgXCLOoFwiOiBcIiZQaTtcIixcbiAgICAgIFwizqFcIjogXCImUmhvO1wiLFxuICAgICAgXCLOo1wiOiBcIiZTaWdtYTtcIixcbiAgICAgIFwizqRcIjogXCImVGF1O1wiLFxuICAgICAgXCLOpVwiOiBcIiZVcHNpbG9uO1wiLFxuICAgICAgXCLOplwiOiBcIiZQaGk7XCIsXG4gICAgICBcIs6nXCI6IFwiJkNoaTtcIixcbiAgICAgIFwizqhcIjogXCImUHNpO1wiLFxuICAgICAgXCLOqVwiOiBcIiZPbWVnYTtcIixcbiAgICAgIFwizrFcIjogXCImYWxwaGE7XCIsXG4gICAgICBcIs6yXCI6IFwiJmJldGE7XCIsXG4gICAgICBcIs6zXCI6IFwiJmdhbW1hO1wiLFxuICAgICAgXCLOtFwiOiBcIiZkZWx0YTtcIixcbiAgICAgIFwizrVcIjogXCImZXBzaWxvbjtcIixcbiAgICAgIFwizrZcIjogXCImemV0YTtcIixcbiAgICAgIFwizrdcIjogXCImZXRhO1wiLFxuICAgICAgXCLOuFwiOiBcIiZ0aGV0YTtcIixcbiAgICAgIFwizrlcIjogXCImaW90YTtcIixcbiAgICAgIFwizrpcIjogXCIma2FwcGE7XCIsXG4gICAgICBcIs67XCI6IFwiJmxhbWJkYTtcIixcbiAgICAgIFwizrxcIjogXCImbXU7XCIsXG4gICAgICBcIs69XCI6IFwiJm51O1wiLFxuICAgICAgXCLOvlwiOiBcIiZ4aTtcIixcbiAgICAgIFwizr9cIjogXCImb21pY3JvbjtcIixcbiAgICAgIFwiz4BcIjogXCImcGk7XCIsXG4gICAgICBcIs+BXCI6IFwiJnJobztcIixcbiAgICAgIFwiz4JcIjogXCImc2lnbWFmO1wiLFxuICAgICAgXCLPg1wiOiBcIiZzaWdtYTtcIixcbiAgICAgIFwiz4RcIjogXCImdGF1O1wiLFxuICAgICAgXCLPhVwiOiBcIiZ1cHNpbG9uO1wiLFxuICAgICAgXCLPhlwiOiBcIiZwaGk7XCIsXG4gICAgICBcIs+HXCI6IFwiJmNoaTtcIixcbiAgICAgIFwiz4hcIjogXCImcHNpO1wiLFxuICAgICAgXCLPiVwiOiBcIiZvbWVnYTtcIixcbiAgICAgIFwiz5FcIjogXCImdGhldGFzeW07XCIsXG4gICAgICBcIs+SXCI6IFwiJnVwc2loO1wiLFxuICAgICAgXCLPllwiOiBcIiZwaXY7XCIsXG4gICAgICBcIuKAolwiOiBcIiZidWxsO1wiLFxuICAgICAgXCLigKZcIjogXCImaGVsbGlwO1wiLFxuICAgICAgXCLigLJcIjogXCImcHJpbWU7XCIsXG4gICAgICBcIuKAs1wiOiBcIiZQcmltZTtcIixcbiAgICAgIFwi4oC+XCI6IFwiJm9saW5lO1wiLFxuICAgICAgXCLigYRcIjogXCImZnJhc2w7XCIsXG4gICAgICBcIuKEmFwiOiBcIiZ3ZWllcnA7XCIsXG4gICAgICBcIuKEkVwiOiBcIiZpbWFnZTtcIixcbiAgICAgIFwi4oScXCI6IFwiJnJlYWw7XCIsXG4gICAgICBcIuKEolwiOiBcIiZ0cmFkZTtcIixcbiAgICAgIFwi4oS1XCI6IFwiJmFsZWZzeW07XCIsXG4gICAgICBcIuKGkFwiOiBcIiZsYXJyO1wiLFxuICAgICAgXCLihpFcIjogXCImdWFycjtcIixcbiAgICAgIFwi4oaSXCI6IFwiJnJhcnI7XCIsXG4gICAgICBcIuKGk1wiOiBcIiZkYXJyO1wiLFxuICAgICAgXCLihpRcIjogXCImaGFycjtcIixcbiAgICAgIFwi4oa1XCI6IFwiJmNyYXJyO1wiLFxuICAgICAgXCLih5BcIjogXCImbEFycjtcIixcbiAgICAgIFwi4oeRXCI6IFwiJnVBcnI7XCIsXG4gICAgICBcIuKHklwiOiBcIiZyQXJyO1wiLFxuICAgICAgXCLih5NcIjogXCImZEFycjtcIixcbiAgICAgIFwi4oeUXCI6IFwiJmhBcnI7XCIsXG4gICAgICBcIuKIgFwiOiBcIiZmb3JhbGw7XCIsXG4gICAgICBcIuKIglwiOiBcIiZwYXJ0O1wiLFxuICAgICAgXCLiiINcIjogXCImZXhpc3Q7XCIsXG4gICAgICBcIuKIhVwiOiBcIiZlbXB0eTtcIixcbiAgICAgIFwi4oiHXCI6IFwiJm5hYmxhO1wiLFxuICAgICAgXCLiiIhcIjogXCImaXNpbjtcIixcbiAgICAgIFwi4oiJXCI6IFwiJm5vdGluO1wiLFxuICAgICAgXCLiiItcIjogXCImbmk7XCIsXG4gICAgICBcIuKIj1wiOiBcIiZwcm9kO1wiLFxuICAgICAgXCLiiJFcIjogXCImc3VtO1wiLFxuICAgICAgXCLiiJJcIjogXCImbWludXM7XCIsXG4gICAgICBcIuKIl1wiOiBcIiZsb3dhc3Q7XCIsXG4gICAgICBcIuKImlwiOiBcIiZyYWRpYztcIixcbiAgICAgIFwi4oidXCI6IFwiJnByb3A7XCIsXG4gICAgICBcIuKInlwiOiBcIiZpbmZpbjtcIixcbiAgICAgIFwi4oigXCI6IFwiJmFuZztcIixcbiAgICAgIFwi4oinXCI6IFwiJmFuZDtcIixcbiAgICAgIFwi4oioXCI6IFwiJm9yO1wiLFxuICAgICAgXCLiiKlcIjogXCImY2FwO1wiLFxuICAgICAgXCLiiKpcIjogXCImY3VwO1wiLFxuICAgICAgXCLiiKtcIjogXCImaW50O1wiLFxuICAgICAgXCLiiLRcIjogXCImdGhlcmU0O1wiLFxuICAgICAgXCLiiLxcIjogXCImc2ltO1wiLFxuICAgICAgXCLiiYVcIjogXCImY29uZztcIixcbiAgICAgIFwi4omIXCI6IFwiJmFzeW1wO1wiLFxuICAgICAgXCLiiaBcIjogXCImbmU7XCIsXG4gICAgICBcIuKJoVwiOiBcIiZlcXVpdjtcIixcbiAgICAgIFwi4omkXCI6IFwiJmxlO1wiLFxuICAgICAgXCLiiaVcIjogXCImZ2U7XCIsXG4gICAgICBcIuKKglwiOiBcIiZzdWI7XCIsXG4gICAgICBcIuKKg1wiOiBcIiZzdXA7XCIsXG4gICAgICBcIuKKhFwiOiBcIiZuc3ViO1wiLFxuICAgICAgXCLiioZcIjogXCImc3ViZTtcIixcbiAgICAgIFwi4oqHXCI6IFwiJnN1cGU7XCIsXG4gICAgICBcIuKKlVwiOiBcIiZvcGx1cztcIixcbiAgICAgIFwi4oqXXCI6IFwiJm90aW1lcztcIixcbiAgICAgIFwi4oqlXCI6IFwiJnBlcnA7XCIsXG4gICAgICBcIuKLhVwiOiBcIiZzZG90O1wiLFxuICAgICAgXCLijIhcIjogXCImbGNlaWw7XCIsXG4gICAgICBcIuKMiVwiOiBcIiZyY2VpbDtcIixcbiAgICAgIFwi4oyKXCI6IFwiJmxmbG9vcjtcIixcbiAgICAgIFwi4oyLXCI6IFwiJnJmbG9vcjtcIixcbiAgICAgIFwi4oypXCI6IFwiJmxhbmc7XCIsXG4gICAgICBcIuKMqlwiOiBcIiZyYW5nO1wiLFxuICAgICAgXCLil4pcIjogXCImbG96O1wiLFxuICAgICAgXCLimaBcIjogXCImc3BhZGVzO1wiLFxuICAgICAgXCLimaNcIjogXCImY2x1YnM7XCIsXG4gICAgICBcIuKZpVwiOiBcIiZoZWFydHM7XCIsXG4gICAgICBcIuKZplwiOiBcIiZkaWFtcztcIlxuICAgIH1cbiAgfSxcbiAgaHRtbDU6IHtcbiAgICBlbnRpdGllczoge1xuICAgICAgXCImQUVsaWdcIjogXCLDhlwiLFxuICAgICAgXCImQUVsaWc7XCI6IFwiw4ZcIixcbiAgICAgIFwiJkFNUFwiOiBcIiZcIixcbiAgICAgIFwiJkFNUDtcIjogXCImXCIsXG4gICAgICBcIiZBYWN1dGVcIjogXCLDgVwiLFxuICAgICAgXCImQWFjdXRlO1wiOiBcIsOBXCIsXG4gICAgICBcIiZBYnJldmU7XCI6IFwixIJcIixcbiAgICAgIFwiJkFjaXJjXCI6IFwiw4JcIixcbiAgICAgIFwiJkFjaXJjO1wiOiBcIsOCXCIsXG4gICAgICBcIiZBY3k7XCI6IFwi0JBcIixcbiAgICAgIFwiJkFmcjtcIjogXCLwnZSEXCIsXG4gICAgICBcIiZBZ3JhdmVcIjogXCLDgFwiLFxuICAgICAgXCImQWdyYXZlO1wiOiBcIsOAXCIsXG4gICAgICBcIiZBbHBoYTtcIjogXCLOkVwiLFxuICAgICAgXCImQW1hY3I7XCI6IFwixIBcIixcbiAgICAgIFwiJkFuZDtcIjogXCLiqZNcIixcbiAgICAgIFwiJkFvZ29uO1wiOiBcIsSEXCIsXG4gICAgICBcIiZBb3BmO1wiOiBcIvCdlLhcIixcbiAgICAgIFwiJkFwcGx5RnVuY3Rpb247XCI6IFwi4oGhXCIsXG4gICAgICBcIiZBcmluZ1wiOiBcIsOFXCIsXG4gICAgICBcIiZBcmluZztcIjogXCLDhVwiLFxuICAgICAgXCImQXNjcjtcIjogXCLwnZKcXCIsXG4gICAgICBcIiZBc3NpZ247XCI6IFwi4omUXCIsXG4gICAgICBcIiZBdGlsZGVcIjogXCLDg1wiLFxuICAgICAgXCImQXRpbGRlO1wiOiBcIsODXCIsXG4gICAgICBcIiZBdW1sXCI6IFwiw4RcIixcbiAgICAgIFwiJkF1bWw7XCI6IFwiw4RcIixcbiAgICAgIFwiJkJhY2tzbGFzaDtcIjogXCLiiJZcIixcbiAgICAgIFwiJkJhcnY7XCI6IFwi4qunXCIsXG4gICAgICBcIiZCYXJ3ZWQ7XCI6IFwi4oyGXCIsXG4gICAgICBcIiZCY3k7XCI6IFwi0JFcIixcbiAgICAgIFwiJkJlY2F1c2U7XCI6IFwi4oi1XCIsXG4gICAgICBcIiZCZXJub3VsbGlzO1wiOiBcIuKErFwiLFxuICAgICAgXCImQmV0YTtcIjogXCLOklwiLFxuICAgICAgXCImQmZyO1wiOiBcIvCdlIVcIixcbiAgICAgIFwiJkJvcGY7XCI6IFwi8J2UuVwiLFxuICAgICAgXCImQnJldmU7XCI6IFwiy5hcIixcbiAgICAgIFwiJkJzY3I7XCI6IFwi4oSsXCIsXG4gICAgICBcIiZCdW1wZXE7XCI6IFwi4omOXCIsXG4gICAgICBcIiZDSGN5O1wiOiBcItCnXCIsXG4gICAgICBcIiZDT1BZXCI6IFwiwqlcIixcbiAgICAgIFwiJkNPUFk7XCI6IFwiwqlcIixcbiAgICAgIFwiJkNhY3V0ZTtcIjogXCLEhlwiLFxuICAgICAgXCImQ2FwO1wiOiBcIuKLklwiLFxuICAgICAgXCImQ2FwaXRhbERpZmZlcmVudGlhbEQ7XCI6IFwi4oWFXCIsXG4gICAgICBcIiZDYXlsZXlzO1wiOiBcIuKErVwiLFxuICAgICAgXCImQ2Nhcm9uO1wiOiBcIsSMXCIsXG4gICAgICBcIiZDY2VkaWxcIjogXCLDh1wiLFxuICAgICAgXCImQ2NlZGlsO1wiOiBcIsOHXCIsXG4gICAgICBcIiZDY2lyYztcIjogXCLEiFwiLFxuICAgICAgXCImQ2NvbmludDtcIjogXCLiiLBcIixcbiAgICAgIFwiJkNkb3Q7XCI6IFwixIpcIixcbiAgICAgIFwiJkNlZGlsbGE7XCI6IFwiwrhcIixcbiAgICAgIFwiJkNlbnRlckRvdDtcIjogXCLCt1wiLFxuICAgICAgXCImQ2ZyO1wiOiBcIuKErVwiLFxuICAgICAgXCImQ2hpO1wiOiBcIs6nXCIsXG4gICAgICBcIiZDaXJjbGVEb3Q7XCI6IFwi4oqZXCIsXG4gICAgICBcIiZDaXJjbGVNaW51cztcIjogXCLiipZcIixcbiAgICAgIFwiJkNpcmNsZVBsdXM7XCI6IFwi4oqVXCIsXG4gICAgICBcIiZDaXJjbGVUaW1lcztcIjogXCLiipdcIixcbiAgICAgIFwiJkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDtcIjogXCLiiLJcIixcbiAgICAgIFwiJkNsb3NlQ3VybHlEb3VibGVRdW90ZTtcIjogXCLigJ1cIixcbiAgICAgIFwiJkNsb3NlQ3VybHlRdW90ZTtcIjogXCLigJlcIixcbiAgICAgIFwiJkNvbG9uO1wiOiBcIuKIt1wiLFxuICAgICAgXCImQ29sb25lO1wiOiBcIuKptFwiLFxuICAgICAgXCImQ29uZ3J1ZW50O1wiOiBcIuKJoVwiLFxuICAgICAgXCImQ29uaW50O1wiOiBcIuKIr1wiLFxuICAgICAgXCImQ29udG91ckludGVncmFsO1wiOiBcIuKIrlwiLFxuICAgICAgXCImQ29wZjtcIjogXCLihIJcIixcbiAgICAgIFwiJkNvcHJvZHVjdDtcIjogXCLiiJBcIixcbiAgICAgIFwiJkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWw7XCI6IFwi4oizXCIsXG4gICAgICBcIiZDcm9zcztcIjogXCLiqK9cIixcbiAgICAgIFwiJkNzY3I7XCI6IFwi8J2SnlwiLFxuICAgICAgXCImQ3VwO1wiOiBcIuKLk1wiLFxuICAgICAgXCImQ3VwQ2FwO1wiOiBcIuKJjVwiLFxuICAgICAgXCImREQ7XCI6IFwi4oWFXCIsXG4gICAgICBcIiZERG90cmFoZDtcIjogXCLipJFcIixcbiAgICAgIFwiJkRKY3k7XCI6IFwi0IJcIixcbiAgICAgIFwiJkRTY3k7XCI6IFwi0IVcIixcbiAgICAgIFwiJkRaY3k7XCI6IFwi0I9cIixcbiAgICAgIFwiJkRhZ2dlcjtcIjogXCLigKFcIixcbiAgICAgIFwiJkRhcnI7XCI6IFwi4oahXCIsXG4gICAgICBcIiZEYXNodjtcIjogXCLiq6RcIixcbiAgICAgIFwiJkRjYXJvbjtcIjogXCLEjlwiLFxuICAgICAgXCImRGN5O1wiOiBcItCUXCIsXG4gICAgICBcIiZEZWw7XCI6IFwi4oiHXCIsXG4gICAgICBcIiZEZWx0YTtcIjogXCLOlFwiLFxuICAgICAgXCImRGZyO1wiOiBcIvCdlIdcIixcbiAgICAgIFwiJkRpYWNyaXRpY2FsQWN1dGU7XCI6IFwiwrRcIixcbiAgICAgIFwiJkRpYWNyaXRpY2FsRG90O1wiOiBcIsuZXCIsXG4gICAgICBcIiZEaWFjcml0aWNhbERvdWJsZUFjdXRlO1wiOiBcIsudXCIsXG4gICAgICBcIiZEaWFjcml0aWNhbEdyYXZlO1wiOiBcImBcIixcbiAgICAgIFwiJkRpYWNyaXRpY2FsVGlsZGU7XCI6IFwiy5xcIixcbiAgICAgIFwiJkRpYW1vbmQ7XCI6IFwi4ouEXCIsXG4gICAgICBcIiZEaWZmZXJlbnRpYWxEO1wiOiBcIuKFhlwiLFxuICAgICAgXCImRG9wZjtcIjogXCLwnZS7XCIsXG4gICAgICBcIiZEb3Q7XCI6IFwiwqhcIixcbiAgICAgIFwiJkRvdERvdDtcIjogXCLig5xcIixcbiAgICAgIFwiJkRvdEVxdWFsO1wiOiBcIuKJkFwiLFxuICAgICAgXCImRG91YmxlQ29udG91ckludGVncmFsO1wiOiBcIuKIr1wiLFxuICAgICAgXCImRG91YmxlRG90O1wiOiBcIsKoXCIsXG4gICAgICBcIiZEb3VibGVEb3duQXJyb3c7XCI6IFwi4oeTXCIsXG4gICAgICBcIiZEb3VibGVMZWZ0QXJyb3c7XCI6IFwi4oeQXCIsXG4gICAgICBcIiZEb3VibGVMZWZ0UmlnaHRBcnJvdztcIjogXCLih5RcIixcbiAgICAgIFwiJkRvdWJsZUxlZnRUZWU7XCI6IFwi4qukXCIsXG4gICAgICBcIiZEb3VibGVMb25nTGVmdEFycm93O1wiOiBcIuKfuFwiLFxuICAgICAgXCImRG91YmxlTG9uZ0xlZnRSaWdodEFycm93O1wiOiBcIuKfulwiLFxuICAgICAgXCImRG91YmxlTG9uZ1JpZ2h0QXJyb3c7XCI6IFwi4p+5XCIsXG4gICAgICBcIiZEb3VibGVSaWdodEFycm93O1wiOiBcIuKHklwiLFxuICAgICAgXCImRG91YmxlUmlnaHRUZWU7XCI6IFwi4oqoXCIsXG4gICAgICBcIiZEb3VibGVVcEFycm93O1wiOiBcIuKHkVwiLFxuICAgICAgXCImRG91YmxlVXBEb3duQXJyb3c7XCI6IFwi4oeVXCIsXG4gICAgICBcIiZEb3VibGVWZXJ0aWNhbEJhcjtcIjogXCLiiKVcIixcbiAgICAgIFwiJkRvd25BcnJvdztcIjogXCLihpNcIixcbiAgICAgIFwiJkRvd25BcnJvd0JhcjtcIjogXCLipJNcIixcbiAgICAgIFwiJkRvd25BcnJvd1VwQXJyb3c7XCI6IFwi4oe1XCIsXG4gICAgICBcIiZEb3duQnJldmU7XCI6IFwizJFcIixcbiAgICAgIFwiJkRvd25MZWZ0UmlnaHRWZWN0b3I7XCI6IFwi4qWQXCIsXG4gICAgICBcIiZEb3duTGVmdFRlZVZlY3RvcjtcIjogXCLipZ5cIixcbiAgICAgIFwiJkRvd25MZWZ0VmVjdG9yO1wiOiBcIuKGvVwiLFxuICAgICAgXCImRG93bkxlZnRWZWN0b3JCYXI7XCI6IFwi4qWWXCIsXG4gICAgICBcIiZEb3duUmlnaHRUZWVWZWN0b3I7XCI6IFwi4qWfXCIsXG4gICAgICBcIiZEb3duUmlnaHRWZWN0b3I7XCI6IFwi4oeBXCIsXG4gICAgICBcIiZEb3duUmlnaHRWZWN0b3JCYXI7XCI6IFwi4qWXXCIsXG4gICAgICBcIiZEb3duVGVlO1wiOiBcIuKKpFwiLFxuICAgICAgXCImRG93blRlZUFycm93O1wiOiBcIuKGp1wiLFxuICAgICAgXCImRG93bmFycm93O1wiOiBcIuKHk1wiLFxuICAgICAgXCImRHNjcjtcIjogXCLwnZKfXCIsXG4gICAgICBcIiZEc3Ryb2s7XCI6IFwixJBcIixcbiAgICAgIFwiJkVORztcIjogXCLFilwiLFxuICAgICAgXCImRVRIXCI6IFwiw5BcIixcbiAgICAgIFwiJkVUSDtcIjogXCLDkFwiLFxuICAgICAgXCImRWFjdXRlXCI6IFwiw4lcIixcbiAgICAgIFwiJkVhY3V0ZTtcIjogXCLDiVwiLFxuICAgICAgXCImRWNhcm9uO1wiOiBcIsSaXCIsXG4gICAgICBcIiZFY2lyY1wiOiBcIsOKXCIsXG4gICAgICBcIiZFY2lyYztcIjogXCLDilwiLFxuICAgICAgXCImRWN5O1wiOiBcItCtXCIsXG4gICAgICBcIiZFZG90O1wiOiBcIsSWXCIsXG4gICAgICBcIiZFZnI7XCI6IFwi8J2UiFwiLFxuICAgICAgXCImRWdyYXZlXCI6IFwiw4hcIixcbiAgICAgIFwiJkVncmF2ZTtcIjogXCLDiFwiLFxuICAgICAgXCImRWxlbWVudDtcIjogXCLiiIhcIixcbiAgICAgIFwiJkVtYWNyO1wiOiBcIsSSXCIsXG4gICAgICBcIiZFbXB0eVNtYWxsU3F1YXJlO1wiOiBcIuKXu1wiLFxuICAgICAgXCImRW1wdHlWZXJ5U21hbGxTcXVhcmU7XCI6IFwi4parXCIsXG4gICAgICBcIiZFb2dvbjtcIjogXCLEmFwiLFxuICAgICAgXCImRW9wZjtcIjogXCLwnZS8XCIsXG4gICAgICBcIiZFcHNpbG9uO1wiOiBcIs6VXCIsXG4gICAgICBcIiZFcXVhbDtcIjogXCLiqbVcIixcbiAgICAgIFwiJkVxdWFsVGlsZGU7XCI6IFwi4omCXCIsXG4gICAgICBcIiZFcXVpbGlicml1bTtcIjogXCLih4xcIixcbiAgICAgIFwiJkVzY3I7XCI6IFwi4oSwXCIsXG4gICAgICBcIiZFc2ltO1wiOiBcIuKps1wiLFxuICAgICAgXCImRXRhO1wiOiBcIs6XXCIsXG4gICAgICBcIiZFdW1sXCI6IFwiw4tcIixcbiAgICAgIFwiJkV1bWw7XCI6IFwiw4tcIixcbiAgICAgIFwiJkV4aXN0cztcIjogXCLiiINcIixcbiAgICAgIFwiJkV4cG9uZW50aWFsRTtcIjogXCLihYdcIixcbiAgICAgIFwiJkZjeTtcIjogXCLQpFwiLFxuICAgICAgXCImRmZyO1wiOiBcIvCdlIlcIixcbiAgICAgIFwiJkZpbGxlZFNtYWxsU3F1YXJlO1wiOiBcIuKXvFwiLFxuICAgICAgXCImRmlsbGVkVmVyeVNtYWxsU3F1YXJlO1wiOiBcIuKWqlwiLFxuICAgICAgXCImRm9wZjtcIjogXCLwnZS9XCIsXG4gICAgICBcIiZGb3JBbGw7XCI6IFwi4oiAXCIsXG4gICAgICBcIiZGb3VyaWVydHJmO1wiOiBcIuKEsVwiLFxuICAgICAgXCImRnNjcjtcIjogXCLihLFcIixcbiAgICAgIFwiJkdKY3k7XCI6IFwi0INcIixcbiAgICAgIFwiJkdUXCI6IFwiPlwiLFxuICAgICAgXCImR1Q7XCI6IFwiPlwiLFxuICAgICAgXCImR2FtbWE7XCI6IFwizpNcIixcbiAgICAgIFwiJkdhbW1hZDtcIjogXCLPnFwiLFxuICAgICAgXCImR2JyZXZlO1wiOiBcIsSeXCIsXG4gICAgICBcIiZHY2VkaWw7XCI6IFwixKJcIixcbiAgICAgIFwiJkdjaXJjO1wiOiBcIsScXCIsXG4gICAgICBcIiZHY3k7XCI6IFwi0JNcIixcbiAgICAgIFwiJkdkb3Q7XCI6IFwixKBcIixcbiAgICAgIFwiJkdmcjtcIjogXCLwnZSKXCIsXG4gICAgICBcIiZHZztcIjogXCLii5lcIixcbiAgICAgIFwiJkdvcGY7XCI6IFwi8J2UvlwiLFxuICAgICAgXCImR3JlYXRlckVxdWFsO1wiOiBcIuKJpVwiLFxuICAgICAgXCImR3JlYXRlckVxdWFsTGVzcztcIjogXCLii5tcIixcbiAgICAgIFwiJkdyZWF0ZXJGdWxsRXF1YWw7XCI6IFwi4omnXCIsXG4gICAgICBcIiZHcmVhdGVyR3JlYXRlcjtcIjogXCLiqqJcIixcbiAgICAgIFwiJkdyZWF0ZXJMZXNzO1wiOiBcIuKJt1wiLFxuICAgICAgXCImR3JlYXRlclNsYW50RXF1YWw7XCI6IFwi4qm+XCIsXG4gICAgICBcIiZHcmVhdGVyVGlsZGU7XCI6IFwi4omzXCIsXG4gICAgICBcIiZHc2NyO1wiOiBcIvCdkqJcIixcbiAgICAgIFwiJkd0O1wiOiBcIuKJq1wiLFxuICAgICAgXCImSEFSRGN5O1wiOiBcItCqXCIsXG4gICAgICBcIiZIYWNlaztcIjogXCLLh1wiLFxuICAgICAgXCImSGF0O1wiOiBcIl5cIixcbiAgICAgIFwiJkhjaXJjO1wiOiBcIsSkXCIsXG4gICAgICBcIiZIZnI7XCI6IFwi4oSMXCIsXG4gICAgICBcIiZIaWxiZXJ0U3BhY2U7XCI6IFwi4oSLXCIsXG4gICAgICBcIiZIb3BmO1wiOiBcIuKEjVwiLFxuICAgICAgXCImSG9yaXpvbnRhbExpbmU7XCI6IFwi4pSAXCIsXG4gICAgICBcIiZIc2NyO1wiOiBcIuKEi1wiLFxuICAgICAgXCImSHN0cm9rO1wiOiBcIsSmXCIsXG4gICAgICBcIiZIdW1wRG93bkh1bXA7XCI6IFwi4omOXCIsXG4gICAgICBcIiZIdW1wRXF1YWw7XCI6IFwi4omPXCIsXG4gICAgICBcIiZJRWN5O1wiOiBcItCVXCIsXG4gICAgICBcIiZJSmxpZztcIjogXCLEslwiLFxuICAgICAgXCImSU9jeTtcIjogXCLQgVwiLFxuICAgICAgXCImSWFjdXRlXCI6IFwiw41cIixcbiAgICAgIFwiJklhY3V0ZTtcIjogXCLDjVwiLFxuICAgICAgXCImSWNpcmNcIjogXCLDjlwiLFxuICAgICAgXCImSWNpcmM7XCI6IFwiw45cIixcbiAgICAgIFwiJkljeTtcIjogXCLQmFwiLFxuICAgICAgXCImSWRvdDtcIjogXCLEsFwiLFxuICAgICAgXCImSWZyO1wiOiBcIuKEkVwiLFxuICAgICAgXCImSWdyYXZlXCI6IFwiw4xcIixcbiAgICAgIFwiJklncmF2ZTtcIjogXCLDjFwiLFxuICAgICAgXCImSW07XCI6IFwi4oSRXCIsXG4gICAgICBcIiZJbWFjcjtcIjogXCLEqlwiLFxuICAgICAgXCImSW1hZ2luYXJ5STtcIjogXCLihYhcIixcbiAgICAgIFwiJkltcGxpZXM7XCI6IFwi4oeSXCIsXG4gICAgICBcIiZJbnQ7XCI6IFwi4oisXCIsXG4gICAgICBcIiZJbnRlZ3JhbDtcIjogXCLiiKtcIixcbiAgICAgIFwiJkludGVyc2VjdGlvbjtcIjogXCLii4JcIixcbiAgICAgIFwiJkludmlzaWJsZUNvbW1hO1wiOiBcIuKBo1wiLFxuICAgICAgXCImSW52aXNpYmxlVGltZXM7XCI6IFwi4oGiXCIsXG4gICAgICBcIiZJb2dvbjtcIjogXCLErlwiLFxuICAgICAgXCImSW9wZjtcIjogXCLwnZWAXCIsXG4gICAgICBcIiZJb3RhO1wiOiBcIs6ZXCIsXG4gICAgICBcIiZJc2NyO1wiOiBcIuKEkFwiLFxuICAgICAgXCImSXRpbGRlO1wiOiBcIsSoXCIsXG4gICAgICBcIiZJdWtjeTtcIjogXCLQhlwiLFxuICAgICAgXCImSXVtbFwiOiBcIsOPXCIsXG4gICAgICBcIiZJdW1sO1wiOiBcIsOPXCIsXG4gICAgICBcIiZKY2lyYztcIjogXCLEtFwiLFxuICAgICAgXCImSmN5O1wiOiBcItCZXCIsXG4gICAgICBcIiZKZnI7XCI6IFwi8J2UjVwiLFxuICAgICAgXCImSm9wZjtcIjogXCLwnZWBXCIsXG4gICAgICBcIiZKc2NyO1wiOiBcIvCdkqVcIixcbiAgICAgIFwiJkpzZXJjeTtcIjogXCLQiFwiLFxuICAgICAgXCImSnVrY3k7XCI6IFwi0IRcIixcbiAgICAgIFwiJktIY3k7XCI6IFwi0KVcIixcbiAgICAgIFwiJktKY3k7XCI6IFwi0IxcIixcbiAgICAgIFwiJkthcHBhO1wiOiBcIs6aXCIsXG4gICAgICBcIiZLY2VkaWw7XCI6IFwixLZcIixcbiAgICAgIFwiJktjeTtcIjogXCLQmlwiLFxuICAgICAgXCImS2ZyO1wiOiBcIvCdlI5cIixcbiAgICAgIFwiJktvcGY7XCI6IFwi8J2VglwiLFxuICAgICAgXCImS3NjcjtcIjogXCLwnZKmXCIsXG4gICAgICBcIiZMSmN5O1wiOiBcItCJXCIsXG4gICAgICBcIiZMVFwiOiBcIjxcIixcbiAgICAgIFwiJkxUO1wiOiBcIjxcIixcbiAgICAgIFwiJkxhY3V0ZTtcIjogXCLEuVwiLFxuICAgICAgXCImTGFtYmRhO1wiOiBcIs6bXCIsXG4gICAgICBcIiZMYW5nO1wiOiBcIuKfqlwiLFxuICAgICAgXCImTGFwbGFjZXRyZjtcIjogXCLihJJcIixcbiAgICAgIFwiJkxhcnI7XCI6IFwi4oaeXCIsXG4gICAgICBcIiZMY2Fyb247XCI6IFwixL1cIixcbiAgICAgIFwiJkxjZWRpbDtcIjogXCLEu1wiLFxuICAgICAgXCImTGN5O1wiOiBcItCbXCIsXG4gICAgICBcIiZMZWZ0QW5nbGVCcmFja2V0O1wiOiBcIuKfqFwiLFxuICAgICAgXCImTGVmdEFycm93O1wiOiBcIuKGkFwiLFxuICAgICAgXCImTGVmdEFycm93QmFyO1wiOiBcIuKHpFwiLFxuICAgICAgXCImTGVmdEFycm93UmlnaHRBcnJvdztcIjogXCLih4ZcIixcbiAgICAgIFwiJkxlZnRDZWlsaW5nO1wiOiBcIuKMiFwiLFxuICAgICAgXCImTGVmdERvdWJsZUJyYWNrZXQ7XCI6IFwi4p+mXCIsXG4gICAgICBcIiZMZWZ0RG93blRlZVZlY3RvcjtcIjogXCLipaFcIixcbiAgICAgIFwiJkxlZnREb3duVmVjdG9yO1wiOiBcIuKHg1wiLFxuICAgICAgXCImTGVmdERvd25WZWN0b3JCYXI7XCI6IFwi4qWZXCIsXG4gICAgICBcIiZMZWZ0Rmxvb3I7XCI6IFwi4oyKXCIsXG4gICAgICBcIiZMZWZ0UmlnaHRBcnJvdztcIjogXCLihpRcIixcbiAgICAgIFwiJkxlZnRSaWdodFZlY3RvcjtcIjogXCLipY5cIixcbiAgICAgIFwiJkxlZnRUZWU7XCI6IFwi4oqjXCIsXG4gICAgICBcIiZMZWZ0VGVlQXJyb3c7XCI6IFwi4oakXCIsXG4gICAgICBcIiZMZWZ0VGVlVmVjdG9yO1wiOiBcIuKlmlwiLFxuICAgICAgXCImTGVmdFRyaWFuZ2xlO1wiOiBcIuKKslwiLFxuICAgICAgXCImTGVmdFRyaWFuZ2xlQmFyO1wiOiBcIuKnj1wiLFxuICAgICAgXCImTGVmdFRyaWFuZ2xlRXF1YWw7XCI6IFwi4oq0XCIsXG4gICAgICBcIiZMZWZ0VXBEb3duVmVjdG9yO1wiOiBcIuKlkVwiLFxuICAgICAgXCImTGVmdFVwVGVlVmVjdG9yO1wiOiBcIuKloFwiLFxuICAgICAgXCImTGVmdFVwVmVjdG9yO1wiOiBcIuKGv1wiLFxuICAgICAgXCImTGVmdFVwVmVjdG9yQmFyO1wiOiBcIuKlmFwiLFxuICAgICAgXCImTGVmdFZlY3RvcjtcIjogXCLihrxcIixcbiAgICAgIFwiJkxlZnRWZWN0b3JCYXI7XCI6IFwi4qWSXCIsXG4gICAgICBcIiZMZWZ0YXJyb3c7XCI6IFwi4oeQXCIsXG4gICAgICBcIiZMZWZ0cmlnaHRhcnJvdztcIjogXCLih5RcIixcbiAgICAgIFwiJkxlc3NFcXVhbEdyZWF0ZXI7XCI6IFwi4ouaXCIsXG4gICAgICBcIiZMZXNzRnVsbEVxdWFsO1wiOiBcIuKJplwiLFxuICAgICAgXCImTGVzc0dyZWF0ZXI7XCI6IFwi4om2XCIsXG4gICAgICBcIiZMZXNzTGVzcztcIjogXCLiqqFcIixcbiAgICAgIFwiJkxlc3NTbGFudEVxdWFsO1wiOiBcIuKpvVwiLFxuICAgICAgXCImTGVzc1RpbGRlO1wiOiBcIuKJslwiLFxuICAgICAgXCImTGZyO1wiOiBcIvCdlI9cIixcbiAgICAgIFwiJkxsO1wiOiBcIuKLmFwiLFxuICAgICAgXCImTGxlZnRhcnJvdztcIjogXCLih5pcIixcbiAgICAgIFwiJkxtaWRvdDtcIjogXCLEv1wiLFxuICAgICAgXCImTG9uZ0xlZnRBcnJvdztcIjogXCLin7VcIixcbiAgICAgIFwiJkxvbmdMZWZ0UmlnaHRBcnJvdztcIjogXCLin7dcIixcbiAgICAgIFwiJkxvbmdSaWdodEFycm93O1wiOiBcIuKftlwiLFxuICAgICAgXCImTG9uZ2xlZnRhcnJvdztcIjogXCLin7hcIixcbiAgICAgIFwiJkxvbmdsZWZ0cmlnaHRhcnJvdztcIjogXCLin7pcIixcbiAgICAgIFwiJkxvbmdyaWdodGFycm93O1wiOiBcIuKfuVwiLFxuICAgICAgXCImTG9wZjtcIjogXCLwnZWDXCIsXG4gICAgICBcIiZMb3dlckxlZnRBcnJvdztcIjogXCLihplcIixcbiAgICAgIFwiJkxvd2VyUmlnaHRBcnJvdztcIjogXCLihphcIixcbiAgICAgIFwiJkxzY3I7XCI6IFwi4oSSXCIsXG4gICAgICBcIiZMc2g7XCI6IFwi4oawXCIsXG4gICAgICBcIiZMc3Ryb2s7XCI6IFwixYFcIixcbiAgICAgIFwiJkx0O1wiOiBcIuKJqlwiLFxuICAgICAgXCImTWFwO1wiOiBcIuKkhVwiLFxuICAgICAgXCImTWN5O1wiOiBcItCcXCIsXG4gICAgICBcIiZNZWRpdW1TcGFjZTtcIjogXCLigZ9cIixcbiAgICAgIFwiJk1lbGxpbnRyZjtcIjogXCLihLNcIixcbiAgICAgIFwiJk1mcjtcIjogXCLwnZSQXCIsXG4gICAgICBcIiZNaW51c1BsdXM7XCI6IFwi4oiTXCIsXG4gICAgICBcIiZNb3BmO1wiOiBcIvCdlYRcIixcbiAgICAgIFwiJk1zY3I7XCI6IFwi4oSzXCIsXG4gICAgICBcIiZNdTtcIjogXCLOnFwiLFxuICAgICAgXCImTkpjeTtcIjogXCLQilwiLFxuICAgICAgXCImTmFjdXRlO1wiOiBcIsWDXCIsXG4gICAgICBcIiZOY2Fyb247XCI6IFwixYdcIixcbiAgICAgIFwiJk5jZWRpbDtcIjogXCLFhVwiLFxuICAgICAgXCImTmN5O1wiOiBcItCdXCIsXG4gICAgICBcIiZOZWdhdGl2ZU1lZGl1bVNwYWNlO1wiOiBcIuKAi1wiLFxuICAgICAgXCImTmVnYXRpdmVUaGlja1NwYWNlO1wiOiBcIuKAi1wiLFxuICAgICAgXCImTmVnYXRpdmVUaGluU3BhY2U7XCI6IFwi4oCLXCIsXG4gICAgICBcIiZOZWdhdGl2ZVZlcnlUaGluU3BhY2U7XCI6IFwi4oCLXCIsXG4gICAgICBcIiZOZXN0ZWRHcmVhdGVyR3JlYXRlcjtcIjogXCLiiatcIixcbiAgICAgIFwiJk5lc3RlZExlc3NMZXNzO1wiOiBcIuKJqlwiLFxuICAgICAgXCImTmV3TGluZTtcIjogXCJcXG5cIixcbiAgICAgIFwiJk5mcjtcIjogXCLwnZSRXCIsXG4gICAgICBcIiZOb0JyZWFrO1wiOiBcIuKBoFwiLFxuICAgICAgXCImTm9uQnJlYWtpbmdTcGFjZTtcIjogXCLCoFwiLFxuICAgICAgXCImTm9wZjtcIjogXCLihJVcIixcbiAgICAgIFwiJk5vdDtcIjogXCLiq6xcIixcbiAgICAgIFwiJk5vdENvbmdydWVudDtcIjogXCLiiaJcIixcbiAgICAgIFwiJk5vdEN1cENhcDtcIjogXCLiia1cIixcbiAgICAgIFwiJk5vdERvdWJsZVZlcnRpY2FsQmFyO1wiOiBcIuKIplwiLFxuICAgICAgXCImTm90RWxlbWVudDtcIjogXCLiiIlcIixcbiAgICAgIFwiJk5vdEVxdWFsO1wiOiBcIuKJoFwiLFxuICAgICAgXCImTm90RXF1YWxUaWxkZTtcIjogXCLiiYLMuFwiLFxuICAgICAgXCImTm90RXhpc3RzO1wiOiBcIuKIhFwiLFxuICAgICAgXCImTm90R3JlYXRlcjtcIjogXCLiia9cIixcbiAgICAgIFwiJk5vdEdyZWF0ZXJFcXVhbDtcIjogXCLiibFcIixcbiAgICAgIFwiJk5vdEdyZWF0ZXJGdWxsRXF1YWw7XCI6IFwi4omnzLhcIixcbiAgICAgIFwiJk5vdEdyZWF0ZXJHcmVhdGVyO1wiOiBcIuKJq8y4XCIsXG4gICAgICBcIiZOb3RHcmVhdGVyTGVzcztcIjogXCLiiblcIixcbiAgICAgIFwiJk5vdEdyZWF0ZXJTbGFudEVxdWFsO1wiOiBcIuKpvsy4XCIsXG4gICAgICBcIiZOb3RHcmVhdGVyVGlsZGU7XCI6IFwi4om1XCIsXG4gICAgICBcIiZOb3RIdW1wRG93bkh1bXA7XCI6IFwi4omOzLhcIixcbiAgICAgIFwiJk5vdEh1bXBFcXVhbDtcIjogXCLiiY/MuFwiLFxuICAgICAgXCImTm90TGVmdFRyaWFuZ2xlO1wiOiBcIuKLqlwiLFxuICAgICAgXCImTm90TGVmdFRyaWFuZ2xlQmFyO1wiOiBcIuKnj8y4XCIsXG4gICAgICBcIiZOb3RMZWZ0VHJpYW5nbGVFcXVhbDtcIjogXCLii6xcIixcbiAgICAgIFwiJk5vdExlc3M7XCI6IFwi4omuXCIsXG4gICAgICBcIiZOb3RMZXNzRXF1YWw7XCI6IFwi4omwXCIsXG4gICAgICBcIiZOb3RMZXNzR3JlYXRlcjtcIjogXCLiibhcIixcbiAgICAgIFwiJk5vdExlc3NMZXNzO1wiOiBcIuKJqsy4XCIsXG4gICAgICBcIiZOb3RMZXNzU2xhbnRFcXVhbDtcIjogXCLiqb3MuFwiLFxuICAgICAgXCImTm90TGVzc1RpbGRlO1wiOiBcIuKJtFwiLFxuICAgICAgXCImTm90TmVzdGVkR3JlYXRlckdyZWF0ZXI7XCI6IFwi4qqizLhcIixcbiAgICAgIFwiJk5vdE5lc3RlZExlc3NMZXNzO1wiOiBcIuKqocy4XCIsXG4gICAgICBcIiZOb3RQcmVjZWRlcztcIjogXCLiioBcIixcbiAgICAgIFwiJk5vdFByZWNlZGVzRXF1YWw7XCI6IFwi4qqvzLhcIixcbiAgICAgIFwiJk5vdFByZWNlZGVzU2xhbnRFcXVhbDtcIjogXCLii6BcIixcbiAgICAgIFwiJk5vdFJldmVyc2VFbGVtZW50O1wiOiBcIuKIjFwiLFxuICAgICAgXCImTm90UmlnaHRUcmlhbmdsZTtcIjogXCLii6tcIixcbiAgICAgIFwiJk5vdFJpZ2h0VHJpYW5nbGVCYXI7XCI6IFwi4qeQzLhcIixcbiAgICAgIFwiJk5vdFJpZ2h0VHJpYW5nbGVFcXVhbDtcIjogXCLii61cIixcbiAgICAgIFwiJk5vdFNxdWFyZVN1YnNldDtcIjogXCLiio/MuFwiLFxuICAgICAgXCImTm90U3F1YXJlU3Vic2V0RXF1YWw7XCI6IFwi4ouiXCIsXG4gICAgICBcIiZOb3RTcXVhcmVTdXBlcnNldDtcIjogXCLiipDMuFwiLFxuICAgICAgXCImTm90U3F1YXJlU3VwZXJzZXRFcXVhbDtcIjogXCLii6NcIixcbiAgICAgIFwiJk5vdFN1YnNldDtcIjogXCLiioLig5JcIixcbiAgICAgIFwiJk5vdFN1YnNldEVxdWFsO1wiOiBcIuKKiFwiLFxuICAgICAgXCImTm90U3VjY2VlZHM7XCI6IFwi4oqBXCIsXG4gICAgICBcIiZOb3RTdWNjZWVkc0VxdWFsO1wiOiBcIuKqsMy4XCIsXG4gICAgICBcIiZOb3RTdWNjZWVkc1NsYW50RXF1YWw7XCI6IFwi4ouhXCIsXG4gICAgICBcIiZOb3RTdWNjZWVkc1RpbGRlO1wiOiBcIuKJv8y4XCIsXG4gICAgICBcIiZOb3RTdXBlcnNldDtcIjogXCLiioPig5JcIixcbiAgICAgIFwiJk5vdFN1cGVyc2V0RXF1YWw7XCI6IFwi4oqJXCIsXG4gICAgICBcIiZOb3RUaWxkZTtcIjogXCLiiYFcIixcbiAgICAgIFwiJk5vdFRpbGRlRXF1YWw7XCI6IFwi4omEXCIsXG4gICAgICBcIiZOb3RUaWxkZUZ1bGxFcXVhbDtcIjogXCLiiYdcIixcbiAgICAgIFwiJk5vdFRpbGRlVGlsZGU7XCI6IFwi4omJXCIsXG4gICAgICBcIiZOb3RWZXJ0aWNhbEJhcjtcIjogXCLiiKRcIixcbiAgICAgIFwiJk5zY3I7XCI6IFwi8J2SqVwiLFxuICAgICAgXCImTnRpbGRlXCI6IFwiw5FcIixcbiAgICAgIFwiJk50aWxkZTtcIjogXCLDkVwiLFxuICAgICAgXCImTnU7XCI6IFwizp1cIixcbiAgICAgIFwiJk9FbGlnO1wiOiBcIsWSXCIsXG4gICAgICBcIiZPYWN1dGVcIjogXCLDk1wiLFxuICAgICAgXCImT2FjdXRlO1wiOiBcIsOTXCIsXG4gICAgICBcIiZPY2lyY1wiOiBcIsOUXCIsXG4gICAgICBcIiZPY2lyYztcIjogXCLDlFwiLFxuICAgICAgXCImT2N5O1wiOiBcItCeXCIsXG4gICAgICBcIiZPZGJsYWM7XCI6IFwixZBcIixcbiAgICAgIFwiJk9mcjtcIjogXCLwnZSSXCIsXG4gICAgICBcIiZPZ3JhdmVcIjogXCLDklwiLFxuICAgICAgXCImT2dyYXZlO1wiOiBcIsOSXCIsXG4gICAgICBcIiZPbWFjcjtcIjogXCLFjFwiLFxuICAgICAgXCImT21lZ2E7XCI6IFwizqlcIixcbiAgICAgIFwiJk9taWNyb247XCI6IFwizp9cIixcbiAgICAgIFwiJk9vcGY7XCI6IFwi8J2VhlwiLFxuICAgICAgXCImT3BlbkN1cmx5RG91YmxlUXVvdGU7XCI6IFwi4oCcXCIsXG4gICAgICBcIiZPcGVuQ3VybHlRdW90ZTtcIjogXCLigJhcIixcbiAgICAgIFwiJk9yO1wiOiBcIuKplFwiLFxuICAgICAgXCImT3NjcjtcIjogXCLwnZKqXCIsXG4gICAgICBcIiZPc2xhc2hcIjogXCLDmFwiLFxuICAgICAgXCImT3NsYXNoO1wiOiBcIsOYXCIsXG4gICAgICBcIiZPdGlsZGVcIjogXCLDlVwiLFxuICAgICAgXCImT3RpbGRlO1wiOiBcIsOVXCIsXG4gICAgICBcIiZPdGltZXM7XCI6IFwi4qi3XCIsXG4gICAgICBcIiZPdW1sXCI6IFwiw5ZcIixcbiAgICAgIFwiJk91bWw7XCI6IFwiw5ZcIixcbiAgICAgIFwiJk92ZXJCYXI7XCI6IFwi4oC+XCIsXG4gICAgICBcIiZPdmVyQnJhY2U7XCI6IFwi4o+eXCIsXG4gICAgICBcIiZPdmVyQnJhY2tldDtcIjogXCLijrRcIixcbiAgICAgIFwiJk92ZXJQYXJlbnRoZXNpcztcIjogXCLij5xcIixcbiAgICAgIFwiJlBhcnRpYWxEO1wiOiBcIuKIglwiLFxuICAgICAgXCImUGN5O1wiOiBcItCfXCIsXG4gICAgICBcIiZQZnI7XCI6IFwi8J2Uk1wiLFxuICAgICAgXCImUGhpO1wiOiBcIs6mXCIsXG4gICAgICBcIiZQaTtcIjogXCLOoFwiLFxuICAgICAgXCImUGx1c01pbnVzO1wiOiBcIsKxXCIsXG4gICAgICBcIiZQb2luY2FyZXBsYW5lO1wiOiBcIuKEjFwiLFxuICAgICAgXCImUG9wZjtcIjogXCLihJlcIixcbiAgICAgIFwiJlByO1wiOiBcIuKqu1wiLFxuICAgICAgXCImUHJlY2VkZXM7XCI6IFwi4om6XCIsXG4gICAgICBcIiZQcmVjZWRlc0VxdWFsO1wiOiBcIuKqr1wiLFxuICAgICAgXCImUHJlY2VkZXNTbGFudEVxdWFsO1wiOiBcIuKJvFwiLFxuICAgICAgXCImUHJlY2VkZXNUaWxkZTtcIjogXCLiib5cIixcbiAgICAgIFwiJlByaW1lO1wiOiBcIuKAs1wiLFxuICAgICAgXCImUHJvZHVjdDtcIjogXCLiiI9cIixcbiAgICAgIFwiJlByb3BvcnRpb247XCI6IFwi4oi3XCIsXG4gICAgICBcIiZQcm9wb3J0aW9uYWw7XCI6IFwi4oidXCIsXG4gICAgICBcIiZQc2NyO1wiOiBcIvCdkqtcIixcbiAgICAgIFwiJlBzaTtcIjogXCLOqFwiLFxuICAgICAgXCImUVVPVFwiOiAnXCInLFxuICAgICAgXCImUVVPVDtcIjogJ1wiJyxcbiAgICAgIFwiJlFmcjtcIjogXCLwnZSUXCIsXG4gICAgICBcIiZRb3BmO1wiOiBcIuKEmlwiLFxuICAgICAgXCImUXNjcjtcIjogXCLwnZKsXCIsXG4gICAgICBcIiZSQmFycjtcIjogXCLipJBcIixcbiAgICAgIFwiJlJFR1wiOiBcIsKuXCIsXG4gICAgICBcIiZSRUc7XCI6IFwiwq5cIixcbiAgICAgIFwiJlJhY3V0ZTtcIjogXCLFlFwiLFxuICAgICAgXCImUmFuZztcIjogXCLin6tcIixcbiAgICAgIFwiJlJhcnI7XCI6IFwi4oagXCIsXG4gICAgICBcIiZSYXJydGw7XCI6IFwi4qSWXCIsXG4gICAgICBcIiZSY2Fyb247XCI6IFwixZhcIixcbiAgICAgIFwiJlJjZWRpbDtcIjogXCLFllwiLFxuICAgICAgXCImUmN5O1wiOiBcItCgXCIsXG4gICAgICBcIiZSZTtcIjogXCLihJxcIixcbiAgICAgIFwiJlJldmVyc2VFbGVtZW50O1wiOiBcIuKIi1wiLFxuICAgICAgXCImUmV2ZXJzZUVxdWlsaWJyaXVtO1wiOiBcIuKHi1wiLFxuICAgICAgXCImUmV2ZXJzZVVwRXF1aWxpYnJpdW07XCI6IFwi4qWvXCIsXG4gICAgICBcIiZSZnI7XCI6IFwi4oScXCIsXG4gICAgICBcIiZSaG87XCI6IFwizqFcIixcbiAgICAgIFwiJlJpZ2h0QW5nbGVCcmFja2V0O1wiOiBcIuKfqVwiLFxuICAgICAgXCImUmlnaHRBcnJvdztcIjogXCLihpJcIixcbiAgICAgIFwiJlJpZ2h0QXJyb3dCYXI7XCI6IFwi4oelXCIsXG4gICAgICBcIiZSaWdodEFycm93TGVmdEFycm93O1wiOiBcIuKHhFwiLFxuICAgICAgXCImUmlnaHRDZWlsaW5nO1wiOiBcIuKMiVwiLFxuICAgICAgXCImUmlnaHREb3VibGVCcmFja2V0O1wiOiBcIuKfp1wiLFxuICAgICAgXCImUmlnaHREb3duVGVlVmVjdG9yO1wiOiBcIuKlnVwiLFxuICAgICAgXCImUmlnaHREb3duVmVjdG9yO1wiOiBcIuKHglwiLFxuICAgICAgXCImUmlnaHREb3duVmVjdG9yQmFyO1wiOiBcIuKllVwiLFxuICAgICAgXCImUmlnaHRGbG9vcjtcIjogXCLijItcIixcbiAgICAgIFwiJlJpZ2h0VGVlO1wiOiBcIuKKolwiLFxuICAgICAgXCImUmlnaHRUZWVBcnJvdztcIjogXCLihqZcIixcbiAgICAgIFwiJlJpZ2h0VGVlVmVjdG9yO1wiOiBcIuKlm1wiLFxuICAgICAgXCImUmlnaHRUcmlhbmdsZTtcIjogXCLiirNcIixcbiAgICAgIFwiJlJpZ2h0VHJpYW5nbGVCYXI7XCI6IFwi4qeQXCIsXG4gICAgICBcIiZSaWdodFRyaWFuZ2xlRXF1YWw7XCI6IFwi4oq1XCIsXG4gICAgICBcIiZSaWdodFVwRG93blZlY3RvcjtcIjogXCLipY9cIixcbiAgICAgIFwiJlJpZ2h0VXBUZWVWZWN0b3I7XCI6IFwi4qWcXCIsXG4gICAgICBcIiZSaWdodFVwVmVjdG9yO1wiOiBcIuKGvlwiLFxuICAgICAgXCImUmlnaHRVcFZlY3RvckJhcjtcIjogXCLipZRcIixcbiAgICAgIFwiJlJpZ2h0VmVjdG9yO1wiOiBcIuKHgFwiLFxuICAgICAgXCImUmlnaHRWZWN0b3JCYXI7XCI6IFwi4qWTXCIsXG4gICAgICBcIiZSaWdodGFycm93O1wiOiBcIuKHklwiLFxuICAgICAgXCImUm9wZjtcIjogXCLihJ1cIixcbiAgICAgIFwiJlJvdW5kSW1wbGllcztcIjogXCLipbBcIixcbiAgICAgIFwiJlJyaWdodGFycm93O1wiOiBcIuKHm1wiLFxuICAgICAgXCImUnNjcjtcIjogXCLihJtcIixcbiAgICAgIFwiJlJzaDtcIjogXCLihrFcIixcbiAgICAgIFwiJlJ1bGVEZWxheWVkO1wiOiBcIuKntFwiLFxuICAgICAgXCImU0hDSGN5O1wiOiBcItCpXCIsXG4gICAgICBcIiZTSGN5O1wiOiBcItCoXCIsXG4gICAgICBcIiZTT0ZUY3k7XCI6IFwi0KxcIixcbiAgICAgIFwiJlNhY3V0ZTtcIjogXCLFmlwiLFxuICAgICAgXCImU2M7XCI6IFwi4qq8XCIsXG4gICAgICBcIiZTY2Fyb247XCI6IFwixaBcIixcbiAgICAgIFwiJlNjZWRpbDtcIjogXCLFnlwiLFxuICAgICAgXCImU2NpcmM7XCI6IFwixZxcIixcbiAgICAgIFwiJlNjeTtcIjogXCLQoVwiLFxuICAgICAgXCImU2ZyO1wiOiBcIvCdlJZcIixcbiAgICAgIFwiJlNob3J0RG93bkFycm93O1wiOiBcIuKGk1wiLFxuICAgICAgXCImU2hvcnRMZWZ0QXJyb3c7XCI6IFwi4oaQXCIsXG4gICAgICBcIiZTaG9ydFJpZ2h0QXJyb3c7XCI6IFwi4oaSXCIsXG4gICAgICBcIiZTaG9ydFVwQXJyb3c7XCI6IFwi4oaRXCIsXG4gICAgICBcIiZTaWdtYTtcIjogXCLOo1wiLFxuICAgICAgXCImU21hbGxDaXJjbGU7XCI6IFwi4oiYXCIsXG4gICAgICBcIiZTb3BmO1wiOiBcIvCdlYpcIixcbiAgICAgIFwiJlNxcnQ7XCI6IFwi4oiaXCIsXG4gICAgICBcIiZTcXVhcmU7XCI6IFwi4pahXCIsXG4gICAgICBcIiZTcXVhcmVJbnRlcnNlY3Rpb247XCI6IFwi4oqTXCIsXG4gICAgICBcIiZTcXVhcmVTdWJzZXQ7XCI6IFwi4oqPXCIsXG4gICAgICBcIiZTcXVhcmVTdWJzZXRFcXVhbDtcIjogXCLiipFcIixcbiAgICAgIFwiJlNxdWFyZVN1cGVyc2V0O1wiOiBcIuKKkFwiLFxuICAgICAgXCImU3F1YXJlU3VwZXJzZXRFcXVhbDtcIjogXCLiipJcIixcbiAgICAgIFwiJlNxdWFyZVVuaW9uO1wiOiBcIuKKlFwiLFxuICAgICAgXCImU3NjcjtcIjogXCLwnZKuXCIsXG4gICAgICBcIiZTdGFyO1wiOiBcIuKLhlwiLFxuICAgICAgXCImU3ViO1wiOiBcIuKLkFwiLFxuICAgICAgXCImU3Vic2V0O1wiOiBcIuKLkFwiLFxuICAgICAgXCImU3Vic2V0RXF1YWw7XCI6IFwi4oqGXCIsXG4gICAgICBcIiZTdWNjZWVkcztcIjogXCLiibtcIixcbiAgICAgIFwiJlN1Y2NlZWRzRXF1YWw7XCI6IFwi4qqwXCIsXG4gICAgICBcIiZTdWNjZWVkc1NsYW50RXF1YWw7XCI6IFwi4om9XCIsXG4gICAgICBcIiZTdWNjZWVkc1RpbGRlO1wiOiBcIuKJv1wiLFxuICAgICAgXCImU3VjaFRoYXQ7XCI6IFwi4oiLXCIsXG4gICAgICBcIiZTdW07XCI6IFwi4oiRXCIsXG4gICAgICBcIiZTdXA7XCI6IFwi4ouRXCIsXG4gICAgICBcIiZTdXBlcnNldDtcIjogXCLiioNcIixcbiAgICAgIFwiJlN1cGVyc2V0RXF1YWw7XCI6IFwi4oqHXCIsXG4gICAgICBcIiZTdXBzZXQ7XCI6IFwi4ouRXCIsXG4gICAgICBcIiZUSE9STlwiOiBcIsOeXCIsXG4gICAgICBcIiZUSE9STjtcIjogXCLDnlwiLFxuICAgICAgXCImVFJBREU7XCI6IFwi4oSiXCIsXG4gICAgICBcIiZUU0hjeTtcIjogXCLQi1wiLFxuICAgICAgXCImVFNjeTtcIjogXCLQplwiLFxuICAgICAgXCImVGFiO1wiOiBcIlxcdFwiLFxuICAgICAgXCImVGF1O1wiOiBcIs6kXCIsXG4gICAgICBcIiZUY2Fyb247XCI6IFwixaRcIixcbiAgICAgIFwiJlRjZWRpbDtcIjogXCLFolwiLFxuICAgICAgXCImVGN5O1wiOiBcItCiXCIsXG4gICAgICBcIiZUZnI7XCI6IFwi8J2Ul1wiLFxuICAgICAgXCImVGhlcmVmb3JlO1wiOiBcIuKItFwiLFxuICAgICAgXCImVGhldGE7XCI6IFwizphcIixcbiAgICAgIFwiJlRoaWNrU3BhY2U7XCI6IFwi4oGf4oCKXCIsXG4gICAgICBcIiZUaGluU3BhY2U7XCI6IFwi4oCJXCIsXG4gICAgICBcIiZUaWxkZTtcIjogXCLiiLxcIixcbiAgICAgIFwiJlRpbGRlRXF1YWw7XCI6IFwi4omDXCIsXG4gICAgICBcIiZUaWxkZUZ1bGxFcXVhbDtcIjogXCLiiYVcIixcbiAgICAgIFwiJlRpbGRlVGlsZGU7XCI6IFwi4omIXCIsXG4gICAgICBcIiZUb3BmO1wiOiBcIvCdlYtcIixcbiAgICAgIFwiJlRyaXBsZURvdDtcIjogXCLig5tcIixcbiAgICAgIFwiJlRzY3I7XCI6IFwi8J2Sr1wiLFxuICAgICAgXCImVHN0cm9rO1wiOiBcIsWmXCIsXG4gICAgICBcIiZVYWN1dGVcIjogXCLDmlwiLFxuICAgICAgXCImVWFjdXRlO1wiOiBcIsOaXCIsXG4gICAgICBcIiZVYXJyO1wiOiBcIuKGn1wiLFxuICAgICAgXCImVWFycm9jaXI7XCI6IFwi4qWJXCIsXG4gICAgICBcIiZVYnJjeTtcIjogXCLQjlwiLFxuICAgICAgXCImVWJyZXZlO1wiOiBcIsWsXCIsXG4gICAgICBcIiZVY2lyY1wiOiBcIsObXCIsXG4gICAgICBcIiZVY2lyYztcIjogXCLDm1wiLFxuICAgICAgXCImVWN5O1wiOiBcItCjXCIsXG4gICAgICBcIiZVZGJsYWM7XCI6IFwixbBcIixcbiAgICAgIFwiJlVmcjtcIjogXCLwnZSYXCIsXG4gICAgICBcIiZVZ3JhdmVcIjogXCLDmVwiLFxuICAgICAgXCImVWdyYXZlO1wiOiBcIsOZXCIsXG4gICAgICBcIiZVbWFjcjtcIjogXCLFqlwiLFxuICAgICAgXCImVW5kZXJCYXI7XCI6IFwiX1wiLFxuICAgICAgXCImVW5kZXJCcmFjZTtcIjogXCLij59cIixcbiAgICAgIFwiJlVuZGVyQnJhY2tldDtcIjogXCLijrVcIixcbiAgICAgIFwiJlVuZGVyUGFyZW50aGVzaXM7XCI6IFwi4o+dXCIsXG4gICAgICBcIiZVbmlvbjtcIjogXCLii4NcIixcbiAgICAgIFwiJlVuaW9uUGx1cztcIjogXCLiio5cIixcbiAgICAgIFwiJlVvZ29uO1wiOiBcIsWyXCIsXG4gICAgICBcIiZVb3BmO1wiOiBcIvCdlYxcIixcbiAgICAgIFwiJlVwQXJyb3c7XCI6IFwi4oaRXCIsXG4gICAgICBcIiZVcEFycm93QmFyO1wiOiBcIuKkklwiLFxuICAgICAgXCImVXBBcnJvd0Rvd25BcnJvdztcIjogXCLih4VcIixcbiAgICAgIFwiJlVwRG93bkFycm93O1wiOiBcIuKGlVwiLFxuICAgICAgXCImVXBFcXVpbGlicml1bTtcIjogXCLipa5cIixcbiAgICAgIFwiJlVwVGVlO1wiOiBcIuKKpVwiLFxuICAgICAgXCImVXBUZWVBcnJvdztcIjogXCLihqVcIixcbiAgICAgIFwiJlVwYXJyb3c7XCI6IFwi4oeRXCIsXG4gICAgICBcIiZVcGRvd25hcnJvdztcIjogXCLih5VcIixcbiAgICAgIFwiJlVwcGVyTGVmdEFycm93O1wiOiBcIuKGllwiLFxuICAgICAgXCImVXBwZXJSaWdodEFycm93O1wiOiBcIuKGl1wiLFxuICAgICAgXCImVXBzaTtcIjogXCLPklwiLFxuICAgICAgXCImVXBzaWxvbjtcIjogXCLOpVwiLFxuICAgICAgXCImVXJpbmc7XCI6IFwixa5cIixcbiAgICAgIFwiJlVzY3I7XCI6IFwi8J2SsFwiLFxuICAgICAgXCImVXRpbGRlO1wiOiBcIsWoXCIsXG4gICAgICBcIiZVdW1sXCI6IFwiw5xcIixcbiAgICAgIFwiJlV1bWw7XCI6IFwiw5xcIixcbiAgICAgIFwiJlZEYXNoO1wiOiBcIuKKq1wiLFxuICAgICAgXCImVmJhcjtcIjogXCLiq6tcIixcbiAgICAgIFwiJlZjeTtcIjogXCLQklwiLFxuICAgICAgXCImVmRhc2g7XCI6IFwi4oqpXCIsXG4gICAgICBcIiZWZGFzaGw7XCI6IFwi4qumXCIsXG4gICAgICBcIiZWZWU7XCI6IFwi4ouBXCIsXG4gICAgICBcIiZWZXJiYXI7XCI6IFwi4oCWXCIsXG4gICAgICBcIiZWZXJ0O1wiOiBcIuKAllwiLFxuICAgICAgXCImVmVydGljYWxCYXI7XCI6IFwi4oijXCIsXG4gICAgICBcIiZWZXJ0aWNhbExpbmU7XCI6IFwifFwiLFxuICAgICAgXCImVmVydGljYWxTZXBhcmF0b3I7XCI6IFwi4p2YXCIsXG4gICAgICBcIiZWZXJ0aWNhbFRpbGRlO1wiOiBcIuKJgFwiLFxuICAgICAgXCImVmVyeVRoaW5TcGFjZTtcIjogXCLigIpcIixcbiAgICAgIFwiJlZmcjtcIjogXCLwnZSZXCIsXG4gICAgICBcIiZWb3BmO1wiOiBcIvCdlY1cIixcbiAgICAgIFwiJlZzY3I7XCI6IFwi8J2SsVwiLFxuICAgICAgXCImVnZkYXNoO1wiOiBcIuKKqlwiLFxuICAgICAgXCImV2NpcmM7XCI6IFwixbRcIixcbiAgICAgIFwiJldlZGdlO1wiOiBcIuKLgFwiLFxuICAgICAgXCImV2ZyO1wiOiBcIvCdlJpcIixcbiAgICAgIFwiJldvcGY7XCI6IFwi8J2VjlwiLFxuICAgICAgXCImV3NjcjtcIjogXCLwnZKyXCIsXG4gICAgICBcIiZYZnI7XCI6IFwi8J2Um1wiLFxuICAgICAgXCImWGk7XCI6IFwizp5cIixcbiAgICAgIFwiJlhvcGY7XCI6IFwi8J2Vj1wiLFxuICAgICAgXCImWHNjcjtcIjogXCLwnZKzXCIsXG4gICAgICBcIiZZQWN5O1wiOiBcItCvXCIsXG4gICAgICBcIiZZSWN5O1wiOiBcItCHXCIsXG4gICAgICBcIiZZVWN5O1wiOiBcItCuXCIsXG4gICAgICBcIiZZYWN1dGVcIjogXCLDnVwiLFxuICAgICAgXCImWWFjdXRlO1wiOiBcIsOdXCIsXG4gICAgICBcIiZZY2lyYztcIjogXCLFtlwiLFxuICAgICAgXCImWWN5O1wiOiBcItCrXCIsXG4gICAgICBcIiZZZnI7XCI6IFwi8J2UnFwiLFxuICAgICAgXCImWW9wZjtcIjogXCLwnZWQXCIsXG4gICAgICBcIiZZc2NyO1wiOiBcIvCdkrRcIixcbiAgICAgIFwiJll1bWw7XCI6IFwixbhcIixcbiAgICAgIFwiJlpIY3k7XCI6IFwi0JZcIixcbiAgICAgIFwiJlphY3V0ZTtcIjogXCLFuVwiLFxuICAgICAgXCImWmNhcm9uO1wiOiBcIsW9XCIsXG4gICAgICBcIiZaY3k7XCI6IFwi0JdcIixcbiAgICAgIFwiJlpkb3Q7XCI6IFwixbtcIixcbiAgICAgIFwiJlplcm9XaWR0aFNwYWNlO1wiOiBcIuKAi1wiLFxuICAgICAgXCImWmV0YTtcIjogXCLOllwiLFxuICAgICAgXCImWmZyO1wiOiBcIuKEqFwiLFxuICAgICAgXCImWm9wZjtcIjogXCLihKRcIixcbiAgICAgIFwiJlpzY3I7XCI6IFwi8J2StVwiLFxuICAgICAgXCImYWFjdXRlXCI6IFwiw6FcIixcbiAgICAgIFwiJmFhY3V0ZTtcIjogXCLDoVwiLFxuICAgICAgXCImYWJyZXZlO1wiOiBcIsSDXCIsXG4gICAgICBcIiZhYztcIjogXCLiiL5cIixcbiAgICAgIFwiJmFjRTtcIjogXCLiiL7Ms1wiLFxuICAgICAgXCImYWNkO1wiOiBcIuKIv1wiLFxuICAgICAgXCImYWNpcmNcIjogXCLDolwiLFxuICAgICAgXCImYWNpcmM7XCI6IFwiw6JcIixcbiAgICAgIFwiJmFjdXRlXCI6IFwiwrRcIixcbiAgICAgIFwiJmFjdXRlO1wiOiBcIsK0XCIsXG4gICAgICBcIiZhY3k7XCI6IFwi0LBcIixcbiAgICAgIFwiJmFlbGlnXCI6IFwiw6ZcIixcbiAgICAgIFwiJmFlbGlnO1wiOiBcIsOmXCIsXG4gICAgICBcIiZhZjtcIjogXCLigaFcIixcbiAgICAgIFwiJmFmcjtcIjogXCLwnZSeXCIsXG4gICAgICBcIiZhZ3JhdmVcIjogXCLDoFwiLFxuICAgICAgXCImYWdyYXZlO1wiOiBcIsOgXCIsXG4gICAgICBcIiZhbGVmc3ltO1wiOiBcIuKEtVwiLFxuICAgICAgXCImYWxlcGg7XCI6IFwi4oS1XCIsXG4gICAgICBcIiZhbHBoYTtcIjogXCLOsVwiLFxuICAgICAgXCImYW1hY3I7XCI6IFwixIFcIixcbiAgICAgIFwiJmFtYWxnO1wiOiBcIuKov1wiLFxuICAgICAgXCImYW1wXCI6IFwiJlwiLFxuICAgICAgXCImYW1wO1wiOiBcIiZcIixcbiAgICAgIFwiJmFuZDtcIjogXCLiiKdcIixcbiAgICAgIFwiJmFuZGFuZDtcIjogXCLiqZVcIixcbiAgICAgIFwiJmFuZGQ7XCI6IFwi4qmcXCIsXG4gICAgICBcIiZhbmRzbG9wZTtcIjogXCLiqZhcIixcbiAgICAgIFwiJmFuZHY7XCI6IFwi4qmaXCIsXG4gICAgICBcIiZhbmc7XCI6IFwi4oigXCIsXG4gICAgICBcIiZhbmdlO1wiOiBcIuKmpFwiLFxuICAgICAgXCImYW5nbGU7XCI6IFwi4oigXCIsXG4gICAgICBcIiZhbmdtc2Q7XCI6IFwi4oihXCIsXG4gICAgICBcIiZhbmdtc2RhYTtcIjogXCLipqhcIixcbiAgICAgIFwiJmFuZ21zZGFiO1wiOiBcIuKmqVwiLFxuICAgICAgXCImYW5nbXNkYWM7XCI6IFwi4qaqXCIsXG4gICAgICBcIiZhbmdtc2RhZDtcIjogXCLipqtcIixcbiAgICAgIFwiJmFuZ21zZGFlO1wiOiBcIuKmrFwiLFxuICAgICAgXCImYW5nbXNkYWY7XCI6IFwi4qatXCIsXG4gICAgICBcIiZhbmdtc2RhZztcIjogXCLipq5cIixcbiAgICAgIFwiJmFuZ21zZGFoO1wiOiBcIuKmr1wiLFxuICAgICAgXCImYW5ncnQ7XCI6IFwi4oifXCIsXG4gICAgICBcIiZhbmdydHZiO1wiOiBcIuKKvlwiLFxuICAgICAgXCImYW5ncnR2YmQ7XCI6IFwi4qadXCIsXG4gICAgICBcIiZhbmdzcGg7XCI6IFwi4oiiXCIsXG4gICAgICBcIiZhbmdzdDtcIjogXCLDhVwiLFxuICAgICAgXCImYW5nemFycjtcIjogXCLijbxcIixcbiAgICAgIFwiJmFvZ29uO1wiOiBcIsSFXCIsXG4gICAgICBcIiZhb3BmO1wiOiBcIvCdlZJcIixcbiAgICAgIFwiJmFwO1wiOiBcIuKJiFwiLFxuICAgICAgXCImYXBFO1wiOiBcIuKpsFwiLFxuICAgICAgXCImYXBhY2lyO1wiOiBcIuKpr1wiLFxuICAgICAgXCImYXBlO1wiOiBcIuKJilwiLFxuICAgICAgXCImYXBpZDtcIjogXCLiiYtcIixcbiAgICAgIFwiJmFwb3M7XCI6IFwiJ1wiLFxuICAgICAgXCImYXBwcm94O1wiOiBcIuKJiFwiLFxuICAgICAgXCImYXBwcm94ZXE7XCI6IFwi4omKXCIsXG4gICAgICBcIiZhcmluZ1wiOiBcIsOlXCIsXG4gICAgICBcIiZhcmluZztcIjogXCLDpVwiLFxuICAgICAgXCImYXNjcjtcIjogXCLwnZK2XCIsXG4gICAgICBcIiZhc3Q7XCI6IFwiKlwiLFxuICAgICAgXCImYXN5bXA7XCI6IFwi4omIXCIsXG4gICAgICBcIiZhc3ltcGVxO1wiOiBcIuKJjVwiLFxuICAgICAgXCImYXRpbGRlXCI6IFwiw6NcIixcbiAgICAgIFwiJmF0aWxkZTtcIjogXCLDo1wiLFxuICAgICAgXCImYXVtbFwiOiBcIsOkXCIsXG4gICAgICBcIiZhdW1sO1wiOiBcIsOkXCIsXG4gICAgICBcIiZhd2NvbmludDtcIjogXCLiiLNcIixcbiAgICAgIFwiJmF3aW50O1wiOiBcIuKokVwiLFxuICAgICAgXCImYk5vdDtcIjogXCLiq61cIixcbiAgICAgIFwiJmJhY2tjb25nO1wiOiBcIuKJjFwiLFxuICAgICAgXCImYmFja2Vwc2lsb247XCI6IFwiz7ZcIixcbiAgICAgIFwiJmJhY2twcmltZTtcIjogXCLigLVcIixcbiAgICAgIFwiJmJhY2tzaW07XCI6IFwi4oi9XCIsXG4gICAgICBcIiZiYWNrc2ltZXE7XCI6IFwi4ouNXCIsXG4gICAgICBcIiZiYXJ2ZWU7XCI6IFwi4oq9XCIsXG4gICAgICBcIiZiYXJ3ZWQ7XCI6IFwi4oyFXCIsXG4gICAgICBcIiZiYXJ3ZWRnZTtcIjogXCLijIVcIixcbiAgICAgIFwiJmJicms7XCI6IFwi4o61XCIsXG4gICAgICBcIiZiYnJrdGJyaztcIjogXCLijrZcIixcbiAgICAgIFwiJmJjb25nO1wiOiBcIuKJjFwiLFxuICAgICAgXCImYmN5O1wiOiBcItCxXCIsXG4gICAgICBcIiZiZHF1bztcIjogXCLigJ5cIixcbiAgICAgIFwiJmJlY2F1cztcIjogXCLiiLVcIixcbiAgICAgIFwiJmJlY2F1c2U7XCI6IFwi4oi1XCIsXG4gICAgICBcIiZiZW1wdHl2O1wiOiBcIuKmsFwiLFxuICAgICAgXCImYmVwc2k7XCI6IFwiz7ZcIixcbiAgICAgIFwiJmJlcm5vdTtcIjogXCLihKxcIixcbiAgICAgIFwiJmJldGE7XCI6IFwizrJcIixcbiAgICAgIFwiJmJldGg7XCI6IFwi4oS2XCIsXG4gICAgICBcIiZiZXR3ZWVuO1wiOiBcIuKJrFwiLFxuICAgICAgXCImYmZyO1wiOiBcIvCdlJ9cIixcbiAgICAgIFwiJmJpZ2NhcDtcIjogXCLii4JcIixcbiAgICAgIFwiJmJpZ2NpcmM7XCI6IFwi4pevXCIsXG4gICAgICBcIiZiaWdjdXA7XCI6IFwi4ouDXCIsXG4gICAgICBcIiZiaWdvZG90O1wiOiBcIuKogFwiLFxuICAgICAgXCImYmlnb3BsdXM7XCI6IFwi4qiBXCIsXG4gICAgICBcIiZiaWdvdGltZXM7XCI6IFwi4qiCXCIsXG4gICAgICBcIiZiaWdzcWN1cDtcIjogXCLiqIZcIixcbiAgICAgIFwiJmJpZ3N0YXI7XCI6IFwi4piFXCIsXG4gICAgICBcIiZiaWd0cmlhbmdsZWRvd247XCI6IFwi4pa9XCIsXG4gICAgICBcIiZiaWd0cmlhbmdsZXVwO1wiOiBcIuKWs1wiLFxuICAgICAgXCImYmlndXBsdXM7XCI6IFwi4qiEXCIsXG4gICAgICBcIiZiaWd2ZWU7XCI6IFwi4ouBXCIsXG4gICAgICBcIiZiaWd3ZWRnZTtcIjogXCLii4BcIixcbiAgICAgIFwiJmJrYXJvdztcIjogXCLipI1cIixcbiAgICAgIFwiJmJsYWNrbG96ZW5nZTtcIjogXCLip6tcIixcbiAgICAgIFwiJmJsYWNrc3F1YXJlO1wiOiBcIuKWqlwiLFxuICAgICAgXCImYmxhY2t0cmlhbmdsZTtcIjogXCLilrRcIixcbiAgICAgIFwiJmJsYWNrdHJpYW5nbGVkb3duO1wiOiBcIuKWvlwiLFxuICAgICAgXCImYmxhY2t0cmlhbmdsZWxlZnQ7XCI6IFwi4peCXCIsXG4gICAgICBcIiZibGFja3RyaWFuZ2xlcmlnaHQ7XCI6IFwi4pa4XCIsXG4gICAgICBcIiZibGFuaztcIjogXCLikKNcIixcbiAgICAgIFwiJmJsazEyO1wiOiBcIuKWklwiLFxuICAgICAgXCImYmxrMTQ7XCI6IFwi4paRXCIsXG4gICAgICBcIiZibGszNDtcIjogXCLilpNcIixcbiAgICAgIFwiJmJsb2NrO1wiOiBcIuKWiFwiLFxuICAgICAgXCImYm5lO1wiOiBcIj3ig6VcIixcbiAgICAgIFwiJmJuZXF1aXY7XCI6IFwi4omh4oOlXCIsXG4gICAgICBcIiZibm90O1wiOiBcIuKMkFwiLFxuICAgICAgXCImYm9wZjtcIjogXCLwnZWTXCIsXG4gICAgICBcIiZib3Q7XCI6IFwi4oqlXCIsXG4gICAgICBcIiZib3R0b207XCI6IFwi4oqlXCIsXG4gICAgICBcIiZib3d0aWU7XCI6IFwi4ouIXCIsXG4gICAgICBcIiZib3hETDtcIjogXCLilZdcIixcbiAgICAgIFwiJmJveERSO1wiOiBcIuKVlFwiLFxuICAgICAgXCImYm94RGw7XCI6IFwi4pWWXCIsXG4gICAgICBcIiZib3hEcjtcIjogXCLilZNcIixcbiAgICAgIFwiJmJveEg7XCI6IFwi4pWQXCIsXG4gICAgICBcIiZib3hIRDtcIjogXCLilaZcIixcbiAgICAgIFwiJmJveEhVO1wiOiBcIuKVqVwiLFxuICAgICAgXCImYm94SGQ7XCI6IFwi4pWkXCIsXG4gICAgICBcIiZib3hIdTtcIjogXCLiladcIixcbiAgICAgIFwiJmJveFVMO1wiOiBcIuKVnVwiLFxuICAgICAgXCImYm94VVI7XCI6IFwi4pWaXCIsXG4gICAgICBcIiZib3hVbDtcIjogXCLilZxcIixcbiAgICAgIFwiJmJveFVyO1wiOiBcIuKVmVwiLFxuICAgICAgXCImYm94VjtcIjogXCLilZFcIixcbiAgICAgIFwiJmJveFZIO1wiOiBcIuKVrFwiLFxuICAgICAgXCImYm94Vkw7XCI6IFwi4pWjXCIsXG4gICAgICBcIiZib3hWUjtcIjogXCLilaBcIixcbiAgICAgIFwiJmJveFZoO1wiOiBcIuKVq1wiLFxuICAgICAgXCImYm94Vmw7XCI6IFwi4pWiXCIsXG4gICAgICBcIiZib3hWcjtcIjogXCLilZ9cIixcbiAgICAgIFwiJmJveGJveDtcIjogXCLip4lcIixcbiAgICAgIFwiJmJveGRMO1wiOiBcIuKVlVwiLFxuICAgICAgXCImYm94ZFI7XCI6IFwi4pWSXCIsXG4gICAgICBcIiZib3hkbDtcIjogXCLilJBcIixcbiAgICAgIFwiJmJveGRyO1wiOiBcIuKUjFwiLFxuICAgICAgXCImYm94aDtcIjogXCLilIBcIixcbiAgICAgIFwiJmJveGhEO1wiOiBcIuKVpVwiLFxuICAgICAgXCImYm94aFU7XCI6IFwi4pWoXCIsXG4gICAgICBcIiZib3hoZDtcIjogXCLilKxcIixcbiAgICAgIFwiJmJveGh1O1wiOiBcIuKUtFwiLFxuICAgICAgXCImYm94bWludXM7XCI6IFwi4oqfXCIsXG4gICAgICBcIiZib3hwbHVzO1wiOiBcIuKKnlwiLFxuICAgICAgXCImYm94dGltZXM7XCI6IFwi4oqgXCIsXG4gICAgICBcIiZib3h1TDtcIjogXCLilZtcIixcbiAgICAgIFwiJmJveHVSO1wiOiBcIuKVmFwiLFxuICAgICAgXCImYm94dWw7XCI6IFwi4pSYXCIsXG4gICAgICBcIiZib3h1cjtcIjogXCLilJRcIixcbiAgICAgIFwiJmJveHY7XCI6IFwi4pSCXCIsXG4gICAgICBcIiZib3h2SDtcIjogXCLilapcIixcbiAgICAgIFwiJmJveHZMO1wiOiBcIuKVoVwiLFxuICAgICAgXCImYm94dlI7XCI6IFwi4pWeXCIsXG4gICAgICBcIiZib3h2aDtcIjogXCLilLxcIixcbiAgICAgIFwiJmJveHZsO1wiOiBcIuKUpFwiLFxuICAgICAgXCImYm94dnI7XCI6IFwi4pScXCIsXG4gICAgICBcIiZicHJpbWU7XCI6IFwi4oC1XCIsXG4gICAgICBcIiZicmV2ZTtcIjogXCLLmFwiLFxuICAgICAgXCImYnJ2YmFyXCI6IFwiwqZcIixcbiAgICAgIFwiJmJydmJhcjtcIjogXCLCplwiLFxuICAgICAgXCImYnNjcjtcIjogXCLwnZK3XCIsXG4gICAgICBcIiZic2VtaTtcIjogXCLigY9cIixcbiAgICAgIFwiJmJzaW07XCI6IFwi4oi9XCIsXG4gICAgICBcIiZic2ltZTtcIjogXCLii41cIixcbiAgICAgIFwiJmJzb2w7XCI6IFwiXFxcXFwiLFxuICAgICAgXCImYnNvbGI7XCI6IFwi4qeFXCIsXG4gICAgICBcIiZic29saHN1YjtcIjogXCLin4hcIixcbiAgICAgIFwiJmJ1bGw7XCI6IFwi4oCiXCIsXG4gICAgICBcIiZidWxsZXQ7XCI6IFwi4oCiXCIsXG4gICAgICBcIiZidW1wO1wiOiBcIuKJjlwiLFxuICAgICAgXCImYnVtcEU7XCI6IFwi4qquXCIsXG4gICAgICBcIiZidW1wZTtcIjogXCLiiY9cIixcbiAgICAgIFwiJmJ1bXBlcTtcIjogXCLiiY9cIixcbiAgICAgIFwiJmNhY3V0ZTtcIjogXCLEh1wiLFxuICAgICAgXCImY2FwO1wiOiBcIuKIqVwiLFxuICAgICAgXCImY2FwYW5kO1wiOiBcIuKphFwiLFxuICAgICAgXCImY2FwYnJjdXA7XCI6IFwi4qmJXCIsXG4gICAgICBcIiZjYXBjYXA7XCI6IFwi4qmLXCIsXG4gICAgICBcIiZjYXBjdXA7XCI6IFwi4qmHXCIsXG4gICAgICBcIiZjYXBkb3Q7XCI6IFwi4qmAXCIsXG4gICAgICBcIiZjYXBzO1wiOiBcIuKIqe+4gFwiLFxuICAgICAgXCImY2FyZXQ7XCI6IFwi4oGBXCIsXG4gICAgICBcIiZjYXJvbjtcIjogXCLLh1wiLFxuICAgICAgXCImY2NhcHM7XCI6IFwi4qmNXCIsXG4gICAgICBcIiZjY2Fyb247XCI6IFwixI1cIixcbiAgICAgIFwiJmNjZWRpbFwiOiBcIsOnXCIsXG4gICAgICBcIiZjY2VkaWw7XCI6IFwiw6dcIixcbiAgICAgIFwiJmNjaXJjO1wiOiBcIsSJXCIsXG4gICAgICBcIiZjY3VwcztcIjogXCLiqYxcIixcbiAgICAgIFwiJmNjdXBzc207XCI6IFwi4qmQXCIsXG4gICAgICBcIiZjZG90O1wiOiBcIsSLXCIsXG4gICAgICBcIiZjZWRpbFwiOiBcIsK4XCIsXG4gICAgICBcIiZjZWRpbDtcIjogXCLCuFwiLFxuICAgICAgXCImY2VtcHR5djtcIjogXCLiprJcIixcbiAgICAgIFwiJmNlbnRcIjogXCLColwiLFxuICAgICAgXCImY2VudDtcIjogXCLColwiLFxuICAgICAgXCImY2VudGVyZG90O1wiOiBcIsK3XCIsXG4gICAgICBcIiZjZnI7XCI6IFwi8J2UoFwiLFxuICAgICAgXCImY2hjeTtcIjogXCLRh1wiLFxuICAgICAgXCImY2hlY2s7XCI6IFwi4pyTXCIsXG4gICAgICBcIiZjaGVja21hcms7XCI6IFwi4pyTXCIsXG4gICAgICBcIiZjaGk7XCI6IFwiz4dcIixcbiAgICAgIFwiJmNpcjtcIjogXCLil4tcIixcbiAgICAgIFwiJmNpckU7XCI6IFwi4qeDXCIsXG4gICAgICBcIiZjaXJjO1wiOiBcIsuGXCIsXG4gICAgICBcIiZjaXJjZXE7XCI6IFwi4omXXCIsXG4gICAgICBcIiZjaXJjbGVhcnJvd2xlZnQ7XCI6IFwi4oa6XCIsXG4gICAgICBcIiZjaXJjbGVhcnJvd3JpZ2h0O1wiOiBcIuKGu1wiLFxuICAgICAgXCImY2lyY2xlZFI7XCI6IFwiwq5cIixcbiAgICAgIFwiJmNpcmNsZWRTO1wiOiBcIuKTiFwiLFxuICAgICAgXCImY2lyY2xlZGFzdDtcIjogXCLiiptcIixcbiAgICAgIFwiJmNpcmNsZWRjaXJjO1wiOiBcIuKKmlwiLFxuICAgICAgXCImY2lyY2xlZGRhc2g7XCI6IFwi4oqdXCIsXG4gICAgICBcIiZjaXJlO1wiOiBcIuKJl1wiLFxuICAgICAgXCImY2lyZm5pbnQ7XCI6IFwi4qiQXCIsXG4gICAgICBcIiZjaXJtaWQ7XCI6IFwi4quvXCIsXG4gICAgICBcIiZjaXJzY2lyO1wiOiBcIuKnglwiLFxuICAgICAgXCImY2x1YnM7XCI6IFwi4pmjXCIsXG4gICAgICBcIiZjbHVic3VpdDtcIjogXCLimaNcIixcbiAgICAgIFwiJmNvbG9uO1wiOiBcIjpcIixcbiAgICAgIFwiJmNvbG9uZTtcIjogXCLiiZRcIixcbiAgICAgIFwiJmNvbG9uZXE7XCI6IFwi4omUXCIsXG4gICAgICBcIiZjb21tYTtcIjogXCIsXCIsXG4gICAgICBcIiZjb21tYXQ7XCI6IFwiQFwiLFxuICAgICAgXCImY29tcDtcIjogXCLiiIFcIixcbiAgICAgIFwiJmNvbXBmbjtcIjogXCLiiJhcIixcbiAgICAgIFwiJmNvbXBsZW1lbnQ7XCI6IFwi4oiBXCIsXG4gICAgICBcIiZjb21wbGV4ZXM7XCI6IFwi4oSCXCIsXG4gICAgICBcIiZjb25nO1wiOiBcIuKJhVwiLFxuICAgICAgXCImY29uZ2RvdDtcIjogXCLiqa1cIixcbiAgICAgIFwiJmNvbmludDtcIjogXCLiiK5cIixcbiAgICAgIFwiJmNvcGY7XCI6IFwi8J2VlFwiLFxuICAgICAgXCImY29wcm9kO1wiOiBcIuKIkFwiLFxuICAgICAgXCImY29weVwiOiBcIsKpXCIsXG4gICAgICBcIiZjb3B5O1wiOiBcIsKpXCIsXG4gICAgICBcIiZjb3B5c3I7XCI6IFwi4oSXXCIsXG4gICAgICBcIiZjcmFycjtcIjogXCLihrVcIixcbiAgICAgIFwiJmNyb3NzO1wiOiBcIuKcl1wiLFxuICAgICAgXCImY3NjcjtcIjogXCLwnZK4XCIsXG4gICAgICBcIiZjc3ViO1wiOiBcIuKrj1wiLFxuICAgICAgXCImY3N1YmU7XCI6IFwi4quRXCIsXG4gICAgICBcIiZjc3VwO1wiOiBcIuKrkFwiLFxuICAgICAgXCImY3N1cGU7XCI6IFwi4quSXCIsXG4gICAgICBcIiZjdGRvdDtcIjogXCLii69cIixcbiAgICAgIFwiJmN1ZGFycmw7XCI6IFwi4qS4XCIsXG4gICAgICBcIiZjdWRhcnJyO1wiOiBcIuKktVwiLFxuICAgICAgXCImY3VlcHI7XCI6IFwi4oueXCIsXG4gICAgICBcIiZjdWVzYztcIjogXCLii59cIixcbiAgICAgIFwiJmN1bGFycjtcIjogXCLihrZcIixcbiAgICAgIFwiJmN1bGFycnA7XCI6IFwi4qS9XCIsXG4gICAgICBcIiZjdXA7XCI6IFwi4oiqXCIsXG4gICAgICBcIiZjdXBicmNhcDtcIjogXCLiqYhcIixcbiAgICAgIFwiJmN1cGNhcDtcIjogXCLiqYZcIixcbiAgICAgIFwiJmN1cGN1cDtcIjogXCLiqYpcIixcbiAgICAgIFwiJmN1cGRvdDtcIjogXCLiio1cIixcbiAgICAgIFwiJmN1cG9yO1wiOiBcIuKphVwiLFxuICAgICAgXCImY3VwcztcIjogXCLiiKrvuIBcIixcbiAgICAgIFwiJmN1cmFycjtcIjogXCLihrdcIixcbiAgICAgIFwiJmN1cmFycm07XCI6IFwi4qS8XCIsXG4gICAgICBcIiZjdXJseWVxcHJlYztcIjogXCLii55cIixcbiAgICAgIFwiJmN1cmx5ZXFzdWNjO1wiOiBcIuKLn1wiLFxuICAgICAgXCImY3VybHl2ZWU7XCI6IFwi4ouOXCIsXG4gICAgICBcIiZjdXJseXdlZGdlO1wiOiBcIuKLj1wiLFxuICAgICAgXCImY3VycmVuXCI6IFwiwqRcIixcbiAgICAgIFwiJmN1cnJlbjtcIjogXCLCpFwiLFxuICAgICAgXCImY3VydmVhcnJvd2xlZnQ7XCI6IFwi4oa2XCIsXG4gICAgICBcIiZjdXJ2ZWFycm93cmlnaHQ7XCI6IFwi4oa3XCIsXG4gICAgICBcIiZjdXZlZTtcIjogXCLii45cIixcbiAgICAgIFwiJmN1d2VkO1wiOiBcIuKLj1wiLFxuICAgICAgXCImY3djb25pbnQ7XCI6IFwi4oiyXCIsXG4gICAgICBcIiZjd2ludDtcIjogXCLiiLFcIixcbiAgICAgIFwiJmN5bGN0eTtcIjogXCLijK1cIixcbiAgICAgIFwiJmRBcnI7XCI6IFwi4oeTXCIsXG4gICAgICBcIiZkSGFyO1wiOiBcIuKlpVwiLFxuICAgICAgXCImZGFnZ2VyO1wiOiBcIuKAoFwiLFxuICAgICAgXCImZGFsZXRoO1wiOiBcIuKEuFwiLFxuICAgICAgXCImZGFycjtcIjogXCLihpNcIixcbiAgICAgIFwiJmRhc2g7XCI6IFwi4oCQXCIsXG4gICAgICBcIiZkYXNodjtcIjogXCLiiqNcIixcbiAgICAgIFwiJmRia2Fyb3c7XCI6IFwi4qSPXCIsXG4gICAgICBcIiZkYmxhYztcIjogXCLLnVwiLFxuICAgICAgXCImZGNhcm9uO1wiOiBcIsSPXCIsXG4gICAgICBcIiZkY3k7XCI6IFwi0LRcIixcbiAgICAgIFwiJmRkO1wiOiBcIuKFhlwiLFxuICAgICAgXCImZGRhZ2dlcjtcIjogXCLigKFcIixcbiAgICAgIFwiJmRkYXJyO1wiOiBcIuKHilwiLFxuICAgICAgXCImZGRvdHNlcTtcIjogXCLiqbdcIixcbiAgICAgIFwiJmRlZ1wiOiBcIsKwXCIsXG4gICAgICBcIiZkZWc7XCI6IFwiwrBcIixcbiAgICAgIFwiJmRlbHRhO1wiOiBcIs60XCIsXG4gICAgICBcIiZkZW1wdHl2O1wiOiBcIuKmsVwiLFxuICAgICAgXCImZGZpc2h0O1wiOiBcIuKlv1wiLFxuICAgICAgXCImZGZyO1wiOiBcIvCdlKFcIixcbiAgICAgIFwiJmRoYXJsO1wiOiBcIuKHg1wiLFxuICAgICAgXCImZGhhcnI7XCI6IFwi4oeCXCIsXG4gICAgICBcIiZkaWFtO1wiOiBcIuKLhFwiLFxuICAgICAgXCImZGlhbW9uZDtcIjogXCLii4RcIixcbiAgICAgIFwiJmRpYW1vbmRzdWl0O1wiOiBcIuKZplwiLFxuICAgICAgXCImZGlhbXM7XCI6IFwi4pmmXCIsXG4gICAgICBcIiZkaWU7XCI6IFwiwqhcIixcbiAgICAgIFwiJmRpZ2FtbWE7XCI6IFwiz51cIixcbiAgICAgIFwiJmRpc2luO1wiOiBcIuKLslwiLFxuICAgICAgXCImZGl2O1wiOiBcIsO3XCIsXG4gICAgICBcIiZkaXZpZGVcIjogXCLDt1wiLFxuICAgICAgXCImZGl2aWRlO1wiOiBcIsO3XCIsXG4gICAgICBcIiZkaXZpZGVvbnRpbWVzO1wiOiBcIuKLh1wiLFxuICAgICAgXCImZGl2b254O1wiOiBcIuKLh1wiLFxuICAgICAgXCImZGpjeTtcIjogXCLRklwiLFxuICAgICAgXCImZGxjb3JuO1wiOiBcIuKMnlwiLFxuICAgICAgXCImZGxjcm9wO1wiOiBcIuKMjVwiLFxuICAgICAgXCImZG9sbGFyO1wiOiBcIiRcIixcbiAgICAgIFwiJmRvcGY7XCI6IFwi8J2VlVwiLFxuICAgICAgXCImZG90O1wiOiBcIsuZXCIsXG4gICAgICBcIiZkb3RlcTtcIjogXCLiiZBcIixcbiAgICAgIFwiJmRvdGVxZG90O1wiOiBcIuKJkVwiLFxuICAgICAgXCImZG90bWludXM7XCI6IFwi4oi4XCIsXG4gICAgICBcIiZkb3RwbHVzO1wiOiBcIuKIlFwiLFxuICAgICAgXCImZG90c3F1YXJlO1wiOiBcIuKKoVwiLFxuICAgICAgXCImZG91YmxlYmFyd2VkZ2U7XCI6IFwi4oyGXCIsXG4gICAgICBcIiZkb3duYXJyb3c7XCI6IFwi4oaTXCIsXG4gICAgICBcIiZkb3duZG93bmFycm93cztcIjogXCLih4pcIixcbiAgICAgIFwiJmRvd25oYXJwb29ubGVmdDtcIjogXCLih4NcIixcbiAgICAgIFwiJmRvd25oYXJwb29ucmlnaHQ7XCI6IFwi4oeCXCIsXG4gICAgICBcIiZkcmJrYXJvdztcIjogXCLipJBcIixcbiAgICAgIFwiJmRyY29ybjtcIjogXCLijJ9cIixcbiAgICAgIFwiJmRyY3JvcDtcIjogXCLijIxcIixcbiAgICAgIFwiJmRzY3I7XCI6IFwi8J2SuVwiLFxuICAgICAgXCImZHNjeTtcIjogXCLRlVwiLFxuICAgICAgXCImZHNvbDtcIjogXCLip7ZcIixcbiAgICAgIFwiJmRzdHJvaztcIjogXCLEkVwiLFxuICAgICAgXCImZHRkb3Q7XCI6IFwi4ouxXCIsXG4gICAgICBcIiZkdHJpO1wiOiBcIuKWv1wiLFxuICAgICAgXCImZHRyaWY7XCI6IFwi4pa+XCIsXG4gICAgICBcIiZkdWFycjtcIjogXCLih7VcIixcbiAgICAgIFwiJmR1aGFyO1wiOiBcIuKlr1wiLFxuICAgICAgXCImZHdhbmdsZTtcIjogXCLipqZcIixcbiAgICAgIFwiJmR6Y3k7XCI6IFwi0Z9cIixcbiAgICAgIFwiJmR6aWdyYXJyO1wiOiBcIuKfv1wiLFxuICAgICAgXCImZUREb3Q7XCI6IFwi4qm3XCIsXG4gICAgICBcIiZlRG90O1wiOiBcIuKJkVwiLFxuICAgICAgXCImZWFjdXRlXCI6IFwiw6lcIixcbiAgICAgIFwiJmVhY3V0ZTtcIjogXCLDqVwiLFxuICAgICAgXCImZWFzdGVyO1wiOiBcIuKprlwiLFxuICAgICAgXCImZWNhcm9uO1wiOiBcIsSbXCIsXG4gICAgICBcIiZlY2lyO1wiOiBcIuKJllwiLFxuICAgICAgXCImZWNpcmNcIjogXCLDqlwiLFxuICAgICAgXCImZWNpcmM7XCI6IFwiw6pcIixcbiAgICAgIFwiJmVjb2xvbjtcIjogXCLiiZVcIixcbiAgICAgIFwiJmVjeTtcIjogXCLRjVwiLFxuICAgICAgXCImZWRvdDtcIjogXCLEl1wiLFxuICAgICAgXCImZWU7XCI6IFwi4oWHXCIsXG4gICAgICBcIiZlZkRvdDtcIjogXCLiiZJcIixcbiAgICAgIFwiJmVmcjtcIjogXCLwnZSiXCIsXG4gICAgICBcIiZlZztcIjogXCLiqppcIixcbiAgICAgIFwiJmVncmF2ZVwiOiBcIsOoXCIsXG4gICAgICBcIiZlZ3JhdmU7XCI6IFwiw6hcIixcbiAgICAgIFwiJmVncztcIjogXCLiqpZcIixcbiAgICAgIFwiJmVnc2RvdDtcIjogXCLiqphcIixcbiAgICAgIFwiJmVsO1wiOiBcIuKqmVwiLFxuICAgICAgXCImZWxpbnRlcnM7XCI6IFwi4o+nXCIsXG4gICAgICBcIiZlbGw7XCI6IFwi4oSTXCIsXG4gICAgICBcIiZlbHM7XCI6IFwi4qqVXCIsXG4gICAgICBcIiZlbHNkb3Q7XCI6IFwi4qqXXCIsXG4gICAgICBcIiZlbWFjcjtcIjogXCLEk1wiLFxuICAgICAgXCImZW1wdHk7XCI6IFwi4oiFXCIsXG4gICAgICBcIiZlbXB0eXNldDtcIjogXCLiiIVcIixcbiAgICAgIFwiJmVtcHR5djtcIjogXCLiiIVcIixcbiAgICAgIFwiJmVtc3AxMztcIjogXCLigIRcIixcbiAgICAgIFwiJmVtc3AxNDtcIjogXCLigIVcIixcbiAgICAgIFwiJmVtc3A7XCI6IFwi4oCDXCIsXG4gICAgICBcIiZlbmc7XCI6IFwixYtcIixcbiAgICAgIFwiJmVuc3A7XCI6IFwi4oCCXCIsXG4gICAgICBcIiZlb2dvbjtcIjogXCLEmVwiLFxuICAgICAgXCImZW9wZjtcIjogXCLwnZWWXCIsXG4gICAgICBcIiZlcGFyO1wiOiBcIuKLlVwiLFxuICAgICAgXCImZXBhcnNsO1wiOiBcIuKno1wiLFxuICAgICAgXCImZXBsdXM7XCI6IFwi4qmxXCIsXG4gICAgICBcIiZlcHNpO1wiOiBcIs61XCIsXG4gICAgICBcIiZlcHNpbG9uO1wiOiBcIs61XCIsXG4gICAgICBcIiZlcHNpdjtcIjogXCLPtVwiLFxuICAgICAgXCImZXFjaXJjO1wiOiBcIuKJllwiLFxuICAgICAgXCImZXFjb2xvbjtcIjogXCLiiZVcIixcbiAgICAgIFwiJmVxc2ltO1wiOiBcIuKJglwiLFxuICAgICAgXCImZXFzbGFudGd0cjtcIjogXCLiqpZcIixcbiAgICAgIFwiJmVxc2xhbnRsZXNzO1wiOiBcIuKqlVwiLFxuICAgICAgXCImZXF1YWxzO1wiOiBcIj1cIixcbiAgICAgIFwiJmVxdWVzdDtcIjogXCLiiZ9cIixcbiAgICAgIFwiJmVxdWl2O1wiOiBcIuKJoVwiLFxuICAgICAgXCImZXF1aXZERDtcIjogXCLiqbhcIixcbiAgICAgIFwiJmVxdnBhcnNsO1wiOiBcIuKnpVwiLFxuICAgICAgXCImZXJEb3Q7XCI6IFwi4omTXCIsXG4gICAgICBcIiZlcmFycjtcIjogXCLipbFcIixcbiAgICAgIFwiJmVzY3I7XCI6IFwi4oSvXCIsXG4gICAgICBcIiZlc2RvdDtcIjogXCLiiZBcIixcbiAgICAgIFwiJmVzaW07XCI6IFwi4omCXCIsXG4gICAgICBcIiZldGE7XCI6IFwizrdcIixcbiAgICAgIFwiJmV0aFwiOiBcIsOwXCIsXG4gICAgICBcIiZldGg7XCI6IFwiw7BcIixcbiAgICAgIFwiJmV1bWxcIjogXCLDq1wiLFxuICAgICAgXCImZXVtbDtcIjogXCLDq1wiLFxuICAgICAgXCImZXVybztcIjogXCLigqxcIixcbiAgICAgIFwiJmV4Y2w7XCI6IFwiIVwiLFxuICAgICAgXCImZXhpc3Q7XCI6IFwi4oiDXCIsXG4gICAgICBcIiZleHBlY3RhdGlvbjtcIjogXCLihLBcIixcbiAgICAgIFwiJmV4cG9uZW50aWFsZTtcIjogXCLihYdcIixcbiAgICAgIFwiJmZhbGxpbmdkb3RzZXE7XCI6IFwi4omSXCIsXG4gICAgICBcIiZmY3k7XCI6IFwi0YRcIixcbiAgICAgIFwiJmZlbWFsZTtcIjogXCLimYBcIixcbiAgICAgIFwiJmZmaWxpZztcIjogXCLvrINcIixcbiAgICAgIFwiJmZmbGlnO1wiOiBcIu+sgFwiLFxuICAgICAgXCImZmZsbGlnO1wiOiBcIu+shFwiLFxuICAgICAgXCImZmZyO1wiOiBcIvCdlKNcIixcbiAgICAgIFwiJmZpbGlnO1wiOiBcIu+sgVwiLFxuICAgICAgXCImZmpsaWc7XCI6IFwiZmpcIixcbiAgICAgIFwiJmZsYXQ7XCI6IFwi4pmtXCIsXG4gICAgICBcIiZmbGxpZztcIjogXCLvrIJcIixcbiAgICAgIFwiJmZsdG5zO1wiOiBcIuKWsVwiLFxuICAgICAgXCImZm5vZjtcIjogXCLGklwiLFxuICAgICAgXCImZm9wZjtcIjogXCLwnZWXXCIsXG4gICAgICBcIiZmb3JhbGw7XCI6IFwi4oiAXCIsXG4gICAgICBcIiZmb3JrO1wiOiBcIuKLlFwiLFxuICAgICAgXCImZm9ya3Y7XCI6IFwi4quZXCIsXG4gICAgICBcIiZmcGFydGludDtcIjogXCLiqI1cIixcbiAgICAgIFwiJmZyYWMxMlwiOiBcIsK9XCIsXG4gICAgICBcIiZmcmFjMTI7XCI6IFwiwr1cIixcbiAgICAgIFwiJmZyYWMxMztcIjogXCLihZNcIixcbiAgICAgIFwiJmZyYWMxNFwiOiBcIsK8XCIsXG4gICAgICBcIiZmcmFjMTQ7XCI6IFwiwrxcIixcbiAgICAgIFwiJmZyYWMxNTtcIjogXCLihZVcIixcbiAgICAgIFwiJmZyYWMxNjtcIjogXCLihZlcIixcbiAgICAgIFwiJmZyYWMxODtcIjogXCLihZtcIixcbiAgICAgIFwiJmZyYWMyMztcIjogXCLihZRcIixcbiAgICAgIFwiJmZyYWMyNTtcIjogXCLihZZcIixcbiAgICAgIFwiJmZyYWMzNFwiOiBcIsK+XCIsXG4gICAgICBcIiZmcmFjMzQ7XCI6IFwiwr5cIixcbiAgICAgIFwiJmZyYWMzNTtcIjogXCLihZdcIixcbiAgICAgIFwiJmZyYWMzODtcIjogXCLihZxcIixcbiAgICAgIFwiJmZyYWM0NTtcIjogXCLihZhcIixcbiAgICAgIFwiJmZyYWM1NjtcIjogXCLihZpcIixcbiAgICAgIFwiJmZyYWM1ODtcIjogXCLihZ1cIixcbiAgICAgIFwiJmZyYWM3ODtcIjogXCLihZ5cIixcbiAgICAgIFwiJmZyYXNsO1wiOiBcIuKBhFwiLFxuICAgICAgXCImZnJvd247XCI6IFwi4oyiXCIsXG4gICAgICBcIiZmc2NyO1wiOiBcIvCdkrtcIixcbiAgICAgIFwiJmdFO1wiOiBcIuKJp1wiLFxuICAgICAgXCImZ0VsO1wiOiBcIuKqjFwiLFxuICAgICAgXCImZ2FjdXRlO1wiOiBcIse1XCIsXG4gICAgICBcIiZnYW1tYTtcIjogXCLOs1wiLFxuICAgICAgXCImZ2FtbWFkO1wiOiBcIs+dXCIsXG4gICAgICBcIiZnYXA7XCI6IFwi4qqGXCIsXG4gICAgICBcIiZnYnJldmU7XCI6IFwixJ9cIixcbiAgICAgIFwiJmdjaXJjO1wiOiBcIsSdXCIsXG4gICAgICBcIiZnY3k7XCI6IFwi0LNcIixcbiAgICAgIFwiJmdkb3Q7XCI6IFwixKFcIixcbiAgICAgIFwiJmdlO1wiOiBcIuKJpVwiLFxuICAgICAgXCImZ2VsO1wiOiBcIuKLm1wiLFxuICAgICAgXCImZ2VxO1wiOiBcIuKJpVwiLFxuICAgICAgXCImZ2VxcTtcIjogXCLiiadcIixcbiAgICAgIFwiJmdlcXNsYW50O1wiOiBcIuKpvlwiLFxuICAgICAgXCImZ2VzO1wiOiBcIuKpvlwiLFxuICAgICAgXCImZ2VzY2M7XCI6IFwi4qqpXCIsXG4gICAgICBcIiZnZXNkb3Q7XCI6IFwi4qqAXCIsXG4gICAgICBcIiZnZXNkb3RvO1wiOiBcIuKqglwiLFxuICAgICAgXCImZ2VzZG90b2w7XCI6IFwi4qqEXCIsXG4gICAgICBcIiZnZXNsO1wiOiBcIuKLm++4gFwiLFxuICAgICAgXCImZ2VzbGVzO1wiOiBcIuKqlFwiLFxuICAgICAgXCImZ2ZyO1wiOiBcIvCdlKRcIixcbiAgICAgIFwiJmdnO1wiOiBcIuKJq1wiLFxuICAgICAgXCImZ2dnO1wiOiBcIuKLmVwiLFxuICAgICAgXCImZ2ltZWw7XCI6IFwi4oS3XCIsXG4gICAgICBcIiZnamN5O1wiOiBcItGTXCIsXG4gICAgICBcIiZnbDtcIjogXCLiibdcIixcbiAgICAgIFwiJmdsRTtcIjogXCLiqpJcIixcbiAgICAgIFwiJmdsYTtcIjogXCLiqqVcIixcbiAgICAgIFwiJmdsajtcIjogXCLiqqRcIixcbiAgICAgIFwiJmduRTtcIjogXCLiialcIixcbiAgICAgIFwiJmduYXA7XCI6IFwi4qqKXCIsXG4gICAgICBcIiZnbmFwcHJveDtcIjogXCLiqopcIixcbiAgICAgIFwiJmduZTtcIjogXCLiqohcIixcbiAgICAgIFwiJmduZXE7XCI6IFwi4qqIXCIsXG4gICAgICBcIiZnbmVxcTtcIjogXCLiialcIixcbiAgICAgIFwiJmduc2ltO1wiOiBcIuKLp1wiLFxuICAgICAgXCImZ29wZjtcIjogXCLwnZWYXCIsXG4gICAgICBcIiZncmF2ZTtcIjogXCJgXCIsXG4gICAgICBcIiZnc2NyO1wiOiBcIuKEilwiLFxuICAgICAgXCImZ3NpbTtcIjogXCLiibNcIixcbiAgICAgIFwiJmdzaW1lO1wiOiBcIuKqjlwiLFxuICAgICAgXCImZ3NpbWw7XCI6IFwi4qqQXCIsXG4gICAgICBcIiZndFwiOiBcIj5cIixcbiAgICAgIFwiJmd0O1wiOiBcIj5cIixcbiAgICAgIFwiJmd0Y2M7XCI6IFwi4qqnXCIsXG4gICAgICBcIiZndGNpcjtcIjogXCLiqbpcIixcbiAgICAgIFwiJmd0ZG90O1wiOiBcIuKLl1wiLFxuICAgICAgXCImZ3RsUGFyO1wiOiBcIuKmlVwiLFxuICAgICAgXCImZ3RxdWVzdDtcIjogXCLiqbxcIixcbiAgICAgIFwiJmd0cmFwcHJveDtcIjogXCLiqoZcIixcbiAgICAgIFwiJmd0cmFycjtcIjogXCLipbhcIixcbiAgICAgIFwiJmd0cmRvdDtcIjogXCLii5dcIixcbiAgICAgIFwiJmd0cmVxbGVzcztcIjogXCLii5tcIixcbiAgICAgIFwiJmd0cmVxcWxlc3M7XCI6IFwi4qqMXCIsXG4gICAgICBcIiZndHJsZXNzO1wiOiBcIuKJt1wiLFxuICAgICAgXCImZ3Ryc2ltO1wiOiBcIuKJs1wiLFxuICAgICAgXCImZ3ZlcnRuZXFxO1wiOiBcIuKJqe+4gFwiLFxuICAgICAgXCImZ3ZuRTtcIjogXCLiianvuIBcIixcbiAgICAgIFwiJmhBcnI7XCI6IFwi4oeUXCIsXG4gICAgICBcIiZoYWlyc3A7XCI6IFwi4oCKXCIsXG4gICAgICBcIiZoYWxmO1wiOiBcIsK9XCIsXG4gICAgICBcIiZoYW1pbHQ7XCI6IFwi4oSLXCIsXG4gICAgICBcIiZoYXJkY3k7XCI6IFwi0YpcIixcbiAgICAgIFwiJmhhcnI7XCI6IFwi4oaUXCIsXG4gICAgICBcIiZoYXJyY2lyO1wiOiBcIuKliFwiLFxuICAgICAgXCImaGFycnc7XCI6IFwi4oatXCIsXG4gICAgICBcIiZoYmFyO1wiOiBcIuKEj1wiLFxuICAgICAgXCImaGNpcmM7XCI6IFwixKVcIixcbiAgICAgIFwiJmhlYXJ0cztcIjogXCLimaVcIixcbiAgICAgIFwiJmhlYXJ0c3VpdDtcIjogXCLimaVcIixcbiAgICAgIFwiJmhlbGxpcDtcIjogXCLigKZcIixcbiAgICAgIFwiJmhlcmNvbjtcIjogXCLiirlcIixcbiAgICAgIFwiJmhmcjtcIjogXCLwnZSlXCIsXG4gICAgICBcIiZoa3NlYXJvdztcIjogXCLipKVcIixcbiAgICAgIFwiJmhrc3dhcm93O1wiOiBcIuKkplwiLFxuICAgICAgXCImaG9hcnI7XCI6IFwi4oe/XCIsXG4gICAgICBcIiZob210aHQ7XCI6IFwi4oi7XCIsXG4gICAgICBcIiZob29rbGVmdGFycm93O1wiOiBcIuKGqVwiLFxuICAgICAgXCImaG9va3JpZ2h0YXJyb3c7XCI6IFwi4oaqXCIsXG4gICAgICBcIiZob3BmO1wiOiBcIvCdlZlcIixcbiAgICAgIFwiJmhvcmJhcjtcIjogXCLigJVcIixcbiAgICAgIFwiJmhzY3I7XCI6IFwi8J2SvVwiLFxuICAgICAgXCImaHNsYXNoO1wiOiBcIuKEj1wiLFxuICAgICAgXCImaHN0cm9rO1wiOiBcIsSnXCIsXG4gICAgICBcIiZoeWJ1bGw7XCI6IFwi4oGDXCIsXG4gICAgICBcIiZoeXBoZW47XCI6IFwi4oCQXCIsXG4gICAgICBcIiZpYWN1dGVcIjogXCLDrVwiLFxuICAgICAgXCImaWFjdXRlO1wiOiBcIsOtXCIsXG4gICAgICBcIiZpYztcIjogXCLigaNcIixcbiAgICAgIFwiJmljaXJjXCI6IFwiw65cIixcbiAgICAgIFwiJmljaXJjO1wiOiBcIsOuXCIsXG4gICAgICBcIiZpY3k7XCI6IFwi0LhcIixcbiAgICAgIFwiJmllY3k7XCI6IFwi0LVcIixcbiAgICAgIFwiJmlleGNsXCI6IFwiwqFcIixcbiAgICAgIFwiJmlleGNsO1wiOiBcIsKhXCIsXG4gICAgICBcIiZpZmY7XCI6IFwi4oeUXCIsXG4gICAgICBcIiZpZnI7XCI6IFwi8J2UplwiLFxuICAgICAgXCImaWdyYXZlXCI6IFwiw6xcIixcbiAgICAgIFwiJmlncmF2ZTtcIjogXCLDrFwiLFxuICAgICAgXCImaWk7XCI6IFwi4oWIXCIsXG4gICAgICBcIiZpaWlpbnQ7XCI6IFwi4qiMXCIsXG4gICAgICBcIiZpaWludDtcIjogXCLiiK1cIixcbiAgICAgIFwiJmlpbmZpbjtcIjogXCLip5xcIixcbiAgICAgIFwiJmlpb3RhO1wiOiBcIuKEqVwiLFxuICAgICAgXCImaWpsaWc7XCI6IFwixLNcIixcbiAgICAgIFwiJmltYWNyO1wiOiBcIsSrXCIsXG4gICAgICBcIiZpbWFnZTtcIjogXCLihJFcIixcbiAgICAgIFwiJmltYWdsaW5lO1wiOiBcIuKEkFwiLFxuICAgICAgXCImaW1hZ3BhcnQ7XCI6IFwi4oSRXCIsXG4gICAgICBcIiZpbWF0aDtcIjogXCLEsVwiLFxuICAgICAgXCImaW1vZjtcIjogXCLiirdcIixcbiAgICAgIFwiJmltcGVkO1wiOiBcIsa1XCIsXG4gICAgICBcIiZpbjtcIjogXCLiiIhcIixcbiAgICAgIFwiJmluY2FyZTtcIjogXCLihIVcIixcbiAgICAgIFwiJmluZmluO1wiOiBcIuKInlwiLFxuICAgICAgXCImaW5maW50aWU7XCI6IFwi4qedXCIsXG4gICAgICBcIiZpbm9kb3Q7XCI6IFwixLFcIixcbiAgICAgIFwiJmludDtcIjogXCLiiKtcIixcbiAgICAgIFwiJmludGNhbDtcIjogXCLiirpcIixcbiAgICAgIFwiJmludGVnZXJzO1wiOiBcIuKEpFwiLFxuICAgICAgXCImaW50ZXJjYWw7XCI6IFwi4oq6XCIsXG4gICAgICBcIiZpbnRsYXJoaztcIjogXCLiqJdcIixcbiAgICAgIFwiJmludHByb2Q7XCI6IFwi4qi8XCIsXG4gICAgICBcIiZpb2N5O1wiOiBcItGRXCIsXG4gICAgICBcIiZpb2dvbjtcIjogXCLEr1wiLFxuICAgICAgXCImaW9wZjtcIjogXCLwnZWaXCIsXG4gICAgICBcIiZpb3RhO1wiOiBcIs65XCIsXG4gICAgICBcIiZpcHJvZDtcIjogXCLiqLxcIixcbiAgICAgIFwiJmlxdWVzdFwiOiBcIsK/XCIsXG4gICAgICBcIiZpcXVlc3Q7XCI6IFwiwr9cIixcbiAgICAgIFwiJmlzY3I7XCI6IFwi8J2SvlwiLFxuICAgICAgXCImaXNpbjtcIjogXCLiiIhcIixcbiAgICAgIFwiJmlzaW5FO1wiOiBcIuKLuVwiLFxuICAgICAgXCImaXNpbmRvdDtcIjogXCLii7VcIixcbiAgICAgIFwiJmlzaW5zO1wiOiBcIuKLtFwiLFxuICAgICAgXCImaXNpbnN2O1wiOiBcIuKLs1wiLFxuICAgICAgXCImaXNpbnY7XCI6IFwi4oiIXCIsXG4gICAgICBcIiZpdDtcIjogXCLigaJcIixcbiAgICAgIFwiJml0aWxkZTtcIjogXCLEqVwiLFxuICAgICAgXCImaXVrY3k7XCI6IFwi0ZZcIixcbiAgICAgIFwiJml1bWxcIjogXCLDr1wiLFxuICAgICAgXCImaXVtbDtcIjogXCLDr1wiLFxuICAgICAgXCImamNpcmM7XCI6IFwixLVcIixcbiAgICAgIFwiJmpjeTtcIjogXCLQuVwiLFxuICAgICAgXCImamZyO1wiOiBcIvCdlKdcIixcbiAgICAgIFwiJmptYXRoO1wiOiBcIsi3XCIsXG4gICAgICBcIiZqb3BmO1wiOiBcIvCdlZtcIixcbiAgICAgIFwiJmpzY3I7XCI6IFwi8J2Sv1wiLFxuICAgICAgXCImanNlcmN5O1wiOiBcItGYXCIsXG4gICAgICBcIiZqdWtjeTtcIjogXCLRlFwiLFxuICAgICAgXCIma2FwcGE7XCI6IFwizrpcIixcbiAgICAgIFwiJmthcHBhdjtcIjogXCLPsFwiLFxuICAgICAgXCIma2NlZGlsO1wiOiBcIsS3XCIsXG4gICAgICBcIiZrY3k7XCI6IFwi0LpcIixcbiAgICAgIFwiJmtmcjtcIjogXCLwnZSoXCIsXG4gICAgICBcIiZrZ3JlZW47XCI6IFwixLhcIixcbiAgICAgIFwiJmtoY3k7XCI6IFwi0YVcIixcbiAgICAgIFwiJmtqY3k7XCI6IFwi0ZxcIixcbiAgICAgIFwiJmtvcGY7XCI6IFwi8J2VnFwiLFxuICAgICAgXCIma3NjcjtcIjogXCLwnZOAXCIsXG4gICAgICBcIiZsQWFycjtcIjogXCLih5pcIixcbiAgICAgIFwiJmxBcnI7XCI6IFwi4oeQXCIsXG4gICAgICBcIiZsQXRhaWw7XCI6IFwi4qSbXCIsXG4gICAgICBcIiZsQmFycjtcIjogXCLipI5cIixcbiAgICAgIFwiJmxFO1wiOiBcIuKJplwiLFxuICAgICAgXCImbEVnO1wiOiBcIuKqi1wiLFxuICAgICAgXCImbEhhcjtcIjogXCLipaJcIixcbiAgICAgIFwiJmxhY3V0ZTtcIjogXCLEulwiLFxuICAgICAgXCImbGFlbXB0eXY7XCI6IFwi4qa0XCIsXG4gICAgICBcIiZsYWdyYW47XCI6IFwi4oSSXCIsXG4gICAgICBcIiZsYW1iZGE7XCI6IFwizrtcIixcbiAgICAgIFwiJmxhbmc7XCI6IFwi4p+oXCIsXG4gICAgICBcIiZsYW5nZDtcIjogXCLippFcIixcbiAgICAgIFwiJmxhbmdsZTtcIjogXCLin6hcIixcbiAgICAgIFwiJmxhcDtcIjogXCLiqoVcIixcbiAgICAgIFwiJmxhcXVvXCI6IFwiwqtcIixcbiAgICAgIFwiJmxhcXVvO1wiOiBcIsKrXCIsXG4gICAgICBcIiZsYXJyO1wiOiBcIuKGkFwiLFxuICAgICAgXCImbGFycmI7XCI6IFwi4oekXCIsXG4gICAgICBcIiZsYXJyYmZzO1wiOiBcIuKkn1wiLFxuICAgICAgXCImbGFycmZzO1wiOiBcIuKknVwiLFxuICAgICAgXCImbGFycmhrO1wiOiBcIuKGqVwiLFxuICAgICAgXCImbGFycmxwO1wiOiBcIuKGq1wiLFxuICAgICAgXCImbGFycnBsO1wiOiBcIuKkuVwiLFxuICAgICAgXCImbGFycnNpbTtcIjogXCLipbNcIixcbiAgICAgIFwiJmxhcnJ0bDtcIjogXCLihqJcIixcbiAgICAgIFwiJmxhdDtcIjogXCLiqqtcIixcbiAgICAgIFwiJmxhdGFpbDtcIjogXCLipJlcIixcbiAgICAgIFwiJmxhdGU7XCI6IFwi4qqtXCIsXG4gICAgICBcIiZsYXRlcztcIjogXCLiqq3vuIBcIixcbiAgICAgIFwiJmxiYXJyO1wiOiBcIuKkjFwiLFxuICAgICAgXCImbGJicms7XCI6IFwi4p2yXCIsXG4gICAgICBcIiZsYnJhY2U7XCI6IFwie1wiLFxuICAgICAgXCImbGJyYWNrO1wiOiBcIltcIixcbiAgICAgIFwiJmxicmtlO1wiOiBcIuKmi1wiLFxuICAgICAgXCImbGJya3NsZDtcIjogXCLipo9cIixcbiAgICAgIFwiJmxicmtzbHU7XCI6IFwi4qaNXCIsXG4gICAgICBcIiZsY2Fyb247XCI6IFwixL5cIixcbiAgICAgIFwiJmxjZWRpbDtcIjogXCLEvFwiLFxuICAgICAgXCImbGNlaWw7XCI6IFwi4oyIXCIsXG4gICAgICBcIiZsY3ViO1wiOiBcIntcIixcbiAgICAgIFwiJmxjeTtcIjogXCLQu1wiLFxuICAgICAgXCImbGRjYTtcIjogXCLipLZcIixcbiAgICAgIFwiJmxkcXVvO1wiOiBcIuKAnFwiLFxuICAgICAgXCImbGRxdW9yO1wiOiBcIuKAnlwiLFxuICAgICAgXCImbGRyZGhhcjtcIjogXCLipadcIixcbiAgICAgIFwiJmxkcnVzaGFyO1wiOiBcIuKli1wiLFxuICAgICAgXCImbGRzaDtcIjogXCLihrJcIixcbiAgICAgIFwiJmxlO1wiOiBcIuKJpFwiLFxuICAgICAgXCImbGVmdGFycm93O1wiOiBcIuKGkFwiLFxuICAgICAgXCImbGVmdGFycm93dGFpbDtcIjogXCLihqJcIixcbiAgICAgIFwiJmxlZnRoYXJwb29uZG93bjtcIjogXCLihr1cIixcbiAgICAgIFwiJmxlZnRoYXJwb29udXA7XCI6IFwi4oa8XCIsXG4gICAgICBcIiZsZWZ0bGVmdGFycm93cztcIjogXCLih4dcIixcbiAgICAgIFwiJmxlZnRyaWdodGFycm93O1wiOiBcIuKGlFwiLFxuICAgICAgXCImbGVmdHJpZ2h0YXJyb3dzO1wiOiBcIuKHhlwiLFxuICAgICAgXCImbGVmdHJpZ2h0aGFycG9vbnM7XCI6IFwi4oeLXCIsXG4gICAgICBcIiZsZWZ0cmlnaHRzcXVpZ2Fycm93O1wiOiBcIuKGrVwiLFxuICAgICAgXCImbGVmdHRocmVldGltZXM7XCI6IFwi4ouLXCIsXG4gICAgICBcIiZsZWc7XCI6IFwi4ouaXCIsXG4gICAgICBcIiZsZXE7XCI6IFwi4omkXCIsXG4gICAgICBcIiZsZXFxO1wiOiBcIuKJplwiLFxuICAgICAgXCImbGVxc2xhbnQ7XCI6IFwi4qm9XCIsXG4gICAgICBcIiZsZXM7XCI6IFwi4qm9XCIsXG4gICAgICBcIiZsZXNjYztcIjogXCLiqqhcIixcbiAgICAgIFwiJmxlc2RvdDtcIjogXCLiqb9cIixcbiAgICAgIFwiJmxlc2RvdG87XCI6IFwi4qqBXCIsXG4gICAgICBcIiZsZXNkb3RvcjtcIjogXCLiqoNcIixcbiAgICAgIFwiJmxlc2c7XCI6IFwi4oua77iAXCIsXG4gICAgICBcIiZsZXNnZXM7XCI6IFwi4qqTXCIsXG4gICAgICBcIiZsZXNzYXBwcm94O1wiOiBcIuKqhVwiLFxuICAgICAgXCImbGVzc2RvdDtcIjogXCLii5ZcIixcbiAgICAgIFwiJmxlc3NlcWd0cjtcIjogXCLii5pcIixcbiAgICAgIFwiJmxlc3NlcXFndHI7XCI6IFwi4qqLXCIsXG4gICAgICBcIiZsZXNzZ3RyO1wiOiBcIuKJtlwiLFxuICAgICAgXCImbGVzc3NpbTtcIjogXCLiibJcIixcbiAgICAgIFwiJmxmaXNodDtcIjogXCLipbxcIixcbiAgICAgIFwiJmxmbG9vcjtcIjogXCLijIpcIixcbiAgICAgIFwiJmxmcjtcIjogXCLwnZSpXCIsXG4gICAgICBcIiZsZztcIjogXCLiibZcIixcbiAgICAgIFwiJmxnRTtcIjogXCLiqpFcIixcbiAgICAgIFwiJmxoYXJkO1wiOiBcIuKGvVwiLFxuICAgICAgXCImbGhhcnU7XCI6IFwi4oa8XCIsXG4gICAgICBcIiZsaGFydWw7XCI6IFwi4qWqXCIsXG4gICAgICBcIiZsaGJsaztcIjogXCLiloRcIixcbiAgICAgIFwiJmxqY3k7XCI6IFwi0ZlcIixcbiAgICAgIFwiJmxsO1wiOiBcIuKJqlwiLFxuICAgICAgXCImbGxhcnI7XCI6IFwi4oeHXCIsXG4gICAgICBcIiZsbGNvcm5lcjtcIjogXCLijJ5cIixcbiAgICAgIFwiJmxsaGFyZDtcIjogXCLipatcIixcbiAgICAgIFwiJmxsdHJpO1wiOiBcIuKXulwiLFxuICAgICAgXCImbG1pZG90O1wiOiBcIsWAXCIsXG4gICAgICBcIiZsbW91c3Q7XCI6IFwi4o6wXCIsXG4gICAgICBcIiZsbW91c3RhY2hlO1wiOiBcIuKOsFwiLFxuICAgICAgXCImbG5FO1wiOiBcIuKJqFwiLFxuICAgICAgXCImbG5hcDtcIjogXCLiqolcIixcbiAgICAgIFwiJmxuYXBwcm94O1wiOiBcIuKqiVwiLFxuICAgICAgXCImbG5lO1wiOiBcIuKqh1wiLFxuICAgICAgXCImbG5lcTtcIjogXCLiqodcIixcbiAgICAgIFwiJmxuZXFxO1wiOiBcIuKJqFwiLFxuICAgICAgXCImbG5zaW07XCI6IFwi4oumXCIsXG4gICAgICBcIiZsb2FuZztcIjogXCLin6xcIixcbiAgICAgIFwiJmxvYXJyO1wiOiBcIuKHvVwiLFxuICAgICAgXCImbG9icms7XCI6IFwi4p+mXCIsXG4gICAgICBcIiZsb25nbGVmdGFycm93O1wiOiBcIuKftVwiLFxuICAgICAgXCImbG9uZ2xlZnRyaWdodGFycm93O1wiOiBcIuKft1wiLFxuICAgICAgXCImbG9uZ21hcHN0bztcIjogXCLin7xcIixcbiAgICAgIFwiJmxvbmdyaWdodGFycm93O1wiOiBcIuKftlwiLFxuICAgICAgXCImbG9vcGFycm93bGVmdDtcIjogXCLihqtcIixcbiAgICAgIFwiJmxvb3BhcnJvd3JpZ2h0O1wiOiBcIuKGrFwiLFxuICAgICAgXCImbG9wYXI7XCI6IFwi4qaFXCIsXG4gICAgICBcIiZsb3BmO1wiOiBcIvCdlZ1cIixcbiAgICAgIFwiJmxvcGx1cztcIjogXCLiqK1cIixcbiAgICAgIFwiJmxvdGltZXM7XCI6IFwi4qi0XCIsXG4gICAgICBcIiZsb3dhc3Q7XCI6IFwi4oiXXCIsXG4gICAgICBcIiZsb3diYXI7XCI6IFwiX1wiLFxuICAgICAgXCImbG96O1wiOiBcIuKXilwiLFxuICAgICAgXCImbG96ZW5nZTtcIjogXCLil4pcIixcbiAgICAgIFwiJmxvemY7XCI6IFwi4qerXCIsXG4gICAgICBcIiZscGFyO1wiOiBcIihcIixcbiAgICAgIFwiJmxwYXJsdDtcIjogXCLippNcIixcbiAgICAgIFwiJmxyYXJyO1wiOiBcIuKHhlwiLFxuICAgICAgXCImbHJjb3JuZXI7XCI6IFwi4oyfXCIsXG4gICAgICBcIiZscmhhcjtcIjogXCLih4tcIixcbiAgICAgIFwiJmxyaGFyZDtcIjogXCLipa1cIixcbiAgICAgIFwiJmxybTtcIjogXCLigI5cIixcbiAgICAgIFwiJmxydHJpO1wiOiBcIuKKv1wiLFxuICAgICAgXCImbHNhcXVvO1wiOiBcIuKAuVwiLFxuICAgICAgXCImbHNjcjtcIjogXCLwnZOBXCIsXG4gICAgICBcIiZsc2g7XCI6IFwi4oawXCIsXG4gICAgICBcIiZsc2ltO1wiOiBcIuKJslwiLFxuICAgICAgXCImbHNpbWU7XCI6IFwi4qqNXCIsXG4gICAgICBcIiZsc2ltZztcIjogXCLiqo9cIixcbiAgICAgIFwiJmxzcWI7XCI6IFwiW1wiLFxuICAgICAgXCImbHNxdW87XCI6IFwi4oCYXCIsXG4gICAgICBcIiZsc3F1b3I7XCI6IFwi4oCaXCIsXG4gICAgICBcIiZsc3Ryb2s7XCI6IFwixYJcIixcbiAgICAgIFwiJmx0XCI6IFwiPFwiLFxuICAgICAgXCImbHQ7XCI6IFwiPFwiLFxuICAgICAgXCImbHRjYztcIjogXCLiqqZcIixcbiAgICAgIFwiJmx0Y2lyO1wiOiBcIuKpuVwiLFxuICAgICAgXCImbHRkb3Q7XCI6IFwi4ouWXCIsXG4gICAgICBcIiZsdGhyZWU7XCI6IFwi4ouLXCIsXG4gICAgICBcIiZsdGltZXM7XCI6IFwi4ouJXCIsXG4gICAgICBcIiZsdGxhcnI7XCI6IFwi4qW2XCIsXG4gICAgICBcIiZsdHF1ZXN0O1wiOiBcIuKpu1wiLFxuICAgICAgXCImbHRyUGFyO1wiOiBcIuKmllwiLFxuICAgICAgXCImbHRyaTtcIjogXCLil4NcIixcbiAgICAgIFwiJmx0cmllO1wiOiBcIuKKtFwiLFxuICAgICAgXCImbHRyaWY7XCI6IFwi4peCXCIsXG4gICAgICBcIiZsdXJkc2hhcjtcIjogXCLipYpcIixcbiAgICAgIFwiJmx1cnVoYXI7XCI6IFwi4qWmXCIsXG4gICAgICBcIiZsdmVydG5lcXE7XCI6IFwi4omo77iAXCIsXG4gICAgICBcIiZsdm5FO1wiOiBcIuKJqO+4gFwiLFxuICAgICAgXCImbUREb3Q7XCI6IFwi4oi6XCIsXG4gICAgICBcIiZtYWNyXCI6IFwiwq9cIixcbiAgICAgIFwiJm1hY3I7XCI6IFwiwq9cIixcbiAgICAgIFwiJm1hbGU7XCI6IFwi4pmCXCIsXG4gICAgICBcIiZtYWx0O1wiOiBcIuKcoFwiLFxuICAgICAgXCImbWFsdGVzZTtcIjogXCLinKBcIixcbiAgICAgIFwiJm1hcDtcIjogXCLihqZcIixcbiAgICAgIFwiJm1hcHN0bztcIjogXCLihqZcIixcbiAgICAgIFwiJm1hcHN0b2Rvd247XCI6IFwi4oanXCIsXG4gICAgICBcIiZtYXBzdG9sZWZ0O1wiOiBcIuKGpFwiLFxuICAgICAgXCImbWFwc3RvdXA7XCI6IFwi4oalXCIsXG4gICAgICBcIiZtYXJrZXI7XCI6IFwi4pauXCIsXG4gICAgICBcIiZtY29tbWE7XCI6IFwi4qipXCIsXG4gICAgICBcIiZtY3k7XCI6IFwi0LxcIixcbiAgICAgIFwiJm1kYXNoO1wiOiBcIuKAlFwiLFxuICAgICAgXCImbWVhc3VyZWRhbmdsZTtcIjogXCLiiKFcIixcbiAgICAgIFwiJm1mcjtcIjogXCLwnZSqXCIsXG4gICAgICBcIiZtaG87XCI6IFwi4oSnXCIsXG4gICAgICBcIiZtaWNyb1wiOiBcIsK1XCIsXG4gICAgICBcIiZtaWNybztcIjogXCLCtVwiLFxuICAgICAgXCImbWlkO1wiOiBcIuKIo1wiLFxuICAgICAgXCImbWlkYXN0O1wiOiBcIipcIixcbiAgICAgIFwiJm1pZGNpcjtcIjogXCLiq7BcIixcbiAgICAgIFwiJm1pZGRvdFwiOiBcIsK3XCIsXG4gICAgICBcIiZtaWRkb3Q7XCI6IFwiwrdcIixcbiAgICAgIFwiJm1pbnVzO1wiOiBcIuKIklwiLFxuICAgICAgXCImbWludXNiO1wiOiBcIuKKn1wiLFxuICAgICAgXCImbWludXNkO1wiOiBcIuKIuFwiLFxuICAgICAgXCImbWludXNkdTtcIjogXCLiqKpcIixcbiAgICAgIFwiJm1sY3A7XCI6IFwi4qubXCIsXG4gICAgICBcIiZtbGRyO1wiOiBcIuKAplwiLFxuICAgICAgXCImbW5wbHVzO1wiOiBcIuKIk1wiLFxuICAgICAgXCImbW9kZWxzO1wiOiBcIuKKp1wiLFxuICAgICAgXCImbW9wZjtcIjogXCLwnZWeXCIsXG4gICAgICBcIiZtcDtcIjogXCLiiJNcIixcbiAgICAgIFwiJm1zY3I7XCI6IFwi8J2TglwiLFxuICAgICAgXCImbXN0cG9zO1wiOiBcIuKIvlwiLFxuICAgICAgXCImbXU7XCI6IFwizrxcIixcbiAgICAgIFwiJm11bHRpbWFwO1wiOiBcIuKKuFwiLFxuICAgICAgXCImbXVtYXA7XCI6IFwi4oq4XCIsXG4gICAgICBcIiZuR2c7XCI6IFwi4ouZzLhcIixcbiAgICAgIFwiJm5HdDtcIjogXCLiiavig5JcIixcbiAgICAgIFwiJm5HdHY7XCI6IFwi4omrzLhcIixcbiAgICAgIFwiJm5MZWZ0YXJyb3c7XCI6IFwi4oeNXCIsXG4gICAgICBcIiZuTGVmdHJpZ2h0YXJyb3c7XCI6IFwi4oeOXCIsXG4gICAgICBcIiZuTGw7XCI6IFwi4ouYzLhcIixcbiAgICAgIFwiJm5MdDtcIjogXCLiiarig5JcIixcbiAgICAgIFwiJm5MdHY7XCI6IFwi4omqzLhcIixcbiAgICAgIFwiJm5SaWdodGFycm93O1wiOiBcIuKHj1wiLFxuICAgICAgXCImblZEYXNoO1wiOiBcIuKKr1wiLFxuICAgICAgXCImblZkYXNoO1wiOiBcIuKKrlwiLFxuICAgICAgXCImbmFibGE7XCI6IFwi4oiHXCIsXG4gICAgICBcIiZuYWN1dGU7XCI6IFwixYRcIixcbiAgICAgIFwiJm5hbmc7XCI6IFwi4oig4oOSXCIsXG4gICAgICBcIiZuYXA7XCI6IFwi4omJXCIsXG4gICAgICBcIiZuYXBFO1wiOiBcIuKpsMy4XCIsXG4gICAgICBcIiZuYXBpZDtcIjogXCLiiYvMuFwiLFxuICAgICAgXCImbmFwb3M7XCI6IFwixYlcIixcbiAgICAgIFwiJm5hcHByb3g7XCI6IFwi4omJXCIsXG4gICAgICBcIiZuYXR1cjtcIjogXCLima5cIixcbiAgICAgIFwiJm5hdHVyYWw7XCI6IFwi4pmuXCIsXG4gICAgICBcIiZuYXR1cmFscztcIjogXCLihJVcIixcbiAgICAgIFwiJm5ic3BcIjogXCLCoFwiLFxuICAgICAgXCImbmJzcDtcIjogXCLCoFwiLFxuICAgICAgXCImbmJ1bXA7XCI6IFwi4omOzLhcIixcbiAgICAgIFwiJm5idW1wZTtcIjogXCLiiY/MuFwiLFxuICAgICAgXCImbmNhcDtcIjogXCLiqYNcIixcbiAgICAgIFwiJm5jYXJvbjtcIjogXCLFiFwiLFxuICAgICAgXCImbmNlZGlsO1wiOiBcIsWGXCIsXG4gICAgICBcIiZuY29uZztcIjogXCLiiYdcIixcbiAgICAgIFwiJm5jb25nZG90O1wiOiBcIuKprcy4XCIsXG4gICAgICBcIiZuY3VwO1wiOiBcIuKpglwiLFxuICAgICAgXCImbmN5O1wiOiBcItC9XCIsXG4gICAgICBcIiZuZGFzaDtcIjogXCLigJNcIixcbiAgICAgIFwiJm5lO1wiOiBcIuKJoFwiLFxuICAgICAgXCImbmVBcnI7XCI6IFwi4oeXXCIsXG4gICAgICBcIiZuZWFyaGs7XCI6IFwi4qSkXCIsXG4gICAgICBcIiZuZWFycjtcIjogXCLihpdcIixcbiAgICAgIFwiJm5lYXJyb3c7XCI6IFwi4oaXXCIsXG4gICAgICBcIiZuZWRvdDtcIjogXCLiiZDMuFwiLFxuICAgICAgXCImbmVxdWl2O1wiOiBcIuKJolwiLFxuICAgICAgXCImbmVzZWFyO1wiOiBcIuKkqFwiLFxuICAgICAgXCImbmVzaW07XCI6IFwi4omCzLhcIixcbiAgICAgIFwiJm5leGlzdDtcIjogXCLiiIRcIixcbiAgICAgIFwiJm5leGlzdHM7XCI6IFwi4oiEXCIsXG4gICAgICBcIiZuZnI7XCI6IFwi8J2Uq1wiLFxuICAgICAgXCImbmdFO1wiOiBcIuKJp8y4XCIsXG4gICAgICBcIiZuZ2U7XCI6IFwi4omxXCIsXG4gICAgICBcIiZuZ2VxO1wiOiBcIuKJsVwiLFxuICAgICAgXCImbmdlcXE7XCI6IFwi4omnzLhcIixcbiAgICAgIFwiJm5nZXFzbGFudDtcIjogXCLiqb7MuFwiLFxuICAgICAgXCImbmdlcztcIjogXCLiqb7MuFwiLFxuICAgICAgXCImbmdzaW07XCI6IFwi4om1XCIsXG4gICAgICBcIiZuZ3Q7XCI6IFwi4omvXCIsXG4gICAgICBcIiZuZ3RyO1wiOiBcIuKJr1wiLFxuICAgICAgXCImbmhBcnI7XCI6IFwi4oeOXCIsXG4gICAgICBcIiZuaGFycjtcIjogXCLihq5cIixcbiAgICAgIFwiJm5ocGFyO1wiOiBcIuKrslwiLFxuICAgICAgXCImbmk7XCI6IFwi4oiLXCIsXG4gICAgICBcIiZuaXM7XCI6IFwi4ou8XCIsXG4gICAgICBcIiZuaXNkO1wiOiBcIuKLulwiLFxuICAgICAgXCImbml2O1wiOiBcIuKIi1wiLFxuICAgICAgXCImbmpjeTtcIjogXCLRmlwiLFxuICAgICAgXCImbmxBcnI7XCI6IFwi4oeNXCIsXG4gICAgICBcIiZubEU7XCI6IFwi4ommzLhcIixcbiAgICAgIFwiJm5sYXJyO1wiOiBcIuKGmlwiLFxuICAgICAgXCImbmxkcjtcIjogXCLigKVcIixcbiAgICAgIFwiJm5sZTtcIjogXCLiibBcIixcbiAgICAgIFwiJm5sZWZ0YXJyb3c7XCI6IFwi4oaaXCIsXG4gICAgICBcIiZubGVmdHJpZ2h0YXJyb3c7XCI6IFwi4oauXCIsXG4gICAgICBcIiZubGVxO1wiOiBcIuKJsFwiLFxuICAgICAgXCImbmxlcXE7XCI6IFwi4ommzLhcIixcbiAgICAgIFwiJm5sZXFzbGFudDtcIjogXCLiqb3MuFwiLFxuICAgICAgXCImbmxlcztcIjogXCLiqb3MuFwiLFxuICAgICAgXCImbmxlc3M7XCI6IFwi4omuXCIsXG4gICAgICBcIiZubHNpbTtcIjogXCLiibRcIixcbiAgICAgIFwiJm5sdDtcIjogXCLiia5cIixcbiAgICAgIFwiJm5sdHJpO1wiOiBcIuKLqlwiLFxuICAgICAgXCImbmx0cmllO1wiOiBcIuKLrFwiLFxuICAgICAgXCImbm1pZDtcIjogXCLiiKRcIixcbiAgICAgIFwiJm5vcGY7XCI6IFwi8J2Vn1wiLFxuICAgICAgXCImbm90XCI6IFwiwqxcIixcbiAgICAgIFwiJm5vdDtcIjogXCLCrFwiLFxuICAgICAgXCImbm90aW47XCI6IFwi4oiJXCIsXG4gICAgICBcIiZub3RpbkU7XCI6IFwi4ou5zLhcIixcbiAgICAgIFwiJm5vdGluZG90O1wiOiBcIuKLtcy4XCIsXG4gICAgICBcIiZub3RpbnZhO1wiOiBcIuKIiVwiLFxuICAgICAgXCImbm90aW52YjtcIjogXCLii7dcIixcbiAgICAgIFwiJm5vdGludmM7XCI6IFwi4ou2XCIsXG4gICAgICBcIiZub3RuaTtcIjogXCLiiIxcIixcbiAgICAgIFwiJm5vdG5pdmE7XCI6IFwi4oiMXCIsXG4gICAgICBcIiZub3RuaXZiO1wiOiBcIuKLvlwiLFxuICAgICAgXCImbm90bml2YztcIjogXCLii71cIixcbiAgICAgIFwiJm5wYXI7XCI6IFwi4oimXCIsXG4gICAgICBcIiZucGFyYWxsZWw7XCI6IFwi4oimXCIsXG4gICAgICBcIiZucGFyc2w7XCI6IFwi4qu94oOlXCIsXG4gICAgICBcIiZucGFydDtcIjogXCLiiILMuFwiLFxuICAgICAgXCImbnBvbGludDtcIjogXCLiqJRcIixcbiAgICAgIFwiJm5wcjtcIjogXCLiioBcIixcbiAgICAgIFwiJm5wcmN1ZTtcIjogXCLii6BcIixcbiAgICAgIFwiJm5wcmU7XCI6IFwi4qqvzLhcIixcbiAgICAgIFwiJm5wcmVjO1wiOiBcIuKKgFwiLFxuICAgICAgXCImbnByZWNlcTtcIjogXCLiqq/MuFwiLFxuICAgICAgXCImbnJBcnI7XCI6IFwi4oePXCIsXG4gICAgICBcIiZucmFycjtcIjogXCLihptcIixcbiAgICAgIFwiJm5yYXJyYztcIjogXCLipLPMuFwiLFxuICAgICAgXCImbnJhcnJ3O1wiOiBcIuKGncy4XCIsXG4gICAgICBcIiZucmlnaHRhcnJvdztcIjogXCLihptcIixcbiAgICAgIFwiJm5ydHJpO1wiOiBcIuKLq1wiLFxuICAgICAgXCImbnJ0cmllO1wiOiBcIuKLrVwiLFxuICAgICAgXCImbnNjO1wiOiBcIuKKgVwiLFxuICAgICAgXCImbnNjY3VlO1wiOiBcIuKLoVwiLFxuICAgICAgXCImbnNjZTtcIjogXCLiqrDMuFwiLFxuICAgICAgXCImbnNjcjtcIjogXCLwnZODXCIsXG4gICAgICBcIiZuc2hvcnRtaWQ7XCI6IFwi4oikXCIsXG4gICAgICBcIiZuc2hvcnRwYXJhbGxlbDtcIjogXCLiiKZcIixcbiAgICAgIFwiJm5zaW07XCI6IFwi4omBXCIsXG4gICAgICBcIiZuc2ltZTtcIjogXCLiiYRcIixcbiAgICAgIFwiJm5zaW1lcTtcIjogXCLiiYRcIixcbiAgICAgIFwiJm5zbWlkO1wiOiBcIuKIpFwiLFxuICAgICAgXCImbnNwYXI7XCI6IFwi4oimXCIsXG4gICAgICBcIiZuc3FzdWJlO1wiOiBcIuKLolwiLFxuICAgICAgXCImbnNxc3VwZTtcIjogXCLii6NcIixcbiAgICAgIFwiJm5zdWI7XCI6IFwi4oqEXCIsXG4gICAgICBcIiZuc3ViRTtcIjogXCLiq4XMuFwiLFxuICAgICAgXCImbnN1YmU7XCI6IFwi4oqIXCIsXG4gICAgICBcIiZuc3Vic2V0O1wiOiBcIuKKguKDklwiLFxuICAgICAgXCImbnN1YnNldGVxO1wiOiBcIuKKiFwiLFxuICAgICAgXCImbnN1YnNldGVxcTtcIjogXCLiq4XMuFwiLFxuICAgICAgXCImbnN1Y2M7XCI6IFwi4oqBXCIsXG4gICAgICBcIiZuc3VjY2VxO1wiOiBcIuKqsMy4XCIsXG4gICAgICBcIiZuc3VwO1wiOiBcIuKKhVwiLFxuICAgICAgXCImbnN1cEU7XCI6IFwi4quGzLhcIixcbiAgICAgIFwiJm5zdXBlO1wiOiBcIuKKiVwiLFxuICAgICAgXCImbnN1cHNldDtcIjogXCLiioPig5JcIixcbiAgICAgIFwiJm5zdXBzZXRlcTtcIjogXCLiiolcIixcbiAgICAgIFwiJm5zdXBzZXRlcXE7XCI6IFwi4quGzLhcIixcbiAgICAgIFwiJm50Z2w7XCI6IFwi4om5XCIsXG4gICAgICBcIiZudGlsZGVcIjogXCLDsVwiLFxuICAgICAgXCImbnRpbGRlO1wiOiBcIsOxXCIsXG4gICAgICBcIiZudGxnO1wiOiBcIuKJuFwiLFxuICAgICAgXCImbnRyaWFuZ2xlbGVmdDtcIjogXCLii6pcIixcbiAgICAgIFwiJm50cmlhbmdsZWxlZnRlcTtcIjogXCLii6xcIixcbiAgICAgIFwiJm50cmlhbmdsZXJpZ2h0O1wiOiBcIuKLq1wiLFxuICAgICAgXCImbnRyaWFuZ2xlcmlnaHRlcTtcIjogXCLii61cIixcbiAgICAgIFwiJm51O1wiOiBcIs69XCIsXG4gICAgICBcIiZudW07XCI6IFwiI1wiLFxuICAgICAgXCImbnVtZXJvO1wiOiBcIuKEllwiLFxuICAgICAgXCImbnVtc3A7XCI6IFwi4oCHXCIsXG4gICAgICBcIiZudkRhc2g7XCI6IFwi4oqtXCIsXG4gICAgICBcIiZudkhhcnI7XCI6IFwi4qSEXCIsXG4gICAgICBcIiZudmFwO1wiOiBcIuKJjeKDklwiLFxuICAgICAgXCImbnZkYXNoO1wiOiBcIuKKrFwiLFxuICAgICAgXCImbnZnZTtcIjogXCLiiaXig5JcIixcbiAgICAgIFwiJm52Z3Q7XCI6IFwiPuKDklwiLFxuICAgICAgXCImbnZpbmZpbjtcIjogXCLip55cIixcbiAgICAgIFwiJm52bEFycjtcIjogXCLipIJcIixcbiAgICAgIFwiJm52bGU7XCI6IFwi4omk4oOSXCIsXG4gICAgICBcIiZudmx0O1wiOiBcIjzig5JcIixcbiAgICAgIFwiJm52bHRyaWU7XCI6IFwi4oq04oOSXCIsXG4gICAgICBcIiZudnJBcnI7XCI6IFwi4qSDXCIsXG4gICAgICBcIiZudnJ0cmllO1wiOiBcIuKKteKDklwiLFxuICAgICAgXCImbnZzaW07XCI6IFwi4oi84oOSXCIsXG4gICAgICBcIiZud0FycjtcIjogXCLih5ZcIixcbiAgICAgIFwiJm53YXJoaztcIjogXCLipKNcIixcbiAgICAgIFwiJm53YXJyO1wiOiBcIuKGllwiLFxuICAgICAgXCImbndhcnJvdztcIjogXCLihpZcIixcbiAgICAgIFwiJm53bmVhcjtcIjogXCLipKdcIixcbiAgICAgIFwiJm9TO1wiOiBcIuKTiFwiLFxuICAgICAgXCImb2FjdXRlXCI6IFwiw7NcIixcbiAgICAgIFwiJm9hY3V0ZTtcIjogXCLDs1wiLFxuICAgICAgXCImb2FzdDtcIjogXCLiiptcIixcbiAgICAgIFwiJm9jaXI7XCI6IFwi4oqaXCIsXG4gICAgICBcIiZvY2lyY1wiOiBcIsO0XCIsXG4gICAgICBcIiZvY2lyYztcIjogXCLDtFwiLFxuICAgICAgXCImb2N5O1wiOiBcItC+XCIsXG4gICAgICBcIiZvZGFzaDtcIjogXCLiip1cIixcbiAgICAgIFwiJm9kYmxhYztcIjogXCLFkVwiLFxuICAgICAgXCImb2RpdjtcIjogXCLiqLhcIixcbiAgICAgIFwiJm9kb3Q7XCI6IFwi4oqZXCIsXG4gICAgICBcIiZvZHNvbGQ7XCI6IFwi4qa8XCIsXG4gICAgICBcIiZvZWxpZztcIjogXCLFk1wiLFxuICAgICAgXCImb2ZjaXI7XCI6IFwi4qa/XCIsXG4gICAgICBcIiZvZnI7XCI6IFwi8J2UrFwiLFxuICAgICAgXCImb2dvbjtcIjogXCLLm1wiLFxuICAgICAgXCImb2dyYXZlXCI6IFwiw7JcIixcbiAgICAgIFwiJm9ncmF2ZTtcIjogXCLDslwiLFxuICAgICAgXCImb2d0O1wiOiBcIuKngVwiLFxuICAgICAgXCImb2hiYXI7XCI6IFwi4qa1XCIsXG4gICAgICBcIiZvaG07XCI6IFwizqlcIixcbiAgICAgIFwiJm9pbnQ7XCI6IFwi4oiuXCIsXG4gICAgICBcIiZvbGFycjtcIjogXCLihrpcIixcbiAgICAgIFwiJm9sY2lyO1wiOiBcIuKmvlwiLFxuICAgICAgXCImb2xjcm9zcztcIjogXCLiprtcIixcbiAgICAgIFwiJm9saW5lO1wiOiBcIuKAvlwiLFxuICAgICAgXCImb2x0O1wiOiBcIuKngFwiLFxuICAgICAgXCImb21hY3I7XCI6IFwixY1cIixcbiAgICAgIFwiJm9tZWdhO1wiOiBcIs+JXCIsXG4gICAgICBcIiZvbWljcm9uO1wiOiBcIs6/XCIsXG4gICAgICBcIiZvbWlkO1wiOiBcIuKmtlwiLFxuICAgICAgXCImb21pbnVzO1wiOiBcIuKKllwiLFxuICAgICAgXCImb29wZjtcIjogXCLwnZWgXCIsXG4gICAgICBcIiZvcGFyO1wiOiBcIuKmt1wiLFxuICAgICAgXCImb3BlcnA7XCI6IFwi4qa5XCIsXG4gICAgICBcIiZvcGx1cztcIjogXCLiipVcIixcbiAgICAgIFwiJm9yO1wiOiBcIuKIqFwiLFxuICAgICAgXCImb3JhcnI7XCI6IFwi4oa7XCIsXG4gICAgICBcIiZvcmQ7XCI6IFwi4qmdXCIsXG4gICAgICBcIiZvcmRlcjtcIjogXCLihLRcIixcbiAgICAgIFwiJm9yZGVyb2Y7XCI6IFwi4oS0XCIsXG4gICAgICBcIiZvcmRmXCI6IFwiwqpcIixcbiAgICAgIFwiJm9yZGY7XCI6IFwiwqpcIixcbiAgICAgIFwiJm9yZG1cIjogXCLCulwiLFxuICAgICAgXCImb3JkbTtcIjogXCLCulwiLFxuICAgICAgXCImb3JpZ29mO1wiOiBcIuKKtlwiLFxuICAgICAgXCImb3JvcjtcIjogXCLiqZZcIixcbiAgICAgIFwiJm9yc2xvcGU7XCI6IFwi4qmXXCIsXG4gICAgICBcIiZvcnY7XCI6IFwi4qmbXCIsXG4gICAgICBcIiZvc2NyO1wiOiBcIuKEtFwiLFxuICAgICAgXCImb3NsYXNoXCI6IFwiw7hcIixcbiAgICAgIFwiJm9zbGFzaDtcIjogXCLDuFwiLFxuICAgICAgXCImb3NvbDtcIjogXCLiiphcIixcbiAgICAgIFwiJm90aWxkZVwiOiBcIsO1XCIsXG4gICAgICBcIiZvdGlsZGU7XCI6IFwiw7VcIixcbiAgICAgIFwiJm90aW1lcztcIjogXCLiipdcIixcbiAgICAgIFwiJm90aW1lc2FzO1wiOiBcIuKotlwiLFxuICAgICAgXCImb3VtbFwiOiBcIsO2XCIsXG4gICAgICBcIiZvdW1sO1wiOiBcIsO2XCIsXG4gICAgICBcIiZvdmJhcjtcIjogXCLijL1cIixcbiAgICAgIFwiJnBhcjtcIjogXCLiiKVcIixcbiAgICAgIFwiJnBhcmFcIjogXCLCtlwiLFxuICAgICAgXCImcGFyYTtcIjogXCLCtlwiLFxuICAgICAgXCImcGFyYWxsZWw7XCI6IFwi4oilXCIsXG4gICAgICBcIiZwYXJzaW07XCI6IFwi4quzXCIsXG4gICAgICBcIiZwYXJzbDtcIjogXCLiq71cIixcbiAgICAgIFwiJnBhcnQ7XCI6IFwi4oiCXCIsXG4gICAgICBcIiZwY3k7XCI6IFwi0L9cIixcbiAgICAgIFwiJnBlcmNudDtcIjogXCIlXCIsXG4gICAgICBcIiZwZXJpb2Q7XCI6IFwiLlwiLFxuICAgICAgXCImcGVybWlsO1wiOiBcIuKAsFwiLFxuICAgICAgXCImcGVycDtcIjogXCLiiqVcIixcbiAgICAgIFwiJnBlcnRlbms7XCI6IFwi4oCxXCIsXG4gICAgICBcIiZwZnI7XCI6IFwi8J2UrVwiLFxuICAgICAgXCImcGhpO1wiOiBcIs+GXCIsXG4gICAgICBcIiZwaGl2O1wiOiBcIs+VXCIsXG4gICAgICBcIiZwaG1tYXQ7XCI6IFwi4oSzXCIsXG4gICAgICBcIiZwaG9uZTtcIjogXCLimI5cIixcbiAgICAgIFwiJnBpO1wiOiBcIs+AXCIsXG4gICAgICBcIiZwaXRjaGZvcms7XCI6IFwi4ouUXCIsXG4gICAgICBcIiZwaXY7XCI6IFwiz5ZcIixcbiAgICAgIFwiJnBsYW5jaztcIjogXCLihI9cIixcbiAgICAgIFwiJnBsYW5ja2g7XCI6IFwi4oSOXCIsXG4gICAgICBcIiZwbGFua3Y7XCI6IFwi4oSPXCIsXG4gICAgICBcIiZwbHVzO1wiOiBcIitcIixcbiAgICAgIFwiJnBsdXNhY2lyO1wiOiBcIuKoo1wiLFxuICAgICAgXCImcGx1c2I7XCI6IFwi4oqeXCIsXG4gICAgICBcIiZwbHVzY2lyO1wiOiBcIuKoolwiLFxuICAgICAgXCImcGx1c2RvO1wiOiBcIuKIlFwiLFxuICAgICAgXCImcGx1c2R1O1wiOiBcIuKopVwiLFxuICAgICAgXCImcGx1c2U7XCI6IFwi4qmyXCIsXG4gICAgICBcIiZwbHVzbW5cIjogXCLCsVwiLFxuICAgICAgXCImcGx1c21uO1wiOiBcIsKxXCIsXG4gICAgICBcIiZwbHVzc2ltO1wiOiBcIuKoplwiLFxuICAgICAgXCImcGx1c3R3bztcIjogXCLiqKdcIixcbiAgICAgIFwiJnBtO1wiOiBcIsKxXCIsXG4gICAgICBcIiZwb2ludGludDtcIjogXCLiqJVcIixcbiAgICAgIFwiJnBvcGY7XCI6IFwi8J2VoVwiLFxuICAgICAgXCImcG91bmRcIjogXCLCo1wiLFxuICAgICAgXCImcG91bmQ7XCI6IFwiwqNcIixcbiAgICAgIFwiJnByO1wiOiBcIuKJulwiLFxuICAgICAgXCImcHJFO1wiOiBcIuKqs1wiLFxuICAgICAgXCImcHJhcDtcIjogXCLiqrdcIixcbiAgICAgIFwiJnByY3VlO1wiOiBcIuKJvFwiLFxuICAgICAgXCImcHJlO1wiOiBcIuKqr1wiLFxuICAgICAgXCImcHJlYztcIjogXCLiibpcIixcbiAgICAgIFwiJnByZWNhcHByb3g7XCI6IFwi4qq3XCIsXG4gICAgICBcIiZwcmVjY3VybHllcTtcIjogXCLiibxcIixcbiAgICAgIFwiJnByZWNlcTtcIjogXCLiqq9cIixcbiAgICAgIFwiJnByZWNuYXBwcm94O1wiOiBcIuKquVwiLFxuICAgICAgXCImcHJlY25lcXE7XCI6IFwi4qq1XCIsXG4gICAgICBcIiZwcmVjbnNpbTtcIjogXCLii6hcIixcbiAgICAgIFwiJnByZWNzaW07XCI6IFwi4om+XCIsXG4gICAgICBcIiZwcmltZTtcIjogXCLigLJcIixcbiAgICAgIFwiJnByaW1lcztcIjogXCLihJlcIixcbiAgICAgIFwiJnBybkU7XCI6IFwi4qq1XCIsXG4gICAgICBcIiZwcm5hcDtcIjogXCLiqrlcIixcbiAgICAgIFwiJnBybnNpbTtcIjogXCLii6hcIixcbiAgICAgIFwiJnByb2Q7XCI6IFwi4oiPXCIsXG4gICAgICBcIiZwcm9mYWxhcjtcIjogXCLijK5cIixcbiAgICAgIFwiJnByb2ZsaW5lO1wiOiBcIuKMklwiLFxuICAgICAgXCImcHJvZnN1cmY7XCI6IFwi4oyTXCIsXG4gICAgICBcIiZwcm9wO1wiOiBcIuKInVwiLFxuICAgICAgXCImcHJvcHRvO1wiOiBcIuKInVwiLFxuICAgICAgXCImcHJzaW07XCI6IFwi4om+XCIsXG4gICAgICBcIiZwcnVyZWw7XCI6IFwi4oqwXCIsXG4gICAgICBcIiZwc2NyO1wiOiBcIvCdk4VcIixcbiAgICAgIFwiJnBzaTtcIjogXCLPiFwiLFxuICAgICAgXCImcHVuY3NwO1wiOiBcIuKAiFwiLFxuICAgICAgXCImcWZyO1wiOiBcIvCdlK5cIixcbiAgICAgIFwiJnFpbnQ7XCI6IFwi4qiMXCIsXG4gICAgICBcIiZxb3BmO1wiOiBcIvCdlaJcIixcbiAgICAgIFwiJnFwcmltZTtcIjogXCLigZdcIixcbiAgICAgIFwiJnFzY3I7XCI6IFwi8J2ThlwiLFxuICAgICAgXCImcXVhdGVybmlvbnM7XCI6IFwi4oSNXCIsXG4gICAgICBcIiZxdWF0aW50O1wiOiBcIuKollwiLFxuICAgICAgXCImcXVlc3Q7XCI6IFwiP1wiLFxuICAgICAgXCImcXVlc3RlcTtcIjogXCLiiZ9cIixcbiAgICAgIFwiJnF1b3RcIjogJ1wiJyxcbiAgICAgIFwiJnF1b3Q7XCI6ICdcIicsXG4gICAgICBcIiZyQWFycjtcIjogXCLih5tcIixcbiAgICAgIFwiJnJBcnI7XCI6IFwi4oeSXCIsXG4gICAgICBcIiZyQXRhaWw7XCI6IFwi4qScXCIsXG4gICAgICBcIiZyQmFycjtcIjogXCLipI9cIixcbiAgICAgIFwiJnJIYXI7XCI6IFwi4qWkXCIsXG4gICAgICBcIiZyYWNlO1wiOiBcIuKIvcyxXCIsXG4gICAgICBcIiZyYWN1dGU7XCI6IFwixZVcIixcbiAgICAgIFwiJnJhZGljO1wiOiBcIuKImlwiLFxuICAgICAgXCImcmFlbXB0eXY7XCI6IFwi4qazXCIsXG4gICAgICBcIiZyYW5nO1wiOiBcIuKfqVwiLFxuICAgICAgXCImcmFuZ2Q7XCI6IFwi4qaSXCIsXG4gICAgICBcIiZyYW5nZTtcIjogXCLipqVcIixcbiAgICAgIFwiJnJhbmdsZTtcIjogXCLin6lcIixcbiAgICAgIFwiJnJhcXVvXCI6IFwiwrtcIixcbiAgICAgIFwiJnJhcXVvO1wiOiBcIsK7XCIsXG4gICAgICBcIiZyYXJyO1wiOiBcIuKGklwiLFxuICAgICAgXCImcmFycmFwO1wiOiBcIuKltVwiLFxuICAgICAgXCImcmFycmI7XCI6IFwi4oelXCIsXG4gICAgICBcIiZyYXJyYmZzO1wiOiBcIuKkoFwiLFxuICAgICAgXCImcmFycmM7XCI6IFwi4qSzXCIsXG4gICAgICBcIiZyYXJyZnM7XCI6IFwi4qSeXCIsXG4gICAgICBcIiZyYXJyaGs7XCI6IFwi4oaqXCIsXG4gICAgICBcIiZyYXJybHA7XCI6IFwi4oasXCIsXG4gICAgICBcIiZyYXJycGw7XCI6IFwi4qWFXCIsXG4gICAgICBcIiZyYXJyc2ltO1wiOiBcIuKltFwiLFxuICAgICAgXCImcmFycnRsO1wiOiBcIuKGo1wiLFxuICAgICAgXCImcmFycnc7XCI6IFwi4oadXCIsXG4gICAgICBcIiZyYXRhaWw7XCI6IFwi4qSaXCIsXG4gICAgICBcIiZyYXRpbztcIjogXCLiiLZcIixcbiAgICAgIFwiJnJhdGlvbmFscztcIjogXCLihJpcIixcbiAgICAgIFwiJnJiYXJyO1wiOiBcIuKkjVwiLFxuICAgICAgXCImcmJicms7XCI6IFwi4p2zXCIsXG4gICAgICBcIiZyYnJhY2U7XCI6IFwifVwiLFxuICAgICAgXCImcmJyYWNrO1wiOiBcIl1cIixcbiAgICAgIFwiJnJicmtlO1wiOiBcIuKmjFwiLFxuICAgICAgXCImcmJya3NsZDtcIjogXCLipo5cIixcbiAgICAgIFwiJnJicmtzbHU7XCI6IFwi4qaQXCIsXG4gICAgICBcIiZyY2Fyb247XCI6IFwixZlcIixcbiAgICAgIFwiJnJjZWRpbDtcIjogXCLFl1wiLFxuICAgICAgXCImcmNlaWw7XCI6IFwi4oyJXCIsXG4gICAgICBcIiZyY3ViO1wiOiBcIn1cIixcbiAgICAgIFwiJnJjeTtcIjogXCLRgFwiLFxuICAgICAgXCImcmRjYTtcIjogXCLipLdcIixcbiAgICAgIFwiJnJkbGRoYXI7XCI6IFwi4qWpXCIsXG4gICAgICBcIiZyZHF1bztcIjogXCLigJ1cIixcbiAgICAgIFwiJnJkcXVvcjtcIjogXCLigJ1cIixcbiAgICAgIFwiJnJkc2g7XCI6IFwi4oazXCIsXG4gICAgICBcIiZyZWFsO1wiOiBcIuKEnFwiLFxuICAgICAgXCImcmVhbGluZTtcIjogXCLihJtcIixcbiAgICAgIFwiJnJlYWxwYXJ0O1wiOiBcIuKEnFwiLFxuICAgICAgXCImcmVhbHM7XCI6IFwi4oSdXCIsXG4gICAgICBcIiZyZWN0O1wiOiBcIuKWrVwiLFxuICAgICAgXCImcmVnXCI6IFwiwq5cIixcbiAgICAgIFwiJnJlZztcIjogXCLCrlwiLFxuICAgICAgXCImcmZpc2h0O1wiOiBcIuKlvVwiLFxuICAgICAgXCImcmZsb29yO1wiOiBcIuKMi1wiLFxuICAgICAgXCImcmZyO1wiOiBcIvCdlK9cIixcbiAgICAgIFwiJnJoYXJkO1wiOiBcIuKHgVwiLFxuICAgICAgXCImcmhhcnU7XCI6IFwi4oeAXCIsXG4gICAgICBcIiZyaGFydWw7XCI6IFwi4qWsXCIsXG4gICAgICBcIiZyaG87XCI6IFwiz4FcIixcbiAgICAgIFwiJnJob3Y7XCI6IFwiz7FcIixcbiAgICAgIFwiJnJpZ2h0YXJyb3c7XCI6IFwi4oaSXCIsXG4gICAgICBcIiZyaWdodGFycm93dGFpbDtcIjogXCLihqNcIixcbiAgICAgIFwiJnJpZ2h0aGFycG9vbmRvd247XCI6IFwi4oeBXCIsXG4gICAgICBcIiZyaWdodGhhcnBvb251cDtcIjogXCLih4BcIixcbiAgICAgIFwiJnJpZ2h0bGVmdGFycm93cztcIjogXCLih4RcIixcbiAgICAgIFwiJnJpZ2h0bGVmdGhhcnBvb25zO1wiOiBcIuKHjFwiLFxuICAgICAgXCImcmlnaHRyaWdodGFycm93cztcIjogXCLih4lcIixcbiAgICAgIFwiJnJpZ2h0c3F1aWdhcnJvdztcIjogXCLihp1cIixcbiAgICAgIFwiJnJpZ2h0dGhyZWV0aW1lcztcIjogXCLii4xcIixcbiAgICAgIFwiJnJpbmc7XCI6IFwiy5pcIixcbiAgICAgIFwiJnJpc2luZ2RvdHNlcTtcIjogXCLiiZNcIixcbiAgICAgIFwiJnJsYXJyO1wiOiBcIuKHhFwiLFxuICAgICAgXCImcmxoYXI7XCI6IFwi4oeMXCIsXG4gICAgICBcIiZybG07XCI6IFwi4oCPXCIsXG4gICAgICBcIiZybW91c3Q7XCI6IFwi4o6xXCIsXG4gICAgICBcIiZybW91c3RhY2hlO1wiOiBcIuKOsVwiLFxuICAgICAgXCImcm5taWQ7XCI6IFwi4quuXCIsXG4gICAgICBcIiZyb2FuZztcIjogXCLin61cIixcbiAgICAgIFwiJnJvYXJyO1wiOiBcIuKHvlwiLFxuICAgICAgXCImcm9icms7XCI6IFwi4p+nXCIsXG4gICAgICBcIiZyb3BhcjtcIjogXCLipoZcIixcbiAgICAgIFwiJnJvcGY7XCI6IFwi8J2Vo1wiLFxuICAgICAgXCImcm9wbHVzO1wiOiBcIuKorlwiLFxuICAgICAgXCImcm90aW1lcztcIjogXCLiqLVcIixcbiAgICAgIFwiJnJwYXI7XCI6IFwiKVwiLFxuICAgICAgXCImcnBhcmd0O1wiOiBcIuKmlFwiLFxuICAgICAgXCImcnBwb2xpbnQ7XCI6IFwi4qiSXCIsXG4gICAgICBcIiZycmFycjtcIjogXCLih4lcIixcbiAgICAgIFwiJnJzYXF1bztcIjogXCLigLpcIixcbiAgICAgIFwiJnJzY3I7XCI6IFwi8J2Th1wiLFxuICAgICAgXCImcnNoO1wiOiBcIuKGsVwiLFxuICAgICAgXCImcnNxYjtcIjogXCJdXCIsXG4gICAgICBcIiZyc3F1bztcIjogXCLigJlcIixcbiAgICAgIFwiJnJzcXVvcjtcIjogXCLigJlcIixcbiAgICAgIFwiJnJ0aHJlZTtcIjogXCLii4xcIixcbiAgICAgIFwiJnJ0aW1lcztcIjogXCLii4pcIixcbiAgICAgIFwiJnJ0cmk7XCI6IFwi4pa5XCIsXG4gICAgICBcIiZydHJpZTtcIjogXCLiirVcIixcbiAgICAgIFwiJnJ0cmlmO1wiOiBcIuKWuFwiLFxuICAgICAgXCImcnRyaWx0cmk7XCI6IFwi4qeOXCIsXG4gICAgICBcIiZydWx1aGFyO1wiOiBcIuKlqFwiLFxuICAgICAgXCImcng7XCI6IFwi4oSeXCIsXG4gICAgICBcIiZzYWN1dGU7XCI6IFwixZtcIixcbiAgICAgIFwiJnNicXVvO1wiOiBcIuKAmlwiLFxuICAgICAgXCImc2M7XCI6IFwi4om7XCIsXG4gICAgICBcIiZzY0U7XCI6IFwi4qq0XCIsXG4gICAgICBcIiZzY2FwO1wiOiBcIuKquFwiLFxuICAgICAgXCImc2Nhcm9uO1wiOiBcIsWhXCIsXG4gICAgICBcIiZzY2N1ZTtcIjogXCLiib1cIixcbiAgICAgIFwiJnNjZTtcIjogXCLiqrBcIixcbiAgICAgIFwiJnNjZWRpbDtcIjogXCLFn1wiLFxuICAgICAgXCImc2NpcmM7XCI6IFwixZ1cIixcbiAgICAgIFwiJnNjbkU7XCI6IFwi4qq2XCIsXG4gICAgICBcIiZzY25hcDtcIjogXCLiqrpcIixcbiAgICAgIFwiJnNjbnNpbTtcIjogXCLii6lcIixcbiAgICAgIFwiJnNjcG9saW50O1wiOiBcIuKok1wiLFxuICAgICAgXCImc2NzaW07XCI6IFwi4om/XCIsXG4gICAgICBcIiZzY3k7XCI6IFwi0YFcIixcbiAgICAgIFwiJnNkb3Q7XCI6IFwi4ouFXCIsXG4gICAgICBcIiZzZG90YjtcIjogXCLiiqFcIixcbiAgICAgIFwiJnNkb3RlO1wiOiBcIuKpplwiLFxuICAgICAgXCImc2VBcnI7XCI6IFwi4oeYXCIsXG4gICAgICBcIiZzZWFyaGs7XCI6IFwi4qSlXCIsXG4gICAgICBcIiZzZWFycjtcIjogXCLihphcIixcbiAgICAgIFwiJnNlYXJyb3c7XCI6IFwi4oaYXCIsXG4gICAgICBcIiZzZWN0XCI6IFwiwqdcIixcbiAgICAgIFwiJnNlY3Q7XCI6IFwiwqdcIixcbiAgICAgIFwiJnNlbWk7XCI6IFwiO1wiLFxuICAgICAgXCImc2Vzd2FyO1wiOiBcIuKkqVwiLFxuICAgICAgXCImc2V0bWludXM7XCI6IFwi4oiWXCIsXG4gICAgICBcIiZzZXRtbjtcIjogXCLiiJZcIixcbiAgICAgIFwiJnNleHQ7XCI6IFwi4py2XCIsXG4gICAgICBcIiZzZnI7XCI6IFwi8J2UsFwiLFxuICAgICAgXCImc2Zyb3duO1wiOiBcIuKMolwiLFxuICAgICAgXCImc2hhcnA7XCI6IFwi4pmvXCIsXG4gICAgICBcIiZzaGNoY3k7XCI6IFwi0YlcIixcbiAgICAgIFwiJnNoY3k7XCI6IFwi0YhcIixcbiAgICAgIFwiJnNob3J0bWlkO1wiOiBcIuKIo1wiLFxuICAgICAgXCImc2hvcnRwYXJhbGxlbDtcIjogXCLiiKVcIixcbiAgICAgIFwiJnNoeVwiOiBcIsKtXCIsXG4gICAgICBcIiZzaHk7XCI6IFwiwq1cIixcbiAgICAgIFwiJnNpZ21hO1wiOiBcIs+DXCIsXG4gICAgICBcIiZzaWdtYWY7XCI6IFwiz4JcIixcbiAgICAgIFwiJnNpZ21hdjtcIjogXCLPglwiLFxuICAgICAgXCImc2ltO1wiOiBcIuKIvFwiLFxuICAgICAgXCImc2ltZG90O1wiOiBcIuKpqlwiLFxuICAgICAgXCImc2ltZTtcIjogXCLiiYNcIixcbiAgICAgIFwiJnNpbWVxO1wiOiBcIuKJg1wiLFxuICAgICAgXCImc2ltZztcIjogXCLiqp5cIixcbiAgICAgIFwiJnNpbWdFO1wiOiBcIuKqoFwiLFxuICAgICAgXCImc2ltbDtcIjogXCLiqp1cIixcbiAgICAgIFwiJnNpbWxFO1wiOiBcIuKqn1wiLFxuICAgICAgXCImc2ltbmU7XCI6IFwi4omGXCIsXG4gICAgICBcIiZzaW1wbHVzO1wiOiBcIuKopFwiLFxuICAgICAgXCImc2ltcmFycjtcIjogXCLipbJcIixcbiAgICAgIFwiJnNsYXJyO1wiOiBcIuKGkFwiLFxuICAgICAgXCImc21hbGxzZXRtaW51cztcIjogXCLiiJZcIixcbiAgICAgIFwiJnNtYXNocDtcIjogXCLiqLNcIixcbiAgICAgIFwiJnNtZXBhcnNsO1wiOiBcIuKnpFwiLFxuICAgICAgXCImc21pZDtcIjogXCLiiKNcIixcbiAgICAgIFwiJnNtaWxlO1wiOiBcIuKMo1wiLFxuICAgICAgXCImc210O1wiOiBcIuKqqlwiLFxuICAgICAgXCImc210ZTtcIjogXCLiqqxcIixcbiAgICAgIFwiJnNtdGVzO1wiOiBcIuKqrO+4gFwiLFxuICAgICAgXCImc29mdGN5O1wiOiBcItGMXCIsXG4gICAgICBcIiZzb2w7XCI6IFwiL1wiLFxuICAgICAgXCImc29sYjtcIjogXCLip4RcIixcbiAgICAgIFwiJnNvbGJhcjtcIjogXCLijL9cIixcbiAgICAgIFwiJnNvcGY7XCI6IFwi8J2VpFwiLFxuICAgICAgXCImc3BhZGVzO1wiOiBcIuKZoFwiLFxuICAgICAgXCImc3BhZGVzdWl0O1wiOiBcIuKZoFwiLFxuICAgICAgXCImc3BhcjtcIjogXCLiiKVcIixcbiAgICAgIFwiJnNxY2FwO1wiOiBcIuKKk1wiLFxuICAgICAgXCImc3FjYXBzO1wiOiBcIuKKk++4gFwiLFxuICAgICAgXCImc3FjdXA7XCI6IFwi4oqUXCIsXG4gICAgICBcIiZzcWN1cHM7XCI6IFwi4oqU77iAXCIsXG4gICAgICBcIiZzcXN1YjtcIjogXCLiio9cIixcbiAgICAgIFwiJnNxc3ViZTtcIjogXCLiipFcIixcbiAgICAgIFwiJnNxc3Vic2V0O1wiOiBcIuKKj1wiLFxuICAgICAgXCImc3FzdWJzZXRlcTtcIjogXCLiipFcIixcbiAgICAgIFwiJnNxc3VwO1wiOiBcIuKKkFwiLFxuICAgICAgXCImc3FzdXBlO1wiOiBcIuKKklwiLFxuICAgICAgXCImc3FzdXBzZXQ7XCI6IFwi4oqQXCIsXG4gICAgICBcIiZzcXN1cHNldGVxO1wiOiBcIuKKklwiLFxuICAgICAgXCImc3F1O1wiOiBcIuKWoVwiLFxuICAgICAgXCImc3F1YXJlO1wiOiBcIuKWoVwiLFxuICAgICAgXCImc3F1YXJmO1wiOiBcIuKWqlwiLFxuICAgICAgXCImc3F1ZjtcIjogXCLilqpcIixcbiAgICAgIFwiJnNyYXJyO1wiOiBcIuKGklwiLFxuICAgICAgXCImc3NjcjtcIjogXCLwnZOIXCIsXG4gICAgICBcIiZzc2V0bW47XCI6IFwi4oiWXCIsXG4gICAgICBcIiZzc21pbGU7XCI6IFwi4oyjXCIsXG4gICAgICBcIiZzc3RhcmY7XCI6IFwi4ouGXCIsXG4gICAgICBcIiZzdGFyO1wiOiBcIuKYhlwiLFxuICAgICAgXCImc3RhcmY7XCI6IFwi4piFXCIsXG4gICAgICBcIiZzdHJhaWdodGVwc2lsb247XCI6IFwiz7VcIixcbiAgICAgIFwiJnN0cmFpZ2h0cGhpO1wiOiBcIs+VXCIsXG4gICAgICBcIiZzdHJucztcIjogXCLCr1wiLFxuICAgICAgXCImc3ViO1wiOiBcIuKKglwiLFxuICAgICAgXCImc3ViRTtcIjogXCLiq4VcIixcbiAgICAgIFwiJnN1YmRvdDtcIjogXCLiqr1cIixcbiAgICAgIFwiJnN1YmU7XCI6IFwi4oqGXCIsXG4gICAgICBcIiZzdWJlZG90O1wiOiBcIuKrg1wiLFxuICAgICAgXCImc3VibXVsdDtcIjogXCLiq4FcIixcbiAgICAgIFwiJnN1Ym5FO1wiOiBcIuKri1wiLFxuICAgICAgXCImc3VibmU7XCI6IFwi4oqKXCIsXG4gICAgICBcIiZzdWJwbHVzO1wiOiBcIuKqv1wiLFxuICAgICAgXCImc3VicmFycjtcIjogXCLipblcIixcbiAgICAgIFwiJnN1YnNldDtcIjogXCLiioJcIixcbiAgICAgIFwiJnN1YnNldGVxO1wiOiBcIuKKhlwiLFxuICAgICAgXCImc3Vic2V0ZXFxO1wiOiBcIuKrhVwiLFxuICAgICAgXCImc3Vic2V0bmVxO1wiOiBcIuKKilwiLFxuICAgICAgXCImc3Vic2V0bmVxcTtcIjogXCLiq4tcIixcbiAgICAgIFwiJnN1YnNpbTtcIjogXCLiq4dcIixcbiAgICAgIFwiJnN1YnN1YjtcIjogXCLiq5VcIixcbiAgICAgIFwiJnN1YnN1cDtcIjogXCLiq5NcIixcbiAgICAgIFwiJnN1Y2M7XCI6IFwi4om7XCIsXG4gICAgICBcIiZzdWNjYXBwcm94O1wiOiBcIuKquFwiLFxuICAgICAgXCImc3VjY2N1cmx5ZXE7XCI6IFwi4om9XCIsXG4gICAgICBcIiZzdWNjZXE7XCI6IFwi4qqwXCIsXG4gICAgICBcIiZzdWNjbmFwcHJveDtcIjogXCLiqrpcIixcbiAgICAgIFwiJnN1Y2NuZXFxO1wiOiBcIuKqtlwiLFxuICAgICAgXCImc3VjY25zaW07XCI6IFwi4oupXCIsXG4gICAgICBcIiZzdWNjc2ltO1wiOiBcIuKJv1wiLFxuICAgICAgXCImc3VtO1wiOiBcIuKIkVwiLFxuICAgICAgXCImc3VuZztcIjogXCLimapcIixcbiAgICAgIFwiJnN1cDFcIjogXCLCuVwiLFxuICAgICAgXCImc3VwMTtcIjogXCLCuVwiLFxuICAgICAgXCImc3VwMlwiOiBcIsKyXCIsXG4gICAgICBcIiZzdXAyO1wiOiBcIsKyXCIsXG4gICAgICBcIiZzdXAzXCI6IFwiwrNcIixcbiAgICAgIFwiJnN1cDM7XCI6IFwiwrNcIixcbiAgICAgIFwiJnN1cDtcIjogXCLiioNcIixcbiAgICAgIFwiJnN1cEU7XCI6IFwi4quGXCIsXG4gICAgICBcIiZzdXBkb3Q7XCI6IFwi4qq+XCIsXG4gICAgICBcIiZzdXBkc3ViO1wiOiBcIuKrmFwiLFxuICAgICAgXCImc3VwZTtcIjogXCLiiodcIixcbiAgICAgIFwiJnN1cGVkb3Q7XCI6IFwi4quEXCIsXG4gICAgICBcIiZzdXBoc29sO1wiOiBcIuKfiVwiLFxuICAgICAgXCImc3VwaHN1YjtcIjogXCLiq5dcIixcbiAgICAgIFwiJnN1cGxhcnI7XCI6IFwi4qW7XCIsXG4gICAgICBcIiZzdXBtdWx0O1wiOiBcIuKrglwiLFxuICAgICAgXCImc3VwbkU7XCI6IFwi4quMXCIsXG4gICAgICBcIiZzdXBuZTtcIjogXCLiiotcIixcbiAgICAgIFwiJnN1cHBsdXM7XCI6IFwi4quAXCIsXG4gICAgICBcIiZzdXBzZXQ7XCI6IFwi4oqDXCIsXG4gICAgICBcIiZzdXBzZXRlcTtcIjogXCLiiodcIixcbiAgICAgIFwiJnN1cHNldGVxcTtcIjogXCLiq4ZcIixcbiAgICAgIFwiJnN1cHNldG5lcTtcIjogXCLiiotcIixcbiAgICAgIFwiJnN1cHNldG5lcXE7XCI6IFwi4quMXCIsXG4gICAgICBcIiZzdXBzaW07XCI6IFwi4quIXCIsXG4gICAgICBcIiZzdXBzdWI7XCI6IFwi4quUXCIsXG4gICAgICBcIiZzdXBzdXA7XCI6IFwi4quWXCIsXG4gICAgICBcIiZzd0FycjtcIjogXCLih5lcIixcbiAgICAgIFwiJnN3YXJoaztcIjogXCLipKZcIixcbiAgICAgIFwiJnN3YXJyO1wiOiBcIuKGmVwiLFxuICAgICAgXCImc3dhcnJvdztcIjogXCLihplcIixcbiAgICAgIFwiJnN3bndhcjtcIjogXCLipKpcIixcbiAgICAgIFwiJnN6bGlnXCI6IFwiw59cIixcbiAgICAgIFwiJnN6bGlnO1wiOiBcIsOfXCIsXG4gICAgICBcIiZ0YXJnZXQ7XCI6IFwi4oyWXCIsXG4gICAgICBcIiZ0YXU7XCI6IFwiz4RcIixcbiAgICAgIFwiJnRicms7XCI6IFwi4o60XCIsXG4gICAgICBcIiZ0Y2Fyb247XCI6IFwixaVcIixcbiAgICAgIFwiJnRjZWRpbDtcIjogXCLFo1wiLFxuICAgICAgXCImdGN5O1wiOiBcItGCXCIsXG4gICAgICBcIiZ0ZG90O1wiOiBcIuKDm1wiLFxuICAgICAgXCImdGVscmVjO1wiOiBcIuKMlVwiLFxuICAgICAgXCImdGZyO1wiOiBcIvCdlLFcIixcbiAgICAgIFwiJnRoZXJlNDtcIjogXCLiiLRcIixcbiAgICAgIFwiJnRoZXJlZm9yZTtcIjogXCLiiLRcIixcbiAgICAgIFwiJnRoZXRhO1wiOiBcIs64XCIsXG4gICAgICBcIiZ0aGV0YXN5bTtcIjogXCLPkVwiLFxuICAgICAgXCImdGhldGF2O1wiOiBcIs+RXCIsXG4gICAgICBcIiZ0aGlja2FwcHJveDtcIjogXCLiiYhcIixcbiAgICAgIFwiJnRoaWNrc2ltO1wiOiBcIuKIvFwiLFxuICAgICAgXCImdGhpbnNwO1wiOiBcIuKAiVwiLFxuICAgICAgXCImdGhrYXA7XCI6IFwi4omIXCIsXG4gICAgICBcIiZ0aGtzaW07XCI6IFwi4oi8XCIsXG4gICAgICBcIiZ0aG9yblwiOiBcIsO+XCIsXG4gICAgICBcIiZ0aG9ybjtcIjogXCLDvlwiLFxuICAgICAgXCImdGlsZGU7XCI6IFwiy5xcIixcbiAgICAgIFwiJnRpbWVzXCI6IFwiw5dcIixcbiAgICAgIFwiJnRpbWVzO1wiOiBcIsOXXCIsXG4gICAgICBcIiZ0aW1lc2I7XCI6IFwi4oqgXCIsXG4gICAgICBcIiZ0aW1lc2JhcjtcIjogXCLiqLFcIixcbiAgICAgIFwiJnRpbWVzZDtcIjogXCLiqLBcIixcbiAgICAgIFwiJnRpbnQ7XCI6IFwi4oitXCIsXG4gICAgICBcIiZ0b2VhO1wiOiBcIuKkqFwiLFxuICAgICAgXCImdG9wO1wiOiBcIuKKpFwiLFxuICAgICAgXCImdG9wYm90O1wiOiBcIuKMtlwiLFxuICAgICAgXCImdG9wY2lyO1wiOiBcIuKrsVwiLFxuICAgICAgXCImdG9wZjtcIjogXCLwnZWlXCIsXG4gICAgICBcIiZ0b3Bmb3JrO1wiOiBcIuKrmlwiLFxuICAgICAgXCImdG9zYTtcIjogXCLipKlcIixcbiAgICAgIFwiJnRwcmltZTtcIjogXCLigLRcIixcbiAgICAgIFwiJnRyYWRlO1wiOiBcIuKEolwiLFxuICAgICAgXCImdHJpYW5nbGU7XCI6IFwi4pa1XCIsXG4gICAgICBcIiZ0cmlhbmdsZWRvd247XCI6IFwi4pa/XCIsXG4gICAgICBcIiZ0cmlhbmdsZWxlZnQ7XCI6IFwi4peDXCIsXG4gICAgICBcIiZ0cmlhbmdsZWxlZnRlcTtcIjogXCLiirRcIixcbiAgICAgIFwiJnRyaWFuZ2xlcTtcIjogXCLiiZxcIixcbiAgICAgIFwiJnRyaWFuZ2xlcmlnaHQ7XCI6IFwi4pa5XCIsXG4gICAgICBcIiZ0cmlhbmdsZXJpZ2h0ZXE7XCI6IFwi4oq1XCIsXG4gICAgICBcIiZ0cmlkb3Q7XCI6IFwi4pesXCIsXG4gICAgICBcIiZ0cmllO1wiOiBcIuKJnFwiLFxuICAgICAgXCImdHJpbWludXM7XCI6IFwi4qi6XCIsXG4gICAgICBcIiZ0cmlwbHVzO1wiOiBcIuKouVwiLFxuICAgICAgXCImdHJpc2I7XCI6IFwi4qeNXCIsXG4gICAgICBcIiZ0cml0aW1lO1wiOiBcIuKou1wiLFxuICAgICAgXCImdHJwZXppdW07XCI6IFwi4o+iXCIsXG4gICAgICBcIiZ0c2NyO1wiOiBcIvCdk4lcIixcbiAgICAgIFwiJnRzY3k7XCI6IFwi0YZcIixcbiAgICAgIFwiJnRzaGN5O1wiOiBcItGbXCIsXG4gICAgICBcIiZ0c3Ryb2s7XCI6IFwixadcIixcbiAgICAgIFwiJnR3aXh0O1wiOiBcIuKJrFwiLFxuICAgICAgXCImdHdvaGVhZGxlZnRhcnJvdztcIjogXCLihp5cIixcbiAgICAgIFwiJnR3b2hlYWRyaWdodGFycm93O1wiOiBcIuKGoFwiLFxuICAgICAgXCImdUFycjtcIjogXCLih5FcIixcbiAgICAgIFwiJnVIYXI7XCI6IFwi4qWjXCIsXG4gICAgICBcIiZ1YWN1dGVcIjogXCLDulwiLFxuICAgICAgXCImdWFjdXRlO1wiOiBcIsO6XCIsXG4gICAgICBcIiZ1YXJyO1wiOiBcIuKGkVwiLFxuICAgICAgXCImdWJyY3k7XCI6IFwi0Z5cIixcbiAgICAgIFwiJnVicmV2ZTtcIjogXCLFrVwiLFxuICAgICAgXCImdWNpcmNcIjogXCLDu1wiLFxuICAgICAgXCImdWNpcmM7XCI6IFwiw7tcIixcbiAgICAgIFwiJnVjeTtcIjogXCLRg1wiLFxuICAgICAgXCImdWRhcnI7XCI6IFwi4oeFXCIsXG4gICAgICBcIiZ1ZGJsYWM7XCI6IFwixbFcIixcbiAgICAgIFwiJnVkaGFyO1wiOiBcIuKlrlwiLFxuICAgICAgXCImdWZpc2h0O1wiOiBcIuKlvlwiLFxuICAgICAgXCImdWZyO1wiOiBcIvCdlLJcIixcbiAgICAgIFwiJnVncmF2ZVwiOiBcIsO5XCIsXG4gICAgICBcIiZ1Z3JhdmU7XCI6IFwiw7lcIixcbiAgICAgIFwiJnVoYXJsO1wiOiBcIuKGv1wiLFxuICAgICAgXCImdWhhcnI7XCI6IFwi4oa+XCIsXG4gICAgICBcIiZ1aGJsaztcIjogXCLiloBcIixcbiAgICAgIFwiJnVsY29ybjtcIjogXCLijJxcIixcbiAgICAgIFwiJnVsY29ybmVyO1wiOiBcIuKMnFwiLFxuICAgICAgXCImdWxjcm9wO1wiOiBcIuKMj1wiLFxuICAgICAgXCImdWx0cmk7XCI6IFwi4pe4XCIsXG4gICAgICBcIiZ1bWFjcjtcIjogXCLFq1wiLFxuICAgICAgXCImdW1sXCI6IFwiwqhcIixcbiAgICAgIFwiJnVtbDtcIjogXCLCqFwiLFxuICAgICAgXCImdW9nb247XCI6IFwixbNcIixcbiAgICAgIFwiJnVvcGY7XCI6IFwi8J2VplwiLFxuICAgICAgXCImdXBhcnJvdztcIjogXCLihpFcIixcbiAgICAgIFwiJnVwZG93bmFycm93O1wiOiBcIuKGlVwiLFxuICAgICAgXCImdXBoYXJwb29ubGVmdDtcIjogXCLihr9cIixcbiAgICAgIFwiJnVwaGFycG9vbnJpZ2h0O1wiOiBcIuKGvlwiLFxuICAgICAgXCImdXBsdXM7XCI6IFwi4oqOXCIsXG4gICAgICBcIiZ1cHNpO1wiOiBcIs+FXCIsXG4gICAgICBcIiZ1cHNpaDtcIjogXCLPklwiLFxuICAgICAgXCImdXBzaWxvbjtcIjogXCLPhVwiLFxuICAgICAgXCImdXB1cGFycm93cztcIjogXCLih4hcIixcbiAgICAgIFwiJnVyY29ybjtcIjogXCLijJ1cIixcbiAgICAgIFwiJnVyY29ybmVyO1wiOiBcIuKMnVwiLFxuICAgICAgXCImdXJjcm9wO1wiOiBcIuKMjlwiLFxuICAgICAgXCImdXJpbmc7XCI6IFwixa9cIixcbiAgICAgIFwiJnVydHJpO1wiOiBcIuKXuVwiLFxuICAgICAgXCImdXNjcjtcIjogXCLwnZOKXCIsXG4gICAgICBcIiZ1dGRvdDtcIjogXCLii7BcIixcbiAgICAgIFwiJnV0aWxkZTtcIjogXCLFqVwiLFxuICAgICAgXCImdXRyaTtcIjogXCLilrVcIixcbiAgICAgIFwiJnV0cmlmO1wiOiBcIuKWtFwiLFxuICAgICAgXCImdXVhcnI7XCI6IFwi4oeIXCIsXG4gICAgICBcIiZ1dW1sXCI6IFwiw7xcIixcbiAgICAgIFwiJnV1bWw7XCI6IFwiw7xcIixcbiAgICAgIFwiJnV3YW5nbGU7XCI6IFwi4qanXCIsXG4gICAgICBcIiZ2QXJyO1wiOiBcIuKHlVwiLFxuICAgICAgXCImdkJhcjtcIjogXCLiq6hcIixcbiAgICAgIFwiJnZCYXJ2O1wiOiBcIuKrqVwiLFxuICAgICAgXCImdkRhc2g7XCI6IFwi4oqoXCIsXG4gICAgICBcIiZ2YW5ncnQ7XCI6IFwi4qacXCIsXG4gICAgICBcIiZ2YXJlcHNpbG9uO1wiOiBcIs+1XCIsXG4gICAgICBcIiZ2YXJrYXBwYTtcIjogXCLPsFwiLFxuICAgICAgXCImdmFybm90aGluZztcIjogXCLiiIVcIixcbiAgICAgIFwiJnZhcnBoaTtcIjogXCLPlVwiLFxuICAgICAgXCImdmFycGk7XCI6IFwiz5ZcIixcbiAgICAgIFwiJnZhcnByb3B0bztcIjogXCLiiJ1cIixcbiAgICAgIFwiJnZhcnI7XCI6IFwi4oaVXCIsXG4gICAgICBcIiZ2YXJyaG87XCI6IFwiz7FcIixcbiAgICAgIFwiJnZhcnNpZ21hO1wiOiBcIs+CXCIsXG4gICAgICBcIiZ2YXJzdWJzZXRuZXE7XCI6IFwi4oqK77iAXCIsXG4gICAgICBcIiZ2YXJzdWJzZXRuZXFxO1wiOiBcIuKri++4gFwiLFxuICAgICAgXCImdmFyc3Vwc2V0bmVxO1wiOiBcIuKKi++4gFwiLFxuICAgICAgXCImdmFyc3Vwc2V0bmVxcTtcIjogXCLiq4zvuIBcIixcbiAgICAgIFwiJnZhcnRoZXRhO1wiOiBcIs+RXCIsXG4gICAgICBcIiZ2YXJ0cmlhbmdsZWxlZnQ7XCI6IFwi4oqyXCIsXG4gICAgICBcIiZ2YXJ0cmlhbmdsZXJpZ2h0O1wiOiBcIuKKs1wiLFxuICAgICAgXCImdmN5O1wiOiBcItCyXCIsXG4gICAgICBcIiZ2ZGFzaDtcIjogXCLiiqJcIixcbiAgICAgIFwiJnZlZTtcIjogXCLiiKhcIixcbiAgICAgIFwiJnZlZWJhcjtcIjogXCLiirtcIixcbiAgICAgIFwiJnZlZWVxO1wiOiBcIuKJmlwiLFxuICAgICAgXCImdmVsbGlwO1wiOiBcIuKLrlwiLFxuICAgICAgXCImdmVyYmFyO1wiOiBcInxcIixcbiAgICAgIFwiJnZlcnQ7XCI6IFwifFwiLFxuICAgICAgXCImdmZyO1wiOiBcIvCdlLNcIixcbiAgICAgIFwiJnZsdHJpO1wiOiBcIuKKslwiLFxuICAgICAgXCImdm5zdWI7XCI6IFwi4oqC4oOSXCIsXG4gICAgICBcIiZ2bnN1cDtcIjogXCLiioPig5JcIixcbiAgICAgIFwiJnZvcGY7XCI6IFwi8J2Vp1wiLFxuICAgICAgXCImdnByb3A7XCI6IFwi4oidXCIsXG4gICAgICBcIiZ2cnRyaTtcIjogXCLiirNcIixcbiAgICAgIFwiJnZzY3I7XCI6IFwi8J2Ti1wiLFxuICAgICAgXCImdnN1Ym5FO1wiOiBcIuKri++4gFwiLFxuICAgICAgXCImdnN1Ym5lO1wiOiBcIuKKiu+4gFwiLFxuICAgICAgXCImdnN1cG5FO1wiOiBcIuKrjO+4gFwiLFxuICAgICAgXCImdnN1cG5lO1wiOiBcIuKKi++4gFwiLFxuICAgICAgXCImdnppZ3phZztcIjogXCLipppcIixcbiAgICAgIFwiJndjaXJjO1wiOiBcIsW1XCIsXG4gICAgICBcIiZ3ZWRiYXI7XCI6IFwi4qmfXCIsXG4gICAgICBcIiZ3ZWRnZTtcIjogXCLiiKdcIixcbiAgICAgIFwiJndlZGdlcTtcIjogXCLiiZlcIixcbiAgICAgIFwiJndlaWVycDtcIjogXCLihJhcIixcbiAgICAgIFwiJndmcjtcIjogXCLwnZS0XCIsXG4gICAgICBcIiZ3b3BmO1wiOiBcIvCdlahcIixcbiAgICAgIFwiJndwO1wiOiBcIuKEmFwiLFxuICAgICAgXCImd3I7XCI6IFwi4omAXCIsXG4gICAgICBcIiZ3cmVhdGg7XCI6IFwi4omAXCIsXG4gICAgICBcIiZ3c2NyO1wiOiBcIvCdk4xcIixcbiAgICAgIFwiJnhjYXA7XCI6IFwi4ouCXCIsXG4gICAgICBcIiZ4Y2lyYztcIjogXCLil69cIixcbiAgICAgIFwiJnhjdXA7XCI6IFwi4ouDXCIsXG4gICAgICBcIiZ4ZHRyaTtcIjogXCLilr1cIixcbiAgICAgIFwiJnhmcjtcIjogXCLwnZS1XCIsXG4gICAgICBcIiZ4aEFycjtcIjogXCLin7pcIixcbiAgICAgIFwiJnhoYXJyO1wiOiBcIuKft1wiLFxuICAgICAgXCImeGk7XCI6IFwizr5cIixcbiAgICAgIFwiJnhsQXJyO1wiOiBcIuKfuFwiLFxuICAgICAgXCImeGxhcnI7XCI6IFwi4p+1XCIsXG4gICAgICBcIiZ4bWFwO1wiOiBcIuKfvFwiLFxuICAgICAgXCImeG5pcztcIjogXCLii7tcIixcbiAgICAgIFwiJnhvZG90O1wiOiBcIuKogFwiLFxuICAgICAgXCImeG9wZjtcIjogXCLwnZWpXCIsXG4gICAgICBcIiZ4b3BsdXM7XCI6IFwi4qiBXCIsXG4gICAgICBcIiZ4b3RpbWU7XCI6IFwi4qiCXCIsXG4gICAgICBcIiZ4ckFycjtcIjogXCLin7lcIixcbiAgICAgIFwiJnhyYXJyO1wiOiBcIuKftlwiLFxuICAgICAgXCImeHNjcjtcIjogXCLwnZONXCIsXG4gICAgICBcIiZ4c3FjdXA7XCI6IFwi4qiGXCIsXG4gICAgICBcIiZ4dXBsdXM7XCI6IFwi4qiEXCIsXG4gICAgICBcIiZ4dXRyaTtcIjogXCLilrNcIixcbiAgICAgIFwiJnh2ZWU7XCI6IFwi4ouBXCIsXG4gICAgICBcIiZ4d2VkZ2U7XCI6IFwi4ouAXCIsXG4gICAgICBcIiZ5YWN1dGVcIjogXCLDvVwiLFxuICAgICAgXCImeWFjdXRlO1wiOiBcIsO9XCIsXG4gICAgICBcIiZ5YWN5O1wiOiBcItGPXCIsXG4gICAgICBcIiZ5Y2lyYztcIjogXCLFt1wiLFxuICAgICAgXCImeWN5O1wiOiBcItGLXCIsXG4gICAgICBcIiZ5ZW5cIjogXCLCpVwiLFxuICAgICAgXCImeWVuO1wiOiBcIsKlXCIsXG4gICAgICBcIiZ5ZnI7XCI6IFwi8J2UtlwiLFxuICAgICAgXCImeWljeTtcIjogXCLRl1wiLFxuICAgICAgXCImeW9wZjtcIjogXCLwnZWqXCIsXG4gICAgICBcIiZ5c2NyO1wiOiBcIvCdk45cIixcbiAgICAgIFwiJnl1Y3k7XCI6IFwi0Y5cIixcbiAgICAgIFwiJnl1bWxcIjogXCLDv1wiLFxuICAgICAgXCImeXVtbDtcIjogXCLDv1wiLFxuICAgICAgXCImemFjdXRlO1wiOiBcIsW6XCIsXG4gICAgICBcIiZ6Y2Fyb247XCI6IFwixb5cIixcbiAgICAgIFwiJnpjeTtcIjogXCLQt1wiLFxuICAgICAgXCImemRvdDtcIjogXCLFvFwiLFxuICAgICAgXCImemVldHJmO1wiOiBcIuKEqFwiLFxuICAgICAgXCImemV0YTtcIjogXCLOtlwiLFxuICAgICAgXCImemZyO1wiOiBcIvCdlLdcIixcbiAgICAgIFwiJnpoY3k7XCI6IFwi0LZcIixcbiAgICAgIFwiJnppZ3JhcnI7XCI6IFwi4oedXCIsXG4gICAgICBcIiZ6b3BmO1wiOiBcIvCdlatcIixcbiAgICAgIFwiJnpzY3I7XCI6IFwi8J2Tj1wiLFxuICAgICAgXCImendqO1wiOiBcIuKAjVwiLFxuICAgICAgXCImenduajtcIjogXCLigIxcIlxuICAgIH0sXG4gICAgY2hhcmFjdGVyczoge1xuICAgICAgXCLDhlwiOiBcIiZBRWxpZztcIixcbiAgICAgIFwiJlwiOiBcIiZhbXA7XCIsXG4gICAgICBcIsOBXCI6IFwiJkFhY3V0ZTtcIixcbiAgICAgIFwixIJcIjogXCImQWJyZXZlO1wiLFxuICAgICAgXCLDglwiOiBcIiZBY2lyYztcIixcbiAgICAgIFwi0JBcIjogXCImQWN5O1wiLFxuICAgICAgXCLwnZSEXCI6IFwiJkFmcjtcIixcbiAgICAgIFwiw4BcIjogXCImQWdyYXZlO1wiLFxuICAgICAgXCLOkVwiOiBcIiZBbHBoYTtcIixcbiAgICAgIFwixIBcIjogXCImQW1hY3I7XCIsXG4gICAgICBcIuKpk1wiOiBcIiZBbmQ7XCIsXG4gICAgICBcIsSEXCI6IFwiJkFvZ29uO1wiLFxuICAgICAgXCLwnZS4XCI6IFwiJkFvcGY7XCIsXG4gICAgICBcIuKBoVwiOiBcIiZhZjtcIixcbiAgICAgIFwiw4VcIjogXCImYW5nc3Q7XCIsXG4gICAgICBcIvCdkpxcIjogXCImQXNjcjtcIixcbiAgICAgIFwi4omUXCI6IFwiJmNvbG9uZXE7XCIsXG4gICAgICBcIsODXCI6IFwiJkF0aWxkZTtcIixcbiAgICAgIFwiw4RcIjogXCImQXVtbDtcIixcbiAgICAgIFwi4oiWXCI6IFwiJnNzZXRtbjtcIixcbiAgICAgIFwi4qunXCI6IFwiJkJhcnY7XCIsXG4gICAgICBcIuKMhlwiOiBcIiZkb3VibGViYXJ3ZWRnZTtcIixcbiAgICAgIFwi0JFcIjogXCImQmN5O1wiLFxuICAgICAgXCLiiLVcIjogXCImYmVjYXVzZTtcIixcbiAgICAgIFwi4oSsXCI6IFwiJmJlcm5vdTtcIixcbiAgICAgIFwizpJcIjogXCImQmV0YTtcIixcbiAgICAgIFwi8J2UhVwiOiBcIiZCZnI7XCIsXG4gICAgICBcIvCdlLlcIjogXCImQm9wZjtcIixcbiAgICAgIFwiy5hcIjogXCImYnJldmU7XCIsXG4gICAgICBcIuKJjlwiOiBcIiZidW1wO1wiLFxuICAgICAgXCLQp1wiOiBcIiZDSGN5O1wiLFxuICAgICAgXCLCqVwiOiBcIiZjb3B5O1wiLFxuICAgICAgXCLEhlwiOiBcIiZDYWN1dGU7XCIsXG4gICAgICBcIuKLklwiOiBcIiZDYXA7XCIsXG4gICAgICBcIuKFhVwiOiBcIiZERDtcIixcbiAgICAgIFwi4oStXCI6IFwiJkNmcjtcIixcbiAgICAgIFwixIxcIjogXCImQ2Nhcm9uO1wiLFxuICAgICAgXCLDh1wiOiBcIiZDY2VkaWw7XCIsXG4gICAgICBcIsSIXCI6IFwiJkNjaXJjO1wiLFxuICAgICAgXCLiiLBcIjogXCImQ2NvbmludDtcIixcbiAgICAgIFwixIpcIjogXCImQ2RvdDtcIixcbiAgICAgIFwiwrhcIjogXCImY2VkaWw7XCIsXG4gICAgICBcIsK3XCI6IFwiJm1pZGRvdDtcIixcbiAgICAgIFwizqdcIjogXCImQ2hpO1wiLFxuICAgICAgXCLiiplcIjogXCImb2RvdDtcIixcbiAgICAgIFwi4oqWXCI6IFwiJm9taW51cztcIixcbiAgICAgIFwi4oqVXCI6IFwiJm9wbHVzO1wiLFxuICAgICAgXCLiipdcIjogXCImb3RpbWVzO1wiLFxuICAgICAgXCLiiLJcIjogXCImY3djb25pbnQ7XCIsXG4gICAgICBcIuKAnVwiOiBcIiZyZHF1b3I7XCIsXG4gICAgICBcIuKAmVwiOiBcIiZyc3F1b3I7XCIsXG4gICAgICBcIuKIt1wiOiBcIiZQcm9wb3J0aW9uO1wiLFxuICAgICAgXCLiqbRcIjogXCImQ29sb25lO1wiLFxuICAgICAgXCLiiaFcIjogXCImZXF1aXY7XCIsXG4gICAgICBcIuKIr1wiOiBcIiZEb3VibGVDb250b3VySW50ZWdyYWw7XCIsXG4gICAgICBcIuKIrlwiOiBcIiZvaW50O1wiLFxuICAgICAgXCLihIJcIjogXCImY29tcGxleGVzO1wiLFxuICAgICAgXCLiiJBcIjogXCImY29wcm9kO1wiLFxuICAgICAgXCLiiLNcIjogXCImYXdjb25pbnQ7XCIsXG4gICAgICBcIuKor1wiOiBcIiZDcm9zcztcIixcbiAgICAgIFwi8J2SnlwiOiBcIiZDc2NyO1wiLFxuICAgICAgXCLii5NcIjogXCImQ3VwO1wiLFxuICAgICAgXCLiiY1cIjogXCImYXN5bXBlcTtcIixcbiAgICAgIFwi4qSRXCI6IFwiJkREb3RyYWhkO1wiLFxuICAgICAgXCLQglwiOiBcIiZESmN5O1wiLFxuICAgICAgXCLQhVwiOiBcIiZEU2N5O1wiLFxuICAgICAgXCLQj1wiOiBcIiZEWmN5O1wiLFxuICAgICAgXCLigKFcIjogXCImZGRhZ2dlcjtcIixcbiAgICAgIFwi4oahXCI6IFwiJkRhcnI7XCIsXG4gICAgICBcIuKrpFwiOiBcIiZEb3VibGVMZWZ0VGVlO1wiLFxuICAgICAgXCLEjlwiOiBcIiZEY2Fyb247XCIsXG4gICAgICBcItCUXCI6IFwiJkRjeTtcIixcbiAgICAgIFwi4oiHXCI6IFwiJm5hYmxhO1wiLFxuICAgICAgXCLOlFwiOiBcIiZEZWx0YTtcIixcbiAgICAgIFwi8J2Uh1wiOiBcIiZEZnI7XCIsXG4gICAgICBcIsK0XCI6IFwiJmFjdXRlO1wiLFxuICAgICAgXCLLmVwiOiBcIiZkb3Q7XCIsXG4gICAgICBcIsudXCI6IFwiJmRibGFjO1wiLFxuICAgICAgXCJgXCI6IFwiJmdyYXZlO1wiLFxuICAgICAgXCLLnFwiOiBcIiZ0aWxkZTtcIixcbiAgICAgIFwi4ouEXCI6IFwiJmRpYW1vbmQ7XCIsXG4gICAgICBcIuKFhlwiOiBcIiZkZDtcIixcbiAgICAgIFwi8J2Uu1wiOiBcIiZEb3BmO1wiLFxuICAgICAgXCLCqFwiOiBcIiZ1bWw7XCIsXG4gICAgICBcIuKDnFwiOiBcIiZEb3REb3Q7XCIsXG4gICAgICBcIuKJkFwiOiBcIiZlc2RvdDtcIixcbiAgICAgIFwi4oeTXCI6IFwiJmRBcnI7XCIsXG4gICAgICBcIuKHkFwiOiBcIiZsQXJyO1wiLFxuICAgICAgXCLih5RcIjogXCImaWZmO1wiLFxuICAgICAgXCLin7hcIjogXCImeGxBcnI7XCIsXG4gICAgICBcIuKfulwiOiBcIiZ4aEFycjtcIixcbiAgICAgIFwi4p+5XCI6IFwiJnhyQXJyO1wiLFxuICAgICAgXCLih5JcIjogXCImckFycjtcIixcbiAgICAgIFwi4oqoXCI6IFwiJnZEYXNoO1wiLFxuICAgICAgXCLih5FcIjogXCImdUFycjtcIixcbiAgICAgIFwi4oeVXCI6IFwiJnZBcnI7XCIsXG4gICAgICBcIuKIpVwiOiBcIiZzcGFyO1wiLFxuICAgICAgXCLihpNcIjogXCImZG93bmFycm93O1wiLFxuICAgICAgXCLipJNcIjogXCImRG93bkFycm93QmFyO1wiLFxuICAgICAgXCLih7VcIjogXCImZHVhcnI7XCIsXG4gICAgICBcIsyRXCI6IFwiJkRvd25CcmV2ZTtcIixcbiAgICAgIFwi4qWQXCI6IFwiJkRvd25MZWZ0UmlnaHRWZWN0b3I7XCIsXG4gICAgICBcIuKlnlwiOiBcIiZEb3duTGVmdFRlZVZlY3RvcjtcIixcbiAgICAgIFwi4oa9XCI6IFwiJmxoYXJkO1wiLFxuICAgICAgXCLipZZcIjogXCImRG93bkxlZnRWZWN0b3JCYXI7XCIsXG4gICAgICBcIuKln1wiOiBcIiZEb3duUmlnaHRUZWVWZWN0b3I7XCIsXG4gICAgICBcIuKHgVwiOiBcIiZyaWdodGhhcnBvb25kb3duO1wiLFxuICAgICAgXCLipZdcIjogXCImRG93blJpZ2h0VmVjdG9yQmFyO1wiLFxuICAgICAgXCLiiqRcIjogXCImdG9wO1wiLFxuICAgICAgXCLihqdcIjogXCImbWFwc3RvZG93bjtcIixcbiAgICAgIFwi8J2Sn1wiOiBcIiZEc2NyO1wiLFxuICAgICAgXCLEkFwiOiBcIiZEc3Ryb2s7XCIsXG4gICAgICBcIsWKXCI6IFwiJkVORztcIixcbiAgICAgIFwiw5BcIjogXCImRVRIO1wiLFxuICAgICAgXCLDiVwiOiBcIiZFYWN1dGU7XCIsXG4gICAgICBcIsSaXCI6IFwiJkVjYXJvbjtcIixcbiAgICAgIFwiw4pcIjogXCImRWNpcmM7XCIsXG4gICAgICBcItCtXCI6IFwiJkVjeTtcIixcbiAgICAgIFwixJZcIjogXCImRWRvdDtcIixcbiAgICAgIFwi8J2UiFwiOiBcIiZFZnI7XCIsXG4gICAgICBcIsOIXCI6IFwiJkVncmF2ZTtcIixcbiAgICAgIFwi4oiIXCI6IFwiJmlzaW52O1wiLFxuICAgICAgXCLEklwiOiBcIiZFbWFjcjtcIixcbiAgICAgIFwi4pe7XCI6IFwiJkVtcHR5U21hbGxTcXVhcmU7XCIsXG4gICAgICBcIuKWq1wiOiBcIiZFbXB0eVZlcnlTbWFsbFNxdWFyZTtcIixcbiAgICAgIFwixJhcIjogXCImRW9nb247XCIsXG4gICAgICBcIvCdlLxcIjogXCImRW9wZjtcIixcbiAgICAgIFwizpVcIjogXCImRXBzaWxvbjtcIixcbiAgICAgIFwi4qm1XCI6IFwiJkVxdWFsO1wiLFxuICAgICAgXCLiiYJcIjogXCImZXNpbTtcIixcbiAgICAgIFwi4oeMXCI6IFwiJnJsaGFyO1wiLFxuICAgICAgXCLihLBcIjogXCImZXhwZWN0YXRpb247XCIsXG4gICAgICBcIuKps1wiOiBcIiZFc2ltO1wiLFxuICAgICAgXCLOl1wiOiBcIiZFdGE7XCIsXG4gICAgICBcIsOLXCI6IFwiJkV1bWw7XCIsXG4gICAgICBcIuKIg1wiOiBcIiZleGlzdDtcIixcbiAgICAgIFwi4oWHXCI6IFwiJmV4cG9uZW50aWFsZTtcIixcbiAgICAgIFwi0KRcIjogXCImRmN5O1wiLFxuICAgICAgXCLwnZSJXCI6IFwiJkZmcjtcIixcbiAgICAgIFwi4pe8XCI6IFwiJkZpbGxlZFNtYWxsU3F1YXJlO1wiLFxuICAgICAgXCLilqpcIjogXCImc3F1ZjtcIixcbiAgICAgIFwi8J2UvVwiOiBcIiZGb3BmO1wiLFxuICAgICAgXCLiiIBcIjogXCImZm9yYWxsO1wiLFxuICAgICAgXCLihLFcIjogXCImRnNjcjtcIixcbiAgICAgIFwi0INcIjogXCImR0pjeTtcIixcbiAgICAgIFwiPlwiOiBcIiZndDtcIixcbiAgICAgIFwizpNcIjogXCImR2FtbWE7XCIsXG4gICAgICBcIs+cXCI6IFwiJkdhbW1hZDtcIixcbiAgICAgIFwixJ5cIjogXCImR2JyZXZlO1wiLFxuICAgICAgXCLEolwiOiBcIiZHY2VkaWw7XCIsXG4gICAgICBcIsScXCI6IFwiJkdjaXJjO1wiLFxuICAgICAgXCLQk1wiOiBcIiZHY3k7XCIsXG4gICAgICBcIsSgXCI6IFwiJkdkb3Q7XCIsXG4gICAgICBcIvCdlIpcIjogXCImR2ZyO1wiLFxuICAgICAgXCLii5lcIjogXCImZ2dnO1wiLFxuICAgICAgXCLwnZS+XCI6IFwiJkdvcGY7XCIsXG4gICAgICBcIuKJpVwiOiBcIiZnZXE7XCIsXG4gICAgICBcIuKLm1wiOiBcIiZndHJlcWxlc3M7XCIsXG4gICAgICBcIuKJp1wiOiBcIiZnZXFxO1wiLFxuICAgICAgXCLiqqJcIjogXCImR3JlYXRlckdyZWF0ZXI7XCIsXG4gICAgICBcIuKJt1wiOiBcIiZndHJsZXNzO1wiLFxuICAgICAgXCLiqb5cIjogXCImZ2VzO1wiLFxuICAgICAgXCLiibNcIjogXCImZ3Ryc2ltO1wiLFxuICAgICAgXCLwnZKiXCI6IFwiJkdzY3I7XCIsXG4gICAgICBcIuKJq1wiOiBcIiZnZztcIixcbiAgICAgIFwi0KpcIjogXCImSEFSRGN5O1wiLFxuICAgICAgXCLLh1wiOiBcIiZjYXJvbjtcIixcbiAgICAgIFwiXlwiOiBcIiZIYXQ7XCIsXG4gICAgICBcIsSkXCI6IFwiJkhjaXJjO1wiLFxuICAgICAgXCLihIxcIjogXCImUG9pbmNhcmVwbGFuZTtcIixcbiAgICAgIFwi4oSLXCI6IFwiJmhhbWlsdDtcIixcbiAgICAgIFwi4oSNXCI6IFwiJnF1YXRlcm5pb25zO1wiLFxuICAgICAgXCLilIBcIjogXCImYm94aDtcIixcbiAgICAgIFwixKZcIjogXCImSHN0cm9rO1wiLFxuICAgICAgXCLiiY9cIjogXCImYnVtcGVxO1wiLFxuICAgICAgXCLQlVwiOiBcIiZJRWN5O1wiLFxuICAgICAgXCLEslwiOiBcIiZJSmxpZztcIixcbiAgICAgIFwi0IFcIjogXCImSU9jeTtcIixcbiAgICAgIFwiw41cIjogXCImSWFjdXRlO1wiLFxuICAgICAgXCLDjlwiOiBcIiZJY2lyYztcIixcbiAgICAgIFwi0JhcIjogXCImSWN5O1wiLFxuICAgICAgXCLEsFwiOiBcIiZJZG90O1wiLFxuICAgICAgXCLihJFcIjogXCImaW1hZ3BhcnQ7XCIsXG4gICAgICBcIsOMXCI6IFwiJklncmF2ZTtcIixcbiAgICAgIFwixKpcIjogXCImSW1hY3I7XCIsXG4gICAgICBcIuKFiFwiOiBcIiZpaTtcIixcbiAgICAgIFwi4oisXCI6IFwiJkludDtcIixcbiAgICAgIFwi4oirXCI6IFwiJmludDtcIixcbiAgICAgIFwi4ouCXCI6IFwiJnhjYXA7XCIsXG4gICAgICBcIuKBo1wiOiBcIiZpYztcIixcbiAgICAgIFwi4oGiXCI6IFwiJml0O1wiLFxuICAgICAgXCLErlwiOiBcIiZJb2dvbjtcIixcbiAgICAgIFwi8J2VgFwiOiBcIiZJb3BmO1wiLFxuICAgICAgXCLOmVwiOiBcIiZJb3RhO1wiLFxuICAgICAgXCLihJBcIjogXCImaW1hZ2xpbmU7XCIsXG4gICAgICBcIsSoXCI6IFwiJkl0aWxkZTtcIixcbiAgICAgIFwi0IZcIjogXCImSXVrY3k7XCIsXG4gICAgICBcIsOPXCI6IFwiJkl1bWw7XCIsXG4gICAgICBcIsS0XCI6IFwiJkpjaXJjO1wiLFxuICAgICAgXCLQmVwiOiBcIiZKY3k7XCIsXG4gICAgICBcIvCdlI1cIjogXCImSmZyO1wiLFxuICAgICAgXCLwnZWBXCI6IFwiJkpvcGY7XCIsXG4gICAgICBcIvCdkqVcIjogXCImSnNjcjtcIixcbiAgICAgIFwi0IhcIjogXCImSnNlcmN5O1wiLFxuICAgICAgXCLQhFwiOiBcIiZKdWtjeTtcIixcbiAgICAgIFwi0KVcIjogXCImS0hjeTtcIixcbiAgICAgIFwi0IxcIjogXCImS0pjeTtcIixcbiAgICAgIFwizppcIjogXCImS2FwcGE7XCIsXG4gICAgICBcIsS2XCI6IFwiJktjZWRpbDtcIixcbiAgICAgIFwi0JpcIjogXCImS2N5O1wiLFxuICAgICAgXCLwnZSOXCI6IFwiJktmcjtcIixcbiAgICAgIFwi8J2VglwiOiBcIiZLb3BmO1wiLFxuICAgICAgXCLwnZKmXCI6IFwiJktzY3I7XCIsXG4gICAgICBcItCJXCI6IFwiJkxKY3k7XCIsXG4gICAgICBcIjxcIjogXCImbHQ7XCIsXG4gICAgICBcIsS5XCI6IFwiJkxhY3V0ZTtcIixcbiAgICAgIFwizptcIjogXCImTGFtYmRhO1wiLFxuICAgICAgXCLin6pcIjogXCImTGFuZztcIixcbiAgICAgIFwi4oSSXCI6IFwiJmxhZ3JhbjtcIixcbiAgICAgIFwi4oaeXCI6IFwiJnR3b2hlYWRsZWZ0YXJyb3c7XCIsXG4gICAgICBcIsS9XCI6IFwiJkxjYXJvbjtcIixcbiAgICAgIFwixLtcIjogXCImTGNlZGlsO1wiLFxuICAgICAgXCLQm1wiOiBcIiZMY3k7XCIsXG4gICAgICBcIuKfqFwiOiBcIiZsYW5nbGU7XCIsXG4gICAgICBcIuKGkFwiOiBcIiZzbGFycjtcIixcbiAgICAgIFwi4oekXCI6IFwiJmxhcnJiO1wiLFxuICAgICAgXCLih4ZcIjogXCImbHJhcnI7XCIsXG4gICAgICBcIuKMiFwiOiBcIiZsY2VpbDtcIixcbiAgICAgIFwi4p+mXCI6IFwiJmxvYnJrO1wiLFxuICAgICAgXCLipaFcIjogXCImTGVmdERvd25UZWVWZWN0b3I7XCIsXG4gICAgICBcIuKHg1wiOiBcIiZkb3duaGFycG9vbmxlZnQ7XCIsXG4gICAgICBcIuKlmVwiOiBcIiZMZWZ0RG93blZlY3RvckJhcjtcIixcbiAgICAgIFwi4oyKXCI6IFwiJmxmbG9vcjtcIixcbiAgICAgIFwi4oaUXCI6IFwiJmxlZnRyaWdodGFycm93O1wiLFxuICAgICAgXCLipY5cIjogXCImTGVmdFJpZ2h0VmVjdG9yO1wiLFxuICAgICAgXCLiiqNcIjogXCImZGFzaHY7XCIsXG4gICAgICBcIuKGpFwiOiBcIiZtYXBzdG9sZWZ0O1wiLFxuICAgICAgXCLipZpcIjogXCImTGVmdFRlZVZlY3RvcjtcIixcbiAgICAgIFwi4oqyXCI6IFwiJnZsdHJpO1wiLFxuICAgICAgXCLip49cIjogXCImTGVmdFRyaWFuZ2xlQmFyO1wiLFxuICAgICAgXCLiirRcIjogXCImdHJpYW5nbGVsZWZ0ZXE7XCIsXG4gICAgICBcIuKlkVwiOiBcIiZMZWZ0VXBEb3duVmVjdG9yO1wiLFxuICAgICAgXCLipaBcIjogXCImTGVmdFVwVGVlVmVjdG9yO1wiLFxuICAgICAgXCLihr9cIjogXCImdXBoYXJwb29ubGVmdDtcIixcbiAgICAgIFwi4qWYXCI6IFwiJkxlZnRVcFZlY3RvckJhcjtcIixcbiAgICAgIFwi4oa8XCI6IFwiJmxoYXJ1O1wiLFxuICAgICAgXCLipZJcIjogXCImTGVmdFZlY3RvckJhcjtcIixcbiAgICAgIFwi4ouaXCI6IFwiJmxlc3NlcWd0cjtcIixcbiAgICAgIFwi4ommXCI6IFwiJmxlcXE7XCIsXG4gICAgICBcIuKJtlwiOiBcIiZsZztcIixcbiAgICAgIFwi4qqhXCI6IFwiJkxlc3NMZXNzO1wiLFxuICAgICAgXCLiqb1cIjogXCImbGVzO1wiLFxuICAgICAgXCLiibJcIjogXCImbHNpbTtcIixcbiAgICAgIFwi8J2Uj1wiOiBcIiZMZnI7XCIsXG4gICAgICBcIuKLmFwiOiBcIiZMbDtcIixcbiAgICAgIFwi4oeaXCI6IFwiJmxBYXJyO1wiLFxuICAgICAgXCLEv1wiOiBcIiZMbWlkb3Q7XCIsXG4gICAgICBcIuKftVwiOiBcIiZ4bGFycjtcIixcbiAgICAgIFwi4p+3XCI6IFwiJnhoYXJyO1wiLFxuICAgICAgXCLin7ZcIjogXCImeHJhcnI7XCIsXG4gICAgICBcIvCdlYNcIjogXCImTG9wZjtcIixcbiAgICAgIFwi4oaZXCI6IFwiJnN3YXJyb3c7XCIsXG4gICAgICBcIuKGmFwiOiBcIiZzZWFycm93O1wiLFxuICAgICAgXCLihrBcIjogXCImbHNoO1wiLFxuICAgICAgXCLFgVwiOiBcIiZMc3Ryb2s7XCIsXG4gICAgICBcIuKJqlwiOiBcIiZsbDtcIixcbiAgICAgIFwi4qSFXCI6IFwiJk1hcDtcIixcbiAgICAgIFwi0JxcIjogXCImTWN5O1wiLFxuICAgICAgXCLigZ9cIjogXCImTWVkaXVtU3BhY2U7XCIsXG4gICAgICBcIuKEs1wiOiBcIiZwaG1tYXQ7XCIsXG4gICAgICBcIvCdlJBcIjogXCImTWZyO1wiLFxuICAgICAgXCLiiJNcIjogXCImbXA7XCIsXG4gICAgICBcIvCdlYRcIjogXCImTW9wZjtcIixcbiAgICAgIFwizpxcIjogXCImTXU7XCIsXG4gICAgICBcItCKXCI6IFwiJk5KY3k7XCIsXG4gICAgICBcIsWDXCI6IFwiJk5hY3V0ZTtcIixcbiAgICAgIFwixYdcIjogXCImTmNhcm9uO1wiLFxuICAgICAgXCLFhVwiOiBcIiZOY2VkaWw7XCIsXG4gICAgICBcItCdXCI6IFwiJk5jeTtcIixcbiAgICAgIFwi4oCLXCI6IFwiJlplcm9XaWR0aFNwYWNlO1wiLFxuICAgICAgXCJcXG5cIjogXCImTmV3TGluZTtcIixcbiAgICAgIFwi8J2UkVwiOiBcIiZOZnI7XCIsXG4gICAgICBcIuKBoFwiOiBcIiZOb0JyZWFrO1wiLFxuICAgICAgXCLCoFwiOiBcIiZuYnNwO1wiLFxuICAgICAgXCLihJVcIjogXCImbmF0dXJhbHM7XCIsXG4gICAgICBcIuKrrFwiOiBcIiZOb3Q7XCIsXG4gICAgICBcIuKJolwiOiBcIiZuZXF1aXY7XCIsXG4gICAgICBcIuKJrVwiOiBcIiZOb3RDdXBDYXA7XCIsXG4gICAgICBcIuKIplwiOiBcIiZuc3BhcjtcIixcbiAgICAgIFwi4oiJXCI6IFwiJm5vdGludmE7XCIsXG4gICAgICBcIuKJoFwiOiBcIiZuZTtcIixcbiAgICAgIFwi4omCzLhcIjogXCImbmVzaW07XCIsXG4gICAgICBcIuKIhFwiOiBcIiZuZXhpc3RzO1wiLFxuICAgICAgXCLiia9cIjogXCImbmd0cjtcIixcbiAgICAgIFwi4omxXCI6IFwiJm5nZXE7XCIsXG4gICAgICBcIuKJp8y4XCI6IFwiJm5nZXFxO1wiLFxuICAgICAgXCLiiavMuFwiOiBcIiZuR3R2O1wiLFxuICAgICAgXCLiiblcIjogXCImbnRnbDtcIixcbiAgICAgIFwi4qm+zLhcIjogXCImbmdlcztcIixcbiAgICAgIFwi4om1XCI6IFwiJm5nc2ltO1wiLFxuICAgICAgXCLiiY7MuFwiOiBcIiZuYnVtcDtcIixcbiAgICAgIFwi4omPzLhcIjogXCImbmJ1bXBlO1wiLFxuICAgICAgXCLii6pcIjogXCImbnRyaWFuZ2xlbGVmdDtcIixcbiAgICAgIFwi4qePzLhcIjogXCImTm90TGVmdFRyaWFuZ2xlQmFyO1wiLFxuICAgICAgXCLii6xcIjogXCImbnRyaWFuZ2xlbGVmdGVxO1wiLFxuICAgICAgXCLiia5cIjogXCImbmx0O1wiLFxuICAgICAgXCLiibBcIjogXCImbmxlcTtcIixcbiAgICAgIFwi4om4XCI6IFwiJm50bGc7XCIsXG4gICAgICBcIuKJqsy4XCI6IFwiJm5MdHY7XCIsXG4gICAgICBcIuKpvcy4XCI6IFwiJm5sZXM7XCIsXG4gICAgICBcIuKJtFwiOiBcIiZubHNpbTtcIixcbiAgICAgIFwi4qqizLhcIjogXCImTm90TmVzdGVkR3JlYXRlckdyZWF0ZXI7XCIsXG4gICAgICBcIuKqocy4XCI6IFwiJk5vdE5lc3RlZExlc3NMZXNzO1wiLFxuICAgICAgXCLiioBcIjogXCImbnByZWM7XCIsXG4gICAgICBcIuKqr8y4XCI6IFwiJm5wcmVjZXE7XCIsXG4gICAgICBcIuKLoFwiOiBcIiZucHJjdWU7XCIsXG4gICAgICBcIuKIjFwiOiBcIiZub3RuaXZhO1wiLFxuICAgICAgXCLii6tcIjogXCImbnRyaWFuZ2xlcmlnaHQ7XCIsXG4gICAgICBcIuKnkMy4XCI6IFwiJk5vdFJpZ2h0VHJpYW5nbGVCYXI7XCIsXG4gICAgICBcIuKLrVwiOiBcIiZudHJpYW5nbGVyaWdodGVxO1wiLFxuICAgICAgXCLiio/MuFwiOiBcIiZOb3RTcXVhcmVTdWJzZXQ7XCIsXG4gICAgICBcIuKLolwiOiBcIiZuc3FzdWJlO1wiLFxuICAgICAgXCLiipDMuFwiOiBcIiZOb3RTcXVhcmVTdXBlcnNldDtcIixcbiAgICAgIFwi4oujXCI6IFwiJm5zcXN1cGU7XCIsXG4gICAgICBcIuKKguKDklwiOiBcIiZ2bnN1YjtcIixcbiAgICAgIFwi4oqIXCI6IFwiJm5zdWJzZXRlcTtcIixcbiAgICAgIFwi4oqBXCI6IFwiJm5zdWNjO1wiLFxuICAgICAgXCLiqrDMuFwiOiBcIiZuc3VjY2VxO1wiLFxuICAgICAgXCLii6FcIjogXCImbnNjY3VlO1wiLFxuICAgICAgXCLiib/MuFwiOiBcIiZOb3RTdWNjZWVkc1RpbGRlO1wiLFxuICAgICAgXCLiioPig5JcIjogXCImdm5zdXA7XCIsXG4gICAgICBcIuKKiVwiOiBcIiZuc3Vwc2V0ZXE7XCIsXG4gICAgICBcIuKJgVwiOiBcIiZuc2ltO1wiLFxuICAgICAgXCLiiYRcIjogXCImbnNpbWVxO1wiLFxuICAgICAgXCLiiYdcIjogXCImbmNvbmc7XCIsXG4gICAgICBcIuKJiVwiOiBcIiZuYXBwcm94O1wiLFxuICAgICAgXCLiiKRcIjogXCImbnNtaWQ7XCIsXG4gICAgICBcIvCdkqlcIjogXCImTnNjcjtcIixcbiAgICAgIFwiw5FcIjogXCImTnRpbGRlO1wiLFxuICAgICAgXCLOnVwiOiBcIiZOdTtcIixcbiAgICAgIFwixZJcIjogXCImT0VsaWc7XCIsXG4gICAgICBcIsOTXCI6IFwiJk9hY3V0ZTtcIixcbiAgICAgIFwiw5RcIjogXCImT2NpcmM7XCIsXG4gICAgICBcItCeXCI6IFwiJk9jeTtcIixcbiAgICAgIFwixZBcIjogXCImT2RibGFjO1wiLFxuICAgICAgXCLwnZSSXCI6IFwiJk9mcjtcIixcbiAgICAgIFwiw5JcIjogXCImT2dyYXZlO1wiLFxuICAgICAgXCLFjFwiOiBcIiZPbWFjcjtcIixcbiAgICAgIFwizqlcIjogXCImb2htO1wiLFxuICAgICAgXCLOn1wiOiBcIiZPbWljcm9uO1wiLFxuICAgICAgXCLwnZWGXCI6IFwiJk9vcGY7XCIsXG4gICAgICBcIuKAnFwiOiBcIiZsZHF1bztcIixcbiAgICAgIFwi4oCYXCI6IFwiJmxzcXVvO1wiLFxuICAgICAgXCLiqZRcIjogXCImT3I7XCIsXG4gICAgICBcIvCdkqpcIjogXCImT3NjcjtcIixcbiAgICAgIFwiw5hcIjogXCImT3NsYXNoO1wiLFxuICAgICAgXCLDlVwiOiBcIiZPdGlsZGU7XCIsXG4gICAgICBcIuKot1wiOiBcIiZPdGltZXM7XCIsXG4gICAgICBcIsOWXCI6IFwiJk91bWw7XCIsXG4gICAgICBcIuKAvlwiOiBcIiZvbGluZTtcIixcbiAgICAgIFwi4o+eXCI6IFwiJk92ZXJCcmFjZTtcIixcbiAgICAgIFwi4o60XCI6IFwiJnRicms7XCIsXG4gICAgICBcIuKPnFwiOiBcIiZPdmVyUGFyZW50aGVzaXM7XCIsXG4gICAgICBcIuKIglwiOiBcIiZwYXJ0O1wiLFxuICAgICAgXCLQn1wiOiBcIiZQY3k7XCIsXG4gICAgICBcIvCdlJNcIjogXCImUGZyO1wiLFxuICAgICAgXCLOplwiOiBcIiZQaGk7XCIsXG4gICAgICBcIs6gXCI6IFwiJlBpO1wiLFxuICAgICAgXCLCsVwiOiBcIiZwbTtcIixcbiAgICAgIFwi4oSZXCI6IFwiJnByaW1lcztcIixcbiAgICAgIFwi4qq7XCI6IFwiJlByO1wiLFxuICAgICAgXCLiibpcIjogXCImcHJlYztcIixcbiAgICAgIFwi4qqvXCI6IFwiJnByZWNlcTtcIixcbiAgICAgIFwi4om8XCI6IFwiJnByZWNjdXJseWVxO1wiLFxuICAgICAgXCLiib5cIjogXCImcHJzaW07XCIsXG4gICAgICBcIuKAs1wiOiBcIiZQcmltZTtcIixcbiAgICAgIFwi4oiPXCI6IFwiJnByb2Q7XCIsXG4gICAgICBcIuKInVwiOiBcIiZ2cHJvcDtcIixcbiAgICAgIFwi8J2Sq1wiOiBcIiZQc2NyO1wiLFxuICAgICAgXCLOqFwiOiBcIiZQc2k7XCIsXG4gICAgICAnXCInOiBcIiZxdW90O1wiLFxuICAgICAgXCLwnZSUXCI6IFwiJlFmcjtcIixcbiAgICAgIFwi4oSaXCI6IFwiJnJhdGlvbmFscztcIixcbiAgICAgIFwi8J2SrFwiOiBcIiZRc2NyO1wiLFxuICAgICAgXCLipJBcIjogXCImZHJia2Fyb3c7XCIsXG4gICAgICBcIsKuXCI6IFwiJnJlZztcIixcbiAgICAgIFwixZRcIjogXCImUmFjdXRlO1wiLFxuICAgICAgXCLin6tcIjogXCImUmFuZztcIixcbiAgICAgIFwi4oagXCI6IFwiJnR3b2hlYWRyaWdodGFycm93O1wiLFxuICAgICAgXCLipJZcIjogXCImUmFycnRsO1wiLFxuICAgICAgXCLFmFwiOiBcIiZSY2Fyb247XCIsXG4gICAgICBcIsWWXCI6IFwiJlJjZWRpbDtcIixcbiAgICAgIFwi0KBcIjogXCImUmN5O1wiLFxuICAgICAgXCLihJxcIjogXCImcmVhbHBhcnQ7XCIsXG4gICAgICBcIuKIi1wiOiBcIiZuaXY7XCIsXG4gICAgICBcIuKHi1wiOiBcIiZscmhhcjtcIixcbiAgICAgIFwi4qWvXCI6IFwiJmR1aGFyO1wiLFxuICAgICAgXCLOoVwiOiBcIiZSaG87XCIsXG4gICAgICBcIuKfqVwiOiBcIiZyYW5nbGU7XCIsXG4gICAgICBcIuKGklwiOiBcIiZzcmFycjtcIixcbiAgICAgIFwi4oelXCI6IFwiJnJhcnJiO1wiLFxuICAgICAgXCLih4RcIjogXCImcmxhcnI7XCIsXG4gICAgICBcIuKMiVwiOiBcIiZyY2VpbDtcIixcbiAgICAgIFwi4p+nXCI6IFwiJnJvYnJrO1wiLFxuICAgICAgXCLipZ1cIjogXCImUmlnaHREb3duVGVlVmVjdG9yO1wiLFxuICAgICAgXCLih4JcIjogXCImZG93bmhhcnBvb25yaWdodDtcIixcbiAgICAgIFwi4qWVXCI6IFwiJlJpZ2h0RG93blZlY3RvckJhcjtcIixcbiAgICAgIFwi4oyLXCI6IFwiJnJmbG9vcjtcIixcbiAgICAgIFwi4oqiXCI6IFwiJnZkYXNoO1wiLFxuICAgICAgXCLihqZcIjogXCImbWFwc3RvO1wiLFxuICAgICAgXCLipZtcIjogXCImUmlnaHRUZWVWZWN0b3I7XCIsXG4gICAgICBcIuKKs1wiOiBcIiZ2cnRyaTtcIixcbiAgICAgIFwi4qeQXCI6IFwiJlJpZ2h0VHJpYW5nbGVCYXI7XCIsXG4gICAgICBcIuKKtVwiOiBcIiZ0cmlhbmdsZXJpZ2h0ZXE7XCIsXG4gICAgICBcIuKlj1wiOiBcIiZSaWdodFVwRG93blZlY3RvcjtcIixcbiAgICAgIFwi4qWcXCI6IFwiJlJpZ2h0VXBUZWVWZWN0b3I7XCIsXG4gICAgICBcIuKGvlwiOiBcIiZ1cGhhcnBvb25yaWdodDtcIixcbiAgICAgIFwi4qWUXCI6IFwiJlJpZ2h0VXBWZWN0b3JCYXI7XCIsXG4gICAgICBcIuKHgFwiOiBcIiZyaWdodGhhcnBvb251cDtcIixcbiAgICAgIFwi4qWTXCI6IFwiJlJpZ2h0VmVjdG9yQmFyO1wiLFxuICAgICAgXCLihJ1cIjogXCImcmVhbHM7XCIsXG4gICAgICBcIuKlsFwiOiBcIiZSb3VuZEltcGxpZXM7XCIsXG4gICAgICBcIuKHm1wiOiBcIiZyQWFycjtcIixcbiAgICAgIFwi4oSbXCI6IFwiJnJlYWxpbmU7XCIsXG4gICAgICBcIuKGsVwiOiBcIiZyc2g7XCIsXG4gICAgICBcIuKntFwiOiBcIiZSdWxlRGVsYXllZDtcIixcbiAgICAgIFwi0KlcIjogXCImU0hDSGN5O1wiLFxuICAgICAgXCLQqFwiOiBcIiZTSGN5O1wiLFxuICAgICAgXCLQrFwiOiBcIiZTT0ZUY3k7XCIsXG4gICAgICBcIsWaXCI6IFwiJlNhY3V0ZTtcIixcbiAgICAgIFwi4qq8XCI6IFwiJlNjO1wiLFxuICAgICAgXCLFoFwiOiBcIiZTY2Fyb247XCIsXG4gICAgICBcIsWeXCI6IFwiJlNjZWRpbDtcIixcbiAgICAgIFwixZxcIjogXCImU2NpcmM7XCIsXG4gICAgICBcItChXCI6IFwiJlNjeTtcIixcbiAgICAgIFwi8J2UllwiOiBcIiZTZnI7XCIsXG4gICAgICBcIuKGkVwiOiBcIiZ1cGFycm93O1wiLFxuICAgICAgXCLOo1wiOiBcIiZTaWdtYTtcIixcbiAgICAgIFwi4oiYXCI6IFwiJmNvbXBmbjtcIixcbiAgICAgIFwi8J2VilwiOiBcIiZTb3BmO1wiLFxuICAgICAgXCLiiJpcIjogXCImcmFkaWM7XCIsXG4gICAgICBcIuKWoVwiOiBcIiZzcXVhcmU7XCIsXG4gICAgICBcIuKKk1wiOiBcIiZzcWNhcDtcIixcbiAgICAgIFwi4oqPXCI6IFwiJnNxc3Vic2V0O1wiLFxuICAgICAgXCLiipFcIjogXCImc3FzdWJzZXRlcTtcIixcbiAgICAgIFwi4oqQXCI6IFwiJnNxc3Vwc2V0O1wiLFxuICAgICAgXCLiipJcIjogXCImc3FzdXBzZXRlcTtcIixcbiAgICAgIFwi4oqUXCI6IFwiJnNxY3VwO1wiLFxuICAgICAgXCLwnZKuXCI6IFwiJlNzY3I7XCIsXG4gICAgICBcIuKLhlwiOiBcIiZzc3RhcmY7XCIsXG4gICAgICBcIuKLkFwiOiBcIiZTdWJzZXQ7XCIsXG4gICAgICBcIuKKhlwiOiBcIiZzdWJzZXRlcTtcIixcbiAgICAgIFwi4om7XCI6IFwiJnN1Y2M7XCIsXG4gICAgICBcIuKqsFwiOiBcIiZzdWNjZXE7XCIsXG4gICAgICBcIuKJvVwiOiBcIiZzdWNjY3VybHllcTtcIixcbiAgICAgIFwi4om/XCI6IFwiJnN1Y2NzaW07XCIsXG4gICAgICBcIuKIkVwiOiBcIiZzdW07XCIsXG4gICAgICBcIuKLkVwiOiBcIiZTdXBzZXQ7XCIsXG4gICAgICBcIuKKg1wiOiBcIiZzdXBzZXQ7XCIsXG4gICAgICBcIuKKh1wiOiBcIiZzdXBzZXRlcTtcIixcbiAgICAgIFwiw55cIjogXCImVEhPUk47XCIsXG4gICAgICBcIuKEolwiOiBcIiZ0cmFkZTtcIixcbiAgICAgIFwi0ItcIjogXCImVFNIY3k7XCIsXG4gICAgICBcItCmXCI6IFwiJlRTY3k7XCIsXG4gICAgICBcIlxcdFwiOiBcIiZUYWI7XCIsXG4gICAgICBcIs6kXCI6IFwiJlRhdTtcIixcbiAgICAgIFwixaRcIjogXCImVGNhcm9uO1wiLFxuICAgICAgXCLFolwiOiBcIiZUY2VkaWw7XCIsXG4gICAgICBcItCiXCI6IFwiJlRjeTtcIixcbiAgICAgIFwi8J2Ul1wiOiBcIiZUZnI7XCIsXG4gICAgICBcIuKItFwiOiBcIiZ0aGVyZWZvcmU7XCIsXG4gICAgICBcIs6YXCI6IFwiJlRoZXRhO1wiLFxuICAgICAgXCLigZ/igIpcIjogXCImVGhpY2tTcGFjZTtcIixcbiAgICAgIFwi4oCJXCI6IFwiJnRoaW5zcDtcIixcbiAgICAgIFwi4oi8XCI6IFwiJnRoa3NpbTtcIixcbiAgICAgIFwi4omDXCI6IFwiJnNpbWVxO1wiLFxuICAgICAgXCLiiYVcIjogXCImY29uZztcIixcbiAgICAgIFwi4omIXCI6IFwiJnRoa2FwO1wiLFxuICAgICAgXCLwnZWLXCI6IFwiJlRvcGY7XCIsXG4gICAgICBcIuKDm1wiOiBcIiZ0ZG90O1wiLFxuICAgICAgXCLwnZKvXCI6IFwiJlRzY3I7XCIsXG4gICAgICBcIsWmXCI6IFwiJlRzdHJvaztcIixcbiAgICAgIFwiw5pcIjogXCImVWFjdXRlO1wiLFxuICAgICAgXCLihp9cIjogXCImVWFycjtcIixcbiAgICAgIFwi4qWJXCI6IFwiJlVhcnJvY2lyO1wiLFxuICAgICAgXCLQjlwiOiBcIiZVYnJjeTtcIixcbiAgICAgIFwixaxcIjogXCImVWJyZXZlO1wiLFxuICAgICAgXCLDm1wiOiBcIiZVY2lyYztcIixcbiAgICAgIFwi0KNcIjogXCImVWN5O1wiLFxuICAgICAgXCLFsFwiOiBcIiZVZGJsYWM7XCIsXG4gICAgICBcIvCdlJhcIjogXCImVWZyO1wiLFxuICAgICAgXCLDmVwiOiBcIiZVZ3JhdmU7XCIsXG4gICAgICBcIsWqXCI6IFwiJlVtYWNyO1wiLFxuICAgICAgXzogXCImbG93YmFyO1wiLFxuICAgICAgXCLij59cIjogXCImVW5kZXJCcmFjZTtcIixcbiAgICAgIFwi4o61XCI6IFwiJmJicms7XCIsXG4gICAgICBcIuKPnVwiOiBcIiZVbmRlclBhcmVudGhlc2lzO1wiLFxuICAgICAgXCLii4NcIjogXCImeGN1cDtcIixcbiAgICAgIFwi4oqOXCI6IFwiJnVwbHVzO1wiLFxuICAgICAgXCLFslwiOiBcIiZVb2dvbjtcIixcbiAgICAgIFwi8J2VjFwiOiBcIiZVb3BmO1wiLFxuICAgICAgXCLipJJcIjogXCImVXBBcnJvd0JhcjtcIixcbiAgICAgIFwi4oeFXCI6IFwiJnVkYXJyO1wiLFxuICAgICAgXCLihpVcIjogXCImdmFycjtcIixcbiAgICAgIFwi4qWuXCI6IFwiJnVkaGFyO1wiLFxuICAgICAgXCLiiqVcIjogXCImcGVycDtcIixcbiAgICAgIFwi4oalXCI6IFwiJm1hcHN0b3VwO1wiLFxuICAgICAgXCLihpZcIjogXCImbndhcnJvdztcIixcbiAgICAgIFwi4oaXXCI6IFwiJm5lYXJyb3c7XCIsXG4gICAgICBcIs+SXCI6IFwiJnVwc2loO1wiLFxuICAgICAgXCLOpVwiOiBcIiZVcHNpbG9uO1wiLFxuICAgICAgXCLFrlwiOiBcIiZVcmluZztcIixcbiAgICAgIFwi8J2SsFwiOiBcIiZVc2NyO1wiLFxuICAgICAgXCLFqFwiOiBcIiZVdGlsZGU7XCIsXG4gICAgICBcIsOcXCI6IFwiJlV1bWw7XCIsXG4gICAgICBcIuKKq1wiOiBcIiZWRGFzaDtcIixcbiAgICAgIFwi4qurXCI6IFwiJlZiYXI7XCIsXG4gICAgICBcItCSXCI6IFwiJlZjeTtcIixcbiAgICAgIFwi4oqpXCI6IFwiJlZkYXNoO1wiLFxuICAgICAgXCLiq6ZcIjogXCImVmRhc2hsO1wiLFxuICAgICAgXCLii4FcIjogXCImeHZlZTtcIixcbiAgICAgIFwi4oCWXCI6IFwiJlZlcnQ7XCIsXG4gICAgICBcIuKIo1wiOiBcIiZzbWlkO1wiLFxuICAgICAgXCJ8XCI6IFwiJnZlcnQ7XCIsXG4gICAgICBcIuKdmFwiOiBcIiZWZXJ0aWNhbFNlcGFyYXRvcjtcIixcbiAgICAgIFwi4omAXCI6IFwiJndyZWF0aDtcIixcbiAgICAgIFwi4oCKXCI6IFwiJmhhaXJzcDtcIixcbiAgICAgIFwi8J2UmVwiOiBcIiZWZnI7XCIsXG4gICAgICBcIvCdlY1cIjogXCImVm9wZjtcIixcbiAgICAgIFwi8J2SsVwiOiBcIiZWc2NyO1wiLFxuICAgICAgXCLiiqpcIjogXCImVnZkYXNoO1wiLFxuICAgICAgXCLFtFwiOiBcIiZXY2lyYztcIixcbiAgICAgIFwi4ouAXCI6IFwiJnh3ZWRnZTtcIixcbiAgICAgIFwi8J2UmlwiOiBcIiZXZnI7XCIsXG4gICAgICBcIvCdlY5cIjogXCImV29wZjtcIixcbiAgICAgIFwi8J2SslwiOiBcIiZXc2NyO1wiLFxuICAgICAgXCLwnZSbXCI6IFwiJlhmcjtcIixcbiAgICAgIFwizp5cIjogXCImWGk7XCIsXG4gICAgICBcIvCdlY9cIjogXCImWG9wZjtcIixcbiAgICAgIFwi8J2Ss1wiOiBcIiZYc2NyO1wiLFxuICAgICAgXCLQr1wiOiBcIiZZQWN5O1wiLFxuICAgICAgXCLQh1wiOiBcIiZZSWN5O1wiLFxuICAgICAgXCLQrlwiOiBcIiZZVWN5O1wiLFxuICAgICAgXCLDnVwiOiBcIiZZYWN1dGU7XCIsXG4gICAgICBcIsW2XCI6IFwiJlljaXJjO1wiLFxuICAgICAgXCLQq1wiOiBcIiZZY3k7XCIsXG4gICAgICBcIvCdlJxcIjogXCImWWZyO1wiLFxuICAgICAgXCLwnZWQXCI6IFwiJllvcGY7XCIsXG4gICAgICBcIvCdkrRcIjogXCImWXNjcjtcIixcbiAgICAgIFwixbhcIjogXCImWXVtbDtcIixcbiAgICAgIFwi0JZcIjogXCImWkhjeTtcIixcbiAgICAgIFwixblcIjogXCImWmFjdXRlO1wiLFxuICAgICAgXCLFvVwiOiBcIiZaY2Fyb247XCIsXG4gICAgICBcItCXXCI6IFwiJlpjeTtcIixcbiAgICAgIFwixbtcIjogXCImWmRvdDtcIixcbiAgICAgIFwizpZcIjogXCImWmV0YTtcIixcbiAgICAgIFwi4oSoXCI6IFwiJnplZXRyZjtcIixcbiAgICAgIFwi4oSkXCI6IFwiJmludGVnZXJzO1wiLFxuICAgICAgXCLwnZK1XCI6IFwiJlpzY3I7XCIsXG4gICAgICBcIsOhXCI6IFwiJmFhY3V0ZTtcIixcbiAgICAgIFwixINcIjogXCImYWJyZXZlO1wiLFxuICAgICAgXCLiiL5cIjogXCImbXN0cG9zO1wiLFxuICAgICAgXCLiiL7Ms1wiOiBcIiZhY0U7XCIsXG4gICAgICBcIuKIv1wiOiBcIiZhY2Q7XCIsXG4gICAgICBcIsOiXCI6IFwiJmFjaXJjO1wiLFxuICAgICAgXCLQsFwiOiBcIiZhY3k7XCIsXG4gICAgICBcIsOmXCI6IFwiJmFlbGlnO1wiLFxuICAgICAgXCLwnZSeXCI6IFwiJmFmcjtcIixcbiAgICAgIFwiw6BcIjogXCImYWdyYXZlO1wiLFxuICAgICAgXCLihLVcIjogXCImYWxlcGg7XCIsXG4gICAgICBcIs6xXCI6IFwiJmFscGhhO1wiLFxuICAgICAgXCLEgVwiOiBcIiZhbWFjcjtcIixcbiAgICAgIFwi4qi/XCI6IFwiJmFtYWxnO1wiLFxuICAgICAgXCLiiKdcIjogXCImd2VkZ2U7XCIsXG4gICAgICBcIuKplVwiOiBcIiZhbmRhbmQ7XCIsXG4gICAgICBcIuKpnFwiOiBcIiZhbmRkO1wiLFxuICAgICAgXCLiqZhcIjogXCImYW5kc2xvcGU7XCIsXG4gICAgICBcIuKpmlwiOiBcIiZhbmR2O1wiLFxuICAgICAgXCLiiKBcIjogXCImYW5nbGU7XCIsXG4gICAgICBcIuKmpFwiOiBcIiZhbmdlO1wiLFxuICAgICAgXCLiiKFcIjogXCImbWVhc3VyZWRhbmdsZTtcIixcbiAgICAgIFwi4qaoXCI6IFwiJmFuZ21zZGFhO1wiLFxuICAgICAgXCLipqlcIjogXCImYW5nbXNkYWI7XCIsXG4gICAgICBcIuKmqlwiOiBcIiZhbmdtc2RhYztcIixcbiAgICAgIFwi4qarXCI6IFwiJmFuZ21zZGFkO1wiLFxuICAgICAgXCLipqxcIjogXCImYW5nbXNkYWU7XCIsXG4gICAgICBcIuKmrVwiOiBcIiZhbmdtc2RhZjtcIixcbiAgICAgIFwi4qauXCI6IFwiJmFuZ21zZGFnO1wiLFxuICAgICAgXCLipq9cIjogXCImYW5nbXNkYWg7XCIsXG4gICAgICBcIuKIn1wiOiBcIiZhbmdydDtcIixcbiAgICAgIFwi4oq+XCI6IFwiJmFuZ3J0dmI7XCIsXG4gICAgICBcIuKmnVwiOiBcIiZhbmdydHZiZDtcIixcbiAgICAgIFwi4oiiXCI6IFwiJmFuZ3NwaDtcIixcbiAgICAgIFwi4o28XCI6IFwiJmFuZ3phcnI7XCIsXG4gICAgICBcIsSFXCI6IFwiJmFvZ29uO1wiLFxuICAgICAgXCLwnZWSXCI6IFwiJmFvcGY7XCIsXG4gICAgICBcIuKpsFwiOiBcIiZhcEU7XCIsXG4gICAgICBcIuKpr1wiOiBcIiZhcGFjaXI7XCIsXG4gICAgICBcIuKJilwiOiBcIiZhcHByb3hlcTtcIixcbiAgICAgIFwi4omLXCI6IFwiJmFwaWQ7XCIsXG4gICAgICBcIidcIjogXCImYXBvcztcIixcbiAgICAgIFwiw6VcIjogXCImYXJpbmc7XCIsXG4gICAgICBcIvCdkrZcIjogXCImYXNjcjtcIixcbiAgICAgIFwiKlwiOiBcIiZtaWRhc3Q7XCIsXG4gICAgICBcIsOjXCI6IFwiJmF0aWxkZTtcIixcbiAgICAgIFwiw6RcIjogXCImYXVtbDtcIixcbiAgICAgIFwi4qiRXCI6IFwiJmF3aW50O1wiLFxuICAgICAgXCLiq61cIjogXCImYk5vdDtcIixcbiAgICAgIFwi4omMXCI6IFwiJmJjb25nO1wiLFxuICAgICAgXCLPtlwiOiBcIiZiZXBzaTtcIixcbiAgICAgIFwi4oC1XCI6IFwiJmJwcmltZTtcIixcbiAgICAgIFwi4oi9XCI6IFwiJmJzaW07XCIsXG4gICAgICBcIuKLjVwiOiBcIiZic2ltZTtcIixcbiAgICAgIFwi4oq9XCI6IFwiJmJhcnZlZTtcIixcbiAgICAgIFwi4oyFXCI6IFwiJmJhcndlZGdlO1wiLFxuICAgICAgXCLijrZcIjogXCImYmJya3Ricms7XCIsXG4gICAgICBcItCxXCI6IFwiJmJjeTtcIixcbiAgICAgIFwi4oCeXCI6IFwiJmxkcXVvcjtcIixcbiAgICAgIFwi4qawXCI6IFwiJmJlbXB0eXY7XCIsXG4gICAgICBcIs6yXCI6IFwiJmJldGE7XCIsXG4gICAgICBcIuKEtlwiOiBcIiZiZXRoO1wiLFxuICAgICAgXCLiiaxcIjogXCImdHdpeHQ7XCIsXG4gICAgICBcIvCdlJ9cIjogXCImYmZyO1wiLFxuICAgICAgXCLil69cIjogXCImeGNpcmM7XCIsXG4gICAgICBcIuKogFwiOiBcIiZ4b2RvdDtcIixcbiAgICAgIFwi4qiBXCI6IFwiJnhvcGx1cztcIixcbiAgICAgIFwi4qiCXCI6IFwiJnhvdGltZTtcIixcbiAgICAgIFwi4qiGXCI6IFwiJnhzcWN1cDtcIixcbiAgICAgIFwi4piFXCI6IFwiJnN0YXJmO1wiLFxuICAgICAgXCLilr1cIjogXCImeGR0cmk7XCIsXG4gICAgICBcIuKWs1wiOiBcIiZ4dXRyaTtcIixcbiAgICAgIFwi4qiEXCI6IFwiJnh1cGx1cztcIixcbiAgICAgIFwi4qSNXCI6IFwiJnJiYXJyO1wiLFxuICAgICAgXCLip6tcIjogXCImbG96ZjtcIixcbiAgICAgIFwi4pa0XCI6IFwiJnV0cmlmO1wiLFxuICAgICAgXCLilr5cIjogXCImZHRyaWY7XCIsXG4gICAgICBcIuKXglwiOiBcIiZsdHJpZjtcIixcbiAgICAgIFwi4pa4XCI6IFwiJnJ0cmlmO1wiLFxuICAgICAgXCLikKNcIjogXCImYmxhbms7XCIsXG4gICAgICBcIuKWklwiOiBcIiZibGsxMjtcIixcbiAgICAgIFwi4paRXCI6IFwiJmJsazE0O1wiLFxuICAgICAgXCLilpNcIjogXCImYmxrMzQ7XCIsXG4gICAgICBcIuKWiFwiOiBcIiZibG9jaztcIixcbiAgICAgIFwiPeKDpVwiOiBcIiZibmU7XCIsXG4gICAgICBcIuKJoeKDpVwiOiBcIiZibmVxdWl2O1wiLFxuICAgICAgXCLijJBcIjogXCImYm5vdDtcIixcbiAgICAgIFwi8J2Vk1wiOiBcIiZib3BmO1wiLFxuICAgICAgXCLii4hcIjogXCImYm93dGllO1wiLFxuICAgICAgXCLilZdcIjogXCImYm94REw7XCIsXG4gICAgICBcIuKVlFwiOiBcIiZib3hEUjtcIixcbiAgICAgIFwi4pWWXCI6IFwiJmJveERsO1wiLFxuICAgICAgXCLilZNcIjogXCImYm94RHI7XCIsXG4gICAgICBcIuKVkFwiOiBcIiZib3hIO1wiLFxuICAgICAgXCLilaZcIjogXCImYm94SEQ7XCIsXG4gICAgICBcIuKVqVwiOiBcIiZib3hIVTtcIixcbiAgICAgIFwi4pWkXCI6IFwiJmJveEhkO1wiLFxuICAgICAgXCLiladcIjogXCImYm94SHU7XCIsXG4gICAgICBcIuKVnVwiOiBcIiZib3hVTDtcIixcbiAgICAgIFwi4pWaXCI6IFwiJmJveFVSO1wiLFxuICAgICAgXCLilZxcIjogXCImYm94VWw7XCIsXG4gICAgICBcIuKVmVwiOiBcIiZib3hVcjtcIixcbiAgICAgIFwi4pWRXCI6IFwiJmJveFY7XCIsXG4gICAgICBcIuKVrFwiOiBcIiZib3hWSDtcIixcbiAgICAgIFwi4pWjXCI6IFwiJmJveFZMO1wiLFxuICAgICAgXCLilaBcIjogXCImYm94VlI7XCIsXG4gICAgICBcIuKVq1wiOiBcIiZib3hWaDtcIixcbiAgICAgIFwi4pWiXCI6IFwiJmJveFZsO1wiLFxuICAgICAgXCLilZ9cIjogXCImYm94VnI7XCIsXG4gICAgICBcIuKniVwiOiBcIiZib3hib3g7XCIsXG4gICAgICBcIuKVlVwiOiBcIiZib3hkTDtcIixcbiAgICAgIFwi4pWSXCI6IFwiJmJveGRSO1wiLFxuICAgICAgXCLilJBcIjogXCImYm94ZGw7XCIsXG4gICAgICBcIuKUjFwiOiBcIiZib3hkcjtcIixcbiAgICAgIFwi4pWlXCI6IFwiJmJveGhEO1wiLFxuICAgICAgXCLilahcIjogXCImYm94aFU7XCIsXG4gICAgICBcIuKUrFwiOiBcIiZib3hoZDtcIixcbiAgICAgIFwi4pS0XCI6IFwiJmJveGh1O1wiLFxuICAgICAgXCLiip9cIjogXCImbWludXNiO1wiLFxuICAgICAgXCLiip5cIjogXCImcGx1c2I7XCIsXG4gICAgICBcIuKKoFwiOiBcIiZ0aW1lc2I7XCIsXG4gICAgICBcIuKVm1wiOiBcIiZib3h1TDtcIixcbiAgICAgIFwi4pWYXCI6IFwiJmJveHVSO1wiLFxuICAgICAgXCLilJhcIjogXCImYm94dWw7XCIsXG4gICAgICBcIuKUlFwiOiBcIiZib3h1cjtcIixcbiAgICAgIFwi4pSCXCI6IFwiJmJveHY7XCIsXG4gICAgICBcIuKVqlwiOiBcIiZib3h2SDtcIixcbiAgICAgIFwi4pWhXCI6IFwiJmJveHZMO1wiLFxuICAgICAgXCLilZ5cIjogXCImYm94dlI7XCIsXG4gICAgICBcIuKUvFwiOiBcIiZib3h2aDtcIixcbiAgICAgIFwi4pSkXCI6IFwiJmJveHZsO1wiLFxuICAgICAgXCLilJxcIjogXCImYm94dnI7XCIsXG4gICAgICBcIsKmXCI6IFwiJmJydmJhcjtcIixcbiAgICAgIFwi8J2St1wiOiBcIiZic2NyO1wiLFxuICAgICAgXCLigY9cIjogXCImYnNlbWk7XCIsXG4gICAgICBcIlxcXFxcIjogXCImYnNvbDtcIixcbiAgICAgIFwi4qeFXCI6IFwiJmJzb2xiO1wiLFxuICAgICAgXCLin4hcIjogXCImYnNvbGhzdWI7XCIsXG4gICAgICBcIuKAolwiOiBcIiZidWxsZXQ7XCIsXG4gICAgICBcIuKqrlwiOiBcIiZidW1wRTtcIixcbiAgICAgIFwixIdcIjogXCImY2FjdXRlO1wiLFxuICAgICAgXCLiiKlcIjogXCImY2FwO1wiLFxuICAgICAgXCLiqYRcIjogXCImY2FwYW5kO1wiLFxuICAgICAgXCLiqYlcIjogXCImY2FwYnJjdXA7XCIsXG4gICAgICBcIuKpi1wiOiBcIiZjYXBjYXA7XCIsXG4gICAgICBcIuKph1wiOiBcIiZjYXBjdXA7XCIsXG4gICAgICBcIuKpgFwiOiBcIiZjYXBkb3Q7XCIsXG4gICAgICBcIuKIqe+4gFwiOiBcIiZjYXBzO1wiLFxuICAgICAgXCLigYFcIjogXCImY2FyZXQ7XCIsXG4gICAgICBcIuKpjVwiOiBcIiZjY2FwcztcIixcbiAgICAgIFwixI1cIjogXCImY2Nhcm9uO1wiLFxuICAgICAgXCLDp1wiOiBcIiZjY2VkaWw7XCIsXG4gICAgICBcIsSJXCI6IFwiJmNjaXJjO1wiLFxuICAgICAgXCLiqYxcIjogXCImY2N1cHM7XCIsXG4gICAgICBcIuKpkFwiOiBcIiZjY3Vwc3NtO1wiLFxuICAgICAgXCLEi1wiOiBcIiZjZG90O1wiLFxuICAgICAgXCLiprJcIjogXCImY2VtcHR5djtcIixcbiAgICAgIFwiwqJcIjogXCImY2VudDtcIixcbiAgICAgIFwi8J2UoFwiOiBcIiZjZnI7XCIsXG4gICAgICBcItGHXCI6IFwiJmNoY3k7XCIsXG4gICAgICBcIuKck1wiOiBcIiZjaGVja21hcms7XCIsXG4gICAgICBcIs+HXCI6IFwiJmNoaTtcIixcbiAgICAgIFwi4peLXCI6IFwiJmNpcjtcIixcbiAgICAgIFwi4qeDXCI6IFwiJmNpckU7XCIsXG4gICAgICBcIsuGXCI6IFwiJmNpcmM7XCIsXG4gICAgICBcIuKJl1wiOiBcIiZjaXJlO1wiLFxuICAgICAgXCLihrpcIjogXCImb2xhcnI7XCIsXG4gICAgICBcIuKGu1wiOiBcIiZvcmFycjtcIixcbiAgICAgIFwi4pOIXCI6IFwiJm9TO1wiLFxuICAgICAgXCLiiptcIjogXCImb2FzdDtcIixcbiAgICAgIFwi4oqaXCI6IFwiJm9jaXI7XCIsXG4gICAgICBcIuKKnVwiOiBcIiZvZGFzaDtcIixcbiAgICAgIFwi4qiQXCI6IFwiJmNpcmZuaW50O1wiLFxuICAgICAgXCLiq69cIjogXCImY2lybWlkO1wiLFxuICAgICAgXCLip4JcIjogXCImY2lyc2NpcjtcIixcbiAgICAgIFwi4pmjXCI6IFwiJmNsdWJzdWl0O1wiLFxuICAgICAgXCI6XCI6IFwiJmNvbG9uO1wiLFxuICAgICAgXCIsXCI6IFwiJmNvbW1hO1wiLFxuICAgICAgXCJAXCI6IFwiJmNvbW1hdDtcIixcbiAgICAgIFwi4oiBXCI6IFwiJmNvbXBsZW1lbnQ7XCIsXG4gICAgICBcIuKprVwiOiBcIiZjb25nZG90O1wiLFxuICAgICAgXCLwnZWUXCI6IFwiJmNvcGY7XCIsXG4gICAgICBcIuKEl1wiOiBcIiZjb3B5c3I7XCIsXG4gICAgICBcIuKGtVwiOiBcIiZjcmFycjtcIixcbiAgICAgIFwi4pyXXCI6IFwiJmNyb3NzO1wiLFxuICAgICAgXCLwnZK4XCI6IFwiJmNzY3I7XCIsXG4gICAgICBcIuKrj1wiOiBcIiZjc3ViO1wiLFxuICAgICAgXCLiq5FcIjogXCImY3N1YmU7XCIsXG4gICAgICBcIuKrkFwiOiBcIiZjc3VwO1wiLFxuICAgICAgXCLiq5JcIjogXCImY3N1cGU7XCIsXG4gICAgICBcIuKLr1wiOiBcIiZjdGRvdDtcIixcbiAgICAgIFwi4qS4XCI6IFwiJmN1ZGFycmw7XCIsXG4gICAgICBcIuKktVwiOiBcIiZjdWRhcnJyO1wiLFxuICAgICAgXCLii55cIjogXCImY3VybHllcXByZWM7XCIsXG4gICAgICBcIuKLn1wiOiBcIiZjdXJseWVxc3VjYztcIixcbiAgICAgIFwi4oa2XCI6IFwiJmN1cnZlYXJyb3dsZWZ0O1wiLFxuICAgICAgXCLipL1cIjogXCImY3VsYXJycDtcIixcbiAgICAgIFwi4oiqXCI6IFwiJmN1cDtcIixcbiAgICAgIFwi4qmIXCI6IFwiJmN1cGJyY2FwO1wiLFxuICAgICAgXCLiqYZcIjogXCImY3VwY2FwO1wiLFxuICAgICAgXCLiqYpcIjogXCImY3VwY3VwO1wiLFxuICAgICAgXCLiio1cIjogXCImY3VwZG90O1wiLFxuICAgICAgXCLiqYVcIjogXCImY3Vwb3I7XCIsXG4gICAgICBcIuKIqu+4gFwiOiBcIiZjdXBzO1wiLFxuICAgICAgXCLihrdcIjogXCImY3VydmVhcnJvd3JpZ2h0O1wiLFxuICAgICAgXCLipLxcIjogXCImY3VyYXJybTtcIixcbiAgICAgIFwi4ouOXCI6IFwiJmN1dmVlO1wiLFxuICAgICAgXCLii49cIjogXCImY3V3ZWQ7XCIsXG4gICAgICBcIsKkXCI6IFwiJmN1cnJlbjtcIixcbiAgICAgIFwi4oixXCI6IFwiJmN3aW50O1wiLFxuICAgICAgXCLijK1cIjogXCImY3lsY3R5O1wiLFxuICAgICAgXCLipaVcIjogXCImZEhhcjtcIixcbiAgICAgIFwi4oCgXCI6IFwiJmRhZ2dlcjtcIixcbiAgICAgIFwi4oS4XCI6IFwiJmRhbGV0aDtcIixcbiAgICAgIFwi4oCQXCI6IFwiJmh5cGhlbjtcIixcbiAgICAgIFwi4qSPXCI6IFwiJnJCYXJyO1wiLFxuICAgICAgXCLEj1wiOiBcIiZkY2Fyb247XCIsXG4gICAgICBcItC0XCI6IFwiJmRjeTtcIixcbiAgICAgIFwi4oeKXCI6IFwiJmRvd25kb3duYXJyb3dzO1wiLFxuICAgICAgXCLiqbdcIjogXCImZUREb3Q7XCIsXG4gICAgICBcIsKwXCI6IFwiJmRlZztcIixcbiAgICAgIFwizrRcIjogXCImZGVsdGE7XCIsXG4gICAgICBcIuKmsVwiOiBcIiZkZW1wdHl2O1wiLFxuICAgICAgXCLipb9cIjogXCImZGZpc2h0O1wiLFxuICAgICAgXCLwnZShXCI6IFwiJmRmcjtcIixcbiAgICAgIFwi4pmmXCI6IFwiJmRpYW1zO1wiLFxuICAgICAgXCLPnVwiOiBcIiZnYW1tYWQ7XCIsXG4gICAgICBcIuKLslwiOiBcIiZkaXNpbjtcIixcbiAgICAgIFwiw7dcIjogXCImZGl2aWRlO1wiLFxuICAgICAgXCLii4dcIjogXCImZGl2b254O1wiLFxuICAgICAgXCLRklwiOiBcIiZkamN5O1wiLFxuICAgICAgXCLijJ5cIjogXCImbGxjb3JuZXI7XCIsXG4gICAgICBcIuKMjVwiOiBcIiZkbGNyb3A7XCIsXG4gICAgICAkOiBcIiZkb2xsYXI7XCIsXG4gICAgICBcIvCdlZVcIjogXCImZG9wZjtcIixcbiAgICAgIFwi4omRXCI6IFwiJmVEb3Q7XCIsXG4gICAgICBcIuKIuFwiOiBcIiZtaW51c2Q7XCIsXG4gICAgICBcIuKIlFwiOiBcIiZwbHVzZG87XCIsXG4gICAgICBcIuKKoVwiOiBcIiZzZG90YjtcIixcbiAgICAgIFwi4oyfXCI6IFwiJmxyY29ybmVyO1wiLFxuICAgICAgXCLijIxcIjogXCImZHJjcm9wO1wiLFxuICAgICAgXCLwnZK5XCI6IFwiJmRzY3I7XCIsXG4gICAgICBcItGVXCI6IFwiJmRzY3k7XCIsXG4gICAgICBcIuKntlwiOiBcIiZkc29sO1wiLFxuICAgICAgXCLEkVwiOiBcIiZkc3Ryb2s7XCIsXG4gICAgICBcIuKLsVwiOiBcIiZkdGRvdDtcIixcbiAgICAgIFwi4pa/XCI6IFwiJnRyaWFuZ2xlZG93bjtcIixcbiAgICAgIFwi4qamXCI6IFwiJmR3YW5nbGU7XCIsXG4gICAgICBcItGfXCI6IFwiJmR6Y3k7XCIsXG4gICAgICBcIuKfv1wiOiBcIiZkemlncmFycjtcIixcbiAgICAgIFwiw6lcIjogXCImZWFjdXRlO1wiLFxuICAgICAgXCLiqa5cIjogXCImZWFzdGVyO1wiLFxuICAgICAgXCLEm1wiOiBcIiZlY2Fyb247XCIsXG4gICAgICBcIuKJllwiOiBcIiZlcWNpcmM7XCIsXG4gICAgICBcIsOqXCI6IFwiJmVjaXJjO1wiLFxuICAgICAgXCLiiZVcIjogXCImZXFjb2xvbjtcIixcbiAgICAgIFwi0Y1cIjogXCImZWN5O1wiLFxuICAgICAgXCLEl1wiOiBcIiZlZG90O1wiLFxuICAgICAgXCLiiZJcIjogXCImZmFsbGluZ2RvdHNlcTtcIixcbiAgICAgIFwi8J2UolwiOiBcIiZlZnI7XCIsXG4gICAgICBcIuKqmlwiOiBcIiZlZztcIixcbiAgICAgIFwiw6hcIjogXCImZWdyYXZlO1wiLFxuICAgICAgXCLiqpZcIjogXCImZXFzbGFudGd0cjtcIixcbiAgICAgIFwi4qqYXCI6IFwiJmVnc2RvdDtcIixcbiAgICAgIFwi4qqZXCI6IFwiJmVsO1wiLFxuICAgICAgXCLij6dcIjogXCImZWxpbnRlcnM7XCIsXG4gICAgICBcIuKEk1wiOiBcIiZlbGw7XCIsXG4gICAgICBcIuKqlVwiOiBcIiZlcXNsYW50bGVzcztcIixcbiAgICAgIFwi4qqXXCI6IFwiJmVsc2RvdDtcIixcbiAgICAgIFwixJNcIjogXCImZW1hY3I7XCIsXG4gICAgICBcIuKIhVwiOiBcIiZ2YXJub3RoaW5nO1wiLFxuICAgICAgXCLigIRcIjogXCImZW1zcDEzO1wiLFxuICAgICAgXCLigIVcIjogXCImZW1zcDE0O1wiLFxuICAgICAgXCLigINcIjogXCImZW1zcDtcIixcbiAgICAgIFwixYtcIjogXCImZW5nO1wiLFxuICAgICAgXCLigIJcIjogXCImZW5zcDtcIixcbiAgICAgIFwixJlcIjogXCImZW9nb247XCIsXG4gICAgICBcIvCdlZZcIjogXCImZW9wZjtcIixcbiAgICAgIFwi4ouVXCI6IFwiJmVwYXI7XCIsXG4gICAgICBcIuKno1wiOiBcIiZlcGFyc2w7XCIsXG4gICAgICBcIuKpsVwiOiBcIiZlcGx1cztcIixcbiAgICAgIFwizrVcIjogXCImZXBzaWxvbjtcIixcbiAgICAgIFwiz7VcIjogXCImdmFyZXBzaWxvbjtcIixcbiAgICAgIFwiPVwiOiBcIiZlcXVhbHM7XCIsXG4gICAgICBcIuKJn1wiOiBcIiZxdWVzdGVxO1wiLFxuICAgICAgXCLiqbhcIjogXCImZXF1aXZERDtcIixcbiAgICAgIFwi4qelXCI6IFwiJmVxdnBhcnNsO1wiLFxuICAgICAgXCLiiZNcIjogXCImcmlzaW5nZG90c2VxO1wiLFxuICAgICAgXCLipbFcIjogXCImZXJhcnI7XCIsXG4gICAgICBcIuKEr1wiOiBcIiZlc2NyO1wiLFxuICAgICAgXCLOt1wiOiBcIiZldGE7XCIsXG4gICAgICBcIsOwXCI6IFwiJmV0aDtcIixcbiAgICAgIFwiw6tcIjogXCImZXVtbDtcIixcbiAgICAgIFwi4oKsXCI6IFwiJmV1cm87XCIsXG4gICAgICBcIiFcIjogXCImZXhjbDtcIixcbiAgICAgIFwi0YRcIjogXCImZmN5O1wiLFxuICAgICAgXCLimYBcIjogXCImZmVtYWxlO1wiLFxuICAgICAgXCLvrINcIjogXCImZmZpbGlnO1wiLFxuICAgICAgXCLvrIBcIjogXCImZmZsaWc7XCIsXG4gICAgICBcIu+shFwiOiBcIiZmZmxsaWc7XCIsXG4gICAgICBcIvCdlKNcIjogXCImZmZyO1wiLFxuICAgICAgXCLvrIFcIjogXCImZmlsaWc7XCIsXG4gICAgICBmajogXCImZmpsaWc7XCIsXG4gICAgICBcIuKZrVwiOiBcIiZmbGF0O1wiLFxuICAgICAgXCLvrIJcIjogXCImZmxsaWc7XCIsXG4gICAgICBcIuKWsVwiOiBcIiZmbHRucztcIixcbiAgICAgIFwixpJcIjogXCImZm5vZjtcIixcbiAgICAgIFwi8J2Vl1wiOiBcIiZmb3BmO1wiLFxuICAgICAgXCLii5RcIjogXCImcGl0Y2hmb3JrO1wiLFxuICAgICAgXCLiq5lcIjogXCImZm9ya3Y7XCIsXG4gICAgICBcIuKojVwiOiBcIiZmcGFydGludDtcIixcbiAgICAgIFwiwr1cIjogXCImaGFsZjtcIixcbiAgICAgIFwi4oWTXCI6IFwiJmZyYWMxMztcIixcbiAgICAgIFwiwrxcIjogXCImZnJhYzE0O1wiLFxuICAgICAgXCLihZVcIjogXCImZnJhYzE1O1wiLFxuICAgICAgXCLihZlcIjogXCImZnJhYzE2O1wiLFxuICAgICAgXCLihZtcIjogXCImZnJhYzE4O1wiLFxuICAgICAgXCLihZRcIjogXCImZnJhYzIzO1wiLFxuICAgICAgXCLihZZcIjogXCImZnJhYzI1O1wiLFxuICAgICAgXCLCvlwiOiBcIiZmcmFjMzQ7XCIsXG4gICAgICBcIuKFl1wiOiBcIiZmcmFjMzU7XCIsXG4gICAgICBcIuKFnFwiOiBcIiZmcmFjMzg7XCIsXG4gICAgICBcIuKFmFwiOiBcIiZmcmFjNDU7XCIsXG4gICAgICBcIuKFmlwiOiBcIiZmcmFjNTY7XCIsXG4gICAgICBcIuKFnVwiOiBcIiZmcmFjNTg7XCIsXG4gICAgICBcIuKFnlwiOiBcIiZmcmFjNzg7XCIsXG4gICAgICBcIuKBhFwiOiBcIiZmcmFzbDtcIixcbiAgICAgIFwi4oyiXCI6IFwiJnNmcm93bjtcIixcbiAgICAgIFwi8J2Su1wiOiBcIiZmc2NyO1wiLFxuICAgICAgXCLiqoxcIjogXCImZ3RyZXFxbGVzcztcIixcbiAgICAgIFwix7VcIjogXCImZ2FjdXRlO1wiLFxuICAgICAgXCLOs1wiOiBcIiZnYW1tYTtcIixcbiAgICAgIFwi4qqGXCI6IFwiJmd0cmFwcHJveDtcIixcbiAgICAgIFwixJ9cIjogXCImZ2JyZXZlO1wiLFxuICAgICAgXCLEnVwiOiBcIiZnY2lyYztcIixcbiAgICAgIFwi0LNcIjogXCImZ2N5O1wiLFxuICAgICAgXCLEoVwiOiBcIiZnZG90O1wiLFxuICAgICAgXCLiqqlcIjogXCImZ2VzY2M7XCIsXG4gICAgICBcIuKqgFwiOiBcIiZnZXNkb3Q7XCIsXG4gICAgICBcIuKqglwiOiBcIiZnZXNkb3RvO1wiLFxuICAgICAgXCLiqoRcIjogXCImZ2VzZG90b2w7XCIsXG4gICAgICBcIuKLm++4gFwiOiBcIiZnZXNsO1wiLFxuICAgICAgXCLiqpRcIjogXCImZ2VzbGVzO1wiLFxuICAgICAgXCLwnZSkXCI6IFwiJmdmcjtcIixcbiAgICAgIFwi4oS3XCI6IFwiJmdpbWVsO1wiLFxuICAgICAgXCLRk1wiOiBcIiZnamN5O1wiLFxuICAgICAgXCLiqpJcIjogXCImZ2xFO1wiLFxuICAgICAgXCLiqqVcIjogXCImZ2xhO1wiLFxuICAgICAgXCLiqqRcIjogXCImZ2xqO1wiLFxuICAgICAgXCLiialcIjogXCImZ25lcXE7XCIsXG4gICAgICBcIuKqilwiOiBcIiZnbmFwcHJveDtcIixcbiAgICAgIFwi4qqIXCI6IFwiJmduZXE7XCIsXG4gICAgICBcIuKLp1wiOiBcIiZnbnNpbTtcIixcbiAgICAgIFwi8J2VmFwiOiBcIiZnb3BmO1wiLFxuICAgICAgXCLihIpcIjogXCImZ3NjcjtcIixcbiAgICAgIFwi4qqOXCI6IFwiJmdzaW1lO1wiLFxuICAgICAgXCLiqpBcIjogXCImZ3NpbWw7XCIsXG4gICAgICBcIuKqp1wiOiBcIiZndGNjO1wiLFxuICAgICAgXCLiqbpcIjogXCImZ3RjaXI7XCIsXG4gICAgICBcIuKLl1wiOiBcIiZndHJkb3Q7XCIsXG4gICAgICBcIuKmlVwiOiBcIiZndGxQYXI7XCIsXG4gICAgICBcIuKpvFwiOiBcIiZndHF1ZXN0O1wiLFxuICAgICAgXCLipbhcIjogXCImZ3RyYXJyO1wiLFxuICAgICAgXCLiianvuIBcIjogXCImZ3ZuRTtcIixcbiAgICAgIFwi0YpcIjogXCImaGFyZGN5O1wiLFxuICAgICAgXCLipYhcIjogXCImaGFycmNpcjtcIixcbiAgICAgIFwi4oatXCI6IFwiJmxlZnRyaWdodHNxdWlnYXJyb3c7XCIsXG4gICAgICBcIuKEj1wiOiBcIiZwbGFua3Y7XCIsXG4gICAgICBcIsSlXCI6IFwiJmhjaXJjO1wiLFxuICAgICAgXCLimaVcIjogXCImaGVhcnRzdWl0O1wiLFxuICAgICAgXCLigKZcIjogXCImbWxkcjtcIixcbiAgICAgIFwi4oq5XCI6IFwiJmhlcmNvbjtcIixcbiAgICAgIFwi8J2UpVwiOiBcIiZoZnI7XCIsXG4gICAgICBcIuKkpVwiOiBcIiZzZWFyaGs7XCIsXG4gICAgICBcIuKkplwiOiBcIiZzd2FyaGs7XCIsXG4gICAgICBcIuKHv1wiOiBcIiZob2FycjtcIixcbiAgICAgIFwi4oi7XCI6IFwiJmhvbXRodDtcIixcbiAgICAgIFwi4oapXCI6IFwiJmxhcnJoaztcIixcbiAgICAgIFwi4oaqXCI6IFwiJnJhcnJoaztcIixcbiAgICAgIFwi8J2VmVwiOiBcIiZob3BmO1wiLFxuICAgICAgXCLigJVcIjogXCImaG9yYmFyO1wiLFxuICAgICAgXCLwnZK9XCI6IFwiJmhzY3I7XCIsXG4gICAgICBcIsSnXCI6IFwiJmhzdHJvaztcIixcbiAgICAgIFwi4oGDXCI6IFwiJmh5YnVsbDtcIixcbiAgICAgIFwiw61cIjogXCImaWFjdXRlO1wiLFxuICAgICAgXCLDrlwiOiBcIiZpY2lyYztcIixcbiAgICAgIFwi0LhcIjogXCImaWN5O1wiLFxuICAgICAgXCLQtVwiOiBcIiZpZWN5O1wiLFxuICAgICAgXCLCoVwiOiBcIiZpZXhjbDtcIixcbiAgICAgIFwi8J2UplwiOiBcIiZpZnI7XCIsXG4gICAgICBcIsOsXCI6IFwiJmlncmF2ZTtcIixcbiAgICAgIFwi4qiMXCI6IFwiJnFpbnQ7XCIsXG4gICAgICBcIuKIrVwiOiBcIiZ0aW50O1wiLFxuICAgICAgXCLip5xcIjogXCImaWluZmluO1wiLFxuICAgICAgXCLihKlcIjogXCImaWlvdGE7XCIsXG4gICAgICBcIsSzXCI6IFwiJmlqbGlnO1wiLFxuICAgICAgXCLEq1wiOiBcIiZpbWFjcjtcIixcbiAgICAgIFwixLFcIjogXCImaW5vZG90O1wiLFxuICAgICAgXCLiirdcIjogXCImaW1vZjtcIixcbiAgICAgIFwixrVcIjogXCImaW1wZWQ7XCIsXG4gICAgICBcIuKEhVwiOiBcIiZpbmNhcmU7XCIsXG4gICAgICBcIuKInlwiOiBcIiZpbmZpbjtcIixcbiAgICAgIFwi4qedXCI6IFwiJmluZmludGllO1wiLFxuICAgICAgXCLiirpcIjogXCImaW50ZXJjYWw7XCIsXG4gICAgICBcIuKol1wiOiBcIiZpbnRsYXJoaztcIixcbiAgICAgIFwi4qi8XCI6IFwiJmlwcm9kO1wiLFxuICAgICAgXCLRkVwiOiBcIiZpb2N5O1wiLFxuICAgICAgXCLEr1wiOiBcIiZpb2dvbjtcIixcbiAgICAgIFwi8J2VmlwiOiBcIiZpb3BmO1wiLFxuICAgICAgXCLOuVwiOiBcIiZpb3RhO1wiLFxuICAgICAgXCLCv1wiOiBcIiZpcXVlc3Q7XCIsXG4gICAgICBcIvCdkr5cIjogXCImaXNjcjtcIixcbiAgICAgIFwi4ou5XCI6IFwiJmlzaW5FO1wiLFxuICAgICAgXCLii7VcIjogXCImaXNpbmRvdDtcIixcbiAgICAgIFwi4ou0XCI6IFwiJmlzaW5zO1wiLFxuICAgICAgXCLii7NcIjogXCImaXNpbnN2O1wiLFxuICAgICAgXCLEqVwiOiBcIiZpdGlsZGU7XCIsXG4gICAgICBcItGWXCI6IFwiJml1a2N5O1wiLFxuICAgICAgXCLDr1wiOiBcIiZpdW1sO1wiLFxuICAgICAgXCLEtVwiOiBcIiZqY2lyYztcIixcbiAgICAgIFwi0LlcIjogXCImamN5O1wiLFxuICAgICAgXCLwnZSnXCI6IFwiJmpmcjtcIixcbiAgICAgIFwiyLdcIjogXCImam1hdGg7XCIsXG4gICAgICBcIvCdlZtcIjogXCImam9wZjtcIixcbiAgICAgIFwi8J2Sv1wiOiBcIiZqc2NyO1wiLFxuICAgICAgXCLRmFwiOiBcIiZqc2VyY3k7XCIsXG4gICAgICBcItGUXCI6IFwiJmp1a2N5O1wiLFxuICAgICAgXCLOulwiOiBcIiZrYXBwYTtcIixcbiAgICAgIFwiz7BcIjogXCImdmFya2FwcGE7XCIsXG4gICAgICBcIsS3XCI6IFwiJmtjZWRpbDtcIixcbiAgICAgIFwi0LpcIjogXCIma2N5O1wiLFxuICAgICAgXCLwnZSoXCI6IFwiJmtmcjtcIixcbiAgICAgIFwixLhcIjogXCIma2dyZWVuO1wiLFxuICAgICAgXCLRhVwiOiBcIiZraGN5O1wiLFxuICAgICAgXCLRnFwiOiBcIiZramN5O1wiLFxuICAgICAgXCLwnZWcXCI6IFwiJmtvcGY7XCIsXG4gICAgICBcIvCdk4BcIjogXCIma3NjcjtcIixcbiAgICAgIFwi4qSbXCI6IFwiJmxBdGFpbDtcIixcbiAgICAgIFwi4qSOXCI6IFwiJmxCYXJyO1wiLFxuICAgICAgXCLiqotcIjogXCImbGVzc2VxcWd0cjtcIixcbiAgICAgIFwi4qWiXCI6IFwiJmxIYXI7XCIsXG4gICAgICBcIsS6XCI6IFwiJmxhY3V0ZTtcIixcbiAgICAgIFwi4qa0XCI6IFwiJmxhZW1wdHl2O1wiLFxuICAgICAgXCLOu1wiOiBcIiZsYW1iZGE7XCIsXG4gICAgICBcIuKmkVwiOiBcIiZsYW5nZDtcIixcbiAgICAgIFwi4qqFXCI6IFwiJmxlc3NhcHByb3g7XCIsXG4gICAgICBcIsKrXCI6IFwiJmxhcXVvO1wiLFxuICAgICAgXCLipJ9cIjogXCImbGFycmJmcztcIixcbiAgICAgIFwi4qSdXCI6IFwiJmxhcnJmcztcIixcbiAgICAgIFwi4oarXCI6IFwiJmxvb3BhcnJvd2xlZnQ7XCIsXG4gICAgICBcIuKkuVwiOiBcIiZsYXJycGw7XCIsXG4gICAgICBcIuKls1wiOiBcIiZsYXJyc2ltO1wiLFxuICAgICAgXCLihqJcIjogXCImbGVmdGFycm93dGFpbDtcIixcbiAgICAgIFwi4qqrXCI6IFwiJmxhdDtcIixcbiAgICAgIFwi4qSZXCI6IFwiJmxhdGFpbDtcIixcbiAgICAgIFwi4qqtXCI6IFwiJmxhdGU7XCIsXG4gICAgICBcIuKqre+4gFwiOiBcIiZsYXRlcztcIixcbiAgICAgIFwi4qSMXCI6IFwiJmxiYXJyO1wiLFxuICAgICAgXCLinbJcIjogXCImbGJicms7XCIsXG4gICAgICBcIntcIjogXCImbGN1YjtcIixcbiAgICAgIFwiW1wiOiBcIiZsc3FiO1wiLFxuICAgICAgXCLipotcIjogXCImbGJya2U7XCIsXG4gICAgICBcIuKmj1wiOiBcIiZsYnJrc2xkO1wiLFxuICAgICAgXCLipo1cIjogXCImbGJya3NsdTtcIixcbiAgICAgIFwixL5cIjogXCImbGNhcm9uO1wiLFxuICAgICAgXCLEvFwiOiBcIiZsY2VkaWw7XCIsXG4gICAgICBcItC7XCI6IFwiJmxjeTtcIixcbiAgICAgIFwi4qS2XCI6IFwiJmxkY2E7XCIsXG4gICAgICBcIuKlp1wiOiBcIiZsZHJkaGFyO1wiLFxuICAgICAgXCLipYtcIjogXCImbGRydXNoYXI7XCIsXG4gICAgICBcIuKGslwiOiBcIiZsZHNoO1wiLFxuICAgICAgXCLiiaRcIjogXCImbGVxO1wiLFxuICAgICAgXCLih4dcIjogXCImbGxhcnI7XCIsXG4gICAgICBcIuKLi1wiOiBcIiZsdGhyZWU7XCIsXG4gICAgICBcIuKqqFwiOiBcIiZsZXNjYztcIixcbiAgICAgIFwi4qm/XCI6IFwiJmxlc2RvdDtcIixcbiAgICAgIFwi4qqBXCI6IFwiJmxlc2RvdG87XCIsXG4gICAgICBcIuKqg1wiOiBcIiZsZXNkb3RvcjtcIixcbiAgICAgIFwi4oua77iAXCI6IFwiJmxlc2c7XCIsXG4gICAgICBcIuKqk1wiOiBcIiZsZXNnZXM7XCIsXG4gICAgICBcIuKLllwiOiBcIiZsdGRvdDtcIixcbiAgICAgIFwi4qW8XCI6IFwiJmxmaXNodDtcIixcbiAgICAgIFwi8J2UqVwiOiBcIiZsZnI7XCIsXG4gICAgICBcIuKqkVwiOiBcIiZsZ0U7XCIsXG4gICAgICBcIuKlqlwiOiBcIiZsaGFydWw7XCIsXG4gICAgICBcIuKWhFwiOiBcIiZsaGJsaztcIixcbiAgICAgIFwi0ZlcIjogXCImbGpjeTtcIixcbiAgICAgIFwi4qWrXCI6IFwiJmxsaGFyZDtcIixcbiAgICAgIFwi4pe6XCI6IFwiJmxsdHJpO1wiLFxuICAgICAgXCLFgFwiOiBcIiZsbWlkb3Q7XCIsXG4gICAgICBcIuKOsFwiOiBcIiZsbW91c3RhY2hlO1wiLFxuICAgICAgXCLiiahcIjogXCImbG5lcXE7XCIsXG4gICAgICBcIuKqiVwiOiBcIiZsbmFwcHJveDtcIixcbiAgICAgIFwi4qqHXCI6IFwiJmxuZXE7XCIsXG4gICAgICBcIuKLplwiOiBcIiZsbnNpbTtcIixcbiAgICAgIFwi4p+sXCI6IFwiJmxvYW5nO1wiLFxuICAgICAgXCLih71cIjogXCImbG9hcnI7XCIsXG4gICAgICBcIuKfvFwiOiBcIiZ4bWFwO1wiLFxuICAgICAgXCLihqxcIjogXCImcmFycmxwO1wiLFxuICAgICAgXCLipoVcIjogXCImbG9wYXI7XCIsXG4gICAgICBcIvCdlZ1cIjogXCImbG9wZjtcIixcbiAgICAgIFwi4qitXCI6IFwiJmxvcGx1cztcIixcbiAgICAgIFwi4qi0XCI6IFwiJmxvdGltZXM7XCIsXG4gICAgICBcIuKIl1wiOiBcIiZsb3dhc3Q7XCIsXG4gICAgICBcIuKXilwiOiBcIiZsb3plbmdlO1wiLFxuICAgICAgXCIoXCI6IFwiJmxwYXI7XCIsXG4gICAgICBcIuKmk1wiOiBcIiZscGFybHQ7XCIsXG4gICAgICBcIuKlrVwiOiBcIiZscmhhcmQ7XCIsXG4gICAgICBcIuKAjlwiOiBcIiZscm07XCIsXG4gICAgICBcIuKKv1wiOiBcIiZscnRyaTtcIixcbiAgICAgIFwi4oC5XCI6IFwiJmxzYXF1bztcIixcbiAgICAgIFwi8J2TgVwiOiBcIiZsc2NyO1wiLFxuICAgICAgXCLiqo1cIjogXCImbHNpbWU7XCIsXG4gICAgICBcIuKqj1wiOiBcIiZsc2ltZztcIixcbiAgICAgIFwi4oCaXCI6IFwiJnNicXVvO1wiLFxuICAgICAgXCLFglwiOiBcIiZsc3Ryb2s7XCIsXG4gICAgICBcIuKqplwiOiBcIiZsdGNjO1wiLFxuICAgICAgXCLiqblcIjogXCImbHRjaXI7XCIsXG4gICAgICBcIuKLiVwiOiBcIiZsdGltZXM7XCIsXG4gICAgICBcIuKltlwiOiBcIiZsdGxhcnI7XCIsXG4gICAgICBcIuKpu1wiOiBcIiZsdHF1ZXN0O1wiLFxuICAgICAgXCLippZcIjogXCImbHRyUGFyO1wiLFxuICAgICAgXCLil4NcIjogXCImdHJpYW5nbGVsZWZ0O1wiLFxuICAgICAgXCLipYpcIjogXCImbHVyZHNoYXI7XCIsXG4gICAgICBcIuKlplwiOiBcIiZsdXJ1aGFyO1wiLFxuICAgICAgXCLiiajvuIBcIjogXCImbHZuRTtcIixcbiAgICAgIFwi4oi6XCI6IFwiJm1ERG90O1wiLFxuICAgICAgXCLCr1wiOiBcIiZzdHJucztcIixcbiAgICAgIFwi4pmCXCI6IFwiJm1hbGU7XCIsXG4gICAgICBcIuKcoFwiOiBcIiZtYWx0ZXNlO1wiLFxuICAgICAgXCLilq5cIjogXCImbWFya2VyO1wiLFxuICAgICAgXCLiqKlcIjogXCImbWNvbW1hO1wiLFxuICAgICAgXCLQvFwiOiBcIiZtY3k7XCIsXG4gICAgICBcIuKAlFwiOiBcIiZtZGFzaDtcIixcbiAgICAgIFwi8J2UqlwiOiBcIiZtZnI7XCIsXG4gICAgICBcIuKEp1wiOiBcIiZtaG87XCIsXG4gICAgICBcIsK1XCI6IFwiJm1pY3JvO1wiLFxuICAgICAgXCLiq7BcIjogXCImbWlkY2lyO1wiLFxuICAgICAgXCLiiJJcIjogXCImbWludXM7XCIsXG4gICAgICBcIuKoqlwiOiBcIiZtaW51c2R1O1wiLFxuICAgICAgXCLiq5tcIjogXCImbWxjcDtcIixcbiAgICAgIFwi4oqnXCI6IFwiJm1vZGVscztcIixcbiAgICAgIFwi8J2VnlwiOiBcIiZtb3BmO1wiLFxuICAgICAgXCLwnZOCXCI6IFwiJm1zY3I7XCIsXG4gICAgICBcIs68XCI6IFwiJm11O1wiLFxuICAgICAgXCLiirhcIjogXCImbXVtYXA7XCIsXG4gICAgICBcIuKLmcy4XCI6IFwiJm5HZztcIixcbiAgICAgIFwi4omr4oOSXCI6IFwiJm5HdDtcIixcbiAgICAgIFwi4oeNXCI6IFwiJm5sQXJyO1wiLFxuICAgICAgXCLih45cIjogXCImbmhBcnI7XCIsXG4gICAgICBcIuKLmMy4XCI6IFwiJm5MbDtcIixcbiAgICAgIFwi4omq4oOSXCI6IFwiJm5MdDtcIixcbiAgICAgIFwi4oePXCI6IFwiJm5yQXJyO1wiLFxuICAgICAgXCLiiq9cIjogXCImblZEYXNoO1wiLFxuICAgICAgXCLiiq5cIjogXCImblZkYXNoO1wiLFxuICAgICAgXCLFhFwiOiBcIiZuYWN1dGU7XCIsXG4gICAgICBcIuKIoOKDklwiOiBcIiZuYW5nO1wiLFxuICAgICAgXCLiqbDMuFwiOiBcIiZuYXBFO1wiLFxuICAgICAgXCLiiYvMuFwiOiBcIiZuYXBpZDtcIixcbiAgICAgIFwixYlcIjogXCImbmFwb3M7XCIsXG4gICAgICBcIuKZrlwiOiBcIiZuYXR1cmFsO1wiLFxuICAgICAgXCLiqYNcIjogXCImbmNhcDtcIixcbiAgICAgIFwixYhcIjogXCImbmNhcm9uO1wiLFxuICAgICAgXCLFhlwiOiBcIiZuY2VkaWw7XCIsXG4gICAgICBcIuKprcy4XCI6IFwiJm5jb25nZG90O1wiLFxuICAgICAgXCLiqYJcIjogXCImbmN1cDtcIixcbiAgICAgIFwi0L1cIjogXCImbmN5O1wiLFxuICAgICAgXCLigJNcIjogXCImbmRhc2g7XCIsXG4gICAgICBcIuKHl1wiOiBcIiZuZUFycjtcIixcbiAgICAgIFwi4qSkXCI6IFwiJm5lYXJoaztcIixcbiAgICAgIFwi4omQzLhcIjogXCImbmVkb3Q7XCIsXG4gICAgICBcIuKkqFwiOiBcIiZ0b2VhO1wiLFxuICAgICAgXCLwnZSrXCI6IFwiJm5mcjtcIixcbiAgICAgIFwi4oauXCI6IFwiJm5sZWZ0cmlnaHRhcnJvdztcIixcbiAgICAgIFwi4quyXCI6IFwiJm5ocGFyO1wiLFxuICAgICAgXCLii7xcIjogXCImbmlzO1wiLFxuICAgICAgXCLii7pcIjogXCImbmlzZDtcIixcbiAgICAgIFwi0ZpcIjogXCImbmpjeTtcIixcbiAgICAgIFwi4ommzLhcIjogXCImbmxlcXE7XCIsXG4gICAgICBcIuKGmlwiOiBcIiZubGVmdGFycm93O1wiLFxuICAgICAgXCLigKVcIjogXCImbmxkcjtcIixcbiAgICAgIFwi8J2Vn1wiOiBcIiZub3BmO1wiLFxuICAgICAgXCLCrFwiOiBcIiZub3Q7XCIsXG4gICAgICBcIuKLucy4XCI6IFwiJm5vdGluRTtcIixcbiAgICAgIFwi4ou1zLhcIjogXCImbm90aW5kb3Q7XCIsXG4gICAgICBcIuKLt1wiOiBcIiZub3RpbnZiO1wiLFxuICAgICAgXCLii7ZcIjogXCImbm90aW52YztcIixcbiAgICAgIFwi4ou+XCI6IFwiJm5vdG5pdmI7XCIsXG4gICAgICBcIuKLvVwiOiBcIiZub3RuaXZjO1wiLFxuICAgICAgXCLiq73ig6VcIjogXCImbnBhcnNsO1wiLFxuICAgICAgXCLiiILMuFwiOiBcIiZucGFydDtcIixcbiAgICAgIFwi4qiUXCI6IFwiJm5wb2xpbnQ7XCIsXG4gICAgICBcIuKGm1wiOiBcIiZucmlnaHRhcnJvdztcIixcbiAgICAgIFwi4qSzzLhcIjogXCImbnJhcnJjO1wiLFxuICAgICAgXCLihp3MuFwiOiBcIiZucmFycnc7XCIsXG4gICAgICBcIvCdk4NcIjogXCImbnNjcjtcIixcbiAgICAgIFwi4oqEXCI6IFwiJm5zdWI7XCIsXG4gICAgICBcIuKrhcy4XCI6IFwiJm5zdWJzZXRlcXE7XCIsXG4gICAgICBcIuKKhVwiOiBcIiZuc3VwO1wiLFxuICAgICAgXCLiq4bMuFwiOiBcIiZuc3Vwc2V0ZXFxO1wiLFxuICAgICAgXCLDsVwiOiBcIiZudGlsZGU7XCIsXG4gICAgICBcIs69XCI6IFwiJm51O1wiLFxuICAgICAgXCIjXCI6IFwiJm51bTtcIixcbiAgICAgIFwi4oSWXCI6IFwiJm51bWVybztcIixcbiAgICAgIFwi4oCHXCI6IFwiJm51bXNwO1wiLFxuICAgICAgXCLiiq1cIjogXCImbnZEYXNoO1wiLFxuICAgICAgXCLipIRcIjogXCImbnZIYXJyO1wiLFxuICAgICAgXCLiiY3ig5JcIjogXCImbnZhcDtcIixcbiAgICAgIFwi4oqsXCI6IFwiJm52ZGFzaDtcIixcbiAgICAgIFwi4oml4oOSXCI6IFwiJm52Z2U7XCIsXG4gICAgICBcIj7ig5JcIjogXCImbnZndDtcIixcbiAgICAgIFwi4qeeXCI6IFwiJm52aW5maW47XCIsXG4gICAgICBcIuKkglwiOiBcIiZudmxBcnI7XCIsXG4gICAgICBcIuKJpOKDklwiOiBcIiZudmxlO1wiLFxuICAgICAgXCI84oOSXCI6IFwiJm52bHQ7XCIsXG4gICAgICBcIuKKtOKDklwiOiBcIiZudmx0cmllO1wiLFxuICAgICAgXCLipINcIjogXCImbnZyQXJyO1wiLFxuICAgICAgXCLiirXig5JcIjogXCImbnZydHJpZTtcIixcbiAgICAgIFwi4oi84oOSXCI6IFwiJm52c2ltO1wiLFxuICAgICAgXCLih5ZcIjogXCImbndBcnI7XCIsXG4gICAgICBcIuKko1wiOiBcIiZud2FyaGs7XCIsXG4gICAgICBcIuKkp1wiOiBcIiZud25lYXI7XCIsXG4gICAgICBcIsOzXCI6IFwiJm9hY3V0ZTtcIixcbiAgICAgIFwiw7RcIjogXCImb2NpcmM7XCIsXG4gICAgICBcItC+XCI6IFwiJm9jeTtcIixcbiAgICAgIFwixZFcIjogXCImb2RibGFjO1wiLFxuICAgICAgXCLiqLhcIjogXCImb2RpdjtcIixcbiAgICAgIFwi4qa8XCI6IFwiJm9kc29sZDtcIixcbiAgICAgIFwixZNcIjogXCImb2VsaWc7XCIsXG4gICAgICBcIuKmv1wiOiBcIiZvZmNpcjtcIixcbiAgICAgIFwi8J2UrFwiOiBcIiZvZnI7XCIsXG4gICAgICBcIsubXCI6IFwiJm9nb247XCIsXG4gICAgICBcIsOyXCI6IFwiJm9ncmF2ZTtcIixcbiAgICAgIFwi4qeBXCI6IFwiJm9ndDtcIixcbiAgICAgIFwi4qa1XCI6IFwiJm9oYmFyO1wiLFxuICAgICAgXCLipr5cIjogXCImb2xjaXI7XCIsXG4gICAgICBcIuKmu1wiOiBcIiZvbGNyb3NzO1wiLFxuICAgICAgXCLip4BcIjogXCImb2x0O1wiLFxuICAgICAgXCLFjVwiOiBcIiZvbWFjcjtcIixcbiAgICAgIFwiz4lcIjogXCImb21lZ2E7XCIsXG4gICAgICBcIs6/XCI6IFwiJm9taWNyb247XCIsXG4gICAgICBcIuKmtlwiOiBcIiZvbWlkO1wiLFxuICAgICAgXCLwnZWgXCI6IFwiJm9vcGY7XCIsXG4gICAgICBcIuKmt1wiOiBcIiZvcGFyO1wiLFxuICAgICAgXCLiprlcIjogXCImb3BlcnA7XCIsXG4gICAgICBcIuKIqFwiOiBcIiZ2ZWU7XCIsXG4gICAgICBcIuKpnVwiOiBcIiZvcmQ7XCIsXG4gICAgICBcIuKEtFwiOiBcIiZvc2NyO1wiLFxuICAgICAgXCLCqlwiOiBcIiZvcmRmO1wiLFxuICAgICAgXCLCulwiOiBcIiZvcmRtO1wiLFxuICAgICAgXCLiirZcIjogXCImb3JpZ29mO1wiLFxuICAgICAgXCLiqZZcIjogXCImb3JvcjtcIixcbiAgICAgIFwi4qmXXCI6IFwiJm9yc2xvcGU7XCIsXG4gICAgICBcIuKpm1wiOiBcIiZvcnY7XCIsXG4gICAgICBcIsO4XCI6IFwiJm9zbGFzaDtcIixcbiAgICAgIFwi4oqYXCI6IFwiJm9zb2w7XCIsXG4gICAgICBcIsO1XCI6IFwiJm90aWxkZTtcIixcbiAgICAgIFwi4qi2XCI6IFwiJm90aW1lc2FzO1wiLFxuICAgICAgXCLDtlwiOiBcIiZvdW1sO1wiLFxuICAgICAgXCLijL1cIjogXCImb3ZiYXI7XCIsXG4gICAgICBcIsK2XCI6IFwiJnBhcmE7XCIsXG4gICAgICBcIuKrs1wiOiBcIiZwYXJzaW07XCIsXG4gICAgICBcIuKrvVwiOiBcIiZwYXJzbDtcIixcbiAgICAgIFwi0L9cIjogXCImcGN5O1wiLFxuICAgICAgXCIlXCI6IFwiJnBlcmNudDtcIixcbiAgICAgIFwiLlwiOiBcIiZwZXJpb2Q7XCIsXG4gICAgICBcIuKAsFwiOiBcIiZwZXJtaWw7XCIsXG4gICAgICBcIuKAsVwiOiBcIiZwZXJ0ZW5rO1wiLFxuICAgICAgXCLwnZStXCI6IFwiJnBmcjtcIixcbiAgICAgIFwiz4ZcIjogXCImcGhpO1wiLFxuICAgICAgXCLPlVwiOiBcIiZ2YXJwaGk7XCIsXG4gICAgICBcIuKYjlwiOiBcIiZwaG9uZTtcIixcbiAgICAgIFwiz4BcIjogXCImcGk7XCIsXG4gICAgICBcIs+WXCI6IFwiJnZhcnBpO1wiLFxuICAgICAgXCLihI5cIjogXCImcGxhbmNraDtcIixcbiAgICAgIFwiK1wiOiBcIiZwbHVzO1wiLFxuICAgICAgXCLiqKNcIjogXCImcGx1c2FjaXI7XCIsXG4gICAgICBcIuKoolwiOiBcIiZwbHVzY2lyO1wiLFxuICAgICAgXCLiqKVcIjogXCImcGx1c2R1O1wiLFxuICAgICAgXCLiqbJcIjogXCImcGx1c2U7XCIsXG4gICAgICBcIuKoplwiOiBcIiZwbHVzc2ltO1wiLFxuICAgICAgXCLiqKdcIjogXCImcGx1c3R3bztcIixcbiAgICAgIFwi4qiVXCI6IFwiJnBvaW50aW50O1wiLFxuICAgICAgXCLwnZWhXCI6IFwiJnBvcGY7XCIsXG4gICAgICBcIsKjXCI6IFwiJnBvdW5kO1wiLFxuICAgICAgXCLiqrNcIjogXCImcHJFO1wiLFxuICAgICAgXCLiqrdcIjogXCImcHJlY2FwcHJveDtcIixcbiAgICAgIFwi4qq5XCI6IFwiJnBybmFwO1wiLFxuICAgICAgXCLiqrVcIjogXCImcHJuRTtcIixcbiAgICAgIFwi4ouoXCI6IFwiJnBybnNpbTtcIixcbiAgICAgIFwi4oCyXCI6IFwiJnByaW1lO1wiLFxuICAgICAgXCLijK5cIjogXCImcHJvZmFsYXI7XCIsXG4gICAgICBcIuKMklwiOiBcIiZwcm9mbGluZTtcIixcbiAgICAgIFwi4oyTXCI6IFwiJnByb2ZzdXJmO1wiLFxuICAgICAgXCLiirBcIjogXCImcHJ1cmVsO1wiLFxuICAgICAgXCLwnZOFXCI6IFwiJnBzY3I7XCIsXG4gICAgICBcIs+IXCI6IFwiJnBzaTtcIixcbiAgICAgIFwi4oCIXCI6IFwiJnB1bmNzcDtcIixcbiAgICAgIFwi8J2UrlwiOiBcIiZxZnI7XCIsXG4gICAgICBcIvCdlaJcIjogXCImcW9wZjtcIixcbiAgICAgIFwi4oGXXCI6IFwiJnFwcmltZTtcIixcbiAgICAgIFwi8J2ThlwiOiBcIiZxc2NyO1wiLFxuICAgICAgXCLiqJZcIjogXCImcXVhdGludDtcIixcbiAgICAgIFwiP1wiOiBcIiZxdWVzdDtcIixcbiAgICAgIFwi4qScXCI6IFwiJnJBdGFpbDtcIixcbiAgICAgIFwi4qWkXCI6IFwiJnJIYXI7XCIsXG4gICAgICBcIuKIvcyxXCI6IFwiJnJhY2U7XCIsXG4gICAgICBcIsWVXCI6IFwiJnJhY3V0ZTtcIixcbiAgICAgIFwi4qazXCI6IFwiJnJhZW1wdHl2O1wiLFxuICAgICAgXCLippJcIjogXCImcmFuZ2Q7XCIsXG4gICAgICBcIuKmpVwiOiBcIiZyYW5nZTtcIixcbiAgICAgIFwiwrtcIjogXCImcmFxdW87XCIsXG4gICAgICBcIuKltVwiOiBcIiZyYXJyYXA7XCIsXG4gICAgICBcIuKkoFwiOiBcIiZyYXJyYmZzO1wiLFxuICAgICAgXCLipLNcIjogXCImcmFycmM7XCIsXG4gICAgICBcIuKknlwiOiBcIiZyYXJyZnM7XCIsXG4gICAgICBcIuKlhVwiOiBcIiZyYXJycGw7XCIsXG4gICAgICBcIuKltFwiOiBcIiZyYXJyc2ltO1wiLFxuICAgICAgXCLihqNcIjogXCImcmlnaHRhcnJvd3RhaWw7XCIsXG4gICAgICBcIuKGnVwiOiBcIiZyaWdodHNxdWlnYXJyb3c7XCIsXG4gICAgICBcIuKkmlwiOiBcIiZyYXRhaWw7XCIsXG4gICAgICBcIuKItlwiOiBcIiZyYXRpbztcIixcbiAgICAgIFwi4p2zXCI6IFwiJnJiYnJrO1wiLFxuICAgICAgXCJ9XCI6IFwiJnJjdWI7XCIsXG4gICAgICBcIl1cIjogXCImcnNxYjtcIixcbiAgICAgIFwi4qaMXCI6IFwiJnJicmtlO1wiLFxuICAgICAgXCLipo5cIjogXCImcmJya3NsZDtcIixcbiAgICAgIFwi4qaQXCI6IFwiJnJicmtzbHU7XCIsXG4gICAgICBcIsWZXCI6IFwiJnJjYXJvbjtcIixcbiAgICAgIFwixZdcIjogXCImcmNlZGlsO1wiLFxuICAgICAgXCLRgFwiOiBcIiZyY3k7XCIsXG4gICAgICBcIuKkt1wiOiBcIiZyZGNhO1wiLFxuICAgICAgXCLipalcIjogXCImcmRsZGhhcjtcIixcbiAgICAgIFwi4oazXCI6IFwiJnJkc2g7XCIsXG4gICAgICBcIuKWrVwiOiBcIiZyZWN0O1wiLFxuICAgICAgXCLipb1cIjogXCImcmZpc2h0O1wiLFxuICAgICAgXCLwnZSvXCI6IFwiJnJmcjtcIixcbiAgICAgIFwi4qWsXCI6IFwiJnJoYXJ1bDtcIixcbiAgICAgIFwiz4FcIjogXCImcmhvO1wiLFxuICAgICAgXCLPsVwiOiBcIiZ2YXJyaG87XCIsXG4gICAgICBcIuKHiVwiOiBcIiZycmFycjtcIixcbiAgICAgIFwi4ouMXCI6IFwiJnJ0aHJlZTtcIixcbiAgICAgIFwiy5pcIjogXCImcmluZztcIixcbiAgICAgIFwi4oCPXCI6IFwiJnJsbTtcIixcbiAgICAgIFwi4o6xXCI6IFwiJnJtb3VzdGFjaGU7XCIsXG4gICAgICBcIuKrrlwiOiBcIiZybm1pZDtcIixcbiAgICAgIFwi4p+tXCI6IFwiJnJvYW5nO1wiLFxuICAgICAgXCLih75cIjogXCImcm9hcnI7XCIsXG4gICAgICBcIuKmhlwiOiBcIiZyb3BhcjtcIixcbiAgICAgIFwi8J2Vo1wiOiBcIiZyb3BmO1wiLFxuICAgICAgXCLiqK5cIjogXCImcm9wbHVzO1wiLFxuICAgICAgXCLiqLVcIjogXCImcm90aW1lcztcIixcbiAgICAgIFwiKVwiOiBcIiZycGFyO1wiLFxuICAgICAgXCLippRcIjogXCImcnBhcmd0O1wiLFxuICAgICAgXCLiqJJcIjogXCImcnBwb2xpbnQ7XCIsXG4gICAgICBcIuKAulwiOiBcIiZyc2FxdW87XCIsXG4gICAgICBcIvCdk4dcIjogXCImcnNjcjtcIixcbiAgICAgIFwi4ouKXCI6IFwiJnJ0aW1lcztcIixcbiAgICAgIFwi4pa5XCI6IFwiJnRyaWFuZ2xlcmlnaHQ7XCIsXG4gICAgICBcIuKnjlwiOiBcIiZydHJpbHRyaTtcIixcbiAgICAgIFwi4qWoXCI6IFwiJnJ1bHVoYXI7XCIsXG4gICAgICBcIuKEnlwiOiBcIiZyeDtcIixcbiAgICAgIFwixZtcIjogXCImc2FjdXRlO1wiLFxuICAgICAgXCLiqrRcIjogXCImc2NFO1wiLFxuICAgICAgXCLiqrhcIjogXCImc3VjY2FwcHJveDtcIixcbiAgICAgIFwixaFcIjogXCImc2Nhcm9uO1wiLFxuICAgICAgXCLFn1wiOiBcIiZzY2VkaWw7XCIsXG4gICAgICBcIsWdXCI6IFwiJnNjaXJjO1wiLFxuICAgICAgXCLiqrZcIjogXCImc3VjY25lcXE7XCIsXG4gICAgICBcIuKqulwiOiBcIiZzdWNjbmFwcHJveDtcIixcbiAgICAgIFwi4oupXCI6IFwiJnN1Y2Nuc2ltO1wiLFxuICAgICAgXCLiqJNcIjogXCImc2Nwb2xpbnQ7XCIsXG4gICAgICBcItGBXCI6IFwiJnNjeTtcIixcbiAgICAgIFwi4ouFXCI6IFwiJnNkb3Q7XCIsXG4gICAgICBcIuKpplwiOiBcIiZzZG90ZTtcIixcbiAgICAgIFwi4oeYXCI6IFwiJnNlQXJyO1wiLFxuICAgICAgXCLCp1wiOiBcIiZzZWN0O1wiLFxuICAgICAgXCI7XCI6IFwiJnNlbWk7XCIsXG4gICAgICBcIuKkqVwiOiBcIiZ0b3NhO1wiLFxuICAgICAgXCLinLZcIjogXCImc2V4dDtcIixcbiAgICAgIFwi8J2UsFwiOiBcIiZzZnI7XCIsXG4gICAgICBcIuKZr1wiOiBcIiZzaGFycDtcIixcbiAgICAgIFwi0YlcIjogXCImc2hjaGN5O1wiLFxuICAgICAgXCLRiFwiOiBcIiZzaGN5O1wiLFxuICAgICAgXCLCrVwiOiBcIiZzaHk7XCIsXG4gICAgICBcIs+DXCI6IFwiJnNpZ21hO1wiLFxuICAgICAgXCLPglwiOiBcIiZ2YXJzaWdtYTtcIixcbiAgICAgIFwi4qmqXCI6IFwiJnNpbWRvdDtcIixcbiAgICAgIFwi4qqeXCI6IFwiJnNpbWc7XCIsXG4gICAgICBcIuKqoFwiOiBcIiZzaW1nRTtcIixcbiAgICAgIFwi4qqdXCI6IFwiJnNpbWw7XCIsXG4gICAgICBcIuKqn1wiOiBcIiZzaW1sRTtcIixcbiAgICAgIFwi4omGXCI6IFwiJnNpbW5lO1wiLFxuICAgICAgXCLiqKRcIjogXCImc2ltcGx1cztcIixcbiAgICAgIFwi4qWyXCI6IFwiJnNpbXJhcnI7XCIsXG4gICAgICBcIuKos1wiOiBcIiZzbWFzaHA7XCIsXG4gICAgICBcIuKnpFwiOiBcIiZzbWVwYXJzbDtcIixcbiAgICAgIFwi4oyjXCI6IFwiJnNzbWlsZTtcIixcbiAgICAgIFwi4qqqXCI6IFwiJnNtdDtcIixcbiAgICAgIFwi4qqsXCI6IFwiJnNtdGU7XCIsXG4gICAgICBcIuKqrO+4gFwiOiBcIiZzbXRlcztcIixcbiAgICAgIFwi0YxcIjogXCImc29mdGN5O1wiLFxuICAgICAgXCIvXCI6IFwiJnNvbDtcIixcbiAgICAgIFwi4qeEXCI6IFwiJnNvbGI7XCIsXG4gICAgICBcIuKMv1wiOiBcIiZzb2xiYXI7XCIsXG4gICAgICBcIvCdlaRcIjogXCImc29wZjtcIixcbiAgICAgIFwi4pmgXCI6IFwiJnNwYWRlc3VpdDtcIixcbiAgICAgIFwi4oqT77iAXCI6IFwiJnNxY2FwcztcIixcbiAgICAgIFwi4oqU77iAXCI6IFwiJnNxY3VwcztcIixcbiAgICAgIFwi8J2TiFwiOiBcIiZzc2NyO1wiLFxuICAgICAgXCLimIZcIjogXCImc3RhcjtcIixcbiAgICAgIFwi4oqCXCI6IFwiJnN1YnNldDtcIixcbiAgICAgIFwi4quFXCI6IFwiJnN1YnNldGVxcTtcIixcbiAgICAgIFwi4qq9XCI6IFwiJnN1YmRvdDtcIixcbiAgICAgIFwi4quDXCI6IFwiJnN1YmVkb3Q7XCIsXG4gICAgICBcIuKrgVwiOiBcIiZzdWJtdWx0O1wiLFxuICAgICAgXCLiq4tcIjogXCImc3Vic2V0bmVxcTtcIixcbiAgICAgIFwi4oqKXCI6IFwiJnN1YnNldG5lcTtcIixcbiAgICAgIFwi4qq/XCI6IFwiJnN1YnBsdXM7XCIsXG4gICAgICBcIuKluVwiOiBcIiZzdWJyYXJyO1wiLFxuICAgICAgXCLiq4dcIjogXCImc3Vic2ltO1wiLFxuICAgICAgXCLiq5VcIjogXCImc3Vic3ViO1wiLFxuICAgICAgXCLiq5NcIjogXCImc3Vic3VwO1wiLFxuICAgICAgXCLimapcIjogXCImc3VuZztcIixcbiAgICAgIFwiwrlcIjogXCImc3VwMTtcIixcbiAgICAgIFwiwrJcIjogXCImc3VwMjtcIixcbiAgICAgIFwiwrNcIjogXCImc3VwMztcIixcbiAgICAgIFwi4quGXCI6IFwiJnN1cHNldGVxcTtcIixcbiAgICAgIFwi4qq+XCI6IFwiJnN1cGRvdDtcIixcbiAgICAgIFwi4quYXCI6IFwiJnN1cGRzdWI7XCIsXG4gICAgICBcIuKrhFwiOiBcIiZzdXBlZG90O1wiLFxuICAgICAgXCLin4lcIjogXCImc3VwaHNvbDtcIixcbiAgICAgIFwi4quXXCI6IFwiJnN1cGhzdWI7XCIsXG4gICAgICBcIuKlu1wiOiBcIiZzdXBsYXJyO1wiLFxuICAgICAgXCLiq4JcIjogXCImc3VwbXVsdDtcIixcbiAgICAgIFwi4quMXCI6IFwiJnN1cHNldG5lcXE7XCIsXG4gICAgICBcIuKKi1wiOiBcIiZzdXBzZXRuZXE7XCIsXG4gICAgICBcIuKrgFwiOiBcIiZzdXBwbHVzO1wiLFxuICAgICAgXCLiq4hcIjogXCImc3Vwc2ltO1wiLFxuICAgICAgXCLiq5RcIjogXCImc3Vwc3ViO1wiLFxuICAgICAgXCLiq5ZcIjogXCImc3Vwc3VwO1wiLFxuICAgICAgXCLih5lcIjogXCImc3dBcnI7XCIsXG4gICAgICBcIuKkqlwiOiBcIiZzd253YXI7XCIsXG4gICAgICBcIsOfXCI6IFwiJnN6bGlnO1wiLFxuICAgICAgXCLijJZcIjogXCImdGFyZ2V0O1wiLFxuICAgICAgXCLPhFwiOiBcIiZ0YXU7XCIsXG4gICAgICBcIsWlXCI6IFwiJnRjYXJvbjtcIixcbiAgICAgIFwixaNcIjogXCImdGNlZGlsO1wiLFxuICAgICAgXCLRglwiOiBcIiZ0Y3k7XCIsXG4gICAgICBcIuKMlVwiOiBcIiZ0ZWxyZWM7XCIsXG4gICAgICBcIvCdlLFcIjogXCImdGZyO1wiLFxuICAgICAgXCLOuFwiOiBcIiZ0aGV0YTtcIixcbiAgICAgIFwiz5FcIjogXCImdmFydGhldGE7XCIsXG4gICAgICBcIsO+XCI6IFwiJnRob3JuO1wiLFxuICAgICAgXCLDl1wiOiBcIiZ0aW1lcztcIixcbiAgICAgIFwi4qixXCI6IFwiJnRpbWVzYmFyO1wiLFxuICAgICAgXCLiqLBcIjogXCImdGltZXNkO1wiLFxuICAgICAgXCLijLZcIjogXCImdG9wYm90O1wiLFxuICAgICAgXCLiq7FcIjogXCImdG9wY2lyO1wiLFxuICAgICAgXCLwnZWlXCI6IFwiJnRvcGY7XCIsXG4gICAgICBcIuKrmlwiOiBcIiZ0b3Bmb3JrO1wiLFxuICAgICAgXCLigLRcIjogXCImdHByaW1lO1wiLFxuICAgICAgXCLilrVcIjogXCImdXRyaTtcIixcbiAgICAgIFwi4omcXCI6IFwiJnRyaWU7XCIsXG4gICAgICBcIuKXrFwiOiBcIiZ0cmlkb3Q7XCIsXG4gICAgICBcIuKoulwiOiBcIiZ0cmltaW51cztcIixcbiAgICAgIFwi4qi5XCI6IFwiJnRyaXBsdXM7XCIsXG4gICAgICBcIuKnjVwiOiBcIiZ0cmlzYjtcIixcbiAgICAgIFwi4qi7XCI6IFwiJnRyaXRpbWU7XCIsXG4gICAgICBcIuKPolwiOiBcIiZ0cnBleml1bTtcIixcbiAgICAgIFwi8J2TiVwiOiBcIiZ0c2NyO1wiLFxuICAgICAgXCLRhlwiOiBcIiZ0c2N5O1wiLFxuICAgICAgXCLRm1wiOiBcIiZ0c2hjeTtcIixcbiAgICAgIFwixadcIjogXCImdHN0cm9rO1wiLFxuICAgICAgXCLipaNcIjogXCImdUhhcjtcIixcbiAgICAgIFwiw7pcIjogXCImdWFjdXRlO1wiLFxuICAgICAgXCLRnlwiOiBcIiZ1YnJjeTtcIixcbiAgICAgIFwixa1cIjogXCImdWJyZXZlO1wiLFxuICAgICAgXCLDu1wiOiBcIiZ1Y2lyYztcIixcbiAgICAgIFwi0YNcIjogXCImdWN5O1wiLFxuICAgICAgXCLFsVwiOiBcIiZ1ZGJsYWM7XCIsXG4gICAgICBcIuKlvlwiOiBcIiZ1ZmlzaHQ7XCIsXG4gICAgICBcIvCdlLJcIjogXCImdWZyO1wiLFxuICAgICAgXCLDuVwiOiBcIiZ1Z3JhdmU7XCIsXG4gICAgICBcIuKWgFwiOiBcIiZ1aGJsaztcIixcbiAgICAgIFwi4oycXCI6IFwiJnVsY29ybmVyO1wiLFxuICAgICAgXCLijI9cIjogXCImdWxjcm9wO1wiLFxuICAgICAgXCLil7hcIjogXCImdWx0cmk7XCIsXG4gICAgICBcIsWrXCI6IFwiJnVtYWNyO1wiLFxuICAgICAgXCLFs1wiOiBcIiZ1b2dvbjtcIixcbiAgICAgIFwi8J2VplwiOiBcIiZ1b3BmO1wiLFxuICAgICAgXCLPhVwiOiBcIiZ1cHNpbG9uO1wiLFxuICAgICAgXCLih4hcIjogXCImdXVhcnI7XCIsXG4gICAgICBcIuKMnVwiOiBcIiZ1cmNvcm5lcjtcIixcbiAgICAgIFwi4oyOXCI6IFwiJnVyY3JvcDtcIixcbiAgICAgIFwixa9cIjogXCImdXJpbmc7XCIsXG4gICAgICBcIuKXuVwiOiBcIiZ1cnRyaTtcIixcbiAgICAgIFwi8J2TilwiOiBcIiZ1c2NyO1wiLFxuICAgICAgXCLii7BcIjogXCImdXRkb3Q7XCIsXG4gICAgICBcIsWpXCI6IFwiJnV0aWxkZTtcIixcbiAgICAgIFwiw7xcIjogXCImdXVtbDtcIixcbiAgICAgIFwi4qanXCI6IFwiJnV3YW5nbGU7XCIsXG4gICAgICBcIuKrqFwiOiBcIiZ2QmFyO1wiLFxuICAgICAgXCLiq6lcIjogXCImdkJhcnY7XCIsXG4gICAgICBcIuKmnFwiOiBcIiZ2YW5ncnQ7XCIsXG4gICAgICBcIuKKiu+4gFwiOiBcIiZ2c3VibmU7XCIsXG4gICAgICBcIuKri++4gFwiOiBcIiZ2c3VibkU7XCIsXG4gICAgICBcIuKKi++4gFwiOiBcIiZ2c3VwbmU7XCIsXG4gICAgICBcIuKrjO+4gFwiOiBcIiZ2c3VwbkU7XCIsXG4gICAgICBcItCyXCI6IFwiJnZjeTtcIixcbiAgICAgIFwi4oq7XCI6IFwiJnZlZWJhcjtcIixcbiAgICAgIFwi4omaXCI6IFwiJnZlZWVxO1wiLFxuICAgICAgXCLii65cIjogXCImdmVsbGlwO1wiLFxuICAgICAgXCLwnZSzXCI6IFwiJnZmcjtcIixcbiAgICAgIFwi8J2Vp1wiOiBcIiZ2b3BmO1wiLFxuICAgICAgXCLwnZOLXCI6IFwiJnZzY3I7XCIsXG4gICAgICBcIuKmmlwiOiBcIiZ2emlnemFnO1wiLFxuICAgICAgXCLFtVwiOiBcIiZ3Y2lyYztcIixcbiAgICAgIFwi4qmfXCI6IFwiJndlZGJhcjtcIixcbiAgICAgIFwi4omZXCI6IFwiJndlZGdlcTtcIixcbiAgICAgIFwi4oSYXCI6IFwiJndwO1wiLFxuICAgICAgXCLwnZS0XCI6IFwiJndmcjtcIixcbiAgICAgIFwi8J2VqFwiOiBcIiZ3b3BmO1wiLFxuICAgICAgXCLwnZOMXCI6IFwiJndzY3I7XCIsXG4gICAgICBcIvCdlLVcIjogXCImeGZyO1wiLFxuICAgICAgXCLOvlwiOiBcIiZ4aTtcIixcbiAgICAgIFwi4ou7XCI6IFwiJnhuaXM7XCIsXG4gICAgICBcIvCdlalcIjogXCImeG9wZjtcIixcbiAgICAgIFwi8J2TjVwiOiBcIiZ4c2NyO1wiLFxuICAgICAgXCLDvVwiOiBcIiZ5YWN1dGU7XCIsXG4gICAgICBcItGPXCI6IFwiJnlhY3k7XCIsXG4gICAgICBcIsW3XCI6IFwiJnljaXJjO1wiLFxuICAgICAgXCLRi1wiOiBcIiZ5Y3k7XCIsXG4gICAgICBcIsKlXCI6IFwiJnllbjtcIixcbiAgICAgIFwi8J2UtlwiOiBcIiZ5ZnI7XCIsXG4gICAgICBcItGXXCI6IFwiJnlpY3k7XCIsXG4gICAgICBcIvCdlapcIjogXCImeW9wZjtcIixcbiAgICAgIFwi8J2TjlwiOiBcIiZ5c2NyO1wiLFxuICAgICAgXCLRjlwiOiBcIiZ5dWN5O1wiLFxuICAgICAgXCLDv1wiOiBcIiZ5dW1sO1wiLFxuICAgICAgXCLFulwiOiBcIiZ6YWN1dGU7XCIsXG4gICAgICBcIsW+XCI6IFwiJnpjYXJvbjtcIixcbiAgICAgIFwi0LdcIjogXCImemN5O1wiLFxuICAgICAgXCLFvFwiOiBcIiZ6ZG90O1wiLFxuICAgICAgXCLOtlwiOiBcIiZ6ZXRhO1wiLFxuICAgICAgXCLwnZS3XCI6IFwiJnpmcjtcIixcbiAgICAgIFwi0LZcIjogXCImemhjeTtcIixcbiAgICAgIFwi4oedXCI6IFwiJnppZ3JhcnI7XCIsXG4gICAgICBcIvCdlatcIjogXCImem9wZjtcIixcbiAgICAgIFwi8J2Tj1wiOiBcIiZ6c2NyO1wiLFxuICAgICAgXCLigI1cIjogXCImendqO1wiLFxuICAgICAgXCLigIxcIjogXCImenduajtcIlxuICAgIH1cbiAgfVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/named-references.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/numeric-unicode-map.js":
/*!***************************************************************!*\
  !*** ./node_modules/html-entities/lib/numeric-unicode-map.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.numericUnicodeMap = {\n  0: 65533,\n  128: 8364,\n  130: 8218,\n  131: 402,\n  132: 8222,\n  133: 8230,\n  134: 8224,\n  135: 8225,\n  136: 710,\n  137: 8240,\n  138: 352,\n  139: 8249,\n  140: 338,\n  142: 381,\n  145: 8216,\n  146: 8217,\n  147: 8220,\n  148: 8221,\n  149: 8226,\n  150: 8211,\n  151: 8212,\n  152: 732,\n  153: 8482,\n  154: 353,\n  155: 8250,\n  156: 339,\n  158: 382,\n  159: 376\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvbnVtZXJpYy11bmljb2RlLW1hcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9udW1lcmljLXVuaWNvZGUtbWFwLmpzP2QwNGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm51bWVyaWNVbmljb2RlTWFwID0ge1xuICAwOiA2NTUzMyxcbiAgMTI4OiA4MzY0LFxuICAxMzA6IDgyMTgsXG4gIDEzMTogNDAyLFxuICAxMzI6IDgyMjIsXG4gIDEzMzogODIzMCxcbiAgMTM0OiA4MjI0LFxuICAxMzU6IDgyMjUsXG4gIDEzNjogNzEwLFxuICAxMzc6IDgyNDAsXG4gIDEzODogMzUyLFxuICAxMzk6IDgyNDksXG4gIDE0MDogMzM4LFxuICAxNDI6IDM4MSxcbiAgMTQ1OiA4MjE2LFxuICAxNDY6IDgyMTcsXG4gIDE0NzogODIyMCxcbiAgMTQ4OiA4MjIxLFxuICAxNDk6IDgyMjYsXG4gIDE1MDogODIxMSxcbiAgMTUxOiA4MjEyLFxuICAxNTI6IDczMixcbiAgMTUzOiA4NDgyLFxuICAxNTQ6IDM1MyxcbiAgMTU1OiA4MjUwLFxuICAxNTY6IDMzOSxcbiAgMTU4OiAzODIsXG4gIDE1OTogMzc2XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/numeric-unicode-map.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/surrogate-pairs.js":
/*!***********************************************************!*\
  !*** ./node_modules/html-entities/lib/surrogate-pairs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.fromCodePoint = String.fromCodePoint || function (astralCodePoint) {\n  return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);\n};\nexports.getCodePoint = String.prototype.codePointAt ? function (input, position) {\n  return input.codePointAt(position);\n} : function (input, position) {\n  return (input.charCodeAt(position) - 55296) * 1024 + input.charCodeAt(position + 1) - 56320 + 65536;\n};\nexports.highSurrogateFrom = 55296;\nexports.highSurrogateTo = 56319;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvc3Vycm9nYXRlLXBhaXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlfYXBwLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL3N1cnJvZ2F0ZS1wYWlycy5qcz85ZWEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQgfHwgZnVuY3Rpb24gKGFzdHJhbENvZGVQb2ludCkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShNYXRoLmZsb29yKChhc3RyYWxDb2RlUG9pbnQgLSA2NTUzNikgLyAxMDI0KSArIDU1Mjk2LCAoYXN0cmFsQ29kZVBvaW50IC0gNjU1MzYpICUgMTAyNCArIDU2MzIwKTtcbn07XG5leHBvcnRzLmdldENvZGVQb2ludCA9IFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQgPyBmdW5jdGlvbiAoaW5wdXQsIHBvc2l0aW9uKSB7XG4gIHJldHVybiBpbnB1dC5jb2RlUG9pbnRBdChwb3NpdGlvbik7XG59IDogZnVuY3Rpb24gKGlucHV0LCBwb3NpdGlvbikge1xuICByZXR1cm4gKGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24pIC0gNTUyOTYpICogMTAyNCArIGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSAtIDU2MzIwICsgNjU1MzY7XG59O1xuZXhwb3J0cy5oaWdoU3Vycm9nYXRlRnJvbSA9IDU1Mjk2O1xuZXhwb3J0cy5oaWdoU3Vycm9nYXRlVG8gPSA1NjMxOTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/surrogate-pairs.js\n");

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @license React\n * react-dom.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */if(true){(function(){'use strict';/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());}var React=__webpack_require__(/*! react */ \"./node_modules/react/index.js\");var Scheduler=__webpack_require__(/*! scheduler */ \"./node_modules/scheduler/index.js\");var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var suppressWarning=false;function setSuppressWarning(newSuppressWarning){{suppressWarning=newSuppressWarning;}}// In DEV, calls to console.warn and console.error get replaced\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\nfunction warn(format){{if(!suppressWarning){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}printWarning('warn',format,args);}}}function error(format){{if(!suppressWarning){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}printWarning('error',format,args);}}}function printWarning(level,format,args){// When changing this logic, you might want to also\n// update consoleWithStackDev.www.js as well.\n{var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var stack=ReactDebugCurrentFrame.getStackAddendum();if(stack!==''){format+='%s';args=args.concat([stack]);}// eslint-disable-next-line react-internal/safe-string-coercion\nvar argsWithFormat=args.map(function(item){return String(item);});// Careful: RN currently depends on this prefix\nargsWithFormat.unshift('Warning: '+format);// We intentionally don't use spread (or .apply) directly because it\n// breaks IE9: https://github.com/facebook/react/issues/13610\n// eslint-disable-next-line react-internal/no-production-logging\nFunction.prototype.apply.call(console[level],console,argsWithFormat);}}var FunctionComponent=0;var ClassComponent=1;var IndeterminateComponent=2;// Before we know whether it is function or class\nvar HostRoot=3;// Root of a host tree. Could be nested inside another node.\nvar HostPortal=4;// A subtree. Could be an entry point to a different renderer.\nvar HostComponent=5;var HostText=6;var Fragment=7;var Mode=8;var ContextConsumer=9;var ContextProvider=10;var ForwardRef=11;var Profiler=12;var SuspenseComponent=13;var MemoComponent=14;var SimpleMemoComponent=15;var LazyComponent=16;var IncompleteClassComponent=17;var DehydratedFragment=18;var SuspenseListComponent=19;var ScopeComponent=21;var OffscreenComponent=22;var LegacyHiddenComponent=23;var CacheComponent=24;var TracingMarkerComponent=25;// -----------------------------------------------------------------------------\nvar enableClientRenderFallbackOnTextMismatch=true;// TODO: Need to review this code one more time before landing\n// the react-reconciler package.\nvar enableNewReconciler=false;// Support legacy Primer support on internal FB www\nvar enableLazyContextPropagation=false;// FB-only usage. The new API has different semantics.\nvar enableLegacyHidden=false;// Enables unstable_avoidThisFallback feature in Fiber\nvar enableSuspenseAvoidThisFallback=false;// Enables unstable_avoidThisFallback feature in Fizz\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\nvar disableCommentsAsDOMContainers=true;// Disable javascript: URL strings in href for XSS protection.\n// and client rendering, mostly to allow JSX attributes to apply to the custom\n// element's object properties instead of only HTML attributes.\n// https://github.com/facebook/react/issues/11347\nvar enableCustomElementPropertySupport=false;// Disables children for <textarea> elements\nvar warnAboutStringRefs=true;// -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\nvar enableSchedulingProfiler=true;// Helps identify side effects in render-phase lifecycle hooks and setState\nvar enableProfilerTimer=true;// Record durations for commit and passive effects phases.\nvar enableProfilerCommitHooks=true;// Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\nvar allNativeEvents=new Set();/**\n * Mapping from registration name to event name\n */var registrationNameDependencies={};/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true\nfunction registerTwoPhaseEvent(registrationName,dependencies){registerDirectEvent(registrationName,dependencies);registerDirectEvent(registrationName+'Capture',dependencies);}function registerDirectEvent(registrationName,dependencies){{if(registrationNameDependencies[registrationName]){error('EventRegistry: More than one plugin attempted to publish the same '+'registration name, `%s`.',registrationName);}}registrationNameDependencies[registrationName]=dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}for(var i=0;i<dependencies.length;i++){allNativeEvents.add(dependencies[i]);}}var canUseDOM=!!(typeof window!=='undefined'&&typeof window.document!=='undefined'&&typeof window.document.createElement!=='undefined');var hasOwnProperty=Object.prototype.hasOwnProperty;/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value){{// toStringTag is needed for namespaced types like Temporal.Instant\nvar hasToStringTag=typeof Symbol==='function'&&Symbol.toStringTag;var type=hasToStringTag&&value[Symbol.toStringTag]||value.constructor.name||'Object';return type;}}// $FlowFixMe only called in DEV, so void return is not possible.\nfunction willCoercionThrow(value){{try{testStringCoercion(value);return false;}catch(e){return true;}}}function testStringCoercion(value){// If you ended up here by following an exception call stack, here's what's\n// happened: you supplied an object or symbol value to React (as a prop, key,\n// DOM attribute, CSS property, string ref, etc.) and when React tried to\n// coerce it to a string using `'' + value`, an exception was thrown.\n//\n// The most common types that will cause this exception are `Symbol` instances\n// and Temporal objects like `Temporal.Instant`. But any object that has a\n// `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n// exception. (Library authors do this to prevent users from using built-in\n// numeric operators like `+` or comparison operators like `>=` because custom\n// methods are needed to perform accurate arithmetic or comparison.)\n//\n// To fix the problem, coerce this object or symbol value to a string before\n// passing it to React. The most reliable way is usually `String(value)`.\n//\n// To find which value is throwing, check the browser or debugger console.\n// Before this exception was thrown, there should be `console.error` output\n// that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n// problem and how that type was used: key, atrribute, input value prop, etc.\n// In most cases, this console output also shows the component and its\n// ancestor components where the exception happened.\n//\n// eslint-disable-next-line react-internal/safe-string-coercion\nreturn''+value;}function checkAttributeStringCoercion(value,attributeName){{if(willCoercionThrow(value)){error('The provided `%s` attribute is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',attributeName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkKeyStringCoercion(value){{if(willCoercionThrow(value)){error('The provided key is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkPropStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` prop is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkCSSPropertyStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` CSS property is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkHtmlStringCoercion(value){{if(willCoercionThrow(value)){error('The provided HTML markup uses a value of unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkFormFieldValueStringCoercion(value){{if(willCoercionThrow(value)){error('Form field values (value, checked, defaultValue, or defaultChecked props)'+' must be strings, not %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}// A reserved attribute.\n// It is handled by React separately and shouldn't be written to the DOM.\nvar RESERVED=0;// A simple string attribute.\n// Attributes that aren't in the filter are presumed to have this type.\nvar STRING=1;// A string attribute that accepts booleans in React. In HTML, these are called\n// \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n// When true, it should be set to a \"true\" string.\n// When false, it should be set to a \"false\" string.\nvar BOOLEANISH_STRING=2;// A real boolean attribute.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\nvar BOOLEAN=3;// An attribute that can be used as a flag as well as with a value.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\n// For any other value, should be present with that value.\nvar OVERLOADED_BOOLEAN=4;// An attribute that must be numeric or parse as a numeric.\n// When falsy, it should be removed.\nvar NUMERIC=5;// An attribute that must be positive numeric or parse as a positive numeric.\n// When falsy, it should be removed.\nvar POSITIVE_NUMERIC=6;/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=\":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+\"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(hasOwnProperty.call(validatedAttributeNameCache,attributeName)){return true;}if(hasOwnProperty.call(illegalAttributeNameCache,attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{error('Invalid attribute name: `%s`',attributeName);}return false;}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){if(propertyInfo!==null){return propertyInfo.type===RESERVED;}if(isCustomComponentTag){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return true;}return false;}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED){return false;}switch(typeof value){case'function':// $FlowIssue symbol is perfectly valid here\ncase'symbol':// eslint-disable-line\nreturn true;case'boolean':{if(isCustomComponentTag){return false;}if(propertyInfo!==null){return!propertyInfo.acceptsBooleans;}else{var prefix=name.toLowerCase().slice(0,5);return prefix!=='data-'&&prefix!=='aria-';}}default:return false;}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value==='undefined'){return true;}if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag)){return true;}if(isCustomComponentTag){return false;}if(propertyInfo!==null){switch(propertyInfo.type){case BOOLEAN:return!value;case OVERLOADED_BOOLEAN:return value===false;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1;}}return false;}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace,sanitizeURL,removeEmptyString){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN;this.attributeName=attributeName;this.attributeNamespace=attributeNamespace;this.mustUseProperty=mustUseProperty;this.propertyName=name;this.type=type;this.sanitizeURL=sanitizeURL;this.removeEmptyString=removeEmptyString;}// When adding attributes to this list, be sure to also add them to\n// the `possibleStandardNames` module to ensure casing and incorrect\n// name warnings.\nvar properties={};// These props are reserved by React. They shouldn't be written to the DOM.\nvar reservedProps=['children','dangerouslySetInnerHTML',// TODO: This prevents the assignment of defaultValue to regular\n// elements (not just inputs). Now that ReactDOMInput assigns to the\n// defaultValue property -- do we need this?\n'defaultValue','defaultChecked','innerHTML','suppressContentEditableWarning','suppressHydrationWarning','style'];reservedProps.forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// A few React string attributes have a different name.\n// This is a mapping from React prop names to the attribute names.\n[['acceptCharset','accept-charset'],['className','class'],['htmlFor','for'],['httpEquiv','http-equiv']].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n['contentEditable','draggable','spellCheck','value'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n// Since these are SVG attributes, their attribute names are case-sensitive.\n['autoReverse','externalResourcesRequired','focusable','preserveAlpha'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML boolean attributes.\n['allowFullScreen','async',// Note: there is a special case that prevents it from being written to the DOM\n// on the client side because the browsers are inconsistent. Instead we call focus().\n'autoFocus','autoPlay','controls','default','defer','disabled','disablePictureInPicture','disableRemotePlayback','formNoValidate','hidden','loop','noModule','noValidate','open','playsInline','readOnly','required','reversed','scoped','seamless',// Microdata\n'itemScope'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are the few React props that we set as DOM properties\n// rather than attributes. These are all booleans.\n['checked',// Note: `option.selected` is not updated if `select.multiple` is\n// disabled with `removeAttribute`. We have special logic for handling this.\n'multiple','muted','selected'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,true,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that are \"overloaded booleans\": they behave like\n// booleans, but can also accept a string value.\n['capture','download'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that must be positive numbers.\n['cols','rows','size','span'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that must be numbers.\n['rowSpan','start'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});var CAMELIZE=/[\\-\\:]([a-z])/g;var capitalize=function(token){return token[1].toUpperCase();};// This is a list of all SVG attributes that need special casing, namespacing,\n// or boolean value assignment. Regular attributes that just accept strings\n// and have the same names are omitted, just like in the HTML attribute filter.\n// Some of these attributes can be hard to find. This list was created by\n// scraping the MDN documentation.\n['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','xmlns:xlink','x-height'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,null,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// String SVG attributes with the xlink namespace.\n['xlink:actuate','xlink:arcrole','xlink:role','xlink:show','xlink:title','xlink:type'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/1999/xlink',false,// sanitizeURL\nfalse);});// String SVG attributes with the xml namespace.\n['xml:base','xml:lang','xml:space'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/XML/1998/namespace',false,// sanitizeURL\nfalse);});// These attribute exists both in HTML and SVG.\n// The attribute name is case-sensitive in SVG so we can't just use\n// the React name like we do for attributes that exist only in HTML.\n['tabIndex','crossOrigin'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\nattributeName.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These attributes accept URLs. These must not allow javascript: URLS.\n// These will also need to accept Trusted Types object in the future.\nvar xlinkHref='xlinkHref';properties[xlinkHref]=new PropertyInfoRecord('xlinkHref',STRING,false,// mustUseProperty\n'xlink:href','http://www.w3.org/1999/xlink',true,// sanitizeURL\nfalse);['src','href','action','formAction'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\nattributeName.toLowerCase(),// attributeName\nnull,// attributeNamespace\ntrue,// sanitizeURL\ntrue);});// and any newline or tab are filtered out as if they're not part of the URL.\n// https://url.spec.whatwg.org/#url-parsing\n// Tab or newline are defined as \\r\\n\\t:\n// https://infra.spec.whatwg.org/#ascii-tab-or-newline\n// A C0 control is a code point in the range \\u0000 NULL to \\u001F\n// INFORMATION SEPARATOR ONE, inclusive:\n// https://infra.spec.whatwg.org/#c0-control-or-space\n/* eslint-disable max-len */var isJavaScriptProtocol=/^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;var didWarn=false;function sanitizeURL(url){{if(!didWarn&&isJavaScriptProtocol.test(url)){didWarn=true;error('A future version of React will block javascript: URLs as a security precaution. '+'Use event handlers instead if you can. If you need to generate unsafe HTML try '+'using dangerouslySetInnerHTML instead. React was passed %s.',JSON.stringify(url));}}}/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */function getValueForProperty(node,name,expected,propertyInfo){{if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName];}else{// This check protects multiple uses of `expected`, which is why the\n// react-internal/safe-string-coercion rule is disabled in several spots\n// below.\n{checkAttributeStringCoercion(expected,name);}if(propertyInfo.sanitizeURL){// If we haven't fully disabled javascript: URLs, and if\n// the hydration is successful of a javascript: URL, we\n// still want to warn on the client.\n// eslint-disable-next-line react-internal/safe-string-coercion\nsanitizeURL(''+expected);}var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return value;}// eslint-disable-next-line react-internal/safe-string-coercion\nif(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,false)){// We had an attribute but shouldn't have had one, so read it\n// for the error message.\nreturn node.getAttribute(attributeName);}if(propertyInfo.type===BOOLEAN){// If this was a boolean, it doesn't matter what the value is\n// the fact that we have it is the same as the expected.\nreturn expected;}// Even if this property uses a namespace we use getAttribute\n// because we assume its namespaced name is the same as our config.\n// To use getAttributeNS we need the local name which we don't have\n// in our config atm.\nstringValue=node.getAttribute(attributeName);}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return stringValue===null?expected:stringValue;// eslint-disable-next-line react-internal/safe-string-coercion\n}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */function getValueForAttribute(node,name,expected,isCustomComponentTag){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);{checkAttributeStringCoercion(expected,name);}if(value===''+expected){return expected;}return value;}}/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){return;}if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)){value=null;}if(isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;if(value===null){node.removeAttribute(_attributeName);}else{{checkAttributeStringCoercion(value,name);}node.setAttribute(_attributeName,''+value);}}return;}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?false:'';}else{// Contrary to `setAttribute`, object properties are properly\n// `toString`ed by IE8/9.\nnode[propertyName]=value;}return;}// The rest are treated as attributes with special cases.\nvar attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null){node.removeAttribute(attributeName);}else{var _type=propertyInfo.type;var attributeValue;if(_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===true){// If attribute type is boolean, we know for sure it won't be an execution sink\n// and we won't require Trusted Type here.\nattributeValue='';}else{// `setAttribute` with objects becomes only `[object]` in IE8/9,\n// ('' + value) makes it output the correct toString()-value.\n{{checkAttributeStringCoercion(value,attributeName);}attributeValue=''+value;}if(propertyInfo.sanitizeURL){sanitizeURL(attributeValue.toString());}}if(attributeNamespace){node.setAttributeNS(attributeNamespace,attributeName,attributeValue);}else{node.setAttribute(attributeName,attributeValue);}}}// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE=Symbol.for('react.element');var REACT_PORTAL_TYPE=Symbol.for('react.portal');var REACT_FRAGMENT_TYPE=Symbol.for('react.fragment');var REACT_STRICT_MODE_TYPE=Symbol.for('react.strict_mode');var REACT_PROFILER_TYPE=Symbol.for('react.profiler');var REACT_PROVIDER_TYPE=Symbol.for('react.provider');var REACT_CONTEXT_TYPE=Symbol.for('react.context');var REACT_FORWARD_REF_TYPE=Symbol.for('react.forward_ref');var REACT_SUSPENSE_TYPE=Symbol.for('react.suspense');var REACT_SUSPENSE_LIST_TYPE=Symbol.for('react.suspense_list');var REACT_MEMO_TYPE=Symbol.for('react.memo');var REACT_LAZY_TYPE=Symbol.for('react.lazy');var REACT_SCOPE_TYPE=Symbol.for('react.scope');var REACT_DEBUG_TRACING_MODE_TYPE=Symbol.for('react.debug_trace_mode');var REACT_OFFSCREEN_TYPE=Symbol.for('react.offscreen');var REACT_LEGACY_HIDDEN_TYPE=Symbol.for('react.legacy_hidden');var REACT_CACHE_TYPE=Symbol.for('react.cache');var REACT_TRACING_MARKER_TYPE=Symbol.for('react.tracing_marker');var MAYBE_ITERATOR_SYMBOL=Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable!=='object'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var assign=Object.assign;// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth=0;var prevLog;var prevInfo;var prevWarn;var prevError;var prevGroup;var prevGroupCollapsed;var prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=true;function disableLogs(){{if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */prevLog=console.log;prevInfo=console.info;prevWarn=console.warn;prevError=console.error;prevGroup=console.group;prevGroupCollapsed=console.groupCollapsed;prevGroupEnd=console.groupEnd;// https://github.com/facebook/react/issues/19099\nvar props={configurable:true,enumerable:true,value:disabledLog,writable:true};// $FlowFixMe Flow thinks console is immutable.\nObject.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props});/* eslint-enable react-internal/no-production-logging */}disabledDepth++;}}function reenableLogs(){{disabledDepth--;if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */var props={configurable:true,enumerable:true,writable:true};// $FlowFixMe Flow thinks console is immutable.\nObject.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})});/* eslint-enable react-internal/no-production-logging */}if(disabledDepth<0){error('disabledDepth fell below zero. '+'This is a bug in React. Please file an issue.');}}}var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;var prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===undefined){// Extract the VM specific prefix used by each line.\ntry{throw Error();}catch(x){var match=x.stack.trim().match(/\\n( *(at )?)/);prefix=match&&match[1]||'';}}// We use the prefix to ensure our stacks line up with native stack frames.\nreturn'\\n'+prefix+name;}}var reentry=false;var componentFrameCache;{var PossiblyWeakMap=typeof WeakMap==='function'?WeakMap:Map;componentFrameCache=new PossiblyWeakMap();}function describeNativeComponentFrame(fn,construct){// If something asked for a stack inside a fake render, it should get ignored.\nif(!fn||reentry){return'';}{var frame=componentFrameCache.get(fn);if(frame!==undefined){return frame;}}var control;reentry=true;var previousPrepareStackTrace=Error.prepareStackTrace;// $FlowFixMe It does accept undefined.\nError.prepareStackTrace=undefined;var previousDispatcher;{previousDispatcher=ReactCurrentDispatcher.current;// Set the dispatcher in DEV because this might be call in the render function\n// for warnings.\nReactCurrentDispatcher.current=null;disableLogs();}try{// This should throw.\nif(construct){// Something should be setting the props in the constructor.\nvar Fake=function(){throw Error();};// $FlowFixMe\nObject.defineProperty(Fake.prototype,'props',{set:function(){// We use a throwing setter instead of frozen or non-writable props\n// because that won't throw in a non-strict mode function.\nthrow Error();}});if(typeof Reflect==='object'&&Reflect.construct){// We construct a different control for this case to include any extra\n// frames added by the construct call.\ntry{Reflect.construct(Fake,[]);}catch(x){control=x;}Reflect.construct(fn,[],Fake);}else{try{Fake.call();}catch(x){control=x;}fn.call(Fake.prototype);}}else{try{throw Error();}catch(x){control=x;}fn();}}catch(sample){// This is inlined manually because closure doesn't do it for us.\nif(sample&&control&&typeof sample.stack==='string'){// This extracts the first frame from the sample that isn't also in the control.\n// Skipping one frame that we assume is the frame that calls the two.\nvar sampleLines=sample.stack.split('\\n');var controlLines=control.stack.split('\\n');var s=sampleLines.length-1;var c=controlLines.length-1;while(s>=1&&c>=0&&sampleLines[s]!==controlLines[c]){// We expect at least one stack frame to be shared.\n// Typically this will be the root most one. However, stack frames may be\n// cut off due to maximum stack limits. In this case, one maybe cut off\n// earlier than the other. We assume that the sample is longer or the same\n// and there for cut off earlier. So we should find the root most frame in\n// the sample somewhere in the control.\nc--;}for(;s>=1&&c>=0;s--,c--){// Next we find the first one that isn't the same which should be the\n// frame that called our sample function and the control.\nif(sampleLines[s]!==controlLines[c]){// In V8, the first line is describing the message but other VMs don't.\n// If we're about to return the first line, and the control is also on the same\n// line, that's a pretty good indicator that our sample threw at same line as\n// the control. I.e. before we entered the sample frame. So we ignore this result.\n// This can happen if you passed a class to function component, or non-function.\nif(s!==1||c!==1){do{s--;c--;// We may still have similar intermediate frames from the construct call.\n// The next one that isn't the same should be our match though.\nif(c<0||sampleLines[s]!==controlLines[c]){// V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\nvar _frame='\\n'+sampleLines[s].replace(' at new ',' at ');// If our component frame is labeled \"<anonymous>\"\n// but we have a user-provided \"displayName\"\n// splice it in to make the stack more readable.\nif(fn.displayName&&_frame.includes('<anonymous>')){_frame=_frame.replace('<anonymous>',fn.displayName);}{if(typeof fn==='function'){componentFrameCache.set(fn,_frame);}}// Return the line we found.\nreturn _frame;}}while(s>=1&&c>=0);}break;}}}}finally{reentry=false;{ReactCurrentDispatcher.current=previousDispatcher;reenableLogs();}Error.prepareStackTrace=previousPrepareStackTrace;}// Fallback to just using the name if we couldn't make it throw.\nvar name=fn?fn.displayName||fn.name:'';var syntheticFrame=name?describeBuiltInComponentFrame(name):'';{if(typeof fn==='function'){componentFrameCache.set(fn,syntheticFrame);}}return syntheticFrame;}function describeClassComponentFrame(ctor,source,ownerFn){{return describeNativeComponentFrame(ctor,true);}}function describeFunctionComponentFrame(fn,source,ownerFn){{return describeNativeComponentFrame(fn,false);}}function shouldConstruct(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null){return'';}if(typeof type==='function'){{return describeNativeComponentFrame(type,shouldConstruct(type));}}if(typeof type==='string'){return describeBuiltInComponentFrame(type);}switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame('Suspense');case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame('SuspenseList');}if(typeof type==='object'){switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:// Memo may contain any component type so we recursively resolve it.\nreturn describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{// Lazy may contain any component type so we recursively resolve it.\nreturn describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn);}catch(x){}}}}return'';}function describeFiber(fiber){var owner=fiber._debugOwner?fiber._debugOwner.type:null;var source=fiber._debugSource;switch(fiber.tag){case HostComponent:return describeBuiltInComponentFrame(fiber.type);case LazyComponent:return describeBuiltInComponentFrame('Lazy');case SuspenseComponent:return describeBuiltInComponentFrame('Suspense');case SuspenseListComponent:return describeBuiltInComponentFrame('SuspenseList');case FunctionComponent:case IndeterminateComponent:case SimpleMemoComponent:return describeFunctionComponentFrame(fiber.type);case ForwardRef:return describeFunctionComponentFrame(fiber.type.render);case ClassComponent:return describeClassComponentFrame(fiber.type);default:return'';}}function getStackByFiberInDevAndProd(workInProgress){try{var info='';var node=workInProgress;do{info+=describeFiber(node);node=node.return;}while(node);return info;}catch(x){return'\\nError generating stack: '+x.message+'\\n'+x.stack;}}function getWrappedName(outerType,innerType,wrapperName){var displayName=outerType.displayName;if(displayName){return displayName;}var functionName=innerType.displayName||innerType.name||'';return functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName;}// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getContextName(type){return type.displayName||'Context';}// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\nfunction getComponentNameFromType(type){if(type==null){// Host root, text node or just invalid type.\nreturn null;}{if(typeof type.tag==='number'){error('Received an unexpected object in getComponentNameFromType(). '+'This is likely a bug in React. Please file an issue.');}}if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}switch(type){case REACT_FRAGMENT_TYPE:return'Fragment';case REACT_PORTAL_TYPE:return'Portal';case REACT_PROFILER_TYPE:return'Profiler';case REACT_STRICT_MODE_TYPE:return'StrictMode';case REACT_SUSPENSE_TYPE:return'Suspense';case REACT_SUSPENSE_LIST_TYPE:return'SuspenseList';}if(typeof type==='object'){switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context=type;return getContextName(context)+'.Consumer';case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+'.Provider';case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,'ForwardRef');case REACT_MEMO_TYPE:var outerName=type.displayName||null;if(outerName!==null){return outerName;}return getComponentNameFromType(type.type)||'Memo';case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{return getComponentNameFromType(init(payload));}catch(x){return null;}}// eslint-disable-next-line no-fallthrough\n}}return null;}function getWrappedName$1(outerType,innerType,wrapperName){var functionName=innerType.displayName||innerType.name||'';return outerType.displayName||(functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName);}// Keep in sync with shared/getComponentNameFromType\nfunction getContextName$1(type){return type.displayName||'Context';}function getComponentNameFromFiber(fiber){var tag=fiber.tag,type=fiber.type;switch(tag){case CacheComponent:return'Cache';case ContextConsumer:var context=type;return getContextName$1(context)+'.Consumer';case ContextProvider:var provider=type;return getContextName$1(provider._context)+'.Provider';case DehydratedFragment:return'DehydratedFragment';case ForwardRef:return getWrappedName$1(type,type.render,'ForwardRef');case Fragment:return'Fragment';case HostComponent:// Host component type is the display name (e.g. \"div\", \"View\")\nreturn type;case HostPortal:return'Portal';case HostRoot:return'Root';case HostText:return'Text';case LazyComponent:// Name comes from the type in this case; we don't have a tag.\nreturn getComponentNameFromType(type);case Mode:if(type===REACT_STRICT_MODE_TYPE){// Don't be less specific than shared/getComponentNameFromType\nreturn'StrictMode';}return'Mode';case OffscreenComponent:return'Offscreen';case Profiler:return'Profiler';case ScopeComponent:return'Scope';case SuspenseComponent:return'Suspense';case SuspenseListComponent:return'SuspenseList';case TracingMarkerComponent:return'TracingMarker';// The display name for this tags come from the user-provided type:\ncase ClassComponent:case FunctionComponent:case IncompleteClassComponent:case IndeterminateComponent:case MemoComponent:case SimpleMemoComponent:if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}break;}return null;}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var current=null;var isRendering=false;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null){return null;}var owner=current._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentNameFromFiber(owner);}}return null;}function getCurrentFiberStackInDev(){{if(current===null){return'';}// Safe because if current fiber exists, we are reconciling,\n// and it is guaranteed to be the work-in-progress version.\nreturn getStackByFiberInDevAndProd(current);}}function resetCurrentFiber(){{ReactDebugCurrentFrame.getCurrentStack=null;current=null;isRendering=false;}}function setCurrentFiber(fiber){{ReactDebugCurrentFrame.getCurrentStack=fiber===null?null:getCurrentFiberStackInDev;current=fiber;isRendering=false;}}function getCurrentFiber(){{return current;}}function setIsRendering(rendering){{isRendering=rendering;}}// Flow does not allow string concatenation of most non-string types. To work\n// around this limitation, we use an opaque type that can only be obtained by\n// passing the value through getToStringValue first.\nfunction toString(value){// The coercion safety check is performed in getToStringValue().\n// eslint-disable-next-line react-internal/safe-string-coercion\nreturn''+value;}function getToStringValue(value){switch(typeof value){case'boolean':case'number':case'string':case'undefined':return value;case'object':{checkFormFieldValueStringCoercion(value);}return value;default:// function, symbol are assigned as empty strings\nreturn'';}}var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};function checkControlledValueProps(tagName,props){{if(!(hasReadOnlyValue[props.type]||props.onChange||props.onInput||props.readOnly||props.disabled||props.value==null)){error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');}if(!(props.onChange||props.readOnly||props.disabled||props.checked==null)){error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}}}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);{checkFormFieldValueStringCoercion(node[valueField]);}var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail\n// and don't track value will cause over reporting of changes,\n// but it's better then a hard failure\n// (needed for certain tests that spyOn input values and Safari)\nif(node.hasOwnProperty(valueField)||typeof descriptor==='undefined'||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}var get=descriptor.get,set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function(){return get.call(this);},set:function(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;set.call(this,value);}});// We could've passed this the first time\n// but it triggers a bug in IE11 and Edge 14/15.\n// Calling defineProperty() again should be equivalent.\n// https://github.com/facebook/react/issues/11768\nObject.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function(){return currentValue;},setValue:function(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;},stopTracking:function(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState\nnode._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely\n// that trying again will succeed\nif(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}function getActiveElement(doc){doc=doc||(typeof document!=='undefined'?document:undefined);if(typeof doc==='undefined'){return null;}try{return doc.activeElement||doc.body;}catch(e){return doc.body;}}var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */function getHostProps(element,props){var node=element;var checked=props.checked;var hostProps=assign({},props,{defaultChecked:undefined,defaultValue:undefined,value:undefined,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{checkControlledValueProps('input',props);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){error('%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){error('%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnValueDefaultValue=true;}}var node=element;var defaultValue=props.defaultValue==null?'':props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getToStringValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked,false);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){error('A component is changing an uncontrolled input to be controlled. '+'This is likely caused by the value changing from undefined to '+'a defined value, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){error('A component is changing a controlled input to be uncontrolled. '+'This is likely caused by the value changing from a defined to '+'undefined, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=getToStringValue(props.value);var type=props.type;if(value!=null){if(type==='number'){if(value===0&&node.value===''||// We explicitly want to coerce to number here if possible.\n// eslint-disable-next-line\nnode.value!=value){node.value=toString(value);}}else if(node.value!==toString(value)){node.value=toString(value);}}else if(type==='submit'||type==='reset'){// Submit/reset inputs need the attribute removed completely to avoid\n// blank-text buttons.\nnode.removeAttribute('value');return;}{// When syncing the value attribute, the value comes from a cascade of\n// properties:\n//  1. The value React property\n//  2. The defaultValue React property\n//  3. Otherwise there should be no change\nif(props.hasOwnProperty('value')){setDefaultValue(node,props.type,value);}else if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}{// When syncing the checked attribute, it only changes when it needs\n// to be removed, such as transitioning from a checkbox into a text input\nif(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props,isHydrating){var node=element;// Do not assign value if it is already set. This prevents user text input\n// from being lost during SSR hydration.\nif(props.hasOwnProperty('value')||props.hasOwnProperty('defaultValue')){var type=props.type;var isButton=type==='submit'||type==='reset';// Avoid setting value attribute on submit/reset inputs as it overrides the\n// default value provided by the browser. See: #12872\nif(isButton&&(props.value===undefined||props.value===null)){return;}var initialValue=toString(node._wrapperState.initialValue);// Do not assign value if it is already set. This prevents user text input\n// from being lost during SSR hydration.\nif(!isHydrating){{// When syncing the value attribute, the value property should use\n// the wrapperState._initialValue property. This uses:\n//\n//   1. The value React property when present\n//   2. The defaultValue React property when present\n//   3. An empty string\nif(initialValue!==node.value){node.value=initialValue;}}}{// Otherwise, the value attribute is synchronized to the property,\n// so we assign defaultValue to the same thing as the value property\n// assignment step above.\nnode.defaultValue=initialValue;}}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n// this is needed to work around a chrome bug where setting defaultChecked\n// will sometimes influence the value of checked (even after detachment).\n// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n// We need to temporarily unset name to avoid disrupting radio button groups.\nvar name=node.name;if(name!==''){node.name='';}{// When syncing the checked attribute, both the checked property and\n// attribute are assigned at the same time using defaultChecked. This uses:\n//\n//   1. The checked React property when present\n//   2. The defaultChecked React property when present\n//   3. Otherwise, false\nnode.defaultChecked=!node.defaultChecked;node.defaultChecked=!!node._wrapperState.initialChecked;}if(name!==''){node.name=name;}}function restoreControlledState(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,\n// but that sometimes behaves strangely in IE8. We could also try using\n// `form.getElementsByName`, but that will only return direct children\n// and won't include inputs that use the HTML5 `form=` attribute. Since\n// the input might not even be in a form. It might not even be in the\n// document. Let's just use the local `querySelectorAll` to ensure we don't\n// miss anything.\n{checkAttributeStringCoercion(name,'name');}var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type=\"radio\"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React\n// and the same name are rendered into the same form (same as #1939).\n// That's probably okay; we don't support it just as we don't support\n// mixing React radio buttons with non-React ones.\nvar otherProps=getFiberCurrentPropsFromNode(otherNode);if(!otherProps){throw new Error('ReactDOMInput: Mixing React and non-React radio inputs with the '+'same `name` is not supported.');}// We need update the tracked value on the named cousin since the value\n// was changed but the input saw no event or value set\nupdateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that\n// was previously checked to update will cause it to be come re-checked\n// as appropriate.\nupdateWrapper(otherNode,otherProps);}}}// In Chrome, assigning defaultValue to certain input types triggers input validation.\n// For number inputs, the display value loses trailing decimal points. For email inputs,\n// Chrome raises \"The specified value <x> is not a valid email address\".\n//\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\n// when the user is inputting text\n//\n// https://github.com/facebook/react/issues/7253\nfunction setDefaultValue(node,type,value){if(// Focused number inputs synchronize on blur. See ChangeEventPlugin.js\ntype!=='number'||getActiveElement(node.ownerDocument)!==node){if(value==null){node.defaultValue=toString(node._wrapperState.initialValue);}else if(node.defaultValue!==toString(value)){node.defaultValue=toString(value);}}}var didWarnSelectedSetOnOption=false;var didWarnInvalidChild=false;var didWarnInvalidInnerHTML=false;/**\n * Implements an <option> host component that warns when `selected` is set.\n */function validateProps(element,props){{// If a value is not provided, then the children must be simple.\nif(props.value==null){if(typeof props.children==='object'&&props.children!==null){React.Children.forEach(props.children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){return;}if(!didWarnInvalidChild){didWarnInvalidChild=true;error('Cannot infer the option value of complex children. '+'Pass a `value` prop or use a plain string as children to <option>.');}});}else if(props.dangerouslySetInnerHTML!=null){if(!didWarnInvalidInnerHTML){didWarnInvalidInnerHTML=true;error('Pass a `value` prop if you set dangerouslyInnerHTML so React knows '+'which value should be selected.');}}}// TODO: Remove support for `selected` in <option>.\nif(props.selected!=null&&!didWarnSelectedSetOnOption){error('Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');didWarnSelectedSetOnOption=true;}}}function postMountWrapper$1(element,props){// value=\"\" should make a value attribute (#6219)\nif(props.value!=null){element.setAttribute('value',toString(getToStringValue(props.value)));}}var isArrayImpl=Array.isArray;// eslint-disable-next-line no-redeclare\nfunction isArray(a){return isArrayImpl(a);}var didWarnValueDefaultValue$1;{didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){return'\\n\\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**\n * Validation function for `value` and `defaultValue`.\n */function checkSelectPropTypes(props){{checkControlledValueProps('select',props);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var propNameIsArray=isArray(props[propName]);if(props.multiple&&!propNameIsArray){error('The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&propNameIsArray){error('The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.\nselectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all\n// browsers for all cases.\nvar _selectedValue=toString(getToStringValue(propValue));var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */function getHostProps$1(element,props){return assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}node._wrapperState={wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){error('Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.\nif(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.\nupdateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$1(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}var didWarnValDefaultVal=false;/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */function getHostProps$2(element,props){var node=element;if(props.dangerouslySetInnerHTML!=null){throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.');}// Always set children to the same thing. In IE9, the selection range will\n// get reset if `textContent` is mutated.  We could add a check in setTextContent\n// to only set the value if/when the value differs from the node value (which would\n// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n// solution. The value can be a boolean or object so that's why it's forced\n// to be a string.\nvar hostProps=assign({},props,{value:undefined,defaultValue:undefined,children:toString(node._wrapperState.initialValue)});return hostProps;}function initWrapperState$2(element,props){var node=element;{checkControlledValueProps('textarea',props);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){error('%s contains a textarea with both value and defaultValue props. '+'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it\nif(initialValue==null){var children=props.children,defaultValue=props.defaultValue;if(children!=null){{error('Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}{if(defaultValue!=null){throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.');}if(isArray(children)){if(children.length>1){throw new Error('<textarea> can only have at most one child.');}children=children[0];}defaultValue=children;}}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:getToStringValue(initialValue)};}function updateWrapper$1(element,props){var node=element;var value=getToStringValue(props.value);var defaultValue=getToStringValue(props.defaultValue);if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While\n// browsers typically do this as necessary, jsdom doesn't.\nvar newValue=toString(value);// To avoid side effects (such as losing text selection), only set value if changed\nif(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null&&node.defaultValue!==newValue){node.defaultValue=newValue;}}if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not\n// available until after the component has mounted.\nvar textContent=node.textContent;// Only set node.value if textContent is equal to the expected\n// initial value. In IE10/IE11 there is a bug where the placeholder attribute\n// will populate textContent as well.\n// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\nif(textContent===node._wrapperState.initialValue){if(textContent!==''&&textContent!==null){node.value=textContent;}}}function restoreControlledState$2(element,props){// DOM component is still mounted; update\nupdateWrapper$1(element,props);}var HTML_NAMESPACE='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE){// No (or default) parent namespace: potential entry point.\nreturn getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.\nreturn HTML_NAMESPACE;}// By default, pass namespace below.\nreturn parentNamespace;}/* globals MSApp *//**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */var createMicrosoftUnsafeLocalFunction=function(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};var reusableSVGContainer;/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){if(node.namespaceURI===SVG_NAMESPACE){if(!('innerHTML'in node)){// IE does not have innerHTML for SVG nodes, so instead we inject the\n// new markup in a temp node and then move the child nodes across into\n// the target node\nreusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html.valueOf().toString()+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}return;}}node.innerHTML=html;});/**\n * HTML nodeType values that represent the type of the node\n */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**\n * Set the textContent property of a node. For text updates, it's faster\n * to set the `nodeValue` of the Text node directly instead of using\n * `.textContent` which will remove the existing node and create a new one.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */var setTextContent=function(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};// List derived from Gecko source code:\n// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js\nvar shorthandToLonghand={animation:['animationDelay','animationDirection','animationDuration','animationFillMode','animationIterationCount','animationName','animationPlayState','animationTimingFunction'],background:['backgroundAttachment','backgroundClip','backgroundColor','backgroundImage','backgroundOrigin','backgroundPositionX','backgroundPositionY','backgroundRepeat','backgroundSize'],backgroundPosition:['backgroundPositionX','backgroundPositionY'],border:['borderBottomColor','borderBottomStyle','borderBottomWidth','borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth','borderLeftColor','borderLeftStyle','borderLeftWidth','borderRightColor','borderRightStyle','borderRightWidth','borderTopColor','borderTopStyle','borderTopWidth'],borderBlockEnd:['borderBlockEndColor','borderBlockEndStyle','borderBlockEndWidth'],borderBlockStart:['borderBlockStartColor','borderBlockStartStyle','borderBlockStartWidth'],borderBottom:['borderBottomColor','borderBottomStyle','borderBottomWidth'],borderColor:['borderBottomColor','borderLeftColor','borderRightColor','borderTopColor'],borderImage:['borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth'],borderInlineEnd:['borderInlineEndColor','borderInlineEndStyle','borderInlineEndWidth'],borderInlineStart:['borderInlineStartColor','borderInlineStartStyle','borderInlineStartWidth'],borderLeft:['borderLeftColor','borderLeftStyle','borderLeftWidth'],borderRadius:['borderBottomLeftRadius','borderBottomRightRadius','borderTopLeftRadius','borderTopRightRadius'],borderRight:['borderRightColor','borderRightStyle','borderRightWidth'],borderStyle:['borderBottomStyle','borderLeftStyle','borderRightStyle','borderTopStyle'],borderTop:['borderTopColor','borderTopStyle','borderTopWidth'],borderWidth:['borderBottomWidth','borderLeftWidth','borderRightWidth','borderTopWidth'],columnRule:['columnRuleColor','columnRuleStyle','columnRuleWidth'],columns:['columnCount','columnWidth'],flex:['flexBasis','flexGrow','flexShrink'],flexFlow:['flexDirection','flexWrap'],font:['fontFamily','fontFeatureSettings','fontKerning','fontLanguageOverride','fontSize','fontSizeAdjust','fontStretch','fontStyle','fontVariant','fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition','fontWeight','lineHeight'],fontVariant:['fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition'],gap:['columnGap','rowGap'],grid:['gridAutoColumns','gridAutoFlow','gridAutoRows','gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],gridArea:['gridColumnEnd','gridColumnStart','gridRowEnd','gridRowStart'],gridColumn:['gridColumnEnd','gridColumnStart'],gridColumnGap:['columnGap'],gridGap:['columnGap','rowGap'],gridRow:['gridRowEnd','gridRowStart'],gridRowGap:['rowGap'],gridTemplate:['gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],listStyle:['listStyleImage','listStylePosition','listStyleType'],margin:['marginBottom','marginLeft','marginRight','marginTop'],marker:['markerEnd','markerMid','markerStart'],mask:['maskClip','maskComposite','maskImage','maskMode','maskOrigin','maskPositionX','maskPositionY','maskRepeat','maskSize'],maskPosition:['maskPositionX','maskPositionY'],outline:['outlineColor','outlineStyle','outlineWidth'],overflow:['overflowX','overflowY'],padding:['paddingBottom','paddingLeft','paddingRight','paddingTop'],placeContent:['alignContent','justifyContent'],placeItems:['alignItems','justifyItems'],placeSelf:['alignSelf','justifySelf'],textDecoration:['textDecorationColor','textDecorationLine','textDecorationStyle'],textEmphasis:['textEmphasisColor','textEmphasisStyle'],transition:['transitionDelay','transitionDuration','transitionProperty','transitionTimingFunction'],wordWrap:['overflowWrap']};/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */var isUnitlessNumber={animationIterationCount:true,aspectRatio:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties\nfillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the\n// whole string will be escaped when the attribute is injected into\n// the markup. If you provide unsafe user data here they can inject\n// arbitrary CSS which may be problematic (I couldn't repro this):\n// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n// This is not an XSS hole but instead a potential CSS injection issue\n// which has lead to a greater discussion about how we're going to\n// trust URLs moving forward. See #2115901\nvar isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers\n}{checkCSSPropertyStringCoercion(value,name);}return(''+value).trim();}var uppercasePattern=/([A-Z])/g;var msPattern=/^ms-/;/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */function hyphenateStyleName(name){return name.replace(uppercasePattern,'-$1').toLowerCase().replace(msPattern,'-ms-');}var warnValidStyle=function(){};{// 'msTransform' is correct, but the other prefixes should be capitalized\nvar badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;var msPattern$1=/^-ms-/;var hyphenPattern=/-(.)/g;// style values shouldn't contain a semicolon\nvar badStyleValueWithSemicolonPattern=/;\\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var camelize=function(string){return string.replace(hyphenPattern,function(_,character){return character.toUpperCase();});};var warnHyphenatedStyleName=function(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported style property %s. Did you mean %s?',name,// As Andi Smith suggests\n// (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n// is converted to lowercase `ms`.\ncamelize(name.replace(msPattern$1,'ms-')));};var warnBadVendoredStyleName=function(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported vendor-prefixed style property %s. Did you mean %s?',name,name.charAt(0).toUpperCase()+name.slice(1));};var warnStyleValueWithSemicolon=function(name,value){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;error(\"Style property values shouldn't contain a semicolon. \"+'Try \"%s: %s\" instead.',name,value.replace(badStyleValueWithSemicolonPattern,''));};var warnStyleValueIsNaN=function(name,value){if(warnedForNaNValue){return;}warnedForNaNValue=true;error('`NaN` is an invalid value for the `%s` css style property.',name);};var warnStyleValueIsInfinity=function(name,value){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;error('`Infinity` is an invalid value for the `%s` css style property.',name);};warnValidStyle=function(name,value){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value);}}};}var warnValidStyle$1=warnValidStyle;/**\n * Operations for dealing with CSS properties.\n *//**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+(isCustomProperty?styleName:hyphenateStyleName(styleName))+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */function setValueForStyles(node,styles){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName]);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}function isValueEmpty(value){return value==null||typeof value==='boolean'||value==='';}/**\n * Given {color: 'red', overflow: 'hidden'} returns {\n *   color: 'color',\n *   overflowX: 'overflow',\n *   overflowY: 'overflow',\n * }. This can be read as \"the overflowY property was set by the overflow\n * shorthand\". That is, the values are the property that each was derived from.\n */function expandShorthandMap(styles){var expanded={};for(var key in styles){var longhands=shorthandToLonghand[key]||[key];for(var i=0;i<longhands.length;i++){expanded[longhands[i]]=key;}}return expanded;}/**\n * When mixing shorthand and longhand property names, we warn during updates if\n * we expect an incorrect result to occur. In particular, we warn for:\n *\n * Updating a shorthand property (longhand gets overwritten):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}\n *   becomes .style.font = 'baz'\n * Removing a shorthand property (longhand gets lost too):\n *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}\n *   becomes .style.font = ''\n * Removing a longhand property (should revert to shorthand; doesn't):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}\n *   becomes .style.fontVariant = ''\n */function validateShorthandPropertyCollisionInDev(styleUpdates,nextStyles){{if(!nextStyles){return;}var expandedUpdates=expandShorthandMap(styleUpdates);var expandedStyles=expandShorthandMap(nextStyles);var warnedAbout={};for(var key in expandedUpdates){var originalKey=expandedUpdates[key];var correctOriginalKey=expandedStyles[key];if(correctOriginalKey&&originalKey!==correctOriginalKey){var warningKey=originalKey+','+correctOriginalKey;if(warnedAbout[warningKey]){continue;}warnedAbout[warningKey]=true;error('%s a style property during rerender (%s) when a '+'conflicting property is set (%s) can lead to styling bugs. To '+\"avoid this, don't mix shorthand and non-shorthand properties \"+'for the same value; instead, replace the shorthand with '+'separate values.',isValueEmpty(styleUpdates[originalKey])?'Removing':'Updating',originalKey,correctOriginalKey);}}}}// For HTML, certain tags should omit their close tag. We keep a list for\n// those special-case tags.\nvar omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true// NOTE: menuitem's close tag should be omitted, but that causes problems.\n};// `omittedCloseTags` except that `menuitem` should still have its closing tag.\nvar voidElementTags=assign({menuitem:true},omittedCloseTags);var HTML='__html';function assertValidProps(tag,props){if(!props){return;}// Note the use of `==` which checks for null or undefined.\nif(voidElementTags[tag]){if(props.children!=null||props.dangerouslySetInnerHTML!=null){throw new Error(tag+\" is a void element tag and must neither have `children` nor \"+'use `dangerouslySetInnerHTML`.');}}if(props.dangerouslySetInnerHTML!=null){if(props.children!=null){throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');}if(typeof props.dangerouslySetInnerHTML!=='object'||!(HTML in props.dangerouslySetInnerHTML)){throw new Error('`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. '+'Please visit https://reactjs.org/link/dangerously-set-inner-html '+'for more information.');}}{if(!props.suppressContentEditableWarning&&props.contentEditable&&props.children!=null){error('A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.');}}if(props.style!=null&&typeof props.style!=='object'){throw new Error('The `style` prop expects a mapping from style properties to values, '+\"not a string. For example, style={{marginRight: spacing + 'em'}} when \"+'using JSX.');}}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.\n// We don't mind this list too much because we expect it to never grow.\n// The alternative is to track the namespace in a few places which is convoluted.\n// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\ncase'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}// When adding attributes to the HTML or SVG allowed attribute list, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames={// HTML\naccept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite',class:'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime',default:'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',disablepictureinpicture:'disablePictureInPicture',disableremoteplayback:'disableRemotePlayback',download:'download',draggable:'draggable',enctype:'encType',enterkeyhint:'enterKeyHint',for:'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',imagesizes:'imageSizes',imagesrcset:'imageSrcSet',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nomodule:'noModule',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG\nabout:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2',in:'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform',typeof:'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};var ariaProperties={'aria-current':0,// state\n'aria-description':0,'aria-details':0,'aria-disabled':0,// state\n'aria-hidden':0,// state\n'aria-invalid':0,// state\n'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes\n'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes\n'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes\n'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes\n'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');function validateProperty(tagName,name){{if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(correctName==null){error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',name);warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==correctName){error('Invalid ARIA attribute `%s`. Did you mean `%s`?',name,correctName);warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==standardName){error('Unknown ARIA attribute `%s`. Did you mean `%s`?',name,standardName);warnedProperties[name]=true;return true;}}}return true;}function warnInvalidARIAProps(type,props){{var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){error('Invalid aria prop %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}else if(invalidProps.length>1){error('Invalid aria props %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function validateProperties$1(type,props){{if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){error('`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.',type);}else{error('`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.',type);}}}}var validateProperty$1=function(){};{var warnedProperties$1={};var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');validateProperty$1=function(tagName,name,value,eventRegistry){if(hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.\nif(eventRegistry!=null){var registrationNameDependencies=eventRegistry.registrationNameDependencies,possibleRegistrationNames=eventRegistry.possibleRegistrationNames;if(registrationNameDependencies.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){error('Invalid event handler property `%s`. Did you mean `%s`?',name,registrationName);warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){error('Unknown event handler property `%s`. It will be ignored.',name);warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.\n// So we can't tell if the event name is correct for sure, but we can filter\n// out known bad ones like `onclick`. We can't suggest a specific replacement though.\nif(INVALID_EVENT_NAME_REGEX.test(name)){error('Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.',name);}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes\nif(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){error('Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){error('The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){error('Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.',typeof value);warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){error('Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.',name);warnedProperties$1[name]=true;return true;}var propertyInfo=getPropertyInfo(name);var isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;// Known attributes should match the casing specified in the property config.\nif(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){error('Invalid DOM property `%s`. Did you mean `%s`?',name,standardName);warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they\n// will be cased anyway with server rendering.\nerror('React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.',name,lowerCasedName);warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){if(value){error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.',value,name,name,value,name);}else{error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',value,name,name,value,name,name,name);}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate\n// data types for reserved props\nif(isReserved){return true;}// Warn when a known attribute is a bad type\nif(shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){warnedProperties$1[name]=true;return false;}// Warn when passing the strings 'false' or 'true' into a boolean prop\nif((value==='false'||value==='true')&&propertyInfo!==null&&propertyInfo.type===BOOLEAN){error('Received the string `%s` for the boolean attribute `%s`. '+'%s '+'Did you mean %s={%s}?',value,name,value==='false'?'The browser will interpret it as a truthy value.':'Although this works, it will not work as expected if you pass the string \"false\".',name,value);warnedProperties$1[name]=true;return true;}return true;};}var warnUnknownProperties=function(type,props,eventRegistry){{var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],eventRegistry);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){error('Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}else if(unknownProps.length>1){error('Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}}};function validateProperties$2(type,props,eventRegistry){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,eventRegistry);}var IS_EVENT_HANDLE_NON_MANAGED_NODE=1;var IS_NON_DELEGATED=1<<1;var IS_CAPTURE_PHASE=1<<2;// set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when\n// we call willDeferLaterForLegacyFBSupport, thus not bailing out\n// will result in endless cycles like an infinite loop.\n// We also don't want to defer during event replaying.\nvar SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS=IS_EVENT_HANDLE_NON_MANAGED_NODE|IS_NON_DELEGATED|IS_CAPTURE_PHASE;// This exists to avoid circular dependency between ReactDOMEventReplaying\n// and DOMPluginEventSystem.\nvar currentReplayingEvent=null;function setReplayingEvent(event){{if(currentReplayingEvent!==null){error('Expected currently replaying event to be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=event;}function resetReplayingEvent(){{if(currentReplayingEvent===null){error('Expected currently replaying event to not be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=null;}function isReplayingEvent(event){return event===currentReplayingEvent;}/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */function getEventTarget(nativeEvent){// Fallback to nativeEvent.srcElement for IE9\n// https://github.com/facebook/react/issues/12506\nvar target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963\nif(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n// @see http://www.quirksmode.org/js/events_properties.html\nreturn target.nodeType===TEXT_NODE?target.parentNode:target;}var restoreImpl=null;var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we\n// always receive the correct fiber here\nvar internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted\nreturn;}if(typeof restoreImpl!=='function'){throw new Error('setRestoreImplementation() needs to be called to handle a target for controlled '+'events. This error is likely caused by a bug in React. Please file an issue.');}var stateNode=internalInstance.stateNode;// Guard against Fiber being unmounted.\nif(stateNode){var _props=getFiberCurrentPropsFromNode(stateNode);restoreImpl(internalInstance.stateNode,internalInstance.type,_props);}}function setRestoreImplementation(impl){restoreImpl=impl;}function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null;}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n// Defaults\nvar batchedUpdatesImpl=function(fn,bookkeeping){return fn(bookkeeping);};var flushSyncImpl=function(){};var isInsideEventHandler=false;function finishEventHandler(){// Here we wait until all updates have propagated, which is important\n// when using controlled components within layers:\n// https://github.com/facebook/react/issues/1698\n// Then we restore state of any controlled component.\nvar controlledComponentsHavePendingUpdates=needsStateRestore();if(controlledComponentsHavePendingUpdates){// If a controlled event was fired, we may need to restore the state of\n// the DOM node back to the controlled value. This is necessary when React\n// bails out of the update without touching the DOM.\n// TODO: Restore state in the microtask, after the discrete updates flush,\n// instead of early flushing them here.\nflushSyncImpl();restoreStateIfNeeded();}}function batchedUpdates(fn,a,b){if(isInsideEventHandler){// If we are currently inside another batch, we need to wait until it\n// fully completes before restoring state.\nreturn fn(a,b);}isInsideEventHandler=true;try{return batchedUpdatesImpl(fn,a,b);}finally{isInsideEventHandler=false;finishEventHandler();}}// TODO: Replace with flushSync\nfunction setBatchingImplementation(_batchedUpdatesImpl,_discreteUpdatesImpl,_flushSyncImpl){batchedUpdatesImpl=_batchedUpdatesImpl;flushSyncImpl=_flushSyncImpl;}function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':case'onMouseEnter':return!!(props.disabled&&isInteractive(type));default:return false;}}/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */function getListener(inst,registrationName){var stateNode=inst.stateNode;if(stateNode===null){// Work in progress (ex: onload events in incremental mode).\nreturn null;}var props=getFiberCurrentPropsFromNode(stateNode);if(props===null){// Work in progress.\nreturn null;}var listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}if(listener&&typeof listener!=='function'){throw new Error(\"Expected `\"+registrationName+\"` listener to be a function, instead got a value of `\"+typeof listener+\"` type.\");}return listener;}var passiveBrowserEventsSupported=false;// Check if browser support events with passive listeners\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\nif(canUseDOM){try{var options={};// $FlowFixMe: Ignore Flow complaining about needing a value\nObject.defineProperty(options,'passive',{get:function(){passiveBrowserEventsSupported=true;}});window.addEventListener('test',options,options);window.removeEventListener('test',options,options);}catch(e){passiveBrowserEventsSupported=false;}}function invokeGuardedCallbackProd(name,func,context,a,b,c,d,e,f){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){this.onError(error);}}var invokeGuardedCallbackImpl=invokeGuardedCallbackProd;{// In DEV mode, we swap out invokeGuardedCallback for a special version\n// that plays more nicely with the browser's DevTools. The idea is to preserve\n// \"Pause on exceptions\" behavior. Because React wraps all user-provided\n// functions in invokeGuardedCallback, and the production version of\n// invokeGuardedCallback uses a try-catch, all user exceptions are treated\n// like caught exceptions, and the DevTools won't pause unless the developer\n// takes the extra step of enabling pause on caught exceptions. This is\n// unintuitive, though, because even though React has caught the error, from\n// the developer's perspective, the error is uncaught.\n//\n// To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n// DOM node, and call the user-provided callback from inside an event handler\n// for that fake event. If the callback throws, the error is \"captured\" using\n// a global event handler. But because the error happens in a different\n// event loop context, it does not interrupt the normal program flow.\n// Effectively, this gives us try-catch behavior without actually using\n// try-catch. Neat!\n// Check that the browser supports the APIs we need to implement our special\n// DEV version of invokeGuardedCallback\nif(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');invokeGuardedCallbackImpl=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// If document doesn't exist we know for sure we will crash in this method\n// when we call document.createEvent(). However this can cause confusing\n// errors: https://github.com/facebook/create-react-app/issues/3482\n// So we preemptively throw with a better message instead.\nif(typeof document==='undefined'||document===null){throw new Error('The `document` global was defined when React was initialized, but is not '+'defined anymore. This can happen in a test environment if a component '+'schedules an update from an asynchronous callback, but the test has already '+'finished running. To solve this, you can either unmount the component at '+'the end of your test (and ensure that any asynchronous operations get '+'canceled in `componentWillUnmount`), or you can change the test itself '+'to be asynchronous.');}var evt=document.createEvent('Event');var didCall=false;// Keeps track of whether the user-provided callback threw an error. We\n// set this to true at the beginning, then set it to false right after\n// calling the function. If the function errors, `didError` will never be\n// set to false. This strategy works even if the browser is flaky and\n// fails to call our global error handler, because it doesn't rely on\n// the error event at all.\nvar didError=true;// Keeps track of the value of window.event so that we can reset it\n// during the callback to let user code access window.event in the\n// browsers that support it.\nvar windowEvent=window.event;// Keeps track of the descriptor of window.event to restore it after event\n// dispatching: https://github.com/facebook/react/issues/13688\nvar windowEventDescriptor=Object.getOwnPropertyDescriptor(window,'event');function restoreAfterDispatch(){// We immediately remove the callback from event listeners so that\n// nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n// nested call would trigger the fake event handlers of any call higher\n// in the stack.\nfakeNode.removeEventListener(evtType,callCallback,false);// We check for window.hasOwnProperty('event') to prevent the\n// window.event assignment in both IE <= 10 as they throw an error\n// \"Member not found\" in strict mode, and in Firefox which does not\n// support window.event.\nif(typeof window.event!=='undefined'&&window.hasOwnProperty('event')){window.event=windowEvent;}}// Create an event handler for our fake event. We will synchronously\n// dispatch our fake event using `dispatchEvent`. Inside the handler, we\n// call the user-provided callback.\nvar funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){didCall=true;restoreAfterDispatch();func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value\n// that was thrown. It's possible that this error handler will fire more\n// than once; for example, if non-React code also calls `dispatchEvent`\n// and a handler for that event throws. We should be resilient to most of\n// those cases. Even if our error event handler fires more than once, the\n// last error event is always used. If the callback actually does error,\n// we know that the last error event is the correct one, because it's not\n// possible for anything else to have happened in between our callback\n// erroring and the code that follows the `dispatchEvent` call below. If\n// the callback doesn't error, but the error event was fired, we know to\n// ignore it because `didError` will be false, as described above.\nvar error;// Use this to track whether the error event is ever called.\nvar didSetError=false;var isCrossOriginError=false;function handleWindowError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}if(event.defaultPrevented){// Some other error handler has prevented default.\n// Browsers silence the error report if this happens.\n// We'll remember this to later decide whether to log it or not.\nif(error!=null&&typeof error==='object'){try{error._suppressLogging=true;}catch(inner){// Ignore.\n}}}}// Create a fake event type.\nvar evtType=\"react-\"+(name?name:'invokeguardedcallback');// Attach our event handlers\nwindow.addEventListener('error',handleWindowError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function\n// errors, it will trigger our global error handler.\nevt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(windowEventDescriptor){Object.defineProperty(window,'event',windowEventDescriptor);}if(didCall&&didError){if(!didSetError){// The callback errored, but the error event never fired.\n// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error('An error was thrown inside one of your components, but React '+\"doesn't know what it was. This is likely due to browser \"+'flakiness. React does its best to preserve the \"Pause on '+'exceptions\" behavior of the DevTools, which requires some '+\"DEV-mode only tricks. It's possible that these don't work in \"+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error(\"A cross-origin error was thrown. React doesn't have access to \"+'the actual error object in development. '+'See https://reactjs.org/link/crossorigin-error for more information.');}this.onError(error);}// Remove our event listeners\nwindow.removeEventListener('error',handleWindowError);if(!didCall){// Something went really wrong, and our event was not dispatched.\n// https://github.com/facebook/react/issues/16734\n// https://github.com/facebook/react/issues/16585\n// Fall back to the production implementation.\nrestoreAfterDispatch();return invokeGuardedCallbackProd.apply(this,arguments);}};}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl;var hasError=false;var caughtError=null;// Used by event system to capture/rethrow the first error.\nvar hasRethrowError=false;var rethrowError=null;var reporter={onError:function(error){hasError=true;caughtError=error;}};/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){hasError=false;caughtError=null;invokeGuardedCallbackImpl$1.apply(reporter,arguments);}/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){invokeGuardedCallback.apply(this,arguments);if(hasError){var error=clearCaughtError();if(!hasRethrowError){hasRethrowError=true;rethrowError=error;}}}/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */function rethrowCaughtError(){if(hasRethrowError){var error=rethrowError;hasRethrowError=false;rethrowError=null;throw error;}}function hasCaughtError(){return hasError;}function clearCaughtError(){if(hasError){var error=caughtError;hasError=false;caughtError=null;return error;}else{throw new Error('clearCaughtError was called but no error was captured. This error '+'is likely caused by a bug in React. Please file an issue.');}}/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */function get(key){return key._reactInternals;}function has(key){return key._reactInternals!==undefined;}function set(key,value){key._reactInternals=value;}// Don't change these two values. They're used by React Dev Tools.\nvar NoFlags=/*                      */0;var PerformedWork=/*                */1;// You can change the rest (and add more).\nvar Placement=/*                    */2;var Update=/*                       */4;var ChildDeletion=/*                */16;var ContentReset=/*                 */32;var Callback=/*                     */64;var DidCapture=/*                   */128;var ForceClientRender=/*            */256;var Ref=/*                          */512;var Snapshot=/*                     */1024;var Passive=/*                      */2048;var Hydrating=/*                    */4096;var Visibility=/*                   */8192;var StoreConsistency=/*             */16384;var LifecycleEffectMask=Passive|Update|Callback|Ref|Snapshot|StoreConsistency;// Union of all commit flags (flags with the lifetime of a particular commit)\nvar HostEffectMask=/*               */32767;// These are not really side effects, but we still reuse this field.\nvar Incomplete=/*                   */32768;var ShouldCapture=/*                */65536;var ForceUpdateForLegacySuspense=/* */131072;var Forked=/*                       */1048576;// Static tags describe aspects of a fiber that are not specific to a render,\n// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n// This enables us to defer more work in the unmount case,\n// since we can defer traversing the tree during layout to look for Passive effects,\n// and instead rely on the static flag as a signal that there may be cleanup work.\nvar RefStatic=/*                    */2097152;var LayoutStatic=/*                 */4194304;var PassiveStatic=/*                */8388608;// These flags allow us to traverse to fibers that have effects on mount\n// without traversing the entire tree after every commit for\n// double invoking\nvar MountLayoutDev=/*               */16777216;var MountPassiveDev=/*              */33554432;// Groups of flags that are used in the commit phase to skip over trees that\n// don't contain effects, by checking subtreeFlags.\nvar BeforeMutationMask=// TODO: Remove Update flag from before mutation phase by re-landing Visibility\n// flag logic (see #20043)\nUpdate|Snapshot|0;var MutationMask=Placement|Update|ChildDeletion|ContentReset|Ref|Hydrating|Visibility;var LayoutMask=Update|Callback|Ref|Visibility;// TODO: Split into PassiveMountMask and PassiveUnmountMask\nvar PassiveMask=Passive|ChildDeletion;// Union of tags that don't get reset on clones.\n// This allows certain concepts to persist without recalculating them,\n// e.g. whether a subtree contains passive effects or portals.\nvar StaticMask=LayoutStatic|PassiveStatic|RefStatic;var ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;function getNearestMountedFiber(fiber){var node=fiber;var nearestMounted=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted\n// yet. If it is, then it will have a pending insertion effect on it.\nvar nextNode=node;do{node=nextNode;if((node.flags&(Placement|Hydrating))!==NoFlags){// This is an insertion or in-progress hydration. The nearest possible\n// mounted fiber is the parent but we need to continue to figure out\n// if that one is still mounted.\nnearestMounted=node.return;}nextNode=node.return;}while(nextNode);}else{while(node.return){node=node.return;}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with\n// renderContainerIntoSubtree.\nreturn nearestMounted;}// If we didn't hit the root, that means that we're in an disconnected tree\n// that has been unmounted.\nreturn null;}function getSuspenseInstanceFromFiber(fiber){if(fiber.tag===SuspenseComponent){var suspenseState=fiber.memoizedState;if(suspenseState===null){var current=fiber.alternate;if(current!==null){suspenseState=current.memoizedState;}}if(suspenseState!==null){return suspenseState.dehydrated;}}return null;}function getContainerFromFiber(fiber){return fiber.tag===HostRoot?fiber.stateNode.containerInfo:null;}function isFiberMounted(fiber){return getNearestMountedFiber(fiber)===fiber;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;if(!instance._warnedAboutRefsInRender){error('%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromFiber(ownerFiber)||'A component');}instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return getNearestMountedFiber(fiber)===fiber;}function assertIsMounted(fiber){if(getNearestMountedFiber(fiber)!==fiber){throw new Error('Unable to find node on an unmounted component.');}}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.\nvar nearestMounted=getNearestMountedFiber(fiber);if(nearestMounted===null){throw new Error('Unable to find node on an unmounted component.');}if(nearestMounted!==fiber){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root\n// to see what path the root points to. On the way we may hit one of the\n// special cases and we'll deal with them.\nvar a=fiber;var b=alternate;while(true){var parentA=a.return;if(parentA===null){// We're at the root.\nbreak;}var parentB=parentA.alternate;if(parentB===null){// There is no alternate. This is an unusual case. Currently, it only\n// happens when a Suspense component is hidden. An extra fragment fiber\n// is inserted in between the Suspense fiber and its children. Skip\n// over this extra fragment fiber and proceed to the next parent.\nvar nextParent=parentA.return;if(nextParent!==null){a=b=nextParent;continue;}// If there's no parent, we're at the root.\nbreak;}// If both copies of the parent fiber point to the same child, we can\n// assume that the child is current. This happens when we bailout on low\n// priority: the bailed out fiber's child reuses the current child.\nif(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.\nassertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.\nassertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only\n// way this could possibly happen is if this was unmounted, if at all.\nthrow new Error('Unable to find node on an unmounted component.');}if(a.return!==b.return){// The return pointer of A and the return pointer of B point to different\n// fibers. We assume that return pointers never criss-cross, so A must\n// belong to the child set of A.return, and B must belong to the child\n// set of B.return.\na=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the\n// default, slow path: scan the child sets of each parent alternate to see\n// which child belongs to which set.\n//\n// Search parent A's child set\nvar didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set\n_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}if(!didFindChild){throw new Error('Child was not found in either parent set. This indicates a bug '+'in React related to the return pointer. Please file an issue.');}}}if(a.alternate!==b){throw new Error(\"Return fibers should always be each others' alternates. \"+'This error is likely caused by a bug in React. Please file an issue.');}}// If the root is not a host container, we're in a disconnected tree. I.e.\n// unmounted.\nif(a.tag!==HostRoot){throw new Error('Unable to find node on an unmounted component.');}if(a.stateNode.current===a){// We've determined that A is the current branch.\nreturn fiber;}// Otherwise B has to be current branch.\nreturn alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberImpl(currentParent):null;}function findCurrentHostFiberImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\nif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){var match=findCurrentHostFiberImpl(child);if(match!==null){return match;}child=child.sibling;}return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberWithNoPortalsImpl(currentParent):null;}function findCurrentHostFiberWithNoPortalsImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\nif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){if(child.tag!==HostPortal){var match=findCurrentHostFiberWithNoPortalsImpl(child);if(match!==null){return match;}}child=child.sibling;}return null;}// This module only exists as an ESM wrapper around the external CommonJS\nvar scheduleCallback=Scheduler.unstable_scheduleCallback;var cancelCallback=Scheduler.unstable_cancelCallback;var shouldYield=Scheduler.unstable_shouldYield;var requestPaint=Scheduler.unstable_requestPaint;var now=Scheduler.unstable_now;var getCurrentPriorityLevel=Scheduler.unstable_getCurrentPriorityLevel;var ImmediatePriority=Scheduler.unstable_ImmediatePriority;var UserBlockingPriority=Scheduler.unstable_UserBlockingPriority;var NormalPriority=Scheduler.unstable_NormalPriority;var LowPriority=Scheduler.unstable_LowPriority;var IdlePriority=Scheduler.unstable_IdlePriority;// this doesn't actually exist on the scheduler, but it *does*\n// on scheduler/unstable_mock, which we'll need for internal testing\nvar unstable_yieldValue=Scheduler.unstable_yieldValue;var unstable_setDisableYieldValue=Scheduler.unstable_setDisableYieldValue;var rendererID=null;var injectedHook=null;var injectedProfilingHooks=null;var hasLoggedError=false;var isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined';function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools\nreturn false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out\n// of DevTools integration and associated warnings and logs.\n// https://github.com/facebook/react/issues/3877\nreturn true;}if(!hook.supportsFiber){{error('The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://reactjs.org/link/react-devtools');}// DevTools exists, even though it doesn't support Fiber.\nreturn true;}try{if(enableSchedulingProfiler){// Conditionally inject these hooks only if Timeline profiler is supported by this build.\n// This gives DevTools a way to feature detect that isn't tied to version number\n// (since profiling and timeline are controlled by different feature flags).\ninternals=assign({},internals,{getLaneLabelMap:getLaneLabelMap,injectProfilingHooks:injectProfilingHooks});}rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.\ninjectedHook=hook;}catch(err){// Catch all errors because it is unsafe to throw during initialization.\n{error('React instrumentation encountered an error: %s.',err);}}if(hook.checkDCE){// This is the real DevTools.\nreturn true;}else{// This is likely a hook installed by Fast Refresh runtime.\nreturn false;}}function onScheduleRoot(root,children){{if(injectedHook&&typeof injectedHook.onScheduleFiberRoot==='function'){try{injectedHook.onScheduleFiberRoot(rendererID,root,children);}catch(err){if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitRoot(root,eventPriority){if(injectedHook&&typeof injectedHook.onCommitFiberRoot==='function'){try{var didError=(root.current.flags&DidCapture)===DidCapture;if(enableProfilerTimer){var schedulerPriority;switch(eventPriority){case DiscreteEventPriority:schedulerPriority=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriority=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriority=NormalPriority;break;case IdleEventPriority:schedulerPriority=IdlePriority;break;default:schedulerPriority=NormalPriority;break;}injectedHook.onCommitFiberRoot(rendererID,root,schedulerPriority,didError);}else{injectedHook.onCommitFiberRoot(rendererID,root,undefined,didError);}}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onPostCommitRoot(root){if(injectedHook&&typeof injectedHook.onPostCommitFiberRoot==='function'){try{injectedHook.onPostCommitFiberRoot(rendererID,root);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitUnmount(fiber){if(injectedHook&&typeof injectedHook.onCommitFiberUnmount==='function'){try{injectedHook.onCommitFiberUnmount(rendererID,fiber);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function setIsStrictModeForDevtools(newIsStrictMode){{if(typeof unstable_yieldValue==='function'){// We're in a test because Scheduler.unstable_yieldValue only exists\n// in SchedulerMock. To reduce the noise in strict mode tests,\n// suppress warnings and disable scheduler yielding during the double render\nunstable_setDisableYieldValue(newIsStrictMode);setSuppressWarning(newIsStrictMode);}if(injectedHook&&typeof injectedHook.setStrictMode==='function'){try{injectedHook.setStrictMode(rendererID,newIsStrictMode);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}}// Profiler API hooks\nfunction injectProfilingHooks(profilingHooks){injectedProfilingHooks=profilingHooks;}function getLaneLabelMap(){{var map=new Map();var lane=1;for(var index=0;index<TotalLanes;index++){var label=getLabelForLane(lane);map.set(lane,label);lane*=2;}return map;}}function markCommitStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStarted==='function'){injectedProfilingHooks.markCommitStarted(lanes);}}}function markCommitStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStopped==='function'){injectedProfilingHooks.markCommitStopped();}}}function markComponentRenderStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStarted==='function'){injectedProfilingHooks.markComponentRenderStarted(fiber);}}}function markComponentRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStopped==='function'){injectedProfilingHooks.markComponentRenderStopped();}}}function markComponentPassiveEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);}}}function markComponentPassiveEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStopped();}}}function markComponentPassiveEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);}}}function markComponentPassiveEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();}}}function markComponentLayoutEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);}}}function markComponentLayoutEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStopped();}}}function markComponentLayoutEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);}}}function markComponentLayoutEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();}}}function markComponentErrored(fiber,thrownValue,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentErrored==='function'){injectedProfilingHooks.markComponentErrored(fiber,thrownValue,lanes);}}}function markComponentSuspended(fiber,wakeable,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentSuspended==='function'){injectedProfilingHooks.markComponentSuspended(fiber,wakeable,lanes);}}}function markLayoutEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStarted==='function'){injectedProfilingHooks.markLayoutEffectsStarted(lanes);}}}function markLayoutEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStopped==='function'){injectedProfilingHooks.markLayoutEffectsStopped();}}}function markPassiveEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStarted==='function'){injectedProfilingHooks.markPassiveEffectsStarted(lanes);}}}function markPassiveEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStopped==='function'){injectedProfilingHooks.markPassiveEffectsStopped();}}}function markRenderStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStarted==='function'){injectedProfilingHooks.markRenderStarted(lanes);}}}function markRenderYielded(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderYielded==='function'){injectedProfilingHooks.markRenderYielded();}}}function markRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStopped==='function'){injectedProfilingHooks.markRenderStopped();}}}function markRenderScheduled(lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderScheduled==='function'){injectedProfilingHooks.markRenderScheduled(lane);}}}function markForceUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markForceUpdateScheduled==='function'){injectedProfilingHooks.markForceUpdateScheduled(fiber,lane);}}}function markStateUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markStateUpdateScheduled==='function'){injectedProfilingHooks.markStateUpdateScheduled(fiber,lane);}}}var NoMode=/*                         */0;// TODO: Remove ConcurrentMode by reading from the root tag instead\nvar ConcurrentMode=/*                 */1;var ProfileMode=/*                    */2;var StrictLegacyMode=/*               */8;var StrictEffectsMode=/*              */16;// TODO: This is pretty well supported by browsers. Maybe we can drop it.\nvar clz32=Math.clz32?Math.clz32:clz32Fallback;// Count leading zeros.\n// Based on:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\nvar log=Math.log;var LN2=Math.LN2;function clz32Fallback(x){var asUint=x>>>0;if(asUint===0){return 32;}return 31-(log(asUint)/LN2|0)|0;}// If those values are changed that package should be rebuilt and redeployed.\nvar TotalLanes=31;var NoLanes=/*                        */0;var NoLane=/*                          */0;var SyncLane=/*                        */1;var InputContinuousHydrationLane=/*    */2;var InputContinuousLane=/*             */4;var DefaultHydrationLane=/*            */8;var DefaultLane=/*                     */16;var TransitionHydrationLane=/*                */32;var TransitionLanes=/*                       */4194240;var TransitionLane1=/*                        */64;var TransitionLane2=/*                        */128;var TransitionLane3=/*                        */256;var TransitionLane4=/*                        */512;var TransitionLane5=/*                        */1024;var TransitionLane6=/*                        */2048;var TransitionLane7=/*                        */4096;var TransitionLane8=/*                        */8192;var TransitionLane9=/*                        */16384;var TransitionLane10=/*                       */32768;var TransitionLane11=/*                       */65536;var TransitionLane12=/*                       */131072;var TransitionLane13=/*                       */262144;var TransitionLane14=/*                       */524288;var TransitionLane15=/*                       */1048576;var TransitionLane16=/*                       */2097152;var RetryLanes=/*                            */130023424;var RetryLane1=/*                             */4194304;var RetryLane2=/*                             */8388608;var RetryLane3=/*                             */16777216;var RetryLane4=/*                             */33554432;var RetryLane5=/*                             */67108864;var SomeRetryLane=RetryLane1;var SelectiveHydrationLane=/*          */134217728;var NonIdleLanes=/*                          */268435455;var IdleHydrationLane=/*               */268435456;var IdleLane=/*                        */536870912;var OffscreenLane=/*                   */1073741824;// This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\nfunction getLabelForLane(lane){{if(lane&SyncLane){return'Sync';}if(lane&InputContinuousHydrationLane){return'InputContinuousHydration';}if(lane&InputContinuousLane){return'InputContinuous';}if(lane&DefaultHydrationLane){return'DefaultHydration';}if(lane&DefaultLane){return'Default';}if(lane&TransitionHydrationLane){return'TransitionHydration';}if(lane&TransitionLanes){return'Transition';}if(lane&RetryLanes){return'Retry';}if(lane&SelectiveHydrationLane){return'SelectiveHydration';}if(lane&IdleHydrationLane){return'IdleHydration';}if(lane&IdleLane){return'Idle';}if(lane&OffscreenLane){return'Offscreen';}}}var NoTimestamp=-1;var nextTransitionLane=TransitionLane1;var nextRetryLane=RetryLane1;function getHighestPriorityLanes(lanes){switch(getHighestPriorityLane(lanes)){case SyncLane:return SyncLane;case InputContinuousHydrationLane:return InputContinuousHydrationLane;case InputContinuousLane:return InputContinuousLane;case DefaultHydrationLane:return DefaultHydrationLane;case DefaultLane:return DefaultLane;case TransitionHydrationLane:return TransitionHydrationLane;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return lanes&TransitionLanes;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:return lanes&RetryLanes;case SelectiveHydrationLane:return SelectiveHydrationLane;case IdleHydrationLane:return IdleHydrationLane;case IdleLane:return IdleLane;case OffscreenLane:return OffscreenLane;default:{error('Should have found matching lanes. This is a bug in React.');}// This shouldn't be reachable, but as a fallback, return the entire bitmask.\nreturn lanes;}}function getNextLanes(root,wipLanes){// Early bailout if there's no pending work left.\nvar pendingLanes=root.pendingLanes;if(pendingLanes===NoLanes){return NoLanes;}var nextLanes=NoLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;// Do not work on any idle work until all the non-idle work has finished,\n// even if the work is suspended.\nvar nonIdlePendingLanes=pendingLanes&NonIdleLanes;if(nonIdlePendingLanes!==NoLanes){var nonIdleUnblockedLanes=nonIdlePendingLanes&~suspendedLanes;if(nonIdleUnblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdleUnblockedLanes);}else{var nonIdlePingedLanes=nonIdlePendingLanes&pingedLanes;if(nonIdlePingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdlePingedLanes);}}}else{// The only remaining work is Idle.\nvar unblockedLanes=pendingLanes&~suspendedLanes;if(unblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(unblockedLanes);}else{if(pingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(pingedLanes);}}}if(nextLanes===NoLanes){// This should only be reachable if we're suspended\n// TODO: Consider warning in this path if a fallback timer is not scheduled.\nreturn NoLanes;}// If we're already in the middle of a render, switching lanes will interrupt\n// it and we'll lose our progress. We should only do this if the new lanes are\n// higher priority.\nif(wipLanes!==NoLanes&&wipLanes!==nextLanes&&// If we already suspended with a delay, then interrupting is fine. Don't\n// bother waiting until the root is complete.\n(wipLanes&suspendedLanes)===NoLanes){var nextLane=getHighestPriorityLane(nextLanes);var wipLane=getHighestPriorityLane(wipLanes);if(// Tests whether the next lane is equal or lower priority than the wip\n// one. This works because the bits decrease in priority as you go left.\nnextLane>=wipLane||// Default priority updates should not interrupt transition updates. The\n// only difference between default updates and transition updates is that\n// default updates do not support refresh transitions.\nnextLane===DefaultLane&&(wipLane&TransitionLanes)!==NoLanes){// Keep working on the existing in-progress tree. Do not interrupt.\nreturn wipLanes;}}if((nextLanes&InputContinuousLane)!==NoLanes){// When updates are sync by default, we entangle continuous priority updates\n// and default updates, so they render in the same batch. The only reason\n// they use separate lanes is because continuous updates should interrupt\n// transitions, but default updates should not.\nnextLanes|=pendingLanes&DefaultLane;}// Check for entangled lanes and add them to the batch.\n//\n// A lane is said to be entangled with another when it's not allowed to render\n// in a batch that does not also include the other lane. Typically we do this\n// when multiple updates have the same source, and we only want to respond to\n// the most recent event from that source.\n//\n// Note that we apply entanglements *after* checking for partial work above.\n// This means that if a lane is entangled during an interleaved event while\n// it's already rendering, we won't interrupt it. This is intentional, since\n// entanglement is usually \"best effort\": we'll try our best to render the\n// lanes in the same batch, but it's not worth throwing out partially\n// completed work in order to do it.\n// TODO: Reconsider this. The counter-argument is that the partial work\n// represents an intermediate state, which we don't want to show to the user.\n// And by spending extra time finishing it, we're increasing the amount of\n// time it takes to show the final state, which is what they are actually\n// waiting for.\n//\n// For those exceptions where entanglement is semantically important, like\n// useMutableSource, we should ensure that there is no partial work at the\n// time we apply the entanglement.\nvar entangledLanes=root.entangledLanes;if(entangledLanes!==NoLanes){var entanglements=root.entanglements;var lanes=nextLanes&entangledLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;nextLanes|=entanglements[index];lanes&=~lane;}}return nextLanes;}function getMostRecentEventTime(root,lanes){var eventTimes=root.eventTimes;var mostRecentEventTime=NoTimestamp;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var eventTime=eventTimes[index];if(eventTime>mostRecentEventTime){mostRecentEventTime=eventTime;}lanes&=~lane;}return mostRecentEventTime;}function computeExpirationTime(lane,currentTime){switch(lane){case SyncLane:case InputContinuousHydrationLane:case InputContinuousLane:// User interactions should expire slightly more quickly.\n//\n// NOTE: This is set to the corresponding constant as in Scheduler.js.\n// When we made it larger, a product metric in www regressed, suggesting\n// there's a user interaction that's being starved by a series of\n// synchronous updates. If that theory is correct, the proper solution is\n// to fix the starvation. However, this scenario supports the idea that\n// expiration times are an important safeguard when starvation\n// does happen.\nreturn currentTime+250;case DefaultHydrationLane:case DefaultLane:case TransitionHydrationLane:case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return currentTime+5000;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:// TODO: Retries should be allowed to expire if they are CPU bound for\n// too long, but when I made this change it caused a spike in browser\n// crashes. There must be some other underlying bug; not super urgent but\n// ideally should figure out why and fix it. Unfortunately we don't have\n// a repro for the crashes, only detected via production metrics.\nreturn NoTimestamp;case SelectiveHydrationLane:case IdleHydrationLane:case IdleLane:case OffscreenLane:// Anything idle priority or lower should never expire.\nreturn NoTimestamp;default:{error('Should have found matching lanes. This is a bug in React.');}return NoTimestamp;}}function markStarvedLanesAsExpired(root,currentTime){// TODO: This gets called every time we yield. We can optimize by storing\n// the earliest expiration time on the root. Then use that to quickly bail out\n// of this function.\nvar pendingLanes=root.pendingLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;var expirationTimes=root.expirationTimes;// Iterate through the pending lanes and check if we've reached their\n// expiration time. If so, we'll assume the update is being starved and mark\n// it as expired to force it to finish.\nvar lanes=pendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var expirationTime=expirationTimes[index];if(expirationTime===NoTimestamp){// Found a pending lane with no expiration time. If it's not suspended, or\n// if it's pinged, assume it's CPU-bound. Compute a new expiration time\n// using the current time.\nif((lane&suspendedLanes)===NoLanes||(lane&pingedLanes)!==NoLanes){// Assumes timestamps are monotonically increasing.\nexpirationTimes[index]=computeExpirationTime(lane,currentTime);}}else if(expirationTime<=currentTime){// This lane expired\nroot.expiredLanes|=lane;}lanes&=~lane;}}// This returns the highest priority pending lanes regardless of whether they\n// are suspended.\nfunction getHighestPriorityPendingLanes(root){return getHighestPriorityLanes(root.pendingLanes);}function getLanesToRetrySynchronouslyOnError(root){var everythingButOffscreen=root.pendingLanes&~OffscreenLane;if(everythingButOffscreen!==NoLanes){return everythingButOffscreen;}if(everythingButOffscreen&OffscreenLane){return OffscreenLane;}return NoLanes;}function includesSyncLane(lanes){return(lanes&SyncLane)!==NoLanes;}function includesNonIdleWork(lanes){return(lanes&NonIdleLanes)!==NoLanes;}function includesOnlyRetries(lanes){return(lanes&RetryLanes)===lanes;}function includesOnlyNonUrgentLanes(lanes){var UrgentLanes=SyncLane|InputContinuousLane|DefaultLane;return(lanes&UrgentLanes)===NoLanes;}function includesOnlyTransitions(lanes){return(lanes&TransitionLanes)===lanes;}function includesBlockingLane(root,lanes){var SyncDefaultLanes=InputContinuousHydrationLane|InputContinuousLane|DefaultHydrationLane|DefaultLane;return(lanes&SyncDefaultLanes)!==NoLanes;}function includesExpiredLane(root,lanes){// This is a separate check from includesBlockingLane because a lane can\n// expire after a render has already started.\nreturn(lanes&root.expiredLanes)!==NoLanes;}function isTransitionLane(lane){return(lane&TransitionLanes)!==NoLanes;}function claimNextTransitionLane(){// Cycle through the lanes, assigning each new transition to the next lane.\n// In most cases, this means every transition gets its own lane, until we\n// run out of lanes and cycle back to the beginning.\nvar lane=nextTransitionLane;nextTransitionLane<<=1;if((nextTransitionLane&TransitionLanes)===NoLanes){nextTransitionLane=TransitionLane1;}return lane;}function claimNextRetryLane(){var lane=nextRetryLane;nextRetryLane<<=1;if((nextRetryLane&RetryLanes)===NoLanes){nextRetryLane=RetryLane1;}return lane;}function getHighestPriorityLane(lanes){return lanes&-lanes;}function pickArbitraryLane(lanes){// This wrapper function gets inlined. Only exists so to communicate that it\n// doesn't matter which bit is selected; you can pick any bit without\n// affecting the algorithms where its used. Here I'm using\n// getHighestPriorityLane because it requires the fewest operations.\nreturn getHighestPriorityLane(lanes);}function pickArbitraryLaneIndex(lanes){return 31-clz32(lanes);}function laneToIndex(lane){return pickArbitraryLaneIndex(lane);}function includesSomeLane(a,b){return(a&b)!==NoLanes;}function isSubsetOfLanes(set,subset){return(set&subset)===subset;}function mergeLanes(a,b){return a|b;}function removeLanes(set,subset){return set&~subset;}function intersectLanes(a,b){return a&b;}// Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\nfunction laneToLanes(lane){return lane;}function higherPriorityLane(a,b){// This works because the bit ranges decrease in priority as you go left.\nreturn a!==NoLane&&a<b?a:b;}function createLaneMap(initial){// Intentionally pushing one by one.\n// https://v8.dev/blog/elements-kinds#avoid-creating-holes\nvar laneMap=[];for(var i=0;i<TotalLanes;i++){laneMap.push(initial);}return laneMap;}function markRootUpdated(root,updateLane,eventTime){root.pendingLanes|=updateLane;// If there are any suspended transitions, it's possible this new update\n// could unblock them. Clear the suspended lanes so that we can try rendering\n// them again.\n//\n// TODO: We really only need to unsuspend only lanes that are in the\n// `subtreeLanes` of the updated fiber, or the update lanes of the return\n// path. This would exclude suspended updates in an unrelated sibling tree,\n// since there's no way for this update to unblock it.\n//\n// We don't do this if the incoming update is idle, because we never process\n// idle updates until after all the regular updates have finished; there's no\n// way it could unblock a transition.\nif(updateLane!==IdleLane){root.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;}var eventTimes=root.eventTimes;var index=laneToIndex(updateLane);// We can always overwrite an existing timestamp because we prefer the most\n// recent event, and we assume time is monotonically increasing.\neventTimes[index]=eventTime;}function markRootSuspended(root,suspendedLanes){root.suspendedLanes|=suspendedLanes;root.pingedLanes&=~suspendedLanes;// The suspended lanes are no longer CPU-bound. Clear their expiration times.\nvar expirationTimes=root.expirationTimes;var lanes=suspendedLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootPinged(root,pingedLanes,eventTime){root.pingedLanes|=root.suspendedLanes&pingedLanes;}function markRootFinished(root,remainingLanes){var noLongerPendingLanes=root.pendingLanes&~remainingLanes;root.pendingLanes=remainingLanes;// Let's try everything again\nroot.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;root.expiredLanes&=remainingLanes;root.mutableReadLanes&=remainingLanes;root.entangledLanes&=remainingLanes;var entanglements=root.entanglements;var eventTimes=root.eventTimes;var expirationTimes=root.expirationTimes;// Clear the lanes that no longer have pending work\nvar lanes=noLongerPendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;entanglements[index]=NoLanes;eventTimes[index]=NoTimestamp;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootEntangled(root,entangledLanes){// In addition to entangling each of the given lanes with each other, we also\n// have to consider _transitive_ entanglements. For each lane that is already\n// entangled with *any* of the given lanes, that lane is now transitively\n// entangled with *all* the given lanes.\n//\n// Translated: If C is entangled with A, then entangling A with B also\n// entangles C with B.\n//\n// If this is hard to grasp, it might help to intentionally break this\n// function and look at the tests that fail in ReactTransition-test.js. Try\n// commenting out one of the conditions below.\nvar rootEntangledLanes=root.entangledLanes|=entangledLanes;var entanglements=root.entanglements;var lanes=rootEntangledLanes;while(lanes){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;if(// Is this one of the newly entangled lanes?\nlane&entangledLanes|// Is this lane transitively entangled with the newly entangled lanes?\nentanglements[index]&entangledLanes){entanglements[index]|=entangledLanes;}lanes&=~lane;}}function getBumpedLaneForHydration(root,renderLanes){var renderLane=getHighestPriorityLane(renderLanes);var lane;switch(renderLane){case InputContinuousLane:lane=InputContinuousHydrationLane;break;case DefaultLane:lane=DefaultHydrationLane;break;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:lane=TransitionHydrationLane;break;case IdleLane:lane=IdleHydrationLane;break;default:// Everything else is already either a hydration lane, or shouldn't\n// be retried at a hydration lane.\nlane=NoLane;break;}// Check if the lane we chose is suspended. If so, that indicates that we\n// already attempted and failed to hydrate at that level. Also check if we're\n// already rendering that lane, which is rare but could happen.\nif((lane&(root.suspendedLanes|renderLanes))!==NoLane){// Give up trying to hydrate and fall back to client render.\nreturn NoLane;}return lane;}function addFiberToLanesMap(root,fiber,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];updaters.add(fiber);lanes&=~lane;}}function movePendingFibersToMemoized(root,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;var memoizedUpdaters=root.memoizedUpdaters;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];if(updaters.size>0){updaters.forEach(function(fiber){var alternate=fiber.alternate;if(alternate===null||!memoizedUpdaters.has(alternate)){memoizedUpdaters.add(fiber);}});updaters.clear();}lanes&=~lane;}}function getTransitionsForLanes(root,lanes){{return null;}}var DiscreteEventPriority=SyncLane;var ContinuousEventPriority=InputContinuousLane;var DefaultEventPriority=DefaultLane;var IdleEventPriority=IdleLane;var currentUpdatePriority=NoLane;function getCurrentUpdatePriority(){return currentUpdatePriority;}function setCurrentUpdatePriority(newPriority){currentUpdatePriority=newPriority;}function runWithPriority(priority,fn){var previousPriority=currentUpdatePriority;try{currentUpdatePriority=priority;return fn();}finally{currentUpdatePriority=previousPriority;}}function higherEventPriority(a,b){return a!==0&&a<b?a:b;}function lowerEventPriority(a,b){return a===0||a>b?a:b;}function isHigherEventPriority(a,b){return a!==0&&a<b;}function lanesToEventPriority(lanes){var lane=getHighestPriorityLane(lanes);if(!isHigherEventPriority(DiscreteEventPriority,lane)){return DiscreteEventPriority;}if(!isHigherEventPriority(ContinuousEventPriority,lane)){return ContinuousEventPriority;}if(includesNonIdleWork(lane)){return DefaultEventPriority;}return IdleEventPriority;}// This is imported by the event replaying implementation in React DOM. It's\n// in a separate file to break a circular dependency between the renderer and\n// the reconciler.\nfunction isRootDehydrated(root){var currentState=root.current.memoizedState;return currentState.isDehydrated;}var _attemptSynchronousHydration;function setAttemptSynchronousHydration(fn){_attemptSynchronousHydration=fn;}function attemptSynchronousHydration(fiber){_attemptSynchronousHydration(fiber);}var attemptContinuousHydration;function setAttemptContinuousHydration(fn){attemptContinuousHydration=fn;}var attemptHydrationAtCurrentPriority;function setAttemptHydrationAtCurrentPriority(fn){attemptHydrationAtCurrentPriority=fn;}var getCurrentUpdatePriority$1;function setGetCurrentUpdatePriority(fn){getCurrentUpdatePriority$1=fn;}var attemptHydrationAtPriority;function setAttemptHydrationAtPriority(fn){attemptHydrationAtPriority=fn;}// TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\nvar hasScheduledReplayAttempt=false;// The queue of discrete events to be replayed.\nvar queuedDiscreteEvents=[];// Indicates if any continuous event targets are non-null for early bailout.\n// if the last target was dehydrated.\nvar queuedFocus=null;var queuedDrag=null;var queuedMouse=null;// For pointer events there can be one latest event per pointerId.\nvar queuedPointers=new Map();var queuedPointerCaptures=new Map();// We could consider replaying selectionchange and touchmoves too.\nvar queuedExplicitHydrationTargets=[];var discreteReplayableEvents=['mousedown','mouseup','touchcancel','touchend','touchstart','auxclick','dblclick','pointercancel','pointerdown','pointerup','dragend','dragstart','drop','compositionend','compositionstart','keydown','keypress','keyup','input','textInput',// Intentionally camelCase\n'copy','cut','paste','click','change','contextmenu','reset','submit'];function isDiscreteEventThatRequiresHydration(eventType){return discreteReplayableEvents.indexOf(eventType)>-1;}function createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){return{blockedOn:blockedOn,domEventName:domEventName,eventSystemFlags:eventSystemFlags,nativeEvent:nativeEvent,targetContainers:[targetContainer]};}function clearIfContinuousEvent(domEventName,nativeEvent){switch(domEventName){case'focusin':case'focusout':queuedFocus=null;break;case'dragenter':case'dragleave':queuedDrag=null;break;case'mouseover':case'mouseout':queuedMouse=null;break;case'pointerover':case'pointerout':{var pointerId=nativeEvent.pointerId;queuedPointers.delete(pointerId);break;}case'gotpointercapture':case'lostpointercapture':{var _pointerId=nativeEvent.pointerId;queuedPointerCaptures.delete(_pointerId);break;}}}function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){if(existingQueuedEvent===null||existingQueuedEvent.nativeEvent!==nativeEvent){var queuedEvent=createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn!==null){var _fiber2=getInstanceFromNode(blockedOn);if(_fiber2!==null){// Attempt to increase the priority of this target.\nattemptContinuousHydration(_fiber2);}}return queuedEvent;}// If we have already queued this exact event, then it's because\n// the different event systems have different DOM event listeners.\n// We can accumulate the flags, and the targetContainers, and\n// store a single event to be replayed.\nexistingQueuedEvent.eventSystemFlags|=eventSystemFlags;var targetContainers=existingQueuedEvent.targetContainers;if(targetContainer!==null&&targetContainers.indexOf(targetContainer)===-1){targetContainers.push(targetContainer);}return existingQueuedEvent;}function queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){// These set relatedTarget to null because the replayed event will be treated as if we\n// moved from outside the window (no target) onto the target once it hydrates.\n// Instead of mutating we could clone the event.\nswitch(domEventName){case'focusin':{var focusEvent=nativeEvent;queuedFocus=accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus,blockedOn,domEventName,eventSystemFlags,targetContainer,focusEvent);return true;}case'dragenter':{var dragEvent=nativeEvent;queuedDrag=accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag,blockedOn,domEventName,eventSystemFlags,targetContainer,dragEvent);return true;}case'mouseover':{var mouseEvent=nativeEvent;queuedMouse=accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse,blockedOn,domEventName,eventSystemFlags,targetContainer,mouseEvent);return true;}case'pointerover':{var pointerEvent=nativeEvent;var pointerId=pointerEvent.pointerId;queuedPointers.set(pointerId,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,pointerEvent));return true;}case'gotpointercapture':{var _pointerEvent=nativeEvent;var _pointerId2=_pointerEvent.pointerId;queuedPointerCaptures.set(_pointerId2,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,_pointerEvent));return true;}}return false;}// Check if this target is unblocked. Returns true if it's unblocked.\nfunction attemptExplicitHydrationTarget(queuedTarget){// TODO: This function shares a lot of logic with findInstanceBlockingEvent.\n// Try to unify them. It's a bit tricky since it would require two return\n// values.\nvar targetInst=getClosestInstanceFromNode(queuedTarget.target);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted!==null){var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// We're blocked on hydrating this boundary.\n// Increase its priority.\nqueuedTarget.blockedOn=instance;attemptHydrationAtPriority(queuedTarget.priority,function(){attemptHydrationAtCurrentPriority(nearestMounted);});return;}}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){queuedTarget.blockedOn=getContainerFromFiber(nearestMounted);// We don't currently have a way to increase the priority of\n// a root other than sync.\nreturn;}}}}queuedTarget.blockedOn=null;}function queueExplicitHydrationTarget(target){// TODO: This will read the priority if it's dispatched by the React\n// event system but not native events. Should read window.event.type, like\n// we do for updates (getCurrentEventPriority).\nvar updatePriority=getCurrentUpdatePriority$1();var queuedTarget={blockedOn:null,target:target,priority:updatePriority};var i=0;for(;i<queuedExplicitHydrationTargets.length;i++){// Stop once we hit the first target with lower priority than\nif(!isHigherEventPriority(updatePriority,queuedExplicitHydrationTargets[i].priority)){break;}}queuedExplicitHydrationTargets.splice(i,0,queuedTarget);if(i===0){attemptExplicitHydrationTarget(queuedTarget);}}function attemptReplayContinuousQueuedEvent(queuedEvent){if(queuedEvent.blockedOn!==null){return false;}var targetContainers=queuedEvent.targetContainers;while(targetContainers.length>0){var targetContainer=targetContainers[0];var nextBlockedOn=findInstanceBlockingEvent(queuedEvent.domEventName,queuedEvent.eventSystemFlags,targetContainer,queuedEvent.nativeEvent);if(nextBlockedOn===null){{var nativeEvent=queuedEvent.nativeEvent;var nativeEventClone=new nativeEvent.constructor(nativeEvent.type,nativeEvent);setReplayingEvent(nativeEventClone);nativeEvent.target.dispatchEvent(nativeEventClone);resetReplayingEvent();}}else{// We're still blocked. Try again later.\nvar _fiber3=getInstanceFromNode(nextBlockedOn);if(_fiber3!==null){attemptContinuousHydration(_fiber3);}queuedEvent.blockedOn=nextBlockedOn;return false;}// This target container was successfully dispatched. Try the next.\ntargetContainers.shift();}return true;}function attemptReplayContinuousQueuedEventInMap(queuedEvent,key,map){if(attemptReplayContinuousQueuedEvent(queuedEvent)){map.delete(key);}}function replayUnblockedEvents(){hasScheduledReplayAttempt=false;if(queuedFocus!==null&&attemptReplayContinuousQueuedEvent(queuedFocus)){queuedFocus=null;}if(queuedDrag!==null&&attemptReplayContinuousQueuedEvent(queuedDrag)){queuedDrag=null;}if(queuedMouse!==null&&attemptReplayContinuousQueuedEvent(queuedMouse)){queuedMouse=null;}queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);}function scheduleCallbackIfUnblocked(queuedEvent,unblocked){if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;if(!hasScheduledReplayAttempt){hasScheduledReplayAttempt=true;// Schedule a callback to attempt replaying as many events as are\n// now unblocked. This first might not actually be unblocked yet.\n// We could check it early to avoid scheduling an unnecessary callback.\nScheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority,replayUnblockedEvents);}}}function retryIfBlockedOn(unblocked){// Mark anything that was blocked on this as no longer blocked\n// and eligible for a replay.\nif(queuedDiscreteEvents.length>0){scheduleCallbackIfUnblocked(queuedDiscreteEvents[0],unblocked);// This is a exponential search for each boundary that commits. I think it's\n// worth it because we expect very few discrete events to queue up and once\n// we are actually fully unblocked it will be fast to replay them.\nfor(var i=1;i<queuedDiscreteEvents.length;i++){var queuedEvent=queuedDiscreteEvents[i];if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;}}}if(queuedFocus!==null){scheduleCallbackIfUnblocked(queuedFocus,unblocked);}if(queuedDrag!==null){scheduleCallbackIfUnblocked(queuedDrag,unblocked);}if(queuedMouse!==null){scheduleCallbackIfUnblocked(queuedMouse,unblocked);}var unblock=function(queuedEvent){return scheduleCallbackIfUnblocked(queuedEvent,unblocked);};queuedPointers.forEach(unblock);queuedPointerCaptures.forEach(unblock);for(var _i=0;_i<queuedExplicitHydrationTargets.length;_i++){var queuedTarget=queuedExplicitHydrationTargets[_i];if(queuedTarget.blockedOn===unblocked){queuedTarget.blockedOn=null;}}while(queuedExplicitHydrationTargets.length>0){var nextExplicitTarget=queuedExplicitHydrationTargets[0];if(nextExplicitTarget.blockedOn!==null){// We're still blocked.\nbreak;}else{attemptExplicitHydrationTarget(nextExplicitTarget);if(nextExplicitTarget.blockedOn===null){// We're unblocked.\nqueuedExplicitHydrationTargets.shift();}}}}var ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig;// TODO: can we stop exporting these?\nvar _enabled=true;// This is exported in FB builds for use by legacy FB layer infra.\n// We'd like to remove this but it's not clear if this is safe.\nfunction setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}function createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags){var eventPriority=getEventPriority(domEventName);var listenerWrapper;switch(eventPriority){case DiscreteEventPriority:listenerWrapper=dispatchDiscreteEvent;break;case ContinuousEventPriority:listenerWrapper=dispatchContinuousEvent;break;case DefaultEventPriority:default:listenerWrapper=dispatchEvent;break;}return listenerWrapper.bind(null,domEventName,eventSystemFlags,targetContainer);}function dispatchDiscreteEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(DiscreteEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchContinuousEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(ContinuousEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){if(!_enabled){return;}{dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent);}}function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent){var blockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);clearIfContinuousEvent(domEventName,nativeEvent);return;}if(queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent)){nativeEvent.stopPropagation();return;}// We need to clear only if we didn't queue because\n// queueing is accumulative.\nclearIfContinuousEvent(domEventName,nativeEvent);if(eventSystemFlags&IS_CAPTURE_PHASE&&isDiscreteEventThatRequiresHydration(domEventName)){while(blockedOn!==null){var fiber=getInstanceFromNode(blockedOn);if(fiber!==null){attemptSynchronousHydration(fiber);}var nextBlockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(nextBlockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);}if(nextBlockedOn===blockedOn){break;}blockedOn=nextBlockedOn;}if(blockedOn!==null){nativeEvent.stopPropagation();}return;}// This is not replayable so we'll invoke it but without a target,\n// in case the event system needs to trace it.\ndispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,null,targetContainer);}var return_targetInst=null;// Returns a SuspenseInstance or Container if it's blocked.\n// The return_targetInst field above is conceptually part of the return value.\nfunction findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){// TODO: Warn if _enabled is false.\nreturn_targetInst=null;var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted===null){// This tree has been unmounted already. Dispatch without a target.\ntargetInst=null;}else{var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// Queue the event to be replayed later. Abort dispatching since we\n// don't want this event dispatched twice through the event system.\n// TODO: If this is the first discrete event in the queue. Schedule an increased\n// priority for this boundary.\nreturn instance;}// This shouldn't happen, something went wrong but to avoid blocking\n// the whole system, dispatch the event without a target.\n// TODO: Warn.\ntargetInst=null;}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){// If this happens during a replay something went wrong and it might block\n// the whole system.\nreturn getContainerFromFiber(nearestMounted);}targetInst=null;}else if(nearestMounted!==targetInst){// If we get an event (ex: img onload) before committing that\n// component's mount, ignore it for now (that is, treat it as if it was an\n// event on a non-React tree). We might also consider queueing events and\n// dispatching them after the mount.\ntargetInst=null;}}}return_targetInst=targetInst;// We're not blocked on anything.\nreturn null;}function getEventPriority(domEventName){switch(domEventName){// Used by SimpleEventPlugin:\ncase'cancel':case'click':case'close':case'contextmenu':case'copy':case'cut':case'auxclick':case'dblclick':case'dragend':case'dragstart':case'drop':case'focusin':case'focusout':case'input':case'invalid':case'keydown':case'keypress':case'keyup':case'mousedown':case'mouseup':case'paste':case'pause':case'play':case'pointercancel':case'pointerdown':case'pointerup':case'ratechange':case'reset':case'resize':case'seeked':case'submit':case'touchcancel':case'touchend':case'touchstart':case'volumechange':// Used by polyfills:\n// eslint-disable-next-line no-fallthrough\ncase'change':case'selectionchange':case'textInput':case'compositionstart':case'compositionend':case'compositionupdate':// Only enableCreateEventHandleAPI:\n// eslint-disable-next-line no-fallthrough\ncase'beforeblur':case'afterblur':// Not used by React but could be by user code:\n// eslint-disable-next-line no-fallthrough\ncase'beforeinput':case'blur':case'fullscreenchange':case'focus':case'hashchange':case'popstate':case'select':case'selectstart':return DiscreteEventPriority;case'drag':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'mousemove':case'mouseout':case'mouseover':case'pointermove':case'pointerout':case'pointerover':case'scroll':case'toggle':case'touchmove':case'wheel':// Not used by React but could be by user code:\n// eslint-disable-next-line no-fallthrough\ncase'mouseenter':case'mouseleave':case'pointerenter':case'pointerleave':return ContinuousEventPriority;case'message':{// We might be in the Scheduler callback.\n// Eventually this mechanism will be replaced by a check\n// of the current priority on the native scheduler.\nvar schedulerPriority=getCurrentPriorityLevel();switch(schedulerPriority){case ImmediatePriority:return DiscreteEventPriority;case UserBlockingPriority:return ContinuousEventPriority;case NormalPriority:case LowPriority:// TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\nreturn DefaultEventPriority;case IdlePriority:return IdleEventPriority;default:return DefaultEventPriority;}}default:return DefaultEventPriority;}}function addEventBubbleListener(target,eventType,listener){target.addEventListener(eventType,listener,false);return listener;}function addEventCaptureListener(target,eventType,listener){target.addEventListener(eventType,listener,true);return listener;}function addEventCaptureListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{capture:true,passive:passive});return listener;}function addEventBubbleListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{passive:passive});return listener;}/**\n * These variables store information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */var root=null;var startText=null;var fallbackText=null;function initialize(nativeEventTarget){root=nativeEventTarget;startText=getText();return true;}function reset(){root=null;startText=null;fallbackText=null;}function getData(){if(fallbackText){return fallbackText;}var start;var startValue=startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;fallbackText=endValue.slice(start,sliceTail);return fallbackText;}function getText(){if('value'in root){return root.value;}return root.textContent;}/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.\nif(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.\ncharCode=keyCode;}// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\n// report Enter as charCode 10 when ctrl is pressed.\nif(charCode===10){charCode=13;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n// Must not discard the (non-)printable Enter-key.\nif(charCode>=32||charCode===13){return charCode;}return 0;}function functionThatReturnsTrue(){return true;}function functionThatReturnsFalse(){return false;}// This is intentionally a factory so that we have different returned constructors.\n// If we had a single constructor, it would be megamorphic and engines would deopt.\nfunction createSyntheticEvent(Interface){/**\n   * Synthetic events are dispatched by event plugins, typically in response to a\n   * top-level event delegation handler.\n   *\n   * These systems should generally use pooling to reduce the frequency of garbage\n   * collection. The system should check `isPersistent` to determine whether the\n   * event should be released into the pool after being dispatched. Users that\n   * need a persisted event should invoke `persist`.\n   *\n   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n   * normalizing browser quirks. Subclasses do not necessarily have to implement a\n   * DOM interface; custom application-specific events can also subclass this.\n   */function SyntheticBaseEvent(reactName,reactEventType,targetInst,nativeEvent,nativeEventTarget){this._reactName=reactName;this._targetInst=targetInst;this.type=reactEventType;this.nativeEvent=nativeEvent;this.target=nativeEventTarget;this.currentTarget=null;for(var _propName in Interface){if(!Interface.hasOwnProperty(_propName)){continue;}var normalize=Interface[_propName];if(normalize){this[_propName]=normalize(nativeEvent);}else{this[_propName]=nativeEvent[_propName];}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=functionThatReturnsTrue;}else{this.isDefaultPrevented=functionThatReturnsFalse;}this.isPropagationStopped=functionThatReturnsFalse;return this;}assign(SyntheticBaseEvent.prototype,{preventDefault:function(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();// $FlowFixMe - flow is not aware of `unknown` in IE\n}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=functionThatReturnsTrue;},stopPropagation:function(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();// $FlowFixMe - flow is not aware of `unknown` in IE\n}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a \"propertychange\" event for\n// IE. This event does not support bubbling or cancelling, and\n// any references to cancelBubble throw \"Member not found\".  A\n// typeof check of \"unknown\" circumvents this issue (and is also\n// IE specific).\nevent.cancelBubble=true;}this.isPropagationStopped=functionThatReturnsTrue;},/**\n     * We release all dispatched `SyntheticEvent`s after each event loop, adding\n     * them back into the pool. This allows a way to hold onto a reference that\n     * won't be added back into the pool.\n     */persist:function(){// Modern event system doesn't use pooling.\n},/**\n     * Checks if this event should be released back into the pool.\n     *\n     * @return {boolean} True if this should not be released, false otherwise.\n     */isPersistent:functionThatReturnsTrue});return SyntheticBaseEvent;}/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var EventInterface={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(event){return event.timeStamp||Date.now();},defaultPrevented:0,isTrusted:0};var SyntheticEvent=createSyntheticEvent(EventInterface);var UIEventInterface=assign({},EventInterface,{view:0,detail:0});var SyntheticUIEvent=createSyntheticEvent(UIEventInterface);var lastMovementX;var lastMovementY;var lastMouseEvent;function updateMouseMovementPolyfillState(event){if(event!==lastMouseEvent){if(lastMouseEvent&&event.type==='mousemove'){lastMovementX=event.screenX-lastMouseEvent.screenX;lastMovementY=event.screenY-lastMouseEvent.screenY;}else{lastMovementX=0;lastMovementY=0;}lastMouseEvent=event;}}/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var MouseEventInterface=assign({},UIEventInterface,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:getEventModifierState,button:0,buttons:0,relatedTarget:function(event){if(event.relatedTarget===undefined)return event.fromElement===event.srcElement?event.toElement:event.fromElement;return event.relatedTarget;},movementX:function(event){if('movementX'in event){return event.movementX;}updateMouseMovementPolyfillState(event);return lastMovementX;},movementY:function(event){if('movementY'in event){return event.movementY;}// Don't need to call updateMouseMovementPolyfillState() here\n// because it's guaranteed to have already run when movementX\n// was copied.\nreturn lastMovementY;}});var SyntheticMouseEvent=createSyntheticEvent(MouseEventInterface);/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var DragEventInterface=assign({},MouseEventInterface,{dataTransfer:0});var SyntheticDragEvent=createSyntheticEvent(DragEventInterface);/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var FocusEventInterface=assign({},UIEventInterface,{relatedTarget:0});var SyntheticFocusEvent=createSyntheticEvent(FocusEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */var AnimationEventInterface=assign({},EventInterface,{animationName:0,elapsedTime:0,pseudoElement:0});var SyntheticAnimationEvent=createSyntheticEvent(AnimationEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */var ClipboardEventInterface=assign({},EventInterface,{clipboardData:function(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}});var SyntheticClipboardEvent=createSyntheticEvent(ClipboardEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */var CompositionEventInterface=assign({},EventInterface,{data:0});var SyntheticCompositionEvent=createSyntheticEvent(CompositionEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */// Happens to share the same list for now.\nvar SyntheticInputEvent=SyntheticCompositionEvent;/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to\n// implementations of a working draft specification.\n// FireFox implements `key` but returns `MozPrintableKey` for all\n// printable characters (normalized to `Unidentified`), ignore it.\nvar key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.\nif(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can\n// thus be captured by `keypress`, no other non-printable key should.\nreturn charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each\n// `keyCode` value, almost all function keys have a universal value.\nreturn translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support\n// getModifierState. If getModifierState is not supported, we map it to a set of\n// modifier keys exposed by the event. In this case, Lock-keys are not supported.\nfunction modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var KeyboardEventInterface=assign({},UIEventInterface,{key:getEventKey,code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:getEventModifierState,// Legacy Interface\ncharCode:function(event){// `charCode` is the result of a KeyPress event and represents the value of\n// the actual printable character.\n// KeyPress is deprecated, but its replacement is not yet final and not\n// implemented in any major browser. Only KeyPress has charCode.\nif(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of\n// physical keyboard key.\n// The actual meaning of the value depends on the users' keyboard layout\n// which cannot be detected. Assuming that it is a US keyboard layout\n// provides a surprisingly accurate mapping for US and European users.\n// Due to this, it is left to the user to implement at this time.\nif(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function(event){// `which` is an alias for either `keyCode` or `charCode` depending on the\n// type of the event.\nif(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}});var SyntheticKeyboardEvent=createSyntheticEvent(KeyboardEventInterface);/**\n * @interface PointerEvent\n * @see http://www.w3.org/TR/pointerevents/\n */var PointerEventInterface=assign({},MouseEventInterface,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0});var SyntheticPointerEvent=createSyntheticEvent(PointerEventInterface);/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */var TouchEventInterface=assign({},UIEventInterface,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:getEventModifierState});var SyntheticTouchEvent=createSyntheticEvent(TouchEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */var TransitionEventInterface=assign({},EventInterface,{propertyName:0,elapsedTime:0,pseudoElement:0});var SyntheticTransitionEvent=createSyntheticEvent(TransitionEventInterface);/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var WheelEventInterface=assign({},MouseEventInterface,{deltaX:function(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:0,// Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n// notch on the scroll is always +/- 120, roughly equivalent to pixels.\n// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\ndeltaMode:0});var SyntheticWheelEvent=createSyntheticEvent(WheelEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space\nvar START_KEYCODE=229;var canUseCompositionEvent=canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent=canUseDOM&&'TextEvent'in window&&!documentMode;// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);function registerEvents(){registerTwoPhaseEvent('onBeforeInput',['compositionend','keypress','textInput','paste']);registerTwoPhaseEvent('onCompositionEnd',['compositionend','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionStart',['compositionstart','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionUpdate',['compositionupdate','focusout','keydown','keypress','keyup','mousedown']);}// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress=false;/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.\n!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**\n * Translate native top level events into event types.\n */function getCompositionEventType(domEventName){switch(domEventName){case'compositionstart':return'onCompositionStart';case'compositionend':return'onCompositionEnd';case'compositionupdate':return'onCompositionUpdate';}}/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n */function isFallbackCompositionStart(domEventName,nativeEvent){return domEventName==='keydown'&&nativeEvent.keyCode===START_KEYCODE;}/**\n * Does our fallback mode think that this event is the end of composition?\n */function isFallbackCompositionEnd(domEventName,nativeEvent){switch(domEventName){case'keyup':// Command keys insert or clear IME input.\nreturn END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'keydown':// Expect IME keyCode on each keydown. If we get any other\n// code we must have exited earlier.\nreturn nativeEvent.keyCode!==START_KEYCODE;case'keypress':case'mousedown':case'focusout':// Events are not possible without cancelling IME.\nreturn true;default:return false;}}/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if(typeof detail==='object'&&'data'in detail){return detail.data;}return null;}/**\n * Check if a composition event was triggered by Korean IME.\n * Our fallback mode does not work well with IE's Korean IME,\n * so just use native composition events when Korean IME is used.\n * Although CompositionEvent.locale property is deprecated,\n * it is available in IE, where our fallback mode is enabled.\n *\n * @param {object} nativeEvent\n * @return {boolean}\n */function isUsingKoreanIME(nativeEvent){return nativeEvent.locale==='ko';}// Track the current IME composition status, if any.\nvar isComposing=false;/**\n * @return {?object} A SyntheticCompositionEvent.\n */function extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(domEventName);}else if(!isComposing){if(isFallbackCompositionStart(domEventName,nativeEvent)){eventType='onCompositionStart';}}else if(isFallbackCompositionEnd(domEventName,nativeEvent)){eventType='onCompositionEnd';}if(!eventType){return null;}if(useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)){// The current composition is stored statically and must not be\n// overwritten while composition continues.\nif(!isComposing&&eventType==='onCompositionStart'){isComposing=initialize(nativeEventTarget);}else if(eventType==='onCompositionEnd'){if(isComposing){fallbackData=getData();}}}var listeners=accumulateTwoPhaseListeners(targetInst,eventType);if(listeners.length>0){var event=new SyntheticCompositionEvent(eventType,domEventName,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});if(fallbackData){// Inject data generated from fallback path into the synthetic event.\n// This matches the property of native CompositionEventInterface.\nevent.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}}}function getNativeBeforeInputChars(domEventName,nativeEvent){switch(domEventName){case'compositionend':return getDataFromCustomEvent(nativeEvent);case'keypress':/**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'textInput':// Record the characters to be added to the DOM.\nvar chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled\n// it at the keypress level and bail immediately. Android Chrome\n// doesn't give us keycodes, so we need to ignore it.\nif(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.\nreturn null;}}/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n */function getFallbackBeforeInputChars(domEventName,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,\n// try to extract the composed characters from the fallback object.\n// If composition event is available, we extract a string only at\n// compositionevent, otherwise extract it at fallback events.\nif(isComposing){if(domEventName==='compositionend'||!canUseCompositionEvent&&isFallbackCompositionEnd(domEventName,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(domEventName){case'paste':// If a paste event occurs after a keypress, throw out the input\n// chars. Paste events should not lead to BeforeInput events.\nreturn null;case'keypress':/**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via\n// Touch keyboard of Windows.  In such a case, the `char` property\n// holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n// is 2, the property `which` does not represent an emoji correctly.\n// In such a case, we directly return the `char` property instead of\n// using `which`.\nif(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'compositionend':return useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)?null:nativeEvent.data;default:return null;}}/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */function extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(domEventName,nativeEvent);}else{chars=getFallbackBeforeInputChars(domEventName,nativeEvent);}// If no characters are being inserted, no BeforeInput event should\n// be fired.\nif(!chars){return null;}var listeners=accumulateTwoPhaseListeners(targetInst,'onBeforeInput');if(listeners.length>0){var event=new SyntheticInputEvent('onBeforeInput','beforeinput',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.data=chars;}}/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */function extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */function isEventSupported(eventNameSuffix){if(!canUseDOM){return false;}var eventName='on'+eventNameSuffix;var isSupported=eventName in document;if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}return isSupported;}function registerEvents$1(){registerTwoPhaseEvent('onChange',['change','click','focusin','focusout','input','keydown','keyup','selectionchange']);}function createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,target){// Flag this event loop as needing state restore.\nenqueueStateRestore(target);var listeners=accumulateTwoPhaseListeners(inst,'onChange');if(listeners.length>0){var event=new SyntheticEvent('onChange','change',null,nativeEvent,target);dispatchQueue.push({event:event,listeners:listeners});}}/**\n * For IE shims\n */var activeElement=null;var activeElementInst=null;/**\n * SECTION: handle `change` event\n */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var dispatchQueue=[];createAndAccumulateChangeEvent(dispatchQueue,activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the\n// other events and have it go through ReactBrowserEventEmitter. Since it\n// doesn't, we manually listen for the events and so we have to enqueue and\n// process the abstract event manually.\n//\n// Batching is necessary here in order to ensure that all event handlers run\n// before the next rerender (including event handlers attached to ancestor\n// elements instead of directly on the input). Without this, controlled\n// components don't work properly in conjunction with event bubbling because\n// the component is rerendered and the value reverted before all the event\n// handlers can run. See https://github.com/facebook/react/issues/708.\nbatchedUpdates(runEventInBatch,dispatchQueue);}function runEventInBatch(dispatchQueue){processDispatchQueue(dispatchQueue,0);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(domEventName,targetInst){if(domEventName==='change'){return targetInst;}}/**\n * SECTION: handle `input` event\n */var isInputEventSupported=false;if(canUseDOM){// IE9 claims to support the input event but fails to trigger it when\n// deleting text, so we ignore its input events.\nisInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(domEventName,target,targetInst){if(domEventName==='focusin'){// In IE9, propertychange fires for most input events but is buggy and\n// doesn't fire when text is deleted, but conveniently, selectionchange\n// appears to fire in all of the remaining cases so we catch those and\n// forward the event if the value has changed\n// In either case, we don't want to call the event handler if the value\n// is changed from JS so we redefine a setter for `.value` that updates\n// our activeElementValue variable, allowing us to ignore those changes\n//\n// stopWatching() should be a noop here but we call it just in case we\n// missed a blur event somehow.\nstopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(domEventName==='focusout'){stopWatchingForValueChange();}}// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(domEventName,targetInst){if(domEventName==='selectionchange'||domEventName==='keyup'||domEventName==='keydown'){// On the selectionchange event, the target is just document which isn't\n// helpful for us so just check activeElement instead.\n//\n// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n// propertychange on the first input event after setting `value` from a\n// script and fires only keydown, keypress, keyup. Catching keyup usually\n// gets it and catching keydown lets us fire an event for the first\n// keystroke if user does a key repeat (it'll be a little delayed: right\n// before the second keystroke). Other input methods (e.g., paste) seem to\n// fire selectionchange normally.\nreturn getInstIfValueChanged(activeElementInst);}}/**\n * SECTION: handle `click` event\n */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.\n// This approach works across all browsers, whereas `change` does not fire\n// until `blur` in IE8.\nvar nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(domEventName,targetInst){if(domEventName==='click'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(domEventName,targetInst){if(domEventName==='input'||domEventName==='change'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(node){var state=node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}{// If controlled, assign the value attribute to the current value on blur\nsetDefaultValue(node,'number',node.value);}}/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */function extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(domEventName,targetInst);if(inst){createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,nativeEventTarget);return;}}if(handleEventFunc){handleEventFunc(domEventName,targetNode,targetInst);}// When blurring, set the value attribute for number inputs\nif(domEventName==='focusout'){handleControlledInputBlur(targetNode);}}function registerEvents$2(){registerDirectEvent('onMouseEnter',['mouseout','mouseover']);registerDirectEvent('onMouseLeave',['mouseout','mouseover']);registerDirectEvent('onPointerEnter',['pointerout','pointerover']);registerDirectEvent('onPointerLeave',['pointerout','pointerover']);}/**\n * For almost every interaction we care about, there will be both a top-level\n * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n * we do not extract duplicate events. However, moving the mouse into the\n * browser from outside will not fire a `mouseout` event. In this case, we use\n * the `mouseover` top-level event.\n */function extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var isOverEvent=domEventName==='mouseover'||domEventName==='pointerover';var isOutEvent=domEventName==='mouseout'||domEventName==='pointerout';if(isOverEvent&&!isReplayingEvent(nativeEvent)){// If this is an over event with a target, we might have already dispatched\n// the event in the out event of the other target. If this is replayed,\n// then it's because we couldn't dispatch against this target previously\n// so we have to do it now instead.\nvar related=nativeEvent.relatedTarget||nativeEvent.fromElement;if(related){// If the related node is managed by React, we can assume that we have\n// already dispatched the corresponding events during its mouseout.\nif(getClosestInstanceFromNode(related)||isContainerMarkedAsRoot(related)){return;}}}if(!isOutEvent&&!isOverEvent){// Must not be a mouse or pointer in or out - ignoring.\nreturn;}var win;// TODO: why is this nullable in the types but we read from it?\nif(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.\nwin=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\nvar doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(isOutEvent){var _related=nativeEvent.relatedTarget||nativeEvent.toElement;from=targetInst;to=_related?getClosestInstanceFromNode(_related):null;if(to!==null){var nearestMounted=getNearestMountedFiber(to);if(to!==nearestMounted||to.tag!==HostComponent&&to.tag!==HostText){to=null;}}}else{// Moving to a node from outside the window.\nfrom=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.\nreturn;}var SyntheticEventCtor=SyntheticMouseEvent;var leaveEventType='onMouseLeave';var enterEventType='onMouseEnter';var eventTypePrefix='mouse';if(domEventName==='pointerout'||domEventName==='pointerover'){SyntheticEventCtor=SyntheticPointerEvent;leaveEventType='onPointerLeave';enterEventType='onPointerEnter';eventTypePrefix='pointer';}var fromNode=from==null?win:getNodeFromInstance(from);var toNode=to==null?win:getNodeFromInstance(to);var leave=new SyntheticEventCtor(leaveEventType,eventTypePrefix+'leave',from,nativeEvent,nativeEventTarget);leave.target=fromNode;leave.relatedTarget=toNode;var enter=null;// We should only process this nativeEvent if we are processing\n// the first ancestor. Next time, we will ignore the event.\nvar nativeTargetInst=getClosestInstanceFromNode(nativeEventTarget);if(nativeTargetInst===targetInst){var enterEvent=new SyntheticEventCtor(enterEventType,eventTypePrefix+'enter',to,nativeEvent,nativeEventTarget);enterEvent.target=toNode;enterEvent.relatedTarget=fromNode;enter=enterEvent;}accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leave,enter,from,to);}/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */function is(x,y){return x===y&&(x!==0||1/x===1/y)||x!==x&&y!==y// eslint-disable-line no-self-compare\n;}var objectIs=typeof Object.is==='function'?Object.is:is;/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */function shallowEqual(objA,objB){if(objectIs(objA,objB)){return true;}if(typeof objA!=='object'||objA===null||typeof objB!=='object'||objB===null){return false;}var keysA=Object.keys(objA);var keysB=Object.keys(objB);if(keysA.length!==keysB.length){return false;}// Test for A's keys different from B.\nfor(var i=0;i<keysA.length;i++){var currentKey=keysA[i];if(!hasOwnProperty.call(objB,currentKey)||!objectIs(objA[currentKey],objB[currentKey])){return false;}}return true;}/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */function getOffsets(outerNode){var ownerDocument=outerNode.ownerDocument;var win=ownerDocument&&ownerDocument.defaultView||window;var selection=win.getSelection&&win.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n// up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n// expose properties, triggering a \"Permission denied error\" if any of its\n// properties are accessed. The only seemingly possible way to avoid erroring\n// is to access a property that typically works for non-anonymous divs and\n// catch any error that may otherwise arise. See\n// https://bugzilla.mozilla.org/show_bug.cgi?id=208427\ntry{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset);}/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.\nparentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting\n// it. If it has no children, this is still the first loop, and the only\n// valid selection is anchorNode and focusNode both equal to this node\n// and both offsets 0, in which case we will have handled above.\nbreak outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.\nnode=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't\n// actually inside the passed-in node.)\nreturn null;}return{start:start,end:end};}/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */function setOffsets(node,offsets){var doc=node.ownerDocument||document;var win=doc&&doc.defaultView||window;// Edge fails with \"Object expected\" in some scenarios.\n// (For instance: TinyMCE editor used in a list component that supports pasting to add more,\n// fails when pasting 100+ items)\nif(!win.getSelection){return;}var selection=win.getSelection();var length=node.textContent.length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.\n// Flip backward selections, so we can set with a single range.\nif(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isTextNode(node){return node&&node.nodeType===TEXT_NODE;}function containsNode(outerNode,innerNode){if(!outerNode||!innerNode){return false;}else if(outerNode===innerNode){return true;}else if(isTextNode(outerNode)){return false;}else if(isTextNode(innerNode)){return containsNode(outerNode,innerNode.parentNode);}else if('contains'in outerNode){return outerNode.contains(innerNode);}else if(outerNode.compareDocumentPosition){return!!(outerNode.compareDocumentPosition(innerNode)&16);}else{return false;}}function isInDocument(node){return node&&node.ownerDocument&&containsNode(node.ownerDocument.documentElement,node);}function isSameOriginFrame(iframe){try{// Accessing the contentDocument of a HTMLIframeElement can cause the browser\n// to throw, e.g. if it has a cross-origin src attribute.\n// Safari will show an error in the console when the access results in \"Blocked a frame with origin\". e.g:\n// iframe.contentDocument.defaultView;\n// A safety way is to access one of the cross origin properties: Window or Location\n// Which might result in \"SecurityError\" DOM Exception and it is compatible to Safari.\n// https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl\nreturn typeof iframe.contentWindow.location.href==='string';}catch(err){return false;}}function getActiveElementDeep(){var win=window;var element=getActiveElement();while(element instanceof win.HTMLIFrameElement){if(isSameOriginFrame(element)){win=element.contentWindow;}else{return element;}element=getActiveElement(win.document);}return element;}/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n *//**\n * @hasSelectionCapabilities: we get the element types that support selection\n * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\n * and `selectionEnd` rows.\n */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&(elem.type==='text'||elem.type==='search'||elem.type==='tel'||elem.type==='url'||elem.type==='password')||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElementDeep();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection(focusedElem):null};}/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElementDeep();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable\nvar ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}if(typeof priorFocusedElem.focus==='function'){priorFocusedElem.focus();}for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */function getSelection(input){var selection;if('selectionStart'in input){// Modern browser with input or textarea.\nselection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.\nselection=getOffsets(input);}return selection||{start:0,end:0};}/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */function setSelection(input,offsets){var start=offsets.start;var end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=canUseDOM&&'documentMode'in document&&document.documentMode<=11;function registerEvents$3(){registerTwoPhaseEvent('onSelect',['focusout','contextmenu','dragend','focusin','keydown','keyup','mousedown','mouseup','selectionchange']);}var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n */function getSelection$1(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else{var win=node.ownerDocument&&node.ownerDocument.defaultView||window;var selection=win.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**\n * Get document associated with the event target.\n */function getEventTargetDocument(eventTarget){return eventTarget.window===eventTarget?eventTarget.document:eventTarget.nodeType===DOCUMENT_NODE?eventTarget:eventTarget.ownerDocument;}/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @param {object} nativeEventTarget\n * @return {?SyntheticEvent}\n */function constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a\n// selection (this matches native `select` event behavior). In HTML5, select\n// fires only on input and textarea thus if there's no focused element we\n// won't dispatch.\nvar doc=getEventTargetDocument(nativeEventTarget);if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement(doc)){return;}// Only fire when selection has actually changed.\nvar currentSelection=getSelection$1(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var listeners=accumulateTwoPhaseListeners(activeElementInst$1,'onSelect');if(listeners.length>0){var event=new SyntheticEvent('onSelect','select',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.target=activeElement$1;}}}/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */function extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;switch(domEventName){// Track the input node that has focus.\ncase'focusin':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'focusout':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the\n// semantics of the native select event.\ncase'mousedown':mouseDown=true;break;case'contextmenu':case'mouseup':case'dragend':mouseDown=false;constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);break;// Chrome and IE fire non-standard event when selection is changed (and\n// sometimes when it hasn't). IE's event fires out of order with respect\n// to key and input events on deletion, so we discard it.\n//\n// Firefox doesn't support selectionchange, so check selection status\n// after each key entry. The selection changes after keydown and before\n// keyup, but we check on keydown as well in the case of holding down a\n// key, when multiple keydown events are fired but only one keyup is.\n// This is also our approach for IE handling, for the reason above.\ncase'selectionchange':if(skipSelectionChangeEvent){break;}// falls through\ncase'keydown':case'keyup':constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);}}/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;return prefixes;}/**\n * A list of event names to a configurable list of vendor prefixes.\n */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**\n * Event names that have already been detected and prefixed (if applicable).\n */var prefixedEventNames={};/**\n * Element to check for prefixes on.\n */var style={};/**\n * Bootstrap if a DOM exists.\n */if(canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,\n// the un-prefixed \"animation\" and \"transition\" properties are defined on the\n// style object but the events that fire will still be prefixed, so we need\n// to check if the un-prefixed events are usable, and if not remove them from the map.\nif(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above\nif(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return eventName;}var ANIMATION_END=getVendorPrefixedEventName('animationend');var ANIMATION_ITERATION=getVendorPrefixedEventName('animationiteration');var ANIMATION_START=getVendorPrefixedEventName('animationstart');var TRANSITION_END=getVendorPrefixedEventName('transitionend');var topLevelEventsToReactNames=new Map();// NOTE: Capitalization is important in this list!\n//\n// E.g. it needs \"pointerDown\", not \"pointerdown\".\n// This is because we derive both React name (\"onPointerDown\")\n// and DOM name (\"pointerdown\") from the same list.\n//\n// Exceptions that don't match this convention are listed separately.\n//\n// prettier-ignore\nvar simpleEventPluginEvents=['abort','auxClick','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','gotPointerCapture','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','lostPointerCapture','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','pointerCancel','pointerDown','pointerMove','pointerOut','pointerOver','pointerUp','progress','rateChange','reset','resize','seeked','seeking','stalled','submit','suspend','timeUpdate','touchCancel','touchEnd','touchStart','volumeChange','scroll','toggle','touchMove','waiting','wheel'];function registerSimpleEvent(domEventName,reactName){topLevelEventsToReactNames.set(domEventName,reactName);registerTwoPhaseEvent(reactName,[domEventName]);}function registerSimpleEvents(){for(var i=0;i<simpleEventPluginEvents.length;i++){var eventName=simpleEventPluginEvents[i];var domEventName=eventName.toLowerCase();var capitalizedEvent=eventName[0].toUpperCase()+eventName.slice(1);registerSimpleEvent(domEventName,'on'+capitalizedEvent);}// Special cases where event names don't match.\nregisterSimpleEvent(ANIMATION_END,'onAnimationEnd');registerSimpleEvent(ANIMATION_ITERATION,'onAnimationIteration');registerSimpleEvent(ANIMATION_START,'onAnimationStart');registerSimpleEvent('dblclick','onDoubleClick');registerSimpleEvent('focusin','onFocus');registerSimpleEvent('focusout','onBlur');registerSimpleEvent(TRANSITION_END,'onTransitionEnd');}function extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var reactName=topLevelEventsToReactNames.get(domEventName);if(reactName===undefined){return;}var SyntheticEventCtor=SyntheticEvent;var reactEventType=domEventName;switch(domEventName){case'keypress':// Firefox creates a keypress event for function keys too. This removes\n// the unwanted keypress events. Enter is however both printable and\n// non-printable. One would expect Tab to be as well (but it isn't).\nif(getEventCharCode(nativeEvent)===0){return;}/* falls through */case'keydown':case'keyup':SyntheticEventCtor=SyntheticKeyboardEvent;break;case'focusin':reactEventType='focus';SyntheticEventCtor=SyntheticFocusEvent;break;case'focusout':reactEventType='blur';SyntheticEventCtor=SyntheticFocusEvent;break;case'beforeblur':case'afterblur':SyntheticEventCtor=SyntheticFocusEvent;break;case'click':// Firefox creates a click event on right mouse clicks. This removes the\n// unwanted click events.\nif(nativeEvent.button===2){return;}/* falls through */case'auxclick':case'dblclick':case'mousedown':case'mousemove':case'mouseup':// TODO: Disabled elements should not respond to mouse events\n/* falls through */case'mouseout':case'mouseover':case'contextmenu':SyntheticEventCtor=SyntheticMouseEvent;break;case'drag':case'dragend':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'dragstart':case'drop':SyntheticEventCtor=SyntheticDragEvent;break;case'touchcancel':case'touchend':case'touchmove':case'touchstart':SyntheticEventCtor=SyntheticTouchEvent;break;case ANIMATION_END:case ANIMATION_ITERATION:case ANIMATION_START:SyntheticEventCtor=SyntheticAnimationEvent;break;case TRANSITION_END:SyntheticEventCtor=SyntheticTransitionEvent;break;case'scroll':SyntheticEventCtor=SyntheticUIEvent;break;case'wheel':SyntheticEventCtor=SyntheticWheelEvent;break;case'copy':case'cut':case'paste':SyntheticEventCtor=SyntheticClipboardEvent;break;case'gotpointercapture':case'lostpointercapture':case'pointercancel':case'pointerdown':case'pointermove':case'pointerout':case'pointerover':case'pointerup':SyntheticEventCtor=SyntheticPointerEvent;break;}var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;{// Some events don't bubble in the browser.\n// In the past, React has always bubbled them, but this can be surprising.\n// We're going to try aligning closer to the browser behavior by not bubbling\n// them in React either. We'll start by not bubbling onScroll, and then expand.\nvar accumulateTargetOnly=!inCapturePhase&&// TODO: ideally, we'd eventually add all events from\n// nonDelegatedEvents list in DOMPluginEventSystem.\n// Then we can remove this special list.\n// This is a breaking change that can wait until React 18.\ndomEventName==='scroll';var _listeners=accumulateSinglePhaseListeners(targetInst,reactName,nativeEvent.type,inCapturePhase,accumulateTargetOnly);if(_listeners.length>0){// Intentionally create event lazily.\nvar _event=new SyntheticEventCtor(reactName,reactEventType,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:_event,listeners:_listeners});}}}// TODO: remove top-level side effect.\nregisterSimpleEvents();registerEvents$2();registerEvents$1();registerEvents$3();registerEvents();function extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){// TODO: we should remove the concept of a \"SimpleEventPlugin\".\n// This is the basic functionality of the event system. All\n// the other plugins are essentially polyfills. So the plugin\n// should probably be inlined somewhere and have its logic\n// be core the to event system. This would potentially allow\n// us to ship builds of React without the polyfilled plugins below.\nextractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);var shouldProcessPolyfillPlugins=(eventSystemFlags&SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS)===0;// We don't process these events unless we are in the\n// event's native \"bubble\" phase, which means that we're\n// not in the capture phase. That's because we emulate\n// the capture phase here still. This is a trade-off,\n// because in an ideal world we would not emulate and use\n// the phases properly, like we do with the SimpleEvent\n// plugin. However, the plugins below either expect\n// emulation (EnterLeave) or use state localized to that\n// plugin (BeforeInput, Change, Select). The state in\n// these modules complicates things, as you'll essentially\n// get the case where the capture phase event might change\n// state, only for the following bubble event to come in\n// later and not trigger anything as the state now\n// invalidates the heuristics of the event plugin. We\n// could alter all these plugins to work in such ways, but\n// that might cause other unknown side-effects that we\n// can't foresee right now.\nif(shouldProcessPolyfillPlugins){extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}}// List of events that need to be individually attached to media elements.\nvar mediaEventTypes=['abort','canplay','canplaythrough','durationchange','emptied','encrypted','ended','error','loadeddata','loadedmetadata','loadstart','pause','play','playing','progress','ratechange','resize','seeked','seeking','stalled','suspend','timeupdate','volumechange','waiting'];// We should not delegate these events to the container, but rather\n// set them on the actual target element itself. This is primarily\n// because these events do not consistently bubble in the DOM.\nvar nonDelegatedEvents=new Set(['cancel','close','invalid','load','scroll','toggle'].concat(mediaEventTypes));function executeDispatch(event,listener,currentTarget){var type=event.type||'unknown-event';event.currentTarget=currentTarget;invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}function processDispatchQueueItemsInOrder(event,dispatchListeners,inCapturePhase){var previousInstance;if(inCapturePhase){for(var i=dispatchListeners.length-1;i>=0;i--){var _dispatchListeners$i=dispatchListeners[i],instance=_dispatchListeners$i.instance,currentTarget=_dispatchListeners$i.currentTarget,listener=_dispatchListeners$i.listener;if(instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,listener,currentTarget);previousInstance=instance;}}else{for(var _i=0;_i<dispatchListeners.length;_i++){var _dispatchListeners$_i=dispatchListeners[_i],_instance=_dispatchListeners$_i.instance,_currentTarget=_dispatchListeners$_i.currentTarget,_listener=_dispatchListeners$_i.listener;if(_instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,_listener,_currentTarget);previousInstance=_instance;}}}function processDispatchQueue(dispatchQueue,eventSystemFlags){var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;for(var i=0;i<dispatchQueue.length;i++){var _dispatchQueue$i=dispatchQueue[i],event=_dispatchQueue$i.event,listeners=_dispatchQueue$i.listeners;processDispatchQueueItemsInOrder(event,listeners,inCapturePhase);//  event system doesn't use pooling.\n}// This would be a good time to rethrow if any of the event handlers threw.\nrethrowCaughtError();}function dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var nativeEventTarget=getEventTarget(nativeEvent);var dispatchQueue=[];extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);processDispatchQueue(dispatchQueue,eventSystemFlags);}function listenToNonDelegatedEvent(domEventName,targetElement){{if(!nonDelegatedEvents.has(domEventName)){error('Did not expect a listenToNonDelegatedEvent() call for \"%s\". '+'This is a bug in React. Please file an issue.',domEventName);}}var isCapturePhaseListener=false;var listenerSet=getEventListenerSet(targetElement);var listenerSetKey=getListenerSetKey(domEventName,isCapturePhaseListener);if(!listenerSet.has(listenerSetKey)){addTrappedEventListener(targetElement,domEventName,IS_NON_DELEGATED,isCapturePhaseListener);listenerSet.add(listenerSetKey);}}function listenToNativeEvent(domEventName,isCapturePhaseListener,target){{if(nonDelegatedEvents.has(domEventName)&&!isCapturePhaseListener){error('Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. '+'This is a bug in React. Please file an issue.',domEventName);}}var eventSystemFlags=0;if(isCapturePhaseListener){eventSystemFlags|=IS_CAPTURE_PHASE;}addTrappedEventListener(target,domEventName,eventSystemFlags,isCapturePhaseListener);}// This is only used by createEventHandle when the\nvar listeningMarker='_reactListening'+Math.random().toString(36).slice(2);function listenToAllSupportedEvents(rootContainerElement){if(!rootContainerElement[listeningMarker]){rootContainerElement[listeningMarker]=true;allNativeEvents.forEach(function(domEventName){// We handle selectionchange separately because it\n// doesn't bubble and needs to be on the document.\nif(domEventName!=='selectionchange'){if(!nonDelegatedEvents.has(domEventName)){listenToNativeEvent(domEventName,false,rootContainerElement);}listenToNativeEvent(domEventName,true,rootContainerElement);}});var ownerDocument=rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;if(ownerDocument!==null){// The selectionchange event also needs deduplication\n// but it is attached to the document.\nif(!ownerDocument[listeningMarker]){ownerDocument[listeningMarker]=true;listenToNativeEvent('selectionchange',false,ownerDocument);}}}}function addTrappedEventListener(targetContainer,domEventName,eventSystemFlags,isCapturePhaseListener,isDeferredListenerForLegacyFBSupport){var listener=createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags);// If passive option is not supported, then the event will be\n// active and not passive.\nvar isPassiveListener=undefined;if(passiveBrowserEventsSupported){// Browsers introduced an intervention, making these events\n// passive by default on document. React doesn't bind them\n// to document anymore, but changing this now would undo\n// the performance wins from the change. So we emulate\n// the existing behavior manually on the roots now.\n// https://github.com/facebook/react/issues/19651\nif(domEventName==='touchstart'||domEventName==='touchmove'||domEventName==='wheel'){isPassiveListener=true;}}targetContainer=targetContainer;var unsubscribeListener;// When legacyFBSupport is enabled, it's for when we\nif(isCapturePhaseListener){if(isPassiveListener!==undefined){unsubscribeListener=addEventCaptureListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventCaptureListener(targetContainer,domEventName,listener);}}else{if(isPassiveListener!==undefined){unsubscribeListener=addEventBubbleListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventBubbleListener(targetContainer,domEventName,listener);}}}function isMatchingRootContainer(grandContainer,targetContainer){return grandContainer===targetContainer||grandContainer.nodeType===COMMENT_NODE&&grandContainer.parentNode===targetContainer;}function dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var ancestorInst=targetInst;if((eventSystemFlags&IS_EVENT_HANDLE_NON_MANAGED_NODE)===0&&(eventSystemFlags&IS_NON_DELEGATED)===0){var targetContainerNode=targetContainer;// If we are using the legacy FB support flag, we\nif(targetInst!==null){// The below logic attempts to work out if we need to change\n// the target fiber to a different ancestor. We had similar logic\n// in the legacy event system, except the big difference between\n// systems is that the modern event system now has an event listener\n// attached to each React Root and React Portal Root. Together,\n// the DOM nodes representing these roots are the \"rootContainer\".\n// To figure out which ancestor instance we should use, we traverse\n// up the fiber tree from the target instance and attempt to find\n// root boundaries that match that of our current \"rootContainer\".\n// If we find that \"rootContainer\", we find the parent fiber\n// sub-tree for that root and make that our ancestor instance.\nvar node=targetInst;mainLoop:while(true){if(node===null){return;}var nodeTag=node.tag;if(nodeTag===HostRoot||nodeTag===HostPortal){var container=node.stateNode.containerInfo;if(isMatchingRootContainer(container,targetContainerNode)){break;}if(nodeTag===HostPortal){// The target is a portal, but it's not the rootContainer we're looking for.\n// Normally portals handle their own events all the way down to the root.\n// So we should be able to stop now. However, we don't know if this portal\n// was part of *our* root.\nvar grandNode=node.return;while(grandNode!==null){var grandTag=grandNode.tag;if(grandTag===HostRoot||grandTag===HostPortal){var grandContainer=grandNode.stateNode.containerInfo;if(isMatchingRootContainer(grandContainer,targetContainerNode)){// This is the rootContainer we're looking for and we found it as\n// a parent of the Portal. That means we can ignore it because the\n// Portal will bubble through to us.\nreturn;}}grandNode=grandNode.return;}}// Now we need to find it's corresponding host fiber in the other\n// tree. To do this we can use getClosestInstanceFromNode, but we\n// need to validate that the fiber is a host instance, otherwise\n// we need to traverse up through the DOM till we find the correct\n// node that is from the other tree.\nwhile(container!==null){var parentNode=getClosestInstanceFromNode(container);if(parentNode===null){return;}var parentTag=parentNode.tag;if(parentTag===HostComponent||parentTag===HostText){node=ancestorInst=parentNode;continue mainLoop;}container=container.parentNode;}}node=node.return;}}}batchedUpdates(function(){return dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,ancestorInst);});}function createDispatchListener(instance,listener,currentTarget){return{instance:instance,listener:listener,currentTarget:currentTarget};}function accumulateSinglePhaseListeners(targetFiber,reactName,nativeEventType,inCapturePhase,accumulateTargetOnly,nativeEvent){var captureName=reactName!==null?reactName+'Capture':null;var reactEventName=inCapturePhase?captureName:reactName;var listeners=[];var instance=targetFiber;var lastHostComponent=null;// Accumulate all instances and listeners via the target -> root path.\nwhile(instance!==null){var _instance2=instance,stateNode=_instance2.stateNode,tag=_instance2.tag;// Handle listeners that are on HostComponents (i.e. <div>)\nif(tag===HostComponent&&stateNode!==null){lastHostComponent=stateNode;// createEventHandle listeners\nif(reactEventName!==null){var listener=getListener(instance,reactEventName);if(listener!=null){listeners.push(createDispatchListener(instance,listener,lastHostComponent));}}}// If we are only accumulating events for the target, then we don't\n// continue to propagate through the React fiber tree to find other\n// listeners.\nif(accumulateTargetOnly){break;}// If we are processing the onBeforeBlur event, then we need to take\ninstance=instance.return;}return listeners;}// We should only use this function for:\n// - BeforeInputEventPlugin\n// - ChangeEventPlugin\n// - SelectEventPlugin\n// This is because we only process these plugins\n// in the bubble phase, so we need to accumulate two\n// phase event listeners (via emulation).\nfunction accumulateTwoPhaseListeners(targetFiber,reactName){var captureName=reactName+'Capture';var listeners=[];var instance=targetFiber;// Accumulate all instances and listeners via the target -> root path.\nwhile(instance!==null){var _instance3=instance,stateNode=_instance3.stateNode,tag=_instance3.tag;// Handle listeners that are on HostComponents (i.e. <div>)\nif(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;var captureListener=getListener(instance,captureName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}var bubbleListener=getListener(instance,reactName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}instance=instance.return;}return listeners;}function getParent(inst){if(inst===null){return null;}do{inst=inst.return;// TODO: If this is a HostRoot we might want to bail out.\n// That is depending on if we want nested subtrees (layers) to bubble\n// events to their parent. We could also go through parentNode on the\n// host node but that wouldn't work for React Native and doesn't let us\n// do the portal feature.\n}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */function getLowestCommonAncestor(instA,instB){var nodeA=instA;var nodeB=instB;var depthA=0;for(var tempA=nodeA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=nodeB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.\nwhile(depthA-depthB>0){nodeA=getParent(nodeA);depthA--;}// If B is deeper, crawl up.\nwhile(depthB-depthA>0){nodeB=getParent(nodeB);depthB--;}// Walk in lockstep until we find a match.\nvar depth=depthA;while(depth--){if(nodeA===nodeB||nodeB!==null&&nodeA===nodeB.alternate){return nodeA;}nodeA=getParent(nodeA);nodeB=getParent(nodeB);}return null;}function accumulateEnterLeaveListenersForEvent(dispatchQueue,event,target,common,inCapturePhase){var registrationName=event._reactName;var listeners=[];var instance=target;while(instance!==null){if(instance===common){break;}var _instance4=instance,alternate=_instance4.alternate,stateNode=_instance4.stateNode,tag=_instance4.tag;if(alternate!==null&&alternate===common){break;}if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;if(inCapturePhase){var captureListener=getListener(instance,registrationName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}}else if(!inCapturePhase){var bubbleListener=getListener(instance,registrationName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}}instance=instance.return;}if(listeners.length!==0){dispatchQueue.push({event:event,listeners:listeners});}}// We should only use this function for:\n// - EnterLeaveEventPlugin\n// This is because we only process this plugin\n// in the bubble phase, so we need to accumulate two\n// phase event listeners.\nfunction accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leaveEvent,enterEvent,from,to){var common=from&&to?getLowestCommonAncestor(from,to):null;if(from!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,leaveEvent,from,common,false);}if(to!==null&&enterEvent!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,enterEvent,to,common,true);}}function getListenerSetKey(domEventName,capture){return domEventName+\"__\"+(capture?'capture':'bubble');}var didWarnInvalidHydration=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML$1='__html';var warnedUnknownTags;var validatePropertiesInDevelopment;var warnForPropDifference;var warnForExtraAttributes;var warnForInvalidEventListener;var canDiffStyleForHydrationWarning;var normalizeHTML;{warnedUnknownTags={// There are working polyfills for <dialog>. Let people use it.\ndialog:true,// Electron ships a custom <webview> tag to display external web content in\n// an isolated frame and process.\n// This tag is not present in non Electron environments such as JSDom which\n// is often used for testing purposes.\n// @see https://electronjs.org/docs/api/webview-tag\nwebview:true};validatePropertiesInDevelopment=function(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,{registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames});};// IE 11 parses & normalizes the style attribute as opposed to other\n// browsers. It adds spaces and sorts the properties in some\n// non-alphabetical order. Handling that would require sorting CSS\n// properties in the client & server versions or applying\n// `expectedStyle` to a temporary DOM node to read its `style` attribute\n// normalized. Since it only affects IE, we're skipping style warnings\n// in that browser completely in favor of doing all that work.\n// See https://github.com/facebook/react/issues/11807\ncanDiffStyleForHydrationWarning=canUseDOM&&!document.documentMode;warnForPropDifference=function(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;error('Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};warnForExtraAttributes=function(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});error('Extra attributes from the server: %s',names);};warnForInvalidEventListener=function(registrationName,listener){if(listener===false){error('Expected `%s` listener to be a function, instead got `false`.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',registrationName,registrationName,registrationName);}else{error('Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener);}};// Parse the HTML and read it back to normalize the HTML string so that it\n// can be used for comparison.\nnormalizeHTML=function(parent,html){// We could have created a separate document here to avoid\n// re-initializing custom elements if they exist. But this breaks\n// how <noscript> is being handled. So we use the same document.\n// See the discussion in https://github.com/facebook/react/pull/11157.\nvar testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}// HTML parsing normalizes CR and CRLF to LF.\n// It also can turn \\u0000 into \\uFFFD inside attributes.\n// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n// If we have a mismatch, it might be caused by that.\n// We will still patch up in this case but not fire the warning.\nvar NORMALIZE_NEWLINES_REGEX=/\\r\\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\\u0000|\\uFFFD/g;function normalizeMarkupForTextOrAttribute(markup){{checkHtmlStringCoercion(markup);}var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');}function checkForUnmatchedText(serverText,clientText,isConcurrentMode,shouldWarnDev){var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}if(shouldWarnDev){{if(!didWarnInvalidHydration){didWarnInvalidHydration=true;error('Text content did not match. Server: \"%s\" Client: \"%s\"',normalizedServerText,normalizedClientText);}}}if(isConcurrentMode&&enableClientRenderFallbackOnTextMismatch){// In concurrent roots, we throw when there's a text mismatch and revert to\n// client rendering, up to the nearest Suspense boundary.\nthrow new Error('Text content does not match server-rendered HTML.');}}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}function noop(){}function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on\n// non-interactive elements, which means delegated click listeners do not\n// fire. The workaround for this bug involves attaching an empty click\n// listener on the target node.\n// https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n// Just set it using the onclick property so that we don't have to manage any\n// bookkeeping for it. Not sure if we need to clear it when the listener is\n// removed.\n// TODO: Only do this for the relevant Safaris maybe?\nnode.onclick=noop;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.\nsetValueForStyles(domElement,nextProp);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting\n// textContent on a <textarea> will cause the placeholder to not\n// show within the <textarea> until it has been focused and blurred again.\n// https://github.com/facebook/react/issues/6731#issuecomment-254874553\nvar canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(nextProp!=null){setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag\nfor(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else{setValueForProperty(domElement,propKey,propValue,isCustomComponentTag);}}}function createElement(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag;// We create tags in the namespace of their parent container, except HTML\n// tags get no namespace.\nvar ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to\n// allow <SVG> or <mATH>.\nif(!isCustomComponentTag&&type!==type.toLowerCase()){error('<%s /> is using incorrect casing. '+'Use PascalCase for React components, '+'or lowercase for HTML elements.',type);}}if(type==='script'){// Create the script via .innerHTML so its \"parser-inserted\" flag is\n// set to true and it does not execute\nvar div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line\n// This is guaranteed to yield a script element.\nvar firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components\ndomElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n// See discussion in https://github.com/facebook/react/pull/6896\n// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\ndomElement=ownerDocument.createElement(type);// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`\n// attributes on `select`s needs to be added before `option`s are inserted.\n// This prevents:\n// - a bug where the `select` does not scroll to the correct option because singular\n//  `select` elements automatically pick the first item #13222\n// - a bug where the `select` set the first item as selected despite the `size` attribute #14239\n// See https://github.com/facebook/react/issues/13222\n// and https://github.com/facebook/react/issues/14239\nif(type==='select'){var node=domElement;if(props.multiple){node.multiple=true;}else if(props.size){// Setting a size greater than 1 causes a select to behave like `multiple=true`, where\n// it is possible that no option is selected.\n//\n// This is only necessary when a select in \"single selection mode\".\nnode.size=props.size;}}}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;error('The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\nvar props;switch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);props=rawProps;break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the load event.\nlistenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for all the media events.\nfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}props=rawProps;break;case'source':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the error event.\nlistenToNonDelegatedEvent('error',domElement);props=rawProps;break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for error and load events.\nlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'details':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the toggle event.\nlistenToNonDelegatedEvent('toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);props=rawProps;break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;default:props=rawProps;}assertValidProps(tag,props);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,false);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.\nfunction diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" fiber pointer gets updated so we need a commit\n// to update this element.\nif(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use\n// the allowed property list in the commit phase instead.\n(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.\nfor(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.\nfor(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.\nif(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;var lastHtml=lastProp?lastProp[HTML$1]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,nextHtml);}}}else if(propKey===CHILDREN){if(typeof nextProp==='string'||typeof nextProp==='number'){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.\nif(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" props pointer gets updated so we need a commit\n// to update this element.\nupdatePayload=[];}}else{// For any other property we always add it to the queue and then we\n// filter it out using the allowed property list during the commit.\n(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){{validateShorthandPropertyCollisionInDev(styleUpdates,nextProps[STYLE]);}(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.\nfunction updateProperties(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.\n// In the middle of an update, it is possible to have multiple checked.\n// When a checked radio tries to change name, browser makes another radio's checked false.\nif(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.\nupdateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props\n// changed.\nswitch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to\n// happen after `updateDOMProperties`. Otherwise HTML5 input validations\n// raise warnings and prevent the new value from being assigned.\nupdateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children\n// reconciliation\npostUpdateWrapper(domElement,nextRawProps);break;}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();if(!possibleStandardNames.hasOwnProperty(lowerCasedName)){return null;}return possibleStandardNames[lowerCasedName]||null;}}function diffHydratedProperties(domElement,tag,rawProps,parentNamespace,rootContainerElement,isConcurrentMode,shouldWarnDev){var isCustomComponentTag;var extraAttributeNames;{isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\nswitch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the load event.\nlistenToNonDelegatedEvent('load',domElement);break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for all the media events.\nfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}break;case'source':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the error event.\nlistenToNonDelegatedEvent('error',domElement);break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for error and load events.\nlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);break;case'details':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the toggle event.\nlistenToNonDelegatedEvent('toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;}assertValidProps(tag,rawProps);{extraAttributeNames=new Set();var attributes=domElement.attributes;for(var _i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\ncase'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.\n// See discussion in https://github.com/facebook/react/pull/10676.\nextraAttributeNames.add(attributes[_i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This\n// might match additional HTML that is hidden when we read it using\n// textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n// satisfies our requirement. Our requirement is not to produce perfect\n// HTML and attributes. Ideally we should preserve structure but it's\n// ok not to if the visible content is still enough to indicate what\n// even listeners these nodes might be wired up to.\n// TODO: Warn if there is more than a single textNode as a child.\n// TODO: Should we use domElement.firstChild.nodeValue to compare?\nif(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(shouldWarnDev&&true&&// Convince Flow we've calculated it (it's DEV-only in this method.)\ntypeof isCustomComponentTag==='boolean'){// Validate that the properties correspond to their expected values.\nvar serverValue=void 0;var propertyInfo=isCustomComponentTag&&enableCustomElementPropertySupport?null:getPropertyInfo(propKey);if(rawProps[SUPPRESS_HYDRATION_WARNING]===true);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\npropKey==='value'||propKey==='checked'||propKey==='selected');else if(propKey===DANGEROUSLY_SET_INNER_HTML){var serverHTML=domElement.innerHTML;var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){var expectedHTML=normalizeHTML(domElement,nextHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey);if(canDiffStyleForHydrationWarning){var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}}else if(isCustomComponentTag&&!enableCustomElementPropertySupport){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=false;if(propertyInfo!==null){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey.toLowerCase());}else{var standardName=getPossibleStandardName(propKey);if(standardName!==null&&standardName!==propKey){// If an SVG prop is supplied with bad casing, it will\n// be successfully parsed from HTML, but will produce a mismatch\n// (and would be incorrectly rendered on the client).\n// However, we already warn about bad casing elsewhere.\n// So we'll skip the misleading extra mismatch warning in this case.\nisMismatchDueToBadCasing=true;// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(standardName);}// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}var dontWarnCustomElement=enableCustomElementPropertySupport;if(!dontWarnCustomElement&&nextProp!==serverValue&&!isMismatchDueToBadCasing){warnForPropDifference(propKey,serverValue,nextProp);}}}}{if(shouldWarnDev){if(// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.size>0&&rawProps[SUPPRESS_HYDRATION_WARNING]!==true){// $FlowFixMe - Should be inferred as not undefined.\nwarnForExtraAttributes(extraAttributeNames);}}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,true);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement);break;case'select':case'option':// For input and textarea we current always set the value property at\n// post mount to force it to diverge from attributes. However, for\n// option and select we don't quite do the same thing and select\n// is not resilient to the DOM state changing so we don't do that here.\n// TODO: Consider not doing this for input and textarea.\nbreak;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText(textNode,text,isConcurrentMode){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForDeletedHydratableElement(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain the text node \"%s\" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in\n// the HTML.\n// TODO: Remove this special case if we can just avoid inserting empty\n// text nodes.\nreturn;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching text node for \"%s\" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState$3(domElement,tag,props){switch(tag){case'input':restoreControlledState(domElement,props);return;case'textarea':restoreControlledState$2(domElement,props);return;case'select':restoreControlledState$1(domElement,props);return;}}var validateDOMNesting=function(){};var updatedAncestorInfo=function(){};{// This validation code was written based on the HTML5 parsing spec:\n// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n//\n// Note: this does not catch all invalid nesting, nor does it try to (as it's\n// not clear what practical benefit doing so provides); instead, we warn only\n// for cases where the parser will give a parse tree differing from what React\n// intended. For example, <b><div></div></b> is invalid but we don't warn\n// because it still parses correctly; we do warn for other cases like nested\n// <p> tags where the beginning of the second element implicitly closes the\n// first, causing a confusing mess.\n// https://html.spec.whatwg.org/multipage/syntax.html#special\nvar specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\nvar inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n// TODO: Distinguish by namespace here -- for <title>, including it here\n// errs on the side of fewer warnings\n'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\nvar buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\nvar impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};updatedAncestorInfo=function(oldInfo,tag){var ancestorInfo=assign({},oldInfo||emptyAncestorInfo);var info={tag:tag};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nif(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**\n   * Returns whether\n   */var isTagValidWithParent=function(tag,parentTag){// First, let's check if we're in an unusual parsing mode...\nswitch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\ncase'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n// but\ncase'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n// No special behavior since these rules fall back to \"in body\" mode for\n// all except special table nodes which cause bad parsing behavior anyway.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\ncase'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\ncase'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\ncase'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\ncase'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\ncase'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\ncase'html':return tag==='head'||tag==='body'||tag==='frameset';case'frameset':return tag==='frame';case'#document':return tag==='html';}// Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n// where the parsing rules cause implicit opens or closes to be added.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nswitch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frameset':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child\n// parsing rules -- if we're down here, then none of those matched and\n// so we allow it only if we don't know what the parent is, as all other\n// cases are invalid.\nreturn parentTag==null;}return true;};/**\n   * Returns whether\n   */var findInvalidAncestorForTag=function(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds\n// equivalent to this check.\nreturn ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn$1={};validateDOMNesting=function(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){if(childTag!=null){error('validateDOMNesting: when childText is passed, childTag should be null');}childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag;if(didWarn$1[warnKey]){return;}didWarn$1[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=\" Make sure you don't have any extra whitespace between tags on \"+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by '+'the browser.';}error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info);}else{error('validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.',tagDisplayName,ancestorTag);}};}var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var SUSPENSE_START_DATA='$';var SUSPENSE_END_DATA='/$';var SUSPENSE_PENDING_START_DATA='$?';var SUSPENSE_FALLBACK_START_DATA='$!';var STYLE$1='style';var eventsEnabled=null;var selectionInformation=null;function getRootHostContext(rootContainerInstance){var type;var namespace;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var ancestorInfo=updatedAncestorInfo(null,validatedTag);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext;var namespace=getChildNamespace(parentHostContextDev.namespace,type);var ancestorInfo=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getPublicInstance(instance){return instance;}function prepareForCommit(containerInfo){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();var activeInstance=null;setEnabled(false);return activeInstance;}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation);setEnabled(eventsEnabled);eventsEnabled=null;selectionInformation=null;}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace;{// TODO: take namespace into account when validating.\nvar hostContextDev=hostContext;validateDOMNesting(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){setInitialProperties(domElement,type,props,rootContainerInstance);switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;case'img':return true;default:return false;}}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(typeof newProps.children!==typeof oldProps.children&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps);}function shouldSetTextContent(type,props){return type==='textarea'||type==='noscript'||typeof props.children==='string'||typeof props.children==='number'||typeof props.dangerouslySetInnerHTML==='object'&&props.dangerouslySetInnerHTML!==null&&props.dangerouslySetInnerHTML.__html!=null;}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;}function getCurrentEventPriority(){var currentEvent=window.event;if(currentEvent===undefined){return DefaultEventPriority;}return getEventPriority(currentEvent.type);}// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\nvar scheduleTimeout=typeof setTimeout==='function'?setTimeout:undefined;var cancelTimeout=typeof clearTimeout==='function'?clearTimeout:undefined;var noTimeout=-1;var localPromise=typeof Promise==='function'?Promise:undefined;// -------------------\nvar scheduleMicrotask=typeof queueMicrotask==='function'?queueMicrotask:typeof localPromise!=='undefined'?function(callback){return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);}:scheduleTimeout;// TODO: Determine the best fallback here.\nfunction handleErrorInNextTick(error){setTimeout(function(){throw error;});}// -------------------\nfunction commitMount(domElement,type,newProps,internalInstanceHandle){// Despite the naming that might imply otherwise, this method only\n// fires if there is an `Update` effect scheduled during mounting.\n// This happens if `finalizeInitialChildren` returns `true` (which it\n// does to implement the `autoFocus` attribute on the client). But\n// there are also other cases when this might happen (such as patching\n// up text content during hydration mismatch). So we'll check this again.\nswitch(type){case'button':case'input':case'select':case'textarea':if(newProps.autoFocus){domElement.focus();}return;case'img':{if(newProps.src){domElement.src=newProps.src;}return;}}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Apply the diff to the DOM node.\nupdateProperties(domElement,updatePayload,type,oldProps,newProps);// Update the props handle so that we know which props are the ones with\n// with current event handlers.\nupdateFiberProps(domElement,newProps);}function resetTextContent(domElement){setTextContent(domElement,'');}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;}function appendChild(parentInstance,child){parentInstance.appendChild(child);}function appendChildToContainer(container,child){var parentNode;if(container.nodeType===COMMENT_NODE){parentNode=container.parentNode;parentNode.insertBefore(child,container);}else{parentNode=container;parentNode.appendChild(child);}// This container might be used for a portal.\n// If something inside a portal is clicked, that click should bubble\n// through the React tree. However, on Mobile Safari the click would\n// never bubble through the *DOM* tree unless an ancestor with onclick\n// event exists. So we wouldn't see it and dispatch it.\n// This is why we ensure that non React root containers have inline onclick\n// defined.\n// https://github.com/facebook/react/issues/11918\nvar reactRootContainer=container._reactRootContainer;if((reactRootContainer===null||reactRootContainer===undefined)&&parentNode.onclick===null){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(parentNode);}}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);}function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}}function removeChild(parentInstance,child){parentInstance.removeChild(child);}function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}function clearSuspenseBoundary(parentInstance,suspenseInstance){var node=suspenseInstance;// Delete all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;do{var nextNode=node.nextSibling;parentInstance.removeChild(node);if(nextNode&&nextNode.nodeType===COMMENT_NODE){var data=nextNode.data;if(data===SUSPENSE_END_DATA){if(depth===0){parentInstance.removeChild(nextNode);// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);return;}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_PENDING_START_DATA||data===SUSPENSE_FALLBACK_START_DATA){depth++;}}node=nextNode;}while(node);// TODO: Warn, we didn't find the end comment boundary.\n// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);}function clearSuspenseBoundaryFromContainer(container,suspenseInstance){if(container.nodeType===COMMENT_NODE){clearSuspenseBoundary(container.parentNode,suspenseInstance);}else if(container.nodeType===ELEMENT_NODE){clearSuspenseBoundary(container,suspenseInstance);}// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(container);}function hideInstance(instance){// TODO: Does this work for all element types? What about MathML? Should we\n// pass host context to this method?\ninstance=instance;var style=instance.style;if(typeof style.setProperty==='function'){style.setProperty('display','none','important');}else{style.display='none';}}function hideTextInstance(textInstance){textInstance.nodeValue='';}function unhideInstance(instance,props){instance=instance;var styleProp=props[STYLE$1];var display=styleProp!==undefined&&styleProp!==null&&styleProp.hasOwnProperty('display')?styleProp.display:null;instance.style.display=dangerousStyleValue('display',display);}function unhideTextInstance(textInstance,text){textInstance.nodeValue=text;}function clearContainer(container){if(container.nodeType===ELEMENT_NODE){container.textContent='';}else if(container.nodeType===DOCUMENT_NODE){if(container.documentElement){container.removeChild(container.documentElement);}}}// -------------------\nfunction canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.\nreturn instance;}function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\nreturn null;}// This has now been refined to a text node.\nreturn instance;}function canHydrateSuspenseInstance(instance){if(instance.nodeType!==COMMENT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\nreturn null;}// This has now been refined to a suspense node.\nreturn instance;}function isSuspenseInstancePending(instance){return instance.data===SUSPENSE_PENDING_START_DATA;}function isSuspenseInstanceFallback(instance){return instance.data===SUSPENSE_FALLBACK_START_DATA;}function getSuspenseInstanceFallbackErrorDetails(instance){var dataset=instance.nextSibling&&instance.nextSibling.dataset;var digest,message,stack;if(dataset){digest=dataset.dgst;{message=dataset.msg;stack=dataset.stck;}}{return{message:message,digest:digest,stack:stack};}// let value = {message: undefined, hash: undefined};\n// const nextSibling = instance.nextSibling;\n// if (nextSibling) {\n//   const dataset = ((nextSibling: any): HTMLTemplateElement).dataset;\n//   value.message = dataset.msg;\n//   value.hash = dataset.hash;\n//   if (true) {\n//     value.stack = dataset.stack;\n//   }\n// }\n// return value;\n}function registerSuspenseInstanceRetry(instance,callback){instance._reactRetry=callback;}function getNextHydratable(node){// Skip non-hydratable nodes.\nfor(;node!=null;node=node.nextSibling){var nodeType=node.nodeType;if(nodeType===ELEMENT_NODE||nodeType===TEXT_NODE){break;}if(nodeType===COMMENT_NODE){var nodeData=node.data;if(nodeData===SUSPENSE_START_DATA||nodeData===SUSPENSE_FALLBACK_START_DATA||nodeData===SUSPENSE_PENDING_START_DATA){break;}if(nodeData===SUSPENSE_END_DATA){return null;}}}return node;}function getNextHydratableSibling(instance){return getNextHydratable(instance.nextSibling);}function getFirstHydratableChild(parentInstance){return getNextHydratable(parentInstance.firstChild);}function getFirstHydratableChildWithinContainer(parentContainer){return getNextHydratable(parentContainer.firstChild);}function getFirstHydratableChildWithinSuspenseInstance(parentInstance){return getNextHydratable(parentInstance.nextSibling);}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events\n// get attached.\nupdateFiberProps(instance,props);var parentNamespace;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n// when the legacy root API is removed.\nvar isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance,isConcurrentMode,shouldWarnDev);}function hydrateTextInstance(textInstance,text,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,textInstance);// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n// when the legacy root API is removed.\nvar isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedText(textInstance,text);}function hydrateSuspenseInstance(suspenseInstance,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,suspenseInstance);}function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance){var node=suspenseInstance.nextSibling;// Skip past all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_END_DATA){if(depth===0){return getNextHydratableSibling(node);}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){depth++;}}node=node.nextSibling;}// TODO: Warn, we didn't find the end comment boundary.\nreturn null;}// Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\nfunction getParentSuspenseInstance(targetInstance){var node=targetInstance.previousSibling;// Skip past all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){if(depth===0){return node;}else{depth--;}}else if(data===SUSPENSE_END_DATA){depth++;}}node=node.previousSibling;}return null;}function commitHydratedContainer(container){// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(container);}function commitHydratedSuspenseInstance(suspenseInstance){// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);}function shouldDeleteUnhydratedTailInstances(parentType){return parentType!=='head'&&parentType!=='body';}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text,isConcurrentMode){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text,isConcurrentMode){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}}function didNotHydrateInstanceWithinContainer(parentContainer,instance){{if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentContainer,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentContainer,instance);}}}function didNotHydrateInstanceWithinSuspenseInstance(parentInstance,instance){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentNode,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentNode,instance);}}}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentInstance,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentInstance,instance);}}}}function didNotFindHydratableInstanceWithinContainer(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type);}}function didNotFindHydratableTextInstanceWithinContainer(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}}function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance,type,props){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedElement(parentNode,type);}}function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance,text){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedText(parentNode,text);}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedElement(parentInstance,type);}}}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedText(parentInstance,text);}}}function errorHydratingContainer(parentContainer){{// TODO: This gets logged by onRecoverableError, too, so we should be\n// able to remove it.\nerror('An error occurred during hydration. The server HTML was replaced with client content in <%s>.',parentContainer.nodeName.toLowerCase());}}function preparePortalMount(portalInstance){listenToAllSupportedEvents(portalInstance);}var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactFiber$'+randomKey;var internalPropsKey='__reactProps$'+randomKey;var internalContainerInstanceKey='__reactContainer$'+randomKey;var internalEventHandlersKey='__reactEvents$'+randomKey;var internalEventHandlerListenersKey='__reactListeners$'+randomKey;var internalEventHandlesSetKey='__reactHandles$'+randomKey;function detachDeletedInstance(node){// TODO: This function is only called on host components. I don't think all of\n// these fields are relevant.\ndelete node[internalInstanceKey];delete node[internalPropsKey];delete node[internalEventHandlersKey];delete node[internalEventHandlerListenersKey];delete node[internalEventHandlesSetKey];}function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst;}function markContainerAsRoot(hostRoot,node){node[internalContainerInstanceKey]=hostRoot;}function unmarkContainerAsRoot(node){node[internalContainerInstanceKey]=null;}function isContainerMarkedAsRoot(node){return!!node[internalContainerInstanceKey];}// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\n// If the target node is part of a hydrated or not yet rendered subtree, then\n// this may also return a SuspenseComponent or HostRoot to indicate that.\n// Conceptually the HostRoot fiber is a child of the Container node. So if you\n// pass the Container node as the targetNode, you will not actually get the\n// HostRoot back. To get to the HostRoot, you need to pass a child of it.\n// The same thing applies to Suspense boundaries.\nfunction getClosestInstanceFromNode(targetNode){var targetInst=targetNode[internalInstanceKey];if(targetInst){// Don't return HostRoot or SuspenseComponent here.\nreturn targetInst;}// If the direct event target isn't a React owned DOM node, we need to look\n// to see if one of its parents is a React owned DOM node.\nvar parentNode=targetNode.parentNode;while(parentNode){// We'll check if this is a container root that could include\n// React nodes in the future. We need to check this first because\n// if we're a child of a dehydrated container, we need to first\n// find that inner container before moving on to finding the parent\n// instance. Note that we don't check this field on  the targetNode\n// itself because the fibers are conceptually between the container\n// node and the first child. It isn't surrounding the container node.\n// If it's not a container, we check if it's an instance.\ntargetInst=parentNode[internalContainerInstanceKey]||parentNode[internalInstanceKey];if(targetInst){// Since this wasn't the direct target of the event, we might have\n// stepped past dehydrated DOM nodes to get here. However they could\n// also have been non-React nodes. We need to answer which one.\n// If we the instance doesn't have any children, then there can't be\n// a nested suspense boundary within it. So we can use this as a fast\n// bailout. Most of the time, when people add non-React children to\n// the tree, it is using a ref to a child-less DOM node.\n// Normally we'd only need to check one of the fibers because if it\n// has ever gone from having children to deleting them or vice versa\n// it would have deleted the dehydrated boundary nested inside already.\n// However, since the HostRoot starts out with an alternate it might\n// have one on the alternate so we need to check in case this was a\n// root.\nvar alternate=targetInst.alternate;if(targetInst.child!==null||alternate!==null&&alternate.child!==null){// Next we need to figure out if the node that skipped past is\n// nested within a dehydrated boundary and if so, which one.\nvar suspenseInstance=getParentSuspenseInstance(targetNode);while(suspenseInstance!==null){// We found a suspense instance. That means that we haven't\n// hydrated it yet. Even though we leave the comments in the\n// DOM after hydrating, and there are boundaries in the DOM\n// that could already be hydrated, we wouldn't have found them\n// through this pass since if the target is hydrated it would\n// have had an internalInstanceKey on it.\n// Let's get the fiber associated with the SuspenseComponent\n// as the deepest instance.\nvar targetSuspenseInst=suspenseInstance[internalInstanceKey];if(targetSuspenseInst){return targetSuspenseInst;}// If we don't find a Fiber on the comment, it might be because\n// we haven't gotten to hydrate it yet. There might still be a\n// parent boundary that hasn't above this one so we need to find\n// the outer most that is known.\nsuspenseInstance=getParentSuspenseInstance(suspenseInstance);// If we don't find one, then that should mean that the parent\n// host component also hasn't hydrated yet. We can return it\n// below since it will bail out on the isMounted check later.\n}}return targetInst;}targetNode=parentNode;parentNode=targetNode.parentNode;}return null;}/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */function getInstanceFromNode(node){var inst=node[internalInstanceKey]||node[internalContainerInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText||inst.tag===SuspenseComponent||inst.tag===HostRoot){return inst;}else{return null;}}return null;}/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */function getNodeFromInstance(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be\n// a host component or host text.\nreturn inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next\n// invariant for a missing parent, which is super confusing.\nthrow new Error('getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode(node){return node[internalPropsKey]||null;}function updateFiberProps(node,props){node[internalPropsKey]=props;}function getEventListenerSet(node){var elementListenerSet=node[internalEventHandlersKey];if(elementListenerSet===undefined){elementListenerSet=node[internalEventHandlersKey]=new Set();}return elementListenerSet;}var loggedTypeFailures={};var ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){{if(element){var owner=element._owner;var stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame$1.setExtraStackFrame(stack);}else{ReactDebugCurrentFrame$1.setExtraStackFrame(null);}}}function checkPropTypes(typeSpecs,values,location,componentName,element){{// $FlowFixMe This is okay but Flow doesn't know it.\nvar has=Function.call.bind(hasOwnProperty);for(var typeSpecName in typeSpecs){if(has(typeSpecs,typeSpecName)){var error$1=void 0;// Prop type validation may throw. In case they do, we don't want to\n// fail the render phase where it didn't fail before. So we log it.\n// After these have been cleaned up, we'll let them throw.\ntry{// This is intentionally an invariant that gets caught. It's the same\n// behavior as without this statement except with a better message.\nif(typeof typeSpecs[typeSpecName]!=='function'){// eslint-disable-next-line react-internal/prod-error-codes\nvar err=Error((componentName||'React class')+': '+location+' type `'+typeSpecName+'` is invalid; '+'it must be a function, usually from the `prop-types` package, but received `'+typeof typeSpecs[typeSpecName]+'`.'+'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');err.name='Invariant Violation';throw err;}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');}catch(ex){error$1=ex;}if(error$1&&!(error$1 instanceof Error)){setCurrentlyValidatingElement(element);error('%s: type specification of %s'+' `%s` is invalid; the type checker '+'function must return `null` or an `Error` but returned a %s. '+'You may have forgotten to pass an argument to the type checker '+'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and '+'shape all require an argument).',componentName||'React class',location,typeSpecName,typeof error$1);setCurrentlyValidatingElement(null);}if(error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)){// Only monitor this failure once because there tends to be a lot of the\n// same error.\nloggedTypeFailures[error$1.message]=true;setCurrentlyValidatingElement(element);error('Failed %s type: %s',location,error$1.message);setCurrentlyValidatingElement(null);}}}}}var valueStack=[];var fiberStack;{fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{error('Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){error('Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}var warnedAboutMissingGetChildContext;{warnedAboutMissingGetChildContext={};}var emptyContextObject={};{Object.freeze(emptyContextObject);}// A cursor to the current merged context object on the stack.\nvar contextStackCursor=createCursor(emptyContextObject);// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext=emptyContextObject;function getUnmaskedContext(workInProgress,Component,didPushOwnContextIfProvider){{if(didPushOwnContextIfProvider&&isContextProvider(Component)){// If the fiber is a context provider itself, when we read its context\n// we may have already pushed its own child context on the stack. A context\n// provider should not \"see\" its own child context. Therefore we read the\n// previous (parent) context instead for a context provider.\nreturn previousContext;}return contextStackCursor.current;}}function cacheContext(workInProgress,unmaskedContext,maskedContext){{var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}}function getMaskedContext(workInProgress,unmaskedContext){{var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyContextObject;}// Avoid recreating masked context unless unmasked context has changed.\n// Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n// This may trigger infinite loops if componentWillReceiveProps calls setState.\nvar instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentNameFromFiber(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name);}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// Context is created before the class component is instantiated so check for instance.\nif(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}}function hasContextChanged(){{return didPerformWorkStackCursor.current;}}function isContextProvider(type){{var childContextTypes=type.childContextTypes;return childContextTypes!==null&&childContextTypes!==undefined;}}function popContext(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function popTopLevelContextObject(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function pushTopLevelContextObject(fiber,context,didChange){{if(contextStackCursor.current!==emptyContextObject){throw new Error('Unexpected context found on stack. '+'This error is likely caused by a bug in React. Please file an issue.');}push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}}function processChildContext(fiber,type,parentContext){{var instance=fiber.stateNode;var childContextTypes=type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.\n// It has only been added in Fiber to match the (unintentional) behavior in Stack.\nif(typeof instance.getChildContext!=='function'){{var componentName=getComponentNameFromFiber(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;error('%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=instance.getChildContext();for(var contextKey in childContext){if(!(contextKey in childContextTypes)){throw new Error((getComponentNameFromFiber(fiber)||'Unknown')+\".getChildContext(): key \\\"\"+contextKey+\"\\\" is not defined in childContextTypes.\");}}{var name=getComponentNameFromFiber(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name);}return assign({},parentContext,childContext);}}function pushContextProvider(workInProgress){{var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.\n// If the instance does not exist yet, we will push null at first,\n// and replace it on the stack later when invalidating the context.\nvar memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;// Remember the parent context so we can merge with it later.\n// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\npreviousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}}function invalidateContextProvider(workInProgress,type,didChange){{var instance=workInProgress.stateNode;if(!instance){throw new Error('Expected to have an instance by this point. '+'This error is likely caused by a bug in React. Please file an issue.');}if(didChange){// Merge parent and own context.\n// Skip this if we're not updating due to sCU.\n// This avoids unnecessarily recomputing memoized values.\nvar mergedContext=processChildContext(workInProgress,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.\n// It is important to unwind the context in the reverse order.\npop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.\npush(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}}function findCurrentUnmaskedContext(fiber){{// Currently this is only used with renderSubtreeIntoContainer; not sure if it\n// makes sense elsewhere\nif(!isFiberMounted(fiber)||fiber.tag!==ClassComponent){throw new Error('Expected subtree parent to be a mounted class component. '+'This error is likely caused by a bug in React. Please file an issue.');}var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}break;}}node=node.return;}while(node!==null);throw new Error('Found unexpected detached subtree parent. '+'This error is likely caused by a bug in React. Please file an issue.');}}var LegacyRoot=0;var ConcurrentRoot=1;var syncQueue=null;var includesLegacySyncCallbacks=false;var isFlushingSyncQueue=false;function scheduleSyncCallback(callback){// Push this callback into an internal queue. We'll flush these either in\n// the next tick, or earlier if something calls `flushSyncCallbackQueue`.\nif(syncQueue===null){syncQueue=[callback];}else{// Push onto existing queue. Don't need to schedule a callback because\n// we already scheduled one when we created the queue.\nsyncQueue.push(callback);}}function scheduleLegacySyncCallback(callback){includesLegacySyncCallbacks=true;scheduleSyncCallback(callback);}function flushSyncCallbacksOnlyInLegacyMode(){// Only flushes the queue if there's a legacy sync callback scheduled.\n// TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n// it might make more sense for the queue to be a list of roots instead of a\n// list of generic callbacks. Then we can have two: one for legacy roots, one\n// for concurrent roots. And this method would only flush the legacy ones.\nif(includesLegacySyncCallbacks){flushSyncCallbacks();}}function flushSyncCallbacks(){if(!isFlushingSyncQueue&&syncQueue!==null){// Prevent re-entrance.\nisFlushingSyncQueue=true;var i=0;var previousUpdatePriority=getCurrentUpdatePriority();try{var isSync=true;var queue=syncQueue;// TODO: Is this necessary anymore? The only user code that runs in this\n// queue is in the render or commit phases.\nsetCurrentUpdatePriority(DiscreteEventPriority);for(;i<queue.length;i++){var callback=queue[i];do{callback=callback(isSync);}while(callback!==null);}syncQueue=null;includesLegacySyncCallbacks=false;}catch(error){// If something throws, leave the remaining callbacks on the queue.\nif(syncQueue!==null){syncQueue=syncQueue.slice(i+1);}// Resume flushing in the next tick\nscheduleCallback(ImmediatePriority,flushSyncCallbacks);throw error;}finally{setCurrentUpdatePriority(previousUpdatePriority);isFlushingSyncQueue=false;}}return null;}// TODO: Use the unified fiber stack module instead of this local one?\n// Intentionally not using it yet to derisk the initial implementation, because\n// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n// rather the ids be wrong than crash the whole reconciler.\nvar forkStack=[];var forkStackIndex=0;var treeForkProvider=null;var treeForkCount=0;var idStack=[];var idStackIndex=0;var treeContextProvider=null;var treeContextId=1;var treeContextOverflow='';function isForkedChild(workInProgress){warnIfNotHydrating();return(workInProgress.flags&Forked)!==NoFlags;}function getForksAtLevel(workInProgress){warnIfNotHydrating();return treeForkCount;}function getTreeId(){var overflow=treeContextOverflow;var idWithLeadingBit=treeContextId;var id=idWithLeadingBit&~getLeadingBit(idWithLeadingBit);return id.toString(32)+overflow;}function pushTreeFork(workInProgress,totalChildren){// This is called right after we reconcile an array (or iterator) of child\n// fibers, because that's the only place where we know how many children in\n// the whole set without doing extra work later, or storing addtional\n// information on the fiber.\n//\n// That's why this function is separate from pushTreeId  it's called during\n// the render phase of the fork parent, not the child, which is where we push\n// the other context values.\n//\n// In the Fizz implementation this is much simpler because the child is\n// rendered in the same callstack as the parent.\n//\n// It might be better to just add a `forks` field to the Fiber type. It would\n// make this module simpler.\nwarnIfNotHydrating();forkStack[forkStackIndex++]=treeForkCount;forkStack[forkStackIndex++]=treeForkProvider;treeForkProvider=workInProgress;treeForkCount=totalChildren;}function pushTreeId(workInProgress,totalChildren,index){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextProvider=workInProgress;var baseIdWithLeadingBit=treeContextId;var baseOverflow=treeContextOverflow;// The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n// of the id; we use it to account for leading 0s.\nvar baseLength=getBitLength(baseIdWithLeadingBit)-1;var baseId=baseIdWithLeadingBit&~(1<<baseLength);var slot=index+1;var length=getBitLength(totalChildren)+baseLength;// 30 is the max length we can store without overflowing, taking into\n// consideration the leading 1 we use to mark the end of the sequence.\nif(length>30){// We overflowed the bitwise-safe range. Fall back to slower algorithm.\n// This branch assumes the length of the base id is greater than 5; it won't\n// work for smaller ids, because you need 5 bits per character.\n//\n// We encode the id in multiple steps: first the base id, then the\n// remaining digits.\n//\n// Each 5 bit sequence corresponds to a single base 32 character. So for\n// example, if the current id is 23 bits long, we can convert 20 of those\n// bits into a string of 4 characters, with 3 bits left over.\n//\n// First calculate how many bits in the base id represent a complete\n// sequence of characters.\nvar numberOfOverflowBits=baseLength-baseLength%5;// Then create a bitmask that selects only those bits.\nvar newOverflowBits=(1<<numberOfOverflowBits)-1;// Select the bits, and convert them to a base 32 string.\nvar newOverflow=(baseId&newOverflowBits).toString(32);// Now we can remove those bits from the base id.\nvar restOfBaseId=baseId>>numberOfOverflowBits;var restOfBaseLength=baseLength-numberOfOverflowBits;// Finally, encode the rest of the bits using the normal algorithm. Because\n// we made more room, this time it won't overflow.\nvar restOfLength=getBitLength(totalChildren)+restOfBaseLength;var restOfNewBits=slot<<restOfBaseLength;var id=restOfNewBits|restOfBaseId;var overflow=newOverflow+baseOverflow;treeContextId=1<<restOfLength|id;treeContextOverflow=overflow;}else{// Normal path\nvar newBits=slot<<baseLength;var _id=newBits|baseId;var _overflow=baseOverflow;treeContextId=1<<length|_id;treeContextOverflow=_overflow;}}function pushMaterializedTreeId(workInProgress){warnIfNotHydrating();// This component materialized an id. This will affect any ids that appear\n// in its children.\nvar returnFiber=workInProgress.return;if(returnFiber!==null){var numberOfForks=1;var slotIndex=0;pushTreeFork(workInProgress,numberOfForks);pushTreeId(workInProgress,numberOfForks,slotIndex);}}function getBitLength(number){return 32-clz32(number);}function getLeadingBit(id){return 1<<getBitLength(id)-1;}function popTreeContext(workInProgress){// Restore the previous values.\n// This is a bit more complicated than other context-like modules in Fiber\n// because the same Fiber may appear on the stack multiple times and for\n// different reasons. We have to keep popping until the work-in-progress is\n// no longer at the top of the stack.\nwhile(workInProgress===treeForkProvider){treeForkProvider=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;treeForkCount=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;}while(workInProgress===treeContextProvider){treeContextProvider=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextOverflow=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextId=idStack[--idStackIndex];idStack[idStackIndex]=null;}}function getSuspendedTreeContext(){warnIfNotHydrating();if(treeContextProvider!==null){return{id:treeContextId,overflow:treeContextOverflow};}else{return null;}}function restoreSuspendedTreeContext(workInProgress,suspendedContext){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextId=suspendedContext.id;treeContextOverflow=suspendedContext.overflow;treeContextProvider=workInProgress;}function warnIfNotHydrating(){{if(!getIsHydrating()){error('Expected to be hydrating. This is a bug in React. Please file '+'an issue.');}}}// This may have been an insertion or a hydration.\nvar hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;// This flag allows for warning supression when we expect there to be mismatches\n// due to earlier mismatches or a suspended fiber.\nvar didSuspendOrErrorDEV=false;// Hydration errors that were thrown inside this boundary\nvar hydrationErrors=null;function warnIfHydrating(){{if(isHydrating){error('We should not be hydrating here. This is a bug in React. Please file a bug.');}}}function markDidThrowWhileHydratingDEV(){{didSuspendOrErrorDEV=true;}}function didSuspendOrErrorWhileHydratingDEV(){{return didSuspendOrErrorDEV;}}function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChildWithinContainer(parentInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;return true;}function reenterHydrationStateFromDehydratedSuspenseInstance(fiber,suspenseInstance,treeContext){nextHydratableInstance=getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;if(treeContext!==null){restoreSuspendedTreeContext(fiber,treeContext);}return true;}function warnUnhydratedInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:{didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo,instance);break;}case HostComponent:{var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;if(suspenseState.dehydrated!==null)didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated,instance);break;}}}}function deleteHydratableInstance(returnFiber,instance){warnUnhydratedInstance(returnFiber,instance);var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete.return=returnFiber;var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function warnNonhydratedInstance(returnFiber,fiber){{if(didSuspendOrErrorDEV){// Inside a boundary that already suspended. We're currently rendering the\n// siblings of a suspended node. The mismatch may be due to the missing\n// data, so it's probably a false positive.\nreturn;}switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableInstanceWithinContainer(parentContainer,type);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableTextInstanceWithinContainer(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:{var _type=fiber.type;var _props=fiber.pendingProps;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case HostText:{var _text=fiber.pendingProps;var _isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text,// TODO: Delete this argument when we remove the legacy root API.\n_isConcurrentMode);break;}}break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;var _parentInstance=suspenseState.dehydrated;if(_parentInstance!==null)switch(fiber.tag){case HostComponent:var _type2=fiber.type;var _props2=fiber.pendingProps;didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance,_type2);break;case HostText:var _text2=fiber.pendingProps;didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance,_text2);break;}break;}default:return;}}}function insertNonHydratedInstance(returnFiber,fiber){fiber.flags=fiber.flags&~Hydrating|Placement;warnNonhydratedInstance(returnFiber,fiber);}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type);if(instance!==null){fiber.stateNode=instance;hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(instance);return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;hydrationParentFiber=fiber;// Text Instances don't have children so there's nothing to hydrate.\nnextHydratableInstance=null;return true;}return false;}case SuspenseComponent:{var suspenseInstance=canHydrateSuspenseInstance(nextInstance);if(suspenseInstance!==null){var suspenseState={dehydrated:suspenseInstance,treeContext:getSuspendedTreeContext(),retryLane:OffscreenLane};fiber.memoizedState=suspenseState;// Store the dehydrated fragment as a child fiber.\n// This simplifies the code for getHostSibling and deleting nodes,\n// since it doesn't have to consider all Suspense boundaries and\n// check if they're dehydrated ones or not.\nvar dehydratedFragment=createFiberFromDehydratedFragment(suspenseInstance);dehydratedFragment.return=fiber;fiber.child=dehydratedFragment;hydrationParentFiber=fiber;// While a Suspense Instance does have children, we won't step into\n// it during the first pass. Instead, we'll reenter it later.\nnextHydratableInstance=null;return true;}return false;}default:return false;}}function shouldClientRenderOnMismatch(fiber){return(fiber.mode&ConcurrentMode)!==NoMode&&(fiber.flags&DidCapture)===NoFlags;}function throwOnHydrationMismatch(fiber){throw new Error('Hydration failed because the initial UI does not match what was '+'rendered on the server.');}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// If we can't hydrate this instance let's try the next one.\n// We use this as a heuristic. It's based on intuition and not data so it\n// might be flawed or unnecessary.\nnextInstance=getNextHydratableSibling(firstAttemptedInstance);var prevHydrationParentFiber=hydrationParentFiber;if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was\n// superfluous and we'll delete it. Since we can't eagerly delete it\n// we'll have to schedule a deletion. To do that, this node needs a dummy\n// fiber associated with it.\ndeleteHydratableInstance(prevHydrationParentFiber,firstAttemptedInstance);}}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var shouldWarnIfMismatchDev=!didSuspendOrErrorDEV;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber,shouldWarnIfMismatchDev);// TODO: Type this specific to this type of component.\nfiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update.\nif(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the\n// hydration parent is the parent host component of this host text.\nvar returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;var _isConcurrentMode2=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\n_isConcurrentMode2);break;}}}}return shouldUpdate;}function prepareToHydrateHostSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}hydrateSuspenseInstance(suspenseInstance,fiber);}function skipPastDehydratedSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);}function popToNextHostParent(fiber){var parent=fiber.return;while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot&&parent.tag!==SuspenseComponent){parent=parent.return;}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted\n// tree.\nreturn false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then\n// we were an insertion and now need to pop up reenter hydration of our\n// siblings.\npopToNextHostParent(fiber);isHydrating=true;return false;}// If we have any remaining hydratable nodes, we need to delete them now.\n// We only do this deeper than head and body since they tend to have random\n// other nodes in them. We also ignore components with pure text content in\n// side of them. We also don't delete anything inside the root container.\nif(fiber.tag!==HostRoot&&(fiber.tag!==HostComponent||shouldDeleteUnhydratedTailInstances(fiber.type)&&!shouldSetTextContent(fiber.type,fiber.memoizedProps))){var nextInstance=nextHydratableInstance;if(nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnIfUnhydratedTailNodes(fiber);throwOnHydrationMismatch();}else{while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}}}popToNextHostParent(fiber);if(fiber.tag===SuspenseComponent){nextHydratableInstance=skipPastDehydratedSuspenseInstance(fiber);}else{nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;}return true;}function hasUnhydratedTailNodes(){return isHydrating&&nextHydratableInstance!==null;}function warnIfUnhydratedTailNodes(fiber){var nextInstance=nextHydratableInstance;while(nextInstance){warnUnhydratedInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;didSuspendOrErrorDEV=false;}function upgradeHydrationErrorsToRecoverable(){if(hydrationErrors!==null){// Successfully completed a forced client render. The errors that occurred\n// during the hydration attempt are now recovered. We will log them in\n// commit phase, once the entire tree has finished.\nqueueRecoverableErrors(hydrationErrors);hydrationErrors=null;}}function getIsHydrating(){return isHydrating;}function queueHydrationError(error){if(hydrationErrors===null){hydrationErrors=[error];}else{hydrationErrors.push(error);}}var ReactCurrentBatchConfig$1=ReactSharedInternals.ReactCurrentBatchConfig;var NoTransition=null;function requestCurrentTransition(){return ReactCurrentBatchConfig$1.transition;}var ReactStrictModeWarnings={recordUnsafeLifecycleWarnings:function(fiber,instance){},flushPendingUnsafeLifecycleWarnings:function(){},recordLegacyContextWarning:function(fiber,instance){},flushLegacyContextWarning:function(){},discardPendingWarnings:function(){}};{var findStrictRoot=function(fiber){var maybeStrictRoot=null;var node=fiber;while(node!==null){if(node.mode&StrictLegacyMode){maybeStrictRoot=node;}node=node.return;}return maybeStrictRoot;};var setToSortedString=function(set){var array=[];set.forEach(function(value){array.push(value);});return array.sort().join(', ');};var pendingComponentWillMountWarnings=[];var pendingUNSAFE_ComponentWillMountWarnings=[];var pendingComponentWillReceivePropsWarnings=[];var pendingUNSAFE_ComponentWillReceivePropsWarnings=[];var pendingComponentWillUpdateWarnings=[];var pendingUNSAFE_ComponentWillUpdateWarnings=[];// Tracks components we have already warned about.\nvar didWarnAboutUnsafeLifecycles=new Set();ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){// Dedupe strategy: Warn once per component.\nif(didWarnAboutUnsafeLifecycles.has(fiber.type)){return;}if(typeof instance.componentWillMount==='function'&&// Don't warn about react-lifecycles-compat polyfilled components.\ninstance.componentWillMount.__suppressDeprecationWarning!==true){pendingComponentWillMountWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillMount==='function'){pendingUNSAFE_ComponentWillMountWarnings.push(fiber);}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){pendingComponentWillReceivePropsWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillReceiveProps==='function'){pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){pendingComponentWillUpdateWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillUpdate==='function'){pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);}};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){// We do an initial pass to gather component names\nvar componentWillMountUniqueNames=new Set();if(pendingComponentWillMountWarnings.length>0){pendingComponentWillMountWarnings.forEach(function(fiber){componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillMountWarnings=[];}var UNSAFE_componentWillMountUniqueNames=new Set();if(pendingUNSAFE_ComponentWillMountWarnings.length>0){pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber){UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillMountWarnings=[];}var componentWillReceivePropsUniqueNames=new Set();if(pendingComponentWillReceivePropsWarnings.length>0){pendingComponentWillReceivePropsWarnings.forEach(function(fiber){componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillReceivePropsWarnings=[];}var UNSAFE_componentWillReceivePropsUniqueNames=new Set();if(pendingUNSAFE_ComponentWillReceivePropsWarnings.length>0){pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber){UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillReceivePropsWarnings=[];}var componentWillUpdateUniqueNames=new Set();if(pendingComponentWillUpdateWarnings.length>0){pendingComponentWillUpdateWarnings.forEach(function(fiber){componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillUpdateWarnings=[];}var UNSAFE_componentWillUpdateUniqueNames=new Set();if(pendingUNSAFE_ComponentWillUpdateWarnings.length>0){pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber){UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillUpdateWarnings=[];}// Finally, we flush all the warnings\n// UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\nif(UNSAFE_componentWillMountUniqueNames.size>0){var sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'\\nPlease update the following components: %s',sortedNames);}if(UNSAFE_componentWillReceivePropsUniqueNames.size>0){var _sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, \"+'refactor your code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'\\nPlease update the following components: %s',_sortedNames);}if(UNSAFE_componentWillUpdateUniqueNames.size>0){var _sortedNames2=setToSortedString(UNSAFE_componentWillUpdateUniqueNames);error('Using UNSAFE_componentWillUpdate in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'\\nPlease update the following components: %s',_sortedNames2);}if(componentWillMountUniqueNames.size>0){var _sortedNames3=setToSortedString(componentWillMountUniqueNames);warn('componentWillMount has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'* Rename componentWillMount to UNSAFE_componentWillMount to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames3);}if(componentWillReceivePropsUniqueNames.size>0){var _sortedNames4=setToSortedString(componentWillReceivePropsUniqueNames);warn('componentWillReceiveProps has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, refactor your \"+'code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames4);}if(componentWillUpdateUniqueNames.size>0){var _sortedNames5=setToSortedString(componentWillUpdateUniqueNames);warn('componentWillUpdate has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames5);}};var pendingLegacyContextWarning=new Map();// Tracks components we have already warned about.\nvar didWarnAboutLegacyContext=new Set();ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){error('Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.\nif(didWarnAboutLegacyContext.has(fiber.type)){return;}var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);if(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext==='function'){if(warningsForRoot===undefined){warningsForRoot=[];pendingLegacyContextWarning.set(strictRoot,warningsForRoot);}warningsForRoot.push(fiber);}};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){if(fiberArray.length===0){return;}var firstFiber=fiberArray[0];var uniqueNames=new Set();fiberArray.forEach(function(fiber){uniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutLegacyContext.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);try{setCurrentFiber(firstFiber);error('Legacy context API has been detected within a strict-mode tree.'+'\\n\\nThe old API will be supported in all 16.x releases, but applications '+'using it should migrate to the new version.'+'\\n\\nPlease update the following components: %s'+'\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context',sortedNames);}finally{resetCurrentFiber();}});};ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[];pendingUNSAFE_ComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingUNSAFE_ComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUNSAFE_ComponentWillUpdateWarnings=[];pendingLegacyContextWarning=new Map();};}var didWarnAboutMaps;var didWarnAboutGenerators;var didWarnAboutStringRefs;var ownerHasKeyUseWarning;var ownerHasFunctionTypeWarning;var warnForMissingKey=function(child,returnFiber){};{didWarnAboutMaps=false;didWarnAboutGenerators=false;didWarnAboutStringRefs={};/**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */ownerHasKeyUseWarning={};ownerHasFunctionTypeWarning={};warnForMissingKey=function(child,returnFiber){if(child===null||typeof child!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}if(typeof child._store!=='object'){throw new Error('React Component in warnForMissingKey should have a _store. '+'This error is likely caused by a bug in React. Please file an issue.');}child._store.validated=true;var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasKeyUseWarning[componentName]){return;}ownerHasKeyUseWarning[componentName]=true;error('Each child in a list should have a unique '+'\"key\" prop. See https://reactjs.org/link/warning-keys for '+'more information.');};}function isReactClass(type){return type.prototype&&type.prototype.isReactComponent;}function coerceRef(returnFiber,current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'&&typeof mixedRef!=='object'){{// TODO: Clean this up once we turn on the string ref warning for\n// everyone, because the strict mode case will no longer be relevant\nif((returnFiber.mode&StrictLegacyMode||warnAboutStringRefs)&&// We warn in ReactElement.js if owner and self are equal for string refs\n// because these cannot be automatically converted to an arrow function\n// using a codemod. Therefore, we don't have to warn about string refs again.\n!(element._owner&&element._self&&element._owner.stateNode!==element._self)&&// Will already throw with \"Function components cannot have string refs\"\n!(element._owner&&element._owner.tag!==ClassComponent)&&// Will already warn with \"Function components cannot be given refs\"\n!(typeof element.type==='function'&&!isReactClass(element.type))&&// Will already throw with \"Element ref was specified as a string (someStringRef) but no owner was set\"\nelement._owner){var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(!didWarnAboutStringRefs[componentName]){{error('Component \"%s\" contains the string ref \"%s\". Support for string refs '+'will be removed in a future major release. We recommend using '+'useRef() or createRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref',componentName,mixedRef);}didWarnAboutStringRefs[componentName]=true;}}}if(element._owner){var owner=element._owner;var inst;if(owner){var ownerFiber=owner;if(ownerFiber.tag!==ClassComponent){throw new Error('Function components cannot have string refs. '+'We recommend using useRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref');}inst=ownerFiber.stateNode;}if(!inst){throw new Error(\"Missing owner for string ref \"+mixedRef+\". This error is likely caused by a \"+'bug in React. Please file an issue.');}// Assigning this to a const so Flow knows it won't change in the closure\nvar resolvedInst=inst;{checkPropStringCoercion(mixedRef,'ref');}var stringRef=''+mixedRef;// Check if previous string ref matches new string ref\nif(current!==null&&current.ref!==null&&typeof current.ref==='function'&&current.ref._stringRef===stringRef){return current.ref;}var ref=function(value){var refs=resolvedInst.refs;if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{if(typeof mixedRef!=='string'){throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');}if(!element._owner){throw new Error(\"Element ref was specified as a string (\"+mixedRef+\") but no owner was set. This could happen for one of\"+' the following reasons:\\n'+'1. You may be adding a ref to a function component\\n'+\"2. You may be adding a ref to a component that was not created inside a component's render method\\n\"+'3. You have multiple copies of React loaded\\n'+'See https://reactjs.org/link/refs-must-have-owner for more information.');}}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){var childString=Object.prototype.toString.call(newChild);throw new Error(\"Objects are not valid as a React child (found: \"+(childString==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':childString)+\"). \"+'If you meant to render a collection of children, use an array '+'instead.');}function warnOnFunctionType(returnFiber){{var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasFunctionTypeWarning[componentName]){return;}ownerHasFunctionTypeWarning[componentName]=true;error('Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.');}}function resolveLazy(lazyType){var payload=lazyType._payload;var init=lazyType._init;return init(payload);}// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.\nreturn;}var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.\nreturn null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by\n// assuming that after the first child we've already added everything.\nvar childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by\n// keys quickly. Implicit (null) keys get added to this set with their index\n// instead.\nvar existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps){// We currently set sibling to null and index to 0 here because it is easy\n// to forget to do before returning it. E.g. for the single child case.\nvar clone=createWorkInProgress(fiber,pendingProps);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// During hydration, the useId algorithm needs to know which fibers are\n// part of a list of children (arrays, iterators).\nnewFiber.flags|=Forked;return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.\nnewFiber.flags|=Placement;return lastPlacedIndex;}else{// This item can stay in place.\nreturn oldIndex;}}else{// This is an insertion.\nnewFiber.flags|=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a\n// placement for inserting new children.\nif(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.flags|=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,lanes){if(current===null||current.tag!==HostText){// Insert\nvar created=createFiberFromText(textContent,returnFiber.mode,lanes);created.return=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,textContent);existing.return=returnFiber;return existing;}}function updateElement(returnFiber,current,element,lanes){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,current,element.props.children,lanes,element.key);}if(current!==null){if(current.elementType===elementType||// Keep this check inline so it only runs on the false path:\nisCompatibleFamilyForHotReloading(current,element)||// Lazy types should reconcile their resolved type.\n// We need to do this after the Hot Reloading check above,\n// because hot reloading has different semantics than prod because\n// it doesn't resuspend. So we can't let the call below suspend.\ntypeof elementType==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===current.type){// Move based on index\nvar existing=useFiber(current,element.props);existing.ref=coerceRef(returnFiber,current,element);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}// Insert\nvar created=createFiberFromElement(element,returnFiber.mode,lanes);created.ref=coerceRef(returnFiber,current,element);created.return=returnFiber;return created;}function updatePortal(returnFiber,current,portal,lanes){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert\nvar created=createFiberFromPortal(portal,returnFiber.mode,lanes);created.return=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,portal.children||[]);existing.return=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,lanes,key){if(current===null||current.tag!==Fragment){// Insert\nvar created=createFiberFromFragment(fragment,returnFiber.mode,lanes,key);created.return=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,fragment);existing.return=returnFiber;return existing;}}function createChild(returnFiber,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nvar created=createFiberFromText(''+newChild,returnFiber.mode,lanes);created.return=returnFiber;return created;}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,lanes);_created.ref=coerceRef(returnFiber,null,newChild);_created.return=returnFiber;return _created;}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,lanes);_created2.return=returnFiber;return _created2;}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return createChild(returnFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,lanes,null);_created3.return=returnFiber;return _created3;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateSlot(returnFiber,oldFiber,newChild,lanes){// Update the fiber if the keys match, otherwise return null.\nvar key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nif(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,lanes);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){return updateElement(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return updateSlot(returnFiber,oldFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor\n// new node for the key. If both are text nodes, they match.\nvar matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,lanes);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateElement(returnFiber,_matchedFiber,newChild,lanes);}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,lanes);}case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;return updateFromMap(existingChildren,returnFiber,newIdx,init(payload),lanes);}if(isArray(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber3,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}/**\n   * Warns if there is a duplicate or missing key\n   */function warnOnInvalidKey(child,knownKeys,returnFiber){{if(typeof child!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child,returnFiber);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}error('Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted  the behavior is unsupported and '+'could change in a future version.',key);break;case REACT_LAZY_TYPE:var payload=child._payload;var init=child._init;warnOnInvalidKey(init(payload),knownKeys,returnFiber);break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes){// This algorithm can't optimize by searching from both ends since we\n// don't have backpointers on fibers. I'm trying to see how far we can get\n// with that model. If it ends up not being worth the tradeoffs, we can\n// add it later.\n// Even with a two ended optimization, we'd want to optimize for the case\n// where there are few changes and brute force the comparison instead of\n// going for the Map. It'd like to explore hitting that path first in\n// forward-only mode and only go for the Map once we notice that we need\n// lots of look ahead. This doesn't handle reversal as well as two ended\n// search but that's unusual. Besides, for the two ended optimization to\n// work on Iterables, we'd need to copy the whole set.\n// In this first iteration, we'll just live with hitting the bad case\n// (adding everything to a Map) in for every insert/move.\n// If you change this code, also update reconcileChildrenIterator() which\n// uses the same algorithm.\n{// First, validate keys.\nvar knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],lanes);if(_newFiber===null){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}if(getIsHydrating()){var _numberOfForks=newIdx;pushTreeFork(returnFiber,_numberOfForks);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],lanes);if(_newFiber2!==null){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren.delete(_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks2=newIdx;pushTreeFork(returnFiber,_numberOfForks2);}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,lanes){// This is the same implementation as reconcileChildrenArray(),\n// but using the iterator instead.\nvar iteratorFn=getIteratorFn(newChildrenIterable);if(typeof iteratorFn!=='function'){throw new Error('An object is not an iterable. This error is likely caused by a bug in '+'React. Please file an issue.');}{// We don't support rendering Generators because it's a mutation.\n// See https://github.com/facebook/react/issues/12995\nif(typeof Symbol==='function'&&// $FlowFixMe Flow doesn't know about toStringTag\nnewChildrenIterable[Symbol.toStringTag]==='Generator'){if(!didWarnAboutGenerators){error('Using Generators as children is unsupported and will likely yield '+'unexpected results because enumerating a generator mutates it. '+'You may convert it to an array with `Array.from()` or the '+'`[...spread]` operator before rendering. Keep in mind '+'you might need to polyfill these features for older browsers.');}didWarnAboutGenerators=true;}// Warn about using Maps as children\nif(newChildrenIterable.entries===iteratorFn){if(!didWarnAboutMaps){error('Using Maps as children is not supported. '+'Use an array of keyed ReactElements instead.');}didWarnAboutMaps=true;}// First, validate keys.\n// We'll get a different iterator later for the main pass.\nvar _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}}var newChildren=iteratorFn.call(newChildrenIterable);if(newChildren==null){throw new Error('An iterable object provided no iterator.');}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,lanes);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}if(getIsHydrating()){var _numberOfForks3=newIdx;pushTreeFork(returnFiber,_numberOfForks3);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,lanes);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren.delete(_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks4=newIdx;pushTreeFork(returnFiber,_numberOfForks4);}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,lanes){// There's no need to check for keys on text nodes since we don't have a\n// way to define them.\nif(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete\n// the rest.\ndeleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent);existing.return=returnFiber;return existing;}// The existing first child is not a text node so we need to create one\n// and delete the existing ones.\ndeleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,lanes);created.return=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,lanes){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){if(child.tag===Fragment){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.props.children);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}else{if(child.elementType===elementType||// Keep this check inline so it only runs on the false path:\nisCompatibleFamilyForHotReloading(child,element)||// Lazy types should reconcile their resolved type.\n// We need to do this after the Hot Reloading check above,\n// because hot reloading has different semantics than prod because\n// it doesn't resuspend. So we can't let the call below suspend.\ntypeof elementType==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===child.type){deleteRemainingChildren(returnFiber,child.sibling);var _existing=useFiber(child,element.props);_existing.ref=coerceRef(returnFiber,child,element);_existing.return=returnFiber;{_existing._debugSource=element._source;_existing._debugOwner=element._owner;}return _existing;}}// Didn't match.\ndeleteRemainingChildren(returnFiber,child);break;}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,lanes,element.key);created.return=returnFiber;return created;}else{var _created4=createFiberFromElement(element,returnFiber.mode,lanes);_created4.ref=coerceRef(returnFiber,currentFirstChild,element);_created4.return=returnFiber;return _created4;}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,lanes){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[]);existing.return=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.mode,lanes);created.return=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation\n// itself. They will be added to the side-effect list as we pass through the\n// children and the parent.\nfunction reconcileChildFibers(returnFiber,currentFirstChild,newChild,lanes){// This function is not recursive.\n// If the top level item is an array, we treat it as a set of children,\n// not as a fragment. Nested arrays on the other hand will be treated as\n// fragment nodes. Recursion happens at the normal flow.\n// Handle top level unkeyed fragments as if they were arrays.\n// This leads to an ambiguity between <>{[...]}</> and <>...</>.\n// We treat the ambiguous cases above the same.\nvar isUnkeyedTopLevelFragment=typeof newChild==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment){newChild=newChild.props.children;}// Handle object types\nif(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,lanes));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,lanes));case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;// TODO: This function is supposed to be non-recursive.\nreturn reconcileChildFibers(returnFiber,currentFirstChild,init(payload),lanes);}if(isArray(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,lanes);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes);}throwOnInvalidObjectType(returnFiber,newChild);}if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,lanes));}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}// Remaining cases are all treated as empty.\nreturn deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){if(current!==null&&workInProgress.child!==current.child){throw new Error('Resuming work not yet implemented.');}if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps);workInProgress.child=newChild;newChild.return=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps);newChild.return=workInProgress;}newChild.sibling=null;}// Reset a workInProgress child set to prepare it for a second pass.\nfunction resetChildFibers(workInProgress,lanes){var child=workInProgress.child;while(child!==null){resetWorkInProgress(child,lanes);child=child.sibling;}}var valueCursor=createCursor(null);var rendererSigil;{// Use this to detect multiple renderers using the same context\nrendererSigil={};}var currentlyRenderingFiber=null;var lastContextDependency=null;var lastFullyObservedContext=null;var isDisallowedContextReadInDEV=false;function resetContextDependencies(){// This is called right before React yields execution, to ensure `readContext`\n// cannot be called outside the render phase.\ncurrentlyRenderingFiber=null;lastContextDependency=null;lastFullyObservedContext=null;{isDisallowedContextReadInDEV=false;}}function enterDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=true;}}function exitDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=false;}}function pushProvider(providerFiber,context,nextValue){{push(valueCursor,context._currentValue,providerFiber);context._currentValue=nextValue;{if(context._currentRenderer!==undefined&&context._currentRenderer!==null&&context._currentRenderer!==rendererSigil){error('Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.');}context._currentRenderer=rendererSigil;}}}function popProvider(context,providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber);{{context._currentValue=currentValue;}}}function scheduleContextWorkOnParentPath(parent,renderLanes,propagationRoot){// Update the child lanes of all the ancestors, including the alternates.\nvar node=parent;while(node!==null){var alternate=node.alternate;if(!isSubsetOfLanes(node.childLanes,renderLanes)){node.childLanes=mergeLanes(node.childLanes,renderLanes);if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}}else if(alternate!==null&&!isSubsetOfLanes(alternate.childLanes,renderLanes)){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}if(node===propagationRoot){break;}node=node.return;}{if(node!==propagationRoot){error('Expected to find the propagation root when scheduling context work. '+'This error is likely caused by a bug in React. Please file an issue.');}}}function propagateContextChange(workInProgress,context,renderLanes){{propagateContextChange_eager(workInProgress,context,renderLanes);}}function propagateContextChange_eager(workInProgress,context,renderLanes){var fiber=workInProgress.child;if(fiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nfiber.return=workInProgress;}while(fiber!==null){var nextFiber=void 0;// Visit this fiber.\nvar list=fiber.dependencies;if(list!==null){nextFiber=fiber.child;var dependency=list.firstContext;while(dependency!==null){// Check if the context matches.\nif(dependency.context===context){// Match! Schedule an update on this fiber.\nif(fiber.tag===ClassComponent){// Schedule a force update on the work-in-progress.\nvar lane=pickArbitraryLane(renderLanes);var update=createUpdate(NoTimestamp,lane);update.tag=ForceUpdate;// TODO: Because we don't have a work-in-progress, this will add the\n// update to the current fiber, too, which means it will persist even if\n// this render is thrown away. Since it's a race condition, not sure it's\n// worth fixing.\n// Inlined `enqueueUpdate` to remove interleaved update check\nvar updateQueue=fiber.updateQueue;if(updateQueue===null);else{var sharedQueue=updateQueue.shared;var pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;}}fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber.return,renderLanes,workInProgress);// Mark the updated lanes on the list, too.\nlist.lanes=mergeLanes(list.lanes,renderLanes);// Since we already found a match, we can stop traversing the\n// dependency list.\nbreak;}dependency=dependency.next;}}else if(fiber.tag===ContextProvider){// Don't scan deeper if this is a matching provider\nnextFiber=fiber.type===workInProgress.type?null:fiber.child;}else if(fiber.tag===DehydratedFragment){// If a dehydrated suspense boundary is in this subtree, we don't know\n// if it will have any context consumers in it. The best we can do is\n// mark it as having updates.\nvar parentSuspense=fiber.return;if(parentSuspense===null){throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');}parentSuspense.lanes=mergeLanes(parentSuspense.lanes,renderLanes);var _alternate=parentSuspense.alternate;if(_alternate!==null){_alternate.lanes=mergeLanes(_alternate.lanes,renderLanes);}// This is intentionally passing this fiber as the parent\n// because we want to schedule this fiber as having work\n// on its children. We'll use the childLanes on\n// this fiber to indicate that a context has changed.\nscheduleContextWorkOnParentPath(parentSuspense,renderLanes,workInProgress);nextFiber=fiber.sibling;}else{// Traverse down.\nnextFiber=fiber.child;}if(nextFiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nnextFiber.return=fiber;}else{// No child. Traverse to next sibling.\nnextFiber=fiber;while(nextFiber!==null){if(nextFiber===workInProgress){// We're back to the root of this subtree. Exit.\nnextFiber=null;break;}var sibling=nextFiber.sibling;if(sibling!==null){// Set the return pointer of the sibling to the work-in-progress fiber.\nsibling.return=nextFiber.return;nextFiber=sibling;break;}// No more siblings. Traverse up.\nnextFiber=nextFiber.return;}}fiber=nextFiber;}}function prepareToReadContext(workInProgress,renderLanes){currentlyRenderingFiber=workInProgress;lastContextDependency=null;lastFullyObservedContext=null;var dependencies=workInProgress.dependencies;if(dependencies!==null){{var firstContext=dependencies.firstContext;if(firstContext!==null){if(includesSomeLane(dependencies.lanes,renderLanes)){// Context list has a pending update. Mark that this fiber performed work.\nmarkWorkInProgressReceivedUpdate();}// Reset the work-in-progress list\ndependencies.firstContext=null;}}}}function readContext(context){{// This warning would fire if you read context inside a Hook like useMemo.\n// Unlike the class check below, it's not enforced in production for perf.\nif(isDisallowedContextReadInDEV){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}}var value=context._currentValue;if(lastFullyObservedContext===context);else{var contextItem={context:context,memoizedValue:value,next:null};if(lastContextDependency===null){if(currentlyRenderingFiber===null){throw new Error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}// This is the first dependency for this component. Create a new list.\nlastContextDependency=contextItem;currentlyRenderingFiber.dependencies={lanes:NoLanes,firstContext:contextItem};}else{// Append a new context item.\nlastContextDependency=lastContextDependency.next=contextItem;}}return value;}// render. When this render exits, either because it finishes or because it is\n// interrupted, the interleaved updates will be transferred onto the main part\n// of the queue.\nvar concurrentQueues=null;function pushConcurrentUpdateQueue(queue){if(concurrentQueues===null){concurrentQueues=[queue];}else{concurrentQueues.push(queue);}}function finishQueueingConcurrentUpdates(){// Transfer the interleaved updates onto the main queue. Each queue has a\n// `pending` field and an `interleaved` field. When they are not null, they\n// point to the last node in a circular linked list. We need to append the\n// interleaved list to the end of the pending list by joining them into a\n// single, circular list.\nif(concurrentQueues!==null){for(var i=0;i<concurrentQueues.length;i++){var queue=concurrentQueues[i];var lastInterleavedUpdate=queue.interleaved;if(lastInterleavedUpdate!==null){queue.interleaved=null;var firstInterleavedUpdate=lastInterleavedUpdate.next;var lastPendingUpdate=queue.pending;if(lastPendingUpdate!==null){var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=firstInterleavedUpdate;lastInterleavedUpdate.next=firstPendingUpdate;}queue.pending=lastInterleavedUpdate;}}concurrentQueues=null;}}function enqueueConcurrentHookUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;}function enqueueConcurrentClassUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentRenderForLane(fiber,lane){return markUpdateLaneFromFiberToRoot(fiber,lane);}// Calling this function outside this module should only be done for backwards\n// compatibility and should always be accompanied by a warning.\nvar unsafe_markUpdateLaneFromFiberToRoot=markUpdateLaneFromFiberToRoot;function markUpdateLaneFromFiberToRoot(sourceFiber,lane){// Update the source fiber's lanes\nsourceFiber.lanes=mergeLanes(sourceFiber.lanes,lane);var alternate=sourceFiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,lane);}{if(alternate===null&&(sourceFiber.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}// Walk the parent path to the root and update the child lanes.\nvar node=sourceFiber;var parent=sourceFiber.return;while(parent!==null){parent.childLanes=mergeLanes(parent.childLanes,lane);alternate=parent.alternate;if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,lane);}else{{if((parent.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}}node=parent;parent=parent.return;}if(node.tag===HostRoot){var root=node.stateNode;return root;}else{return null;}}var UpdateState=0;var ReplaceState=1;var ForceUpdate=2;var CaptureUpdate=3;// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nvar hasForceUpdate=false;var didWarnUpdateInsideUpdate;var currentlyProcessingQueue;{didWarnUpdateInsideUpdate=false;currentlyProcessingQueue=null;}function initializeUpdateQueue(fiber){var queue={baseState:fiber.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:NoLanes},effects:null};fiber.updateQueue=queue;}function cloneUpdateQueue(current,workInProgress){// Clone the update queue from current. Unless it's already a clone.\nvar queue=workInProgress.updateQueue;var currentQueue=current.updateQueue;if(queue===currentQueue){var clone={baseState:currentQueue.baseState,firstBaseUpdate:currentQueue.firstBaseUpdate,lastBaseUpdate:currentQueue.lastBaseUpdate,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=clone;}}function createUpdate(eventTime,lane){var update={eventTime:eventTime,lane:lane,tag:UpdateState,payload:null,callback:null,next:null};return update;}function enqueueUpdate(fiber,update,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\nreturn null;}var sharedQueue=updateQueue.shared;{if(currentlyProcessingQueue===sharedQueue&&!didWarnUpdateInsideUpdate){error('An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}if(isUnsafeClassRenderPhaseUpdate()){// This is an unsafe render phase update. Add directly to the update\n// queue so we can process it immediately during the current render.\nvar pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;// Update the childLanes even though we're most likely already rendering\n// this fiber. This is for backwards compatibility in the case where you\n// update a different component during render phase than the one that is\n// currently renderings (a pattern that is accompanied by a warning).\nreturn unsafe_markUpdateLaneFromFiberToRoot(fiber,lane);}else{return enqueueConcurrentClassUpdate(fiber,sharedQueue,update,lane);}}function entangleTransitions(root,fiber,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\nreturn;}var sharedQueue=updateQueue.shared;if(isTransitionLane(lane)){var queueLanes=sharedQueue.lanes;// If any entangled lanes are no longer pending on the root, then they must\n// have finished. We can remove them from the shared queue, which represents\n// a superset of the actually pending lanes. In some cases we may entangle\n// more than we need to, but that's OK. In fact it's worse if we *don't*\n// entangle when we should.\nqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\nvar newQueueLanes=mergeLanes(queueLanes,lane);sharedQueue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n// the lane finished since the last time we entangled it. So we need to\n// entangle it again, just to be sure.\nmarkRootEntangled(root,newQueueLanes);}}function enqueueCapturedUpdate(workInProgress,capturedUpdate){// Captured updates are updates that are thrown by a child during the render\n// phase. They should be discarded if the render is aborted. Therefore,\n// we should only put them on the work-in-progress queue, not the current one.\nvar queue=workInProgress.updateQueue;// Check if the work-in-progress queue is a clone.\nvar current=workInProgress.alternate;if(current!==null){var currentQueue=current.updateQueue;if(queue===currentQueue){// The work-in-progress queue is the same as current. This happens when\n// we bail out on a parent fiber that then captures an error thrown by\n// a child. Since we want to append the update only to the work-in\n// -progress queue, we need to clone the updates. We usually clone during\n// processUpdateQueue, but that didn't happen in this case because we\n// skipped over the parent when we bailed out.\nvar newFirst=null;var newLast=null;var firstBaseUpdate=queue.firstBaseUpdate;if(firstBaseUpdate!==null){// Loop through the updates and clone them.\nvar update=firstBaseUpdate;do{var clone={eventTime:update.eventTime,lane:update.lane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLast===null){newFirst=newLast=clone;}else{newLast.next=clone;newLast=clone;}update=update.next;}while(update!==null);// Append the captured update the end of the cloned list.\nif(newLast===null){newFirst=newLast=capturedUpdate;}else{newLast.next=capturedUpdate;newLast=capturedUpdate;}}else{// There are no base updates.\nnewFirst=newLast=capturedUpdate;}queue={baseState:currentQueue.baseState,firstBaseUpdate:newFirst,lastBaseUpdate:newLast,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=queue;return;}}// Append the update to the end of the list.\nvar lastBaseUpdate=queue.lastBaseUpdate;if(lastBaseUpdate===null){queue.firstBaseUpdate=capturedUpdate;}else{lastBaseUpdate.next=capturedUpdate;}queue.lastBaseUpdate=capturedUpdate;}function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var payload=update.payload;if(typeof payload==='function'){// Updater function\n{enterDisallowedContextReadInDEV();}var nextState=payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}return nextState;}// State object\nreturn payload;}case CaptureUpdate:{workInProgress.flags=workInProgress.flags&~ShouldCapture|DidCapture;}// Intentional fallthrough\ncase UpdateState:{var _payload=update.payload;var partialState;if(typeof _payload==='function'){// Updater function\n{enterDisallowedContextReadInDEV();}partialState=_payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{_payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}}else{// Partial state object\npartialState=_payload;}if(partialState===null||partialState===undefined){// Null and undefined are treated as no-ops.\nreturn prevState;}// Merge the partial state and the previous state.\nreturn assign({},prevState,partialState);}case ForceUpdate:{hasForceUpdate=true;return prevState;}}return prevState;}function processUpdateQueue(workInProgress,props,instance,renderLanes){// This is always non-null on a ClassComponent or HostRoot\nvar queue=workInProgress.updateQueue;hasForceUpdate=false;{currentlyProcessingQueue=queue.shared;}var firstBaseUpdate=queue.firstBaseUpdate;var lastBaseUpdate=queue.lastBaseUpdate;// Check if there are pending updates. If so, transfer them to the base queue.\nvar pendingQueue=queue.shared.pending;if(pendingQueue!==null){queue.shared.pending=null;// The pending queue is circular. Disconnect the pointer between first\n// and last so that it's non-circular.\nvar lastPendingUpdate=pendingQueue;var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=null;// Append pending updates to base queue\nif(lastBaseUpdate===null){firstBaseUpdate=firstPendingUpdate;}else{lastBaseUpdate.next=firstPendingUpdate;}lastBaseUpdate=lastPendingUpdate;// If there's a current queue, and it's different from the base queue, then\n// we need to transfer the updates to that queue, too. Because the base\n// queue is a singly-linked list with no cycles, we can append to both\n// lists and take advantage of structural sharing.\n// TODO: Pass `current` as argument\nvar current=workInProgress.alternate;if(current!==null){// This is always non-null on a ClassComponent or HostRoot\nvar currentQueue=current.updateQueue;var currentLastBaseUpdate=currentQueue.lastBaseUpdate;if(currentLastBaseUpdate!==lastBaseUpdate){if(currentLastBaseUpdate===null){currentQueue.firstBaseUpdate=firstPendingUpdate;}else{currentLastBaseUpdate.next=firstPendingUpdate;}currentQueue.lastBaseUpdate=lastPendingUpdate;}}}// These values may change as we process the queue.\nif(firstBaseUpdate!==null){// Iterate through the list of updates to compute the result.\nvar newState=queue.baseState;// TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n// from the original lanes.\nvar newLanes=NoLanes;var newBaseState=null;var newFirstBaseUpdate=null;var newLastBaseUpdate=null;var update=firstBaseUpdate;do{var updateLane=update.lane;var updateEventTime=update.eventTime;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n// skipped update, the previous update/state is the new base\n// update/state.\nvar clone={eventTime:updateEventTime,lane:updateLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLastBaseUpdate===null){newFirstBaseUpdate=newLastBaseUpdate=clone;newBaseState=newState;}else{newLastBaseUpdate=newLastBaseUpdate.next=clone;}// Update the remaining priority in the queue.\nnewLanes=mergeLanes(newLanes,updateLane);}else{// This update does have sufficient priority.\nif(newLastBaseUpdate!==null){var _clone={eventTime:updateEventTime,// This update is going to be committed so we never want uncommit\n// it. Using NoLane works because 0 is a subset of all bitmasks, so\n// this will never be skipped by the check above.\nlane:NoLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLastBaseUpdate=newLastBaseUpdate.next=_clone;}// Process this update.\nnewState=getStateFromUpdate(workInProgress,queue,update,newState,props,instance);var callback=update.callback;if(callback!==null&&// If the update was already committed, we should not queue its\n// callback again.\nupdate.lane!==NoLane){workInProgress.flags|=Callback;var effects=queue.effects;if(effects===null){queue.effects=[update];}else{effects.push(update);}}}update=update.next;if(update===null){pendingQueue=queue.shared.pending;if(pendingQueue===null){break;}else{// An update was scheduled from inside a reducer. Add the new\n// pending updates to the end of the list and keep processing.\nvar _lastPendingUpdate=pendingQueue;// Intentionally unsound. Pending updates form a circular list, but we\n// unravel them when transferring them to the base queue.\nvar _firstPendingUpdate=_lastPendingUpdate.next;_lastPendingUpdate.next=null;update=_firstPendingUpdate;queue.lastBaseUpdate=_lastPendingUpdate;queue.shared.pending=null;}}}while(true);if(newLastBaseUpdate===null){newBaseState=newState;}queue.baseState=newBaseState;queue.firstBaseUpdate=newFirstBaseUpdate;queue.lastBaseUpdate=newLastBaseUpdate;// Interleaved updates are stored on a separate queue. We aren't going to\n// process them during this render, but we do need to track which lanes\n// are remaining.\nvar lastInterleaved=queue.shared.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{newLanes=mergeLanes(newLanes,interleaved.lane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(firstBaseUpdate===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n// zero once the queue is empty.\nqueue.shared.lanes=NoLanes;}// Set the remaining expiration time to be whatever is remaining in the queue.\n// This should be fine because the only two other things that contribute to\n// expiration time are props and context. We're already in the middle of the\n// begin phase by the time we start processing the queue, so we've already\n// dealt with the props. Context in components that specify\n// shouldComponentUpdate is tricky; but we'll have to account for\n// that regardless.\nmarkSkippedUpdateLanes(newLanes);workInProgress.lanes=newLanes;workInProgress.memoizedState=newState;}{currentlyProcessingQueue=null;}}function callCallback(callback,context){if(typeof callback!=='function'){throw new Error('Invalid argument passed as callback. Expected a function. Instead '+(\"received: \"+callback));}callback.call(context);}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=false;}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate;}function commitUpdateQueue(finishedWork,finishedQueue,instance){// Commit the effects\nvar effects=finishedQueue.effects;finishedQueue.effects=null;if(effects!==null){for(var i=0;i<effects.length;i++){var effect=effects[i];var callback=effect.callback;if(callback!==null){effect.callback=null;callCallback(callback,instance);}}}}var NO_CONTEXT={};var contextStackCursor$1=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){if(c===NO_CONTEXT){throw new Error('Expected host context to exist. This error is likely caused by a bug '+'in React. Please file an issue.');}return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;\n// This allows us to reset root when portals are popped.\npush(rootInstanceStackCursor,nextRootInstance,fiber);// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);// Finally, we need to push the host context to the stack.\n// However, we can't just call getRootHostContext() and push it because\n// we'd have a different number of entries on the stack depending on\n// whether getRootHostContext() throws somewhere in renderer code or not.\n// So we push an empty value first. This lets us safely unwind on errors.\npush(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Now that we know this function doesn't throw, replace it.\npop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor$1.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor$1.current);var nextContext=getChildHostContext(context,fiber.type);// Don't push this Fiber's context unless it's unique.\nif(context===nextContext){return;}// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.\n// pushHostContext() only pushes Fibers that provide unique contexts.\nif(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);}var DefaultSuspenseContext=0;// The Suspense Context is split into two parts. The lower bits is\n// inherited deeply down the subtree. The upper bits only affect\n// this immediate suspense boundary and gets reset each new\n// boundary or suspense list.\nvar SubtreeSuspenseContextMask=1;// Subtree Flags:\n// InvisibleParentSuspenseContext indicates that one of our parent Suspense\n// boundaries is not currently showing visible main content.\n// Either because it is already showing a fallback or is not mounted at all.\n// We can use this to determine if it is desirable to trigger a fallback at\n// the parent. If not, then we might need to trigger undesirable boundaries\n// and/or suspend the commit to avoid hiding the parent content.\nvar InvisibleParentSuspenseContext=1;// Shallow Flags:\n// ForceSuspenseFallback can be used by SuspenseList to force newly added\n// items into their fallback state during one of the render passes.\nvar ForceSuspenseFallback=2;var suspenseStackCursor=createCursor(DefaultSuspenseContext);function hasSuspenseContext(parentContext,flag){return(parentContext&flag)!==0;}function setDefaultShallowSuspenseContext(parentContext){return parentContext&SubtreeSuspenseContextMask;}function setShallowSuspenseContext(parentContext,shallowContext){return parentContext&SubtreeSuspenseContextMask|shallowContext;}function addSubtreeSuspenseContext(parentContext,subtreeContext){return parentContext|subtreeContext;}function pushSuspenseContext(fiber,newContext){push(suspenseStackCursor,newContext,fiber);}function popSuspenseContext(fiber){pop(suspenseStackCursor,fiber);}function shouldCaptureSuspense(workInProgress,hasInvisibleParent){// If it was the primary children that just suspended, capture and render the\n// fallback. Otherwise, don't capture and bubble to the next boundary.\nvar nextState=workInProgress.memoizedState;if(nextState!==null){if(nextState.dehydrated!==null){// A dehydrated boundary always captures.\nreturn true;}return false;}var props=workInProgress.memoizedProps;// Regular boundaries always capture.\n{return true;}// If it's a boundary we should avoid, then we prefer to bubble up to the\n}function findFirstSuspended(row){var node=row;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){var dehydrated=state.dehydrated;if(dehydrated===null||isSuspenseInstancePending(dehydrated)||isSuspenseInstanceFallback(dehydrated)){return node;}}}else if(node.tag===SuspenseListComponent&&// revealOrder undefined can't be trusted because it don't\n// keep track of whether it suspended or not.\nnode.memoizedProps.revealOrder!==undefined){var didSuspend=(node.flags&DidCapture)!==NoFlags;if(didSuspend){return node;}}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===row){return null;}while(node.sibling===null){if(node.return===null||node.return===row){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}return null;}var NoFlags$1=/*   */0;// Represents whether effect should fire.\nvar HasEffect=/* */1;// Represents the phase in which the effect (not the clean-up) fires.\nvar Insertion=/*  */2;var Layout=/*    */4;var Passive$1=/*   */8;// and should be reset before starting a new render.\n// This tracks which mutable sources need to be reset after a render.\nvar workInProgressSources=[];function resetWorkInProgressVersions(){for(var i=0;i<workInProgressSources.length;i++){var mutableSource=workInProgressSources[i];{mutableSource._workInProgressVersionPrimary=null;}}workInProgressSources.length=0;}// This ensures that the version used for server rendering matches the one\n// that is eventually read during hydration.\n// If they don't match there's a potential tear and a full deopt render is required.\nfunction registerMutableSourceForHydration(root,mutableSource){var getVersion=mutableSource._getVersion;var version=getVersion(mutableSource._source);// TODO Clear this data once all pending hydration work is finished.\n// Retaining it forever may interfere with GC.\nif(root.mutableSourceEagerHydrationData==null){root.mutableSourceEagerHydrationData=[mutableSource,version];}else{root.mutableSourceEagerHydrationData.push(mutableSource,version);}}var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentBatchConfig$2=ReactSharedInternals.ReactCurrentBatchConfig;var didWarnAboutMismatchedHooksForComponent;var didWarnUncachedGetSnapshot;{didWarnAboutMismatchedHooksForComponent=new Set();}// These are set right before calling the component.\nvar renderLanes=NoLanes;// The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\nvar currentlyRenderingFiber$1=null;// Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\nvar currentHook=null;var workInProgressHook=null;// Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\nvar didScheduleRenderPhaseUpdate=false;// Where an update was scheduled only during the current render pass. This\n// gets reset after each attempt.\n// TODO: Maybe there's some way to consolidate this with\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\nvar didScheduleRenderPhaseUpdateDuringThisPass=false;// Counts the number of useId hooks in this component.\nvar localIdCounter=0;// Used for ids that are generated completely client-side (i.e. not during\n// hydration). This counter is global, so client ids are not stable across\n// render attempts.\nvar globalClientIdCounter=0;var RE_RENDER_LIMIT=25;// In DEV, this is the name of the currently executing primitive hook\nvar currentHookNameInDev=null;// In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\nvar hookTypesDev=null;var hookTypesUpdateIndexDev=-1;// In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\nvar ignorePreviousDependencies=false;function mountHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev===null){hookTypesDev=[hookName];}else{hookTypesDev.push(hookName);}}}function updateHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev!==null){hookTypesUpdateIndexDev++;if(hookTypesDev[hookTypesUpdateIndexDev]!==hookName){warnOnHookMismatchInDev(hookName);}}}}function checkDepsAreArrayDev(deps){{if(deps!==undefined&&deps!==null&&!isArray(deps)){// Verify deps, but only on mount to avoid extra checks.\n// It's unlikely their type would change as usually you define them inline.\nerror('%s received a final argument that is not an array (instead, received `%s`). When '+'specified, the final argument must be an array.',currentHookNameInDev,typeof deps);}}}function warnOnHookMismatchInDev(currentHookName){{var componentName=getComponentNameFromFiber(currentlyRenderingFiber$1);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)){didWarnAboutMismatchedHooksForComponent.add(componentName);if(hookTypesDev!==null){var table='';var secondColumnStart=30;for(var i=0;i<=hookTypesUpdateIndexDev;i++){var oldHookName=hookTypesDev[i];var newHookName=i===hookTypesUpdateIndexDev?currentHookName:oldHookName;var row=i+1+\". \"+oldHookName;// Extra space so second column lines up\n// lol @ IE not supporting String#repeat\nwhile(row.length<secondColumnStart){row+=' ';}row+=newHookName+'\\n';table+=row;}error('React has detected a change in the order of Hooks called by %s. '+'This will lead to bugs and errors if not fixed. '+'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n'+'   Previous render            Next render\\n'+'   ------------------------------------------------------\\n'+'%s'+'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n',componentName,table);}}}}function throwInvalidHookError(){throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for'+' one of the following reasons:\\n'+'1. You might have mismatching versions of React and the renderer (such as React DOM)\\n'+'2. You might be breaking the Rules of Hooks\\n'+'3. You might have more than one copy of React in the same app\\n'+'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');}function areHookInputsEqual(nextDeps,prevDeps){{if(ignorePreviousDependencies){// Only true when this component is being hot reloaded.\nreturn false;}}if(prevDeps===null){{error('%s received a final argument during this render, but not during '+'the previous render. Even though the final argument is optional, '+'its type cannot change between renders.',currentHookNameInDev);}return false;}{// Don't bother comparing lengths in prod because these arrays should be\n// passed inline.\nif(nextDeps.length!==prevDeps.length){error('The final argument passed to %s changed size between renders. The '+'order and size of this array must remain constant.\\n\\n'+'Previous: %s\\n'+'Incoming: %s',currentHookNameInDev,\"[\"+prevDeps.join(', ')+\"]\",\"[\"+nextDeps.join(', ')+\"]\");}}for(var i=0;i<prevDeps.length&&i<nextDeps.length;i++){if(objectIs(nextDeps[i],prevDeps[i])){continue;}return false;}return true;}function renderWithHooks(current,workInProgress,Component,props,secondArg,nextRenderLanes){renderLanes=nextRenderLanes;currentlyRenderingFiber$1=workInProgress;{hookTypesDev=current!==null?current._debugHookTypes:null;hookTypesUpdateIndexDev=-1;// Used for hot reloading:\nignorePreviousDependencies=current!==null&&current.type!==workInProgress.type;}workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.lanes=NoLanes;// The following should have already been reset\n// currentHook = null;\n// workInProgressHook = null;\n// didScheduleRenderPhaseUpdate = false;\n// localIdCounter = 0;\n// TODO Warn if no hooks are used at all during mount, then some are used during update.\n// Currently we will identify the update render as a mount because memoizedState === null.\n// This is tricky because it's valid for certain types of components (e.g. React.lazy)\n// Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n// Non-stateful hooks (e.g. context) don't get added to memoizedState,\n// so memoizedState would be null during updates and mounts.\n{if(current!==null&&current.memoizedState!==null){ReactCurrentDispatcher$1.current=HooksDispatcherOnUpdateInDEV;}else if(hookTypesDev!==null){// This dispatcher handles an edge case where a component is updating,\n// but no stateful hooks have been used.\n// We want to match the production code behavior (which will use HooksDispatcherOnMount),\n// but with the extra DEV validation to ensure hooks ordering hasn't changed.\n// This dispatcher does that.\nReactCurrentDispatcher$1.current=HooksDispatcherOnMountWithHookTypesInDEV;}else{ReactCurrentDispatcher$1.current=HooksDispatcherOnMountInDEV;}}var children=Component(props,secondArg);// Check if there was a render phase update\nif(didScheduleRenderPhaseUpdateDuringThisPass){// Keep rendering in a loop for as long as render phase updates continue to\n// be scheduled. Use a counter to prevent infinite loops.\nvar numberOfReRenders=0;do{didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;if(numberOfReRenders>=RE_RENDER_LIMIT){throw new Error('Too many re-renders. React limits the number of renders to prevent '+'an infinite loop.');}numberOfReRenders+=1;{// Even when hot reloading, allow dependencies to stabilize\n// after first render to prevent infinite render phase updates.\nignorePreviousDependencies=false;}// Start over from the beginning of the list\ncurrentHook=null;workInProgressHook=null;workInProgress.updateQueue=null;{// Also validate hook order for cascading updates.\nhookTypesUpdateIndexDev=-1;}ReactCurrentDispatcher$1.current=HooksDispatcherOnRerenderInDEV;children=Component(props,secondArg);}while(didScheduleRenderPhaseUpdateDuringThisPass);}// We can assume the previous dispatcher is always this one, since we set it\n// at the beginning of the render phase and there's no re-entrance.\nReactCurrentDispatcher$1.current=ContextOnlyDispatcher;{workInProgress._debugHookTypes=hookTypesDev;}// This check uses currentHook so that it works the same in DEV and prod bundles.\n// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\nvar didRenderTooFewHooks=currentHook!==null&&currentHook.next!==null;renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{currentHookNameInDev=null;hookTypesDev=null;hookTypesUpdateIndexDev=-1;// Confirm that a static flag was not added or removed since the last\n// render. If this fires, it suggests that we incorrectly reset the static\n// flags in some other part of the codebase. This has happened before, for\n// example, in the SuspenseList implementation.\nif(current!==null&&(current.flags&StaticMask)!==(workInProgress.flags&StaticMask)&&// Disable this warning in legacy mode, because legacy Suspense is weird\n// and creates false positives. To make this work in legacy mode, we'd\n// need to mark fibers that commit in an incomplete state, somehow. For\n// now I'll disable the warning that most of the bugs that would trigger\n// it are either exclusive to concurrent mode or exist in both.\n(current.mode&ConcurrentMode)!==NoMode){error('Internal React error: Expected static flag was missing. Please '+'notify the React team.');}}didScheduleRenderPhaseUpdate=false;// This is reset by checkDidRenderIdHook\n// localIdCounter = 0;\nif(didRenderTooFewHooks){throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental '+'early return statement.');}return children;}function checkDidRenderIdHook(){// This should be called immediately after every renderWithHooks call.\n// Conceptually, it's part of the return value of renderWithHooks; it's only a\n// separate function to avoid using an array tuple.\nvar didRenderIdHook=localIdCounter!==0;localIdCounter=0;return didRenderIdHook;}function bailoutHooks(current,workInProgress,lanes){workInProgress.updateQueue=current.updateQueue;// TODO: Don't need to reset the flags here, because they're reset in the\n// complete phase (bubbleProperties).\nif((workInProgress.mode&StrictEffectsMode)!==NoMode){workInProgress.flags&=~(MountPassiveDev|MountLayoutDev|Passive|Update);}else{workInProgress.flags&=~(Passive|Update);}current.lanes=removeLanes(current.lanes,lanes);}function resetHooksAfterThrow(){// We can assume the previous dispatcher is always this one, since we set it\n// at the beginning of the render phase and there's no re-entrance.\nReactCurrentDispatcher$1.current=ContextOnlyDispatcher;if(didScheduleRenderPhaseUpdate){// There were render phase updates. These are only valid for this render\n// phase, which we are now aborting. Remove the updates from the queues so\n// they do not persist to the next render. Do not remove updates from hooks\n// that weren't processed.\n//\n// Only reset the updates from the queue if it has a clone. If it does\n// not have a clone, that means it wasn't processed, and the updates were\n// scheduled before we entered the render phase.\nvar hook=currentlyRenderingFiber$1.memoizedState;while(hook!==null){var queue=hook.queue;if(queue!==null){queue.pending=null;}hook=hook.next;}didScheduleRenderPhaseUpdate=false;}renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{hookTypesDev=null;hookTypesUpdateIndexDev=-1;currentHookNameInDev=null;isUpdatingOpaqueValueInRenderPhase=false;}didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};if(workInProgressHook===null){// This is the first hook in the list\ncurrentlyRenderingFiber$1.memoizedState=workInProgressHook=hook;}else{// Append to the end of the list\nworkInProgressHook=workInProgressHook.next=hook;}return workInProgressHook;}function updateWorkInProgressHook(){// This function is used both for updates and for re-renders triggered by a\n// render phase update. It assumes there is either a current hook we can\n// clone, or a work-in-progress hook from a previous render pass that we can\n// use as a base. When we reach the end of the base list, we must switch to\n// the dispatcher used for mounts.\nvar nextCurrentHook;if(currentHook===null){var current=currentlyRenderingFiber$1.alternate;if(current!==null){nextCurrentHook=current.memoizedState;}else{nextCurrentHook=null;}}else{nextCurrentHook=currentHook.next;}var nextWorkInProgressHook;if(workInProgressHook===null){nextWorkInProgressHook=currentlyRenderingFiber$1.memoizedState;}else{nextWorkInProgressHook=workInProgressHook.next;}if(nextWorkInProgressHook!==null){// There's already a work-in-progress. Reuse it.\nworkInProgressHook=nextWorkInProgressHook;nextWorkInProgressHook=workInProgressHook.next;currentHook=nextCurrentHook;}else{// Clone from the current hook.\nif(nextCurrentHook===null){throw new Error('Rendered more hooks than during the previous render.');}currentHook=nextCurrentHook;var newHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};if(workInProgressHook===null){// This is the first hook in the list.\ncurrentlyRenderingFiber$1.memoizedState=workInProgressHook=newHook;}else{// Append to the end of the list.\nworkInProgressHook=workInProgressHook.next=newHook;}}return workInProgressHook;}function createFunctionComponentUpdateQueue(){return{lastEffect:null,stores:null};}function basicStateReducer(state,action){// $FlowFixMe: Flow doesn't like mixed types\nreturn typeof action==='function'?action(state):action;}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook();var initialState;if(init!==undefined){initialState=init(initialArg);}else{initialState=initialArg;}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchReducerAction.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;var current=currentHook;// The last rebase update that is NOT part of the base state.\nvar baseQueue=current.baseQueue;// The last pending update that hasn't been processed yet.\nvar pendingQueue=queue.pending;if(pendingQueue!==null){// We have new updates that haven't been processed yet.\n// We'll add them to the base queue.\nif(baseQueue!==null){// Merge the pending queue and the base queue.\nvar baseFirst=baseQueue.next;var pendingFirst=pendingQueue.next;baseQueue.next=pendingFirst;pendingQueue.next=baseFirst;}{if(current.baseQueue!==baseQueue){// Internal invariant that should never happen, but feasibly could in\n// the future if we implement resuming, or some form of that.\nerror('Internal error: Expected work-in-progress queue to be a clone. '+'This is a bug in React.');}}current.baseQueue=baseQueue=pendingQueue;queue.pending=null;}if(baseQueue!==null){// We have a queue to process.\nvar first=baseQueue.next;var newState=current.baseState;var newBaseState=null;var newBaseQueueFirst=null;var newBaseQueueLast=null;var update=first;do{var updateLane=update.lane;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n// skipped update, the previous update/state is the new base\n// update/state.\nvar clone={lane:updateLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};if(newBaseQueueLast===null){newBaseQueueFirst=newBaseQueueLast=clone;newBaseState=newState;}else{newBaseQueueLast=newBaseQueueLast.next=clone;}// Update the remaining priority in the queue.\n// TODO: Don't need to accumulate this. Instead, we can remove\n// renderLanes from the original lanes.\ncurrentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,updateLane);markSkippedUpdateLanes(updateLane);}else{// This update does have sufficient priority.\nif(newBaseQueueLast!==null){var _clone={// This update is going to be committed so we never want uncommit\n// it. Using NoLane works because 0 is a subset of all bitmasks, so\n// this will never be skipped by the check above.\nlane:NoLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};newBaseQueueLast=newBaseQueueLast.next=_clone;}// Process this update.\nif(update.hasEagerState){// If this update is a state update (not a reducer) and was processed eagerly,\n// we can use the eagerly computed state\nnewState=update.eagerState;}else{var action=update.action;newState=reducer(newState,action);}}update=update.next;}while(update!==null&&update!==first);if(newBaseQueueLast===null){newBaseState=newState;}else{newBaseQueueLast.next=newBaseQueueFirst;}// Mark that the fiber performed work, but only if the new state is\n// different from the current state.\nif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;hook.baseState=newBaseState;hook.baseQueue=newBaseQueueLast;queue.lastRenderedState=newState;}// Interleaved updates are stored on a separate queue. We aren't going to\n// process them during this render, but we do need to track which lanes\n// are remaining.\nvar lastInterleaved=queue.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{var interleavedLane=interleaved.lane;currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,interleavedLane);markSkippedUpdateLanes(interleavedLane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(baseQueue===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n// zero once the queue is empty.\nqueue.lanes=NoLanes;}var dispatch=queue.dispatch;return[hook.memoizedState,dispatch];}function rerenderReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;// This is a re-render. Apply the new render phase updates to the previous\n// work-in-progress hook.\nvar dispatch=queue.dispatch;var lastRenderPhaseUpdate=queue.pending;var newState=hook.memoizedState;if(lastRenderPhaseUpdate!==null){// The queue doesn't persist past this render pass.\nqueue.pending=null;var firstRenderPhaseUpdate=lastRenderPhaseUpdate.next;var update=firstRenderPhaseUpdate;do{// Process this render phase update. We don't have to check the\n// priority because it will always be the same as the current\n// render's.\nvar action=update.action;newState=reducer(newState,action);update=update.next;}while(update!==firstRenderPhaseUpdate);// Mark that the fiber performed work, but only if the new state is\n// different from the current state.\nif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;// Don't persist the state accumulated from the render phase updates to\n// the base state unless the queue is empty.\n// TODO: Not sure if this is the desired semantics, but it's what we\n// do for gDSFP. I can't remember why.\nif(hook.baseQueue===null){hook.baseState=newState;}queue.lastRenderedState=newState;}return[newState,dispatch];}function mountMutableSource(source,getSnapshot,subscribe){{return undefined;}}function updateMutableSource(source,getSnapshot,subscribe){{return undefined;}}function mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=mountWorkInProgressHook();var nextSnapshot;var isHydrating=getIsHydrating();if(isHydrating){if(getServerSnapshot===undefined){throw new Error('Missing getServerSnapshot, which is required for '+'server-rendered content. Will revert to client rendering.');}nextSnapshot=getServerSnapshot();{if(!didWarnUncachedGetSnapshot){if(nextSnapshot!==getServerSnapshot()){error('The result of getServerSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}}else{nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}// Unless we're rendering a blocking lane, schedule a consistency check.\n// Right before committing, we will walk the tree and check if any of the\n// stores were mutated.\n//\n// We won't do this if we're hydrating server-rendered content, because if\n// the content is stale, it's already visible anyway. Instead we'll patch\n// it up in a passive effect.\nvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}// Read the current snapshot from the store on every render. This breaks the\n// normal rules of React, and only works because store updates are\n// always synchronous.\nhook.memoizedState=nextSnapshot;var inst={value:nextSnapshot,getSnapshot:getSnapshot};hook.queue=inst;// Schedule an effect to subscribe to the store.\nmountEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Schedule an effect to update the mutable instance fields. We will update\n// this whenever subscribe, getSnapshot, or value changes. Because there's no\n// clean-up function, and we track the deps correctly, we can call pushEffect\n// directly, without storing any additional state. For the same reason, we\n// don't need to set a static flag, either.\n// TODO: We can move this to the passive phase once we add a pre-commit\n// consistency check. See the next comment.\nfiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);return nextSnapshot;}function updateSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=updateWorkInProgressHook();// Read the current snapshot from the store on every render. This breaks the\n// normal rules of React, and only works because store updates are\n// always synchronous.\nvar nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}var prevSnapshot=hook.memoizedState;var snapshotChanged=!objectIs(prevSnapshot,nextSnapshot);if(snapshotChanged){hook.memoizedState=nextSnapshot;markWorkInProgressReceivedUpdate();}var inst=hook.queue;updateEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Whenever getSnapshot or subscribe changes, we need to check in the\n// commit phase if there was an interleaved mutation. In concurrent mode\n// this can happen all the time, but even in synchronous mode, an earlier\n// effect may have mutated the store.\nif(inst.getSnapshot!==getSnapshot||snapshotChanged||// Check if the susbcribe function changed. We can save some memory by\n// checking whether we scheduled a subscription effect above.\nworkInProgressHook!==null&&workInProgressHook.memoizedState.tag&HasEffect){fiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);// Unless we're rendering a blocking lane, schedule a consistency check.\n// Right before committing, we will walk the tree and check if any of the\n// stores were mutated.\nvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}return nextSnapshot;}function pushStoreConsistencyCheck(fiber,getSnapshot,renderedSnapshot){fiber.flags|=StoreConsistency;var check={getSnapshot:getSnapshot,value:renderedSnapshot};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.stores=[check];}else{var stores=componentUpdateQueue.stores;if(stores===null){componentUpdateQueue.stores=[check];}else{stores.push(check);}}}function updateStoreInstance(fiber,inst,nextSnapshot,getSnapshot){// These are updated in the passive phase\ninst.value=nextSnapshot;inst.getSnapshot=getSnapshot;// Something may have been mutated in between render and commit. This could\n// have been in an event that fired before the passive effects, or it could\n// have been in a layout effect. In that case, we would have used the old\n// snapsho and getSnapshot values to bail out. We need to check one more time.\nif(checkIfSnapshotChanged(inst)){// Force a re-render.\nforceStoreRerender(fiber);}}function subscribeToStore(fiber,inst,subscribe){var handleStoreChange=function(){// The store changed. Check if the snapshot changed since the last time we\n// read from the store.\nif(checkIfSnapshotChanged(inst)){// Force a re-render.\nforceStoreRerender(fiber);}};// Subscribe to the store and return a clean-up function.\nreturn subscribe(handleStoreChange);}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot;var prevValue=inst.value;try{var nextValue=latestGetSnapshot();return!objectIs(prevValue,nextValue);}catch(error){return true;}}function forceStoreRerender(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}function mountState(initialState){var hook=mountWorkInProgressHook();if(typeof initialState==='function'){// $FlowFixMe: Flow doesn't like mixed types\ninitialState=initialState();}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchSetState.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateState(initialState){return updateReducer(basicStateReducer);}function rerenderState(initialState){return rerenderReducer(basicStateReducer);}function pushEffect(tag,create,destroy,deps){var effect={tag:tag,create:create,destroy:destroy,deps:deps,// Circular\nnext:null};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.lastEffect=effect.next=effect;}else{var lastEffect=componentUpdateQueue.lastEffect;if(lastEffect===null){componentUpdateQueue.lastEffect=effect.next=effect;}else{var firstEffect=lastEffect.next;lastEffect.next=effect;effect.next=firstEffect;componentUpdateQueue.lastEffect=effect;}}return effect;}function mountRef(initialValue){var hook=mountWorkInProgressHook();{var _ref2={current:initialValue};hook.memoizedState=_ref2;return _ref2;}}function updateRef(initialValue){var hook=updateWorkInProgressHook();return hook.memoizedState;}function mountEffectImpl(fiberFlags,hookFlags,create,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,undefined,nextDeps);}function updateEffectImpl(fiberFlags,hookFlags,create,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var destroy=undefined;if(currentHook!==null){var prevEffect=currentHook.memoizedState;destroy=prevEffect.destroy;if(nextDeps!==null){var prevDeps=prevEffect.deps;if(areHookInputsEqual(nextDeps,prevDeps)){hook.memoizedState=pushEffect(hookFlags,create,destroy,nextDeps);return;}}}currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,destroy,nextDeps);}function mountEffect(create,deps){if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){return mountEffectImpl(MountPassiveDev|Passive|PassiveStatic,Passive$1,create,deps);}else{return mountEffectImpl(Passive|PassiveStatic,Passive$1,create,deps);}}function updateEffect(create,deps){return updateEffectImpl(Passive,Passive$1,create,deps);}function mountInsertionEffect(create,deps){return mountEffectImpl(Update,Insertion,create,deps);}function updateInsertionEffect(create,deps){return updateEffectImpl(Update,Insertion,create,deps);}function mountLayoutEffect(create,deps){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,create,deps);}function updateLayoutEffect(create,deps){return updateEffectImpl(Update,Layout,create,deps);}function imperativeHandleEffect(create,ref){if(typeof ref==='function'){var refCallback=ref;var _inst=create();refCallback(_inst);return function(){refCallback(null);};}else if(ref!==null&&ref!==undefined){var refObject=ref;{if(!refObject.hasOwnProperty('current')){error('Expected useImperativeHandle() first argument to either be a '+'ref callback or React.createRef() object. Instead received: %s.','an object with keys {'+Object.keys(refObject).join(', ')+'}');}}var _inst2=create();refObject.current=_inst2;return function(){refObject.current=null;};}}function mountImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create:'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\nvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function updateImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create:'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\nvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return updateEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function mountDebugValue(value,formatterFn){// This hook is normally a no-op.\n// The react-debug-hooks package injects its own implementation\n// so that e.g. DevTools can display custom hook values.\n}var updateDebugValue=mountDebugValue;function mountCallback(callback,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;hook.memoizedState=[callback,nextDeps];return callback;}function updateCallback(callback,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}hook.memoizedState=[callback,nextDeps];return callback;}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){// Assume these are defined. If they're not, areHookInputsEqual will warn.\nif(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function mountDeferredValue(value){var hook=mountWorkInProgressHook();hook.memoizedState=value;return value;}function updateDeferredValue(value){var hook=updateWorkInProgressHook();var resolvedCurrentHook=currentHook;var prevValue=resolvedCurrentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}function rerenderDeferredValue(value){var hook=updateWorkInProgressHook();if(currentHook===null){// This is a rerender during a mount.\nhook.memoizedState=value;return value;}else{// This is a rerender during an update.\nvar prevValue=currentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}}function updateDeferredValueImpl(hook,prevValue,value){var shouldDeferValue=!includesOnlyNonUrgentLanes(renderLanes);if(shouldDeferValue){// This is an urgent update. If the value has changed, keep using the\n// previous value and spawn a deferred render to update it later.\nif(!objectIs(value,prevValue)){// Schedule a deferred render\nvar deferredLane=claimNextTransitionLane();currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,deferredLane);markSkippedUpdateLanes(deferredLane);// Set this to true to indicate that the rendered value is inconsistent\n// from the latest value. The name \"baseState\" doesn't really match how we\n// use it because we're reusing a state hook field instead of creating a\n// new one.\nhook.baseState=true;}// Reuse the previous value\nreturn prevValue;}else{// This is not an urgent update, so we can use the latest value regardless\n// of what it is. No need to defer it.\n// However, if we're currently inside a spawned render, then we need to mark\n// this as an update to prevent the fiber from bailing out.\n//\n// `baseState` is true when the current value is different from the rendered\n// value. The name doesn't really match how we use it because we're reusing\n// a state hook field instead of creating a new one.\nif(hook.baseState){// Flip this back to false.\nhook.baseState=false;markWorkInProgressReceivedUpdate();}hook.memoizedState=value;return value;}}function startTransition(setPending,callback,options){var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(higherEventPriority(previousPriority,ContinuousEventPriority));setPending(true);var prevTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition={};var currentTransition=ReactCurrentBatchConfig$2.transition;{ReactCurrentBatchConfig$2.transition._updatedFibers=new Set();}try{setPending(false);callback();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$2.transition=prevTransition;{if(prevTransition===null&&currentTransition._updatedFibers){var updatedFibersCount=currentTransition._updatedFibers.size;if(updatedFibersCount>10){warn('Detected a large number of updates inside startTransition. '+'If this is due to a subscription please re-write it to use React provided hooks. '+'Otherwise concurrent mode guarantees are off the table.');}currentTransition._updatedFibers.clear();}}}}function mountTransition(){var _mountState=mountState(false),isPending=_mountState[0],setPending=_mountState[1];// The `start` method never changes.\nvar start=startTransition.bind(null,setPending);var hook=mountWorkInProgressHook();hook.memoizedState=start;return[isPending,start];}function updateTransition(){var _updateState=updateState(),isPending=_updateState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}function rerenderTransition(){var _rerenderState=rerenderState(),isPending=_rerenderState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}var isUpdatingOpaqueValueInRenderPhase=false;function getIsUpdatingOpaqueValueInRenderPhaseInDEV(){{return isUpdatingOpaqueValueInRenderPhase;}}function mountId(){var hook=mountWorkInProgressHook();var root=getWorkInProgressRoot();// TODO: In Fizz, id generation is specific to each server config. Maybe we\n// should do this in Fiber, too? Deferring this decision for now because\n// there's no other place to store the prefix except for an internal field on\n// the public createRoot object, which the fiber tree does not currently have\n// a reference to.\nvar identifierPrefix=root.identifierPrefix;var id;if(getIsHydrating()){var treeId=getTreeId();// Use a captial R prefix for server-generated ids.\nid=':'+identifierPrefix+'R'+treeId;// Unless this is the first id at this level, append a number at the end\n// that represents the position of this useId hook among all the useId\n// hooks for this fiber.\nvar localId=localIdCounter++;if(localId>0){id+='H'+localId.toString(32);}id+=':';}else{// Use a lowercase r prefix for client-generated ids.\nvar globalClientId=globalClientIdCounter++;id=':'+identifierPrefix+'r'+globalClientId.toString(32)+':';}hook.memoizedState=id;return id;}function updateId(){var hook=updateWorkInProgressHook();var id=hook.memoizedState;return id;}function dispatchReducerAction(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function dispatchSetState(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{var alternate=fiber.alternate;if(fiber.lanes===NoLanes&&(alternate===null||alternate.lanes===NoLanes)){// The queue is currently empty, which means we can eagerly compute the\n// next state before entering the render phase. If the new state is the\n// same as the current state, we may be able to bail out entirely.\nvar lastRenderedReducer=queue.lastRenderedReducer;if(lastRenderedReducer!==null){var prevDispatcher;{prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;}try{var currentState=queue.lastRenderedState;var eagerState=lastRenderedReducer(currentState,action);// Stash the eagerly computed state, and the reducer used to compute\n// it, on the update object. If the reducer hasn't changed by the\n// time we enter the render phase, then the eager state can be used\n// without calling the reducer again.\nupdate.hasEagerState=true;update.eagerState=eagerState;if(objectIs(eagerState,currentState)){// Fast path. We can bail out without scheduling React to re-render.\n// It's still possible that we'll need to rebase this update later,\n// if the component re-renders for a different reason and by that\n// time the reducer has changed.\n// TODO: Do we still need to entangle transitions in this case?\nenqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane);return;}}catch(error){// Suppress the error. It will throw again in the render phase.\n}finally{{ReactCurrentDispatcher$1.current=prevDispatcher;}}}}var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function isRenderPhaseUpdate(fiber){var alternate=fiber.alternate;return fiber===currentlyRenderingFiber$1||alternate!==null&&alternate===currentlyRenderingFiber$1;}function enqueueRenderPhaseUpdate(queue,update){// This is a render phase update. Stash it in a lazily-created map of\n// queue -> linked list of updates. After this render pass, we'll restart\n// and apply the stashed updates on top of the work-in-progress hook.\ndidScheduleRenderPhaseUpdateDuringThisPass=didScheduleRenderPhaseUpdate=true;var pending=queue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}queue.pending=update;}// TODO: Move to ReactFiberConcurrentUpdates?\nfunction entangleTransitionUpdate(root,queue,lane){if(isTransitionLane(lane)){var queueLanes=queue.lanes;// If any entangled lanes are no longer pending on the root, then they\n// must have finished. We can remove them from the shared queue, which\n// represents a superset of the actually pending lanes. In some cases we\n// may entangle more than we need to, but that's OK. In fact it's worse if\n// we *don't* entangle when we should.\nqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\nvar newQueueLanes=mergeLanes(queueLanes,lane);queue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n// the lane finished since the last time we entangled it. So we need to\n// entangle it again, just to be sure.\nmarkRootEntangled(root,newQueueLanes);}}function markUpdateInDevTools(fiber,lane,action){{markStateUpdateScheduled(fiber,lane);}}var ContextOnlyDispatcher={readContext:readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useInsertionEffect:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError,useMutableSource:throwInvalidHookError,useSyncExternalStore:throwInvalidHookError,useId:throwInvalidHookError,unstable_isNewReconciler:enableNewReconciler};var HooksDispatcherOnMountInDEV=null;var HooksDispatcherOnMountWithHookTypesInDEV=null;var HooksDispatcherOnUpdateInDEV=null;var HooksDispatcherOnRerenderInDEV=null;var InvalidNestedHooksDispatcherOnMountInDEV=null;var InvalidNestedHooksDispatcherOnUpdateInDEV=null;var InvalidNestedHooksDispatcherOnRerenderInDEV=null;{var warnInvalidContextAccess=function(){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');};var warnInvalidHookAccess=function(){error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. '+'You can only call Hooks at the top level of your React function. '+'For more information, see '+'https://reactjs.org/link/rules-of-hooks');};HooksDispatcherOnMountInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';mountHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';mountHookTypesDev();checkDepsAreArrayDev(deps);var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';mountHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';mountHookTypesDev();return mountDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';mountHookTypesDev();return mountDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';mountHookTypesDev();return mountTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function(){currentHookNameInDev='useId';mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnMountWithHookTypesInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return mountCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return mountDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return mountDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';updateHookTypesDev();return mountTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return mountMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function(){currentHookNameInDev='useId';updateHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnUpdateInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return updateDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';updateHookTypesDev();return updateTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnRerenderInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';updateHookTypesDev();return rerenderTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnMountInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();mountHookTypesDev();return mountCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';warnInvalidHookAccess();mountHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();mountHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();mountHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();mountHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();mountHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();mountHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();mountHookTypesDev();return mountDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();mountHookTypesDev();return mountDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';warnInvalidHookAccess();mountHookTypesDev();return mountTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function(){currentHookNameInDev='useId';warnInvalidHookAccess();mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return updateDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return updateTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnRerenderInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return rerenderTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};}var now$1=Scheduler.unstable_now;var commitTime=0;var layoutEffectStartTime=-1;var profilerStartTime=-1;var passiveEffectStartTime=-1;/**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */var currentUpdateIsNested=false;var nestedUpdateScheduled=false;function isCurrentUpdateNested(){return currentUpdateIsNested;}function markNestedUpdateScheduled(){{nestedUpdateScheduled=true;}}function resetNestedUpdateFlag(){{currentUpdateIsNested=false;nestedUpdateScheduled=false;}}function syncNestedUpdateFlag(){{currentUpdateIsNested=nestedUpdateScheduled;nestedUpdateScheduled=false;}}function getCommitTime(){return commitTime;}function recordCommitTime(){commitTime=now$1();}function startProfilerTimer(fiber){profilerStartTime=now$1();if(fiber.actualStartTime<0){fiber.actualStartTime=now$1();}}function stopProfilerTimerIfRunning(fiber){profilerStartTime=-1;}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(profilerStartTime>=0){var elapsedTime=now$1()-profilerStartTime;fiber.actualDuration+=elapsedTime;if(overrideBaseTime){fiber.selfBaseDuration=elapsedTime;}profilerStartTime=-1;}}function recordLayoutEffectDuration(fiber){if(layoutEffectStartTime>=0){var elapsedTime=now$1()-layoutEffectStartTime;layoutEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n// Or the root (for the DevTools Profiler to read)\nvar parentFiber=fiber.return;while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=elapsedTime;return;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=elapsedTime;return;}parentFiber=parentFiber.return;}}}function recordPassiveEffectDuration(fiber){if(passiveEffectStartTime>=0){var elapsedTime=now$1()-passiveEffectStartTime;passiveEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n// Or the root (for the DevTools Profiler to read)\nvar parentFiber=fiber.return;while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;if(root!==null){root.passiveEffectDuration+=elapsedTime;}return;case Profiler:var parentStateNode=parentFiber.stateNode;if(parentStateNode!==null){// Detached fibers have their state node cleared out.\n// In this case, the return pointer is also cleared out,\n// so we won't be able to report the time spent in this Profiler's subtree.\nparentStateNode.passiveEffectDuration+=elapsedTime;}return;}parentFiber=parentFiber.return;}}}function startLayoutEffectTimer(){layoutEffectStartTime=now$1();}function startPassiveEffectTimer(){passiveEffectStartTime=now$1();}function transferActualDuration(fiber){// Transfer time spent rendering these children so we don't lose it\n// after we rerender. This is used as a helper in special cases\n// where we should count the work of multiple passes.\nvar child=fiber.child;while(child){fiber.actualDuration+=child.actualDuration;child=child.sibling;}}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){// Resolve default props. Taken from ReactElement\nvar props=assign({},baseProps);var defaultProps=Component.defaultProps;for(var propName in defaultProps){if(props[propName]===undefined){props[propName]=defaultProps[propName];}}return props;}return baseProps;}var fakeInternalInstance={};var didWarnAboutStateAssignmentForComponent;var didWarnAboutUninitializedState;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;var didWarnAboutLegacyLifecyclesAndDerivedState;var didWarnAboutUndefinedDerivedState;var warnOnUndefinedDerivedState;var warnOnInvalidCallback;var didWarnAboutDirectlyAssigningPropsToState;var didWarnAboutContextTypeAndContextTypes;var didWarnAboutInvalidateContextType;var didWarnAboutLegacyContext$1;{didWarnAboutStateAssignmentForComponent=new Set();didWarnAboutUninitializedState=new Set();didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set();didWarnAboutLegacyLifecyclesAndDerivedState=new Set();didWarnAboutDirectlyAssigningPropsToState=new Set();didWarnAboutUndefinedDerivedState=new Set();didWarnAboutContextTypeAndContextTypes=new Set();didWarnAboutInvalidateContextType=new Set();didWarnAboutLegacyContext$1=new Set();var didWarnOnInvalidCallback=new Set();warnOnInvalidCallback=function(callback,callerName){if(callback===null||typeof callback==='function'){return;}var key=callerName+'_'+callback;if(!didWarnOnInvalidCallback.has(key)){didWarnOnInvalidCallback.add(key);error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}};warnOnUndefinedDerivedState=function(type,partialState){if(partialState===undefined){var componentName=getComponentNameFromType(type)||'Component';if(!didWarnAboutUndefinedDerivedState.has(componentName)){didWarnAboutUndefinedDerivedState.add(componentName);error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '+'You have returned undefined.',componentName);}}};// This is so gross but it's at least non-critical and can be removed if\n// it causes problems. This is meant to give a nicer error message for\n// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n// ...)) which otherwise throws a \"_processChildContext is not a function\"\n// exception.\nObject.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function(){throw new Error('_processChildContext is not available in React 16+. This likely '+'means you have multiple copies of React and are attempting to nest '+'a React 15 tree inside a React 16 tree using '+\"unstable_renderSubtreeIntoContainer, which isn't supported. Try \"+'to make sure you have only one copy of React (and ideally, switch '+'to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState;var partialState=getDerivedStateFromProps(nextProps,prevState);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\npartialState=getDerivedStateFromProps(nextProps,prevState);}finally{setIsStrictModeForDevtools(false);}}warnOnUndefinedDerivedState(ctor,partialState);}// Merge the partial state and the previous state.\nvar memoizedState=partialState===null||partialState===undefined?prevState:assign({},prevState,partialState);workInProgress.memoizedState=memoizedState;// Once the update queue is empty, persist the derived state onto the\n// base state.\nif(workInProgress.lanes===NoLanes){// Queue is always non-null for classes\nvar updateQueue=workInProgress.updateQueue;updateQueue.baseState=memoizedState;}}var classComponentUpdater={isMounted:isMounted,enqueueSetState:function(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'setState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueReplaceState:function(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ReplaceState;update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'replaceState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueForceUpdate:function(inst,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ForceUpdate;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'forceUpdate');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markForceUpdateScheduled(fiber,lane);}}};function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress.stateNode;if(typeof instance.shouldComponentUpdate==='function'){var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\nshouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);}finally{setIsStrictModeForDevtools(false);}}if(shouldUpdate===undefined){error('%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentNameFromType(ctor)||'Component');}}return shouldUpdate;}if(ctor.prototype&&ctor.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress,ctor,newProps){var instance=workInProgress.stateNode;{var name=getComponentNameFromType(ctor)||'Component';var renderPresent=instance.render;if(!renderPresent){if(ctor.prototype&&typeof ctor.prototype.render==='function'){error('%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{error('%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}if(instance.getInitialState&&!instance.getInitialState.isReactClassApproved&&!instance.state){error('getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);}if(instance.getDefaultProps&&!instance.getDefaultProps.isReactClassApproved){error('getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);}if(instance.propTypes){error('propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);}if(instance.contextType){error('contextType was defined as an instance property on %s. Use a static '+'property to define contextType instead.',name);}{if(ctor.childContextTypes&&!didWarnAboutLegacyContext$1.has(ctor)&&// Strict Mode has its own warning for legacy context, so we can skip\n// this one.\n(workInProgress.mode&StrictLegacyMode)===NoMode){didWarnAboutLegacyContext$1.add(ctor);error('%s uses the legacy childContextTypes API which is no longer '+'supported and will be removed in the next major release. Use '+'React.createContext() instead\\n\\n.'+'Learn more about this warning here: https://reactjs.org/link/legacy-context',name);}if(ctor.contextTypes&&!didWarnAboutLegacyContext$1.has(ctor)&&// Strict Mode has its own warning for legacy context, so we can skip\n// this one.\n(workInProgress.mode&StrictLegacyMode)===NoMode){didWarnAboutLegacyContext$1.add(ctor);error('%s uses the legacy contextTypes API which is no longer supported '+'and will be removed in the next major release. Use '+'React.createContext() with static contextType instead.\\n\\n'+'Learn more about this warning here: https://reactjs.org/link/legacy-context',name);}if(instance.contextTypes){error('contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);}if(ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)){didWarnAboutContextTypeAndContextTypes.add(ctor);error('%s declares both contextTypes and contextType static properties. '+'The legacy contextTypes property will be ignored.',name);}}if(typeof instance.componentShouldUpdate==='function'){error('%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);}if(ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){error('%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentNameFromType(ctor)||'A pure component');}if(typeof instance.componentDidUnmount==='function'){error('%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);}if(typeof instance.componentDidReceiveProps==='function'){error('%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);}if(typeof instance.componentWillRecieveProps==='function'){error('%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);}if(typeof instance.UNSAFE_componentWillRecieveProps==='function'){error('%s has a method called '+'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',name);}var hasMutatedProps=instance.props!==newProps;if(instance.props!==undefined&&hasMutatedProps){error('%s(...): When calling super() in `%s`, make sure to pass '+\"up the same props that your component's constructor was passed.\",name,name);}if(instance.defaultProps){error('Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}if(typeof instance.getSnapshotBeforeUpdate==='function'&&typeof instance.componentDidUpdate!=='function'&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)){didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '+'This component defines getSnapshotBeforeUpdate() only.',getComponentNameFromType(ctor));}if(typeof instance.getDerivedStateFromProps==='function'){error('%s: getDerivedStateFromProps() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof instance.getDerivedStateFromError==='function'){error('%s: getDerivedStateFromError() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof ctor.getSnapshotBeforeUpdate==='function'){error('%s: getSnapshotBeforeUpdate() is defined as a static method '+'and will be ignored. Instead, declare it as an instance method.',name);}var _state=instance.state;if(_state&&(typeof _state!=='object'||isArray(_state))){error('%s.state: must be set to an object or null',name);}if(typeof instance.getChildContext==='function'&&typeof ctor.childContextTypes!=='object'){error('%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',name);}}}function adoptClassInstance(workInProgress,instance){instance.updater=classComponentUpdater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates\nset(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,ctor,props){var isLegacyContextConsumer=false;var unmaskedContext=emptyContextObject;var context=emptyContextObject;var contextType=ctor.contextType;{if('contextType'in ctor){var isValid=// Allow null for conditional declaration\ncontextType===null||contextType!==undefined&&contextType.$$typeof===REACT_CONTEXT_TYPE&&contextType._context===undefined;// Not a <Context.Consumer>\nif(!isValid&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum='';if(contextType===undefined){addendum=' However, it is set to undefined. '+'This can be caused by a typo or by mixing up named and default imports. '+'This can also happen due to a circular dependency, so '+'try moving the createContext() call to a separate file.';}else if(typeof contextType!=='object'){addendum=' However, it is set to a '+typeof contextType+'.';}else if(contextType.$$typeof===REACT_PROVIDER_TYPE){addendum=' Did you accidentally pass the Context.Provider instead?';}else if(contextType._context!==undefined){// <Context.Consumer>\naddendum=' Did you accidentally pass the Context.Consumer instead?';}else{addendum=' However, it is set to an object with keys {'+Object.keys(contextType).join(', ')+'}.';}error('%s defines an invalid contextType. '+'contextType should point to the Context object returned by React.createContext().%s',getComponentNameFromType(ctor)||'Component',addendum);}}}if(typeof contextType==='object'&&contextType!==null){context=readContext(contextType);}else{unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var contextTypes=ctor.contextTypes;isLegacyContextConsumer=contextTypes!==null&&contextTypes!==undefined;context=isLegacyContextConsumer?getMaskedContext(workInProgress,unmaskedContext):emptyContextObject;}var instance=new ctor(props,context);// Instantiate twice to help detect side-effects.\n{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance=new ctor(props,context);// eslint-disable-line no-new\n}finally{setIsStrictModeForDevtools(false);}}}var state=workInProgress.memoizedState=instance.state!==null&&instance.state!==undefined?instance.state:null;adoptClassInstance(workInProgress,instance);{if(typeof ctor.getDerivedStateFromProps==='function'&&state===null){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutUninitializedState.has(componentName)){didWarnAboutUninitializedState.add(componentName);error('`%s` uses `getDerivedStateFromProps` but its initial state is '+'%s. This is not recommended. Instead, define the initial state by '+'assigning an object to `this.state` in the constructor of `%s`. '+'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',componentName,instance.state===null?'null':'undefined',componentName);}}// If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n// Warn about these lifecycles if they are present.\n// Don't warn about react-lifecycles-compat polyfilled methods though.\nif(typeof ctor.getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function'){var foundWillMountName=null;var foundWillReceivePropsName=null;var foundWillUpdateName=null;if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){foundWillMountName='componentWillMount';}else if(typeof instance.UNSAFE_componentWillMount==='function'){foundWillMountName='UNSAFE_componentWillMount';}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){foundWillReceivePropsName='componentWillReceiveProps';}else if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){foundWillReceivePropsName='UNSAFE_componentWillReceiveProps';}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){foundWillUpdateName='componentWillUpdate';}else if(typeof instance.UNSAFE_componentWillUpdate==='function'){foundWillUpdateName='UNSAFE_componentWillUpdate';}if(foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentNameFromType(ctor)||'Component';var newApiName=typeof ctor.getDerivedStateFromProps==='function'?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';if(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)){didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n'+'%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n'+'The above lifecycles should be removed. Learn more about this warning here:\\n'+'https://reactjs.org/link/unsafe-component-lifecycles',_componentName,newApiName,foundWillMountName!==null?\"\\n  \"+foundWillMountName:'',foundWillReceivePropsName!==null?\"\\n  \"+foundWillReceivePropsName:'',foundWillUpdateName!==null?\"\\n  \"+foundWillUpdateName:'');}}}}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// ReactFiberContext usually updates this cache but can't for newly-created instances.\nif(isLegacyContextConsumer){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){var oldState=instance.state;if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}if(oldState!==instance.state){{error('%s.componentWillMount(): Assigning directly to this.state is '+\"deprecated (except inside a component's \"+'constructor). Use setState instead.',getComponentNameFromFiber(workInProgress)||'Component');}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext){var oldState=instance.state;if(typeof instance.componentWillReceiveProps==='function'){instance.componentWillReceiveProps(newProps,nextContext);}if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){instance.UNSAFE_componentWillReceiveProps(newProps,nextContext);}if(instance.state!==oldState){{var componentName=getComponentNameFromFiber(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent.has(componentName)){didWarnAboutStateAssignmentForComponent.add(componentName);error('%s.componentWillReceiveProps(): Assigning directly to '+\"this.state is deprecated (except inside a component's \"+'constructor). Use setState instead.',componentName);}}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(workInProgress,ctor,newProps,renderLanes){{checkClassInstance(workInProgress,ctor,newProps);}var instance=workInProgress.stateNode;instance.props=newProps;instance.state=workInProgress.memoizedState;instance.refs={};initializeUpdateQueue(workInProgress);var contextType=ctor.contextType;if(typeof contextType==='object'&&contextType!==null){instance.context=readContext(contextType);}else{var unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);instance.context=getMaskedContext(workInProgress,unmaskedContext);}{if(instance.state===newProps){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)){didWarnAboutDirectlyAssigningPropsToState.add(componentName);error('%s: It is not recommended to assign props directly to state '+\"because updates to props won't be reflected in state. \"+'In most cases, it is better to use props directly.',componentName);}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);}{ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);}}instance.state=workInProgress.memoizedState;var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);instance.state=workInProgress.memoizedState;}// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(typeof ctor.getDerivedStateFromProps!=='function'&&typeof instance.getSnapshotBeforeUpdate!=='function'&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's\n// process them now.\nprocessUpdateQueue(workInProgress,newProps,instance,renderLanes);instance.state=workInProgress.memoizedState;}if(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}}function resumeMountClassInstance(workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=oldProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(typeof contextType==='object'&&contextType!==null){nextContext=readContext(contextType);}else{var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}}if(typeof instance.componentDidMount==='function'){var _fiberFlags=Update;{_fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags|=MountLayoutDev;}workInProgress.flags|=_fiberFlags;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){var _fiberFlags2=Update;{_fiberFlags2|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags2|=MountLayoutDev;}workInProgress.flags|=_fiberFlags2;}// If shouldComponentUpdate returned false, we should still update the\n// memoized state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(current,workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;cloneUpdateQueue(current,workInProgress);var unresolvedOldProps=workInProgress.memoizedProps;var oldProps=workInProgress.type===workInProgress.elementType?unresolvedOldProps:resolveDefaultProps(workInProgress.type,unresolvedOldProps);instance.props=oldProps;var unresolvedNewProps=workInProgress.pendingProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(typeof contextType==='object'&&contextType!==null){nextContext=readContext(contextType);}else{var nextUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(unresolvedOldProps!==unresolvedNewProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(unresolvedOldProps===unresolvedNewProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()&&!enableLazyContextPropagation){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext)||// TODO: In some cases, we'll end up checking if context has changed twice,\n// both before and after `shouldComponentUpdate` has been called. Not ideal,\n// but I'm loath to refactor this function. This only happens for memoized\n// components so it's not that common.\nenableLazyContextPropagation;if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate==='function'||typeof instance.componentWillUpdate==='function')){if(typeof instance.componentWillUpdate==='function'){instance.componentWillUpdate(newProps,newState,nextContext);}if(typeof instance.UNSAFE_componentWillUpdate==='function'){instance.UNSAFE_componentWillUpdate(newProps,newState,nextContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.flags|=Update;}if(typeof instance.getSnapshotBeforeUpdate==='function'){workInProgress.flags|=Snapshot;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}// If shouldComponentUpdate returned false, we should still update the\n// memoized props/state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}function createCapturedValueAtFiber(value,source){// If the value is an error, call this function immediately after it is thrown\n// so the stack is accurate.\nreturn{value:value,source:source,stack:getStackByFiberInDevAndProd(source),digest:null};}function createCapturedValue(value,digest,stack){return{value:value,source:null,stack:stack!=null?stack:null,digest:digest!=null?digest:null};}// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(boundary,errorInfo){return true;}function logCapturedError(boundary,errorInfo){try{var logError=showErrorDialog(boundary,errorInfo);// Allow injected showErrorDialog() to prevent default console.error logging.\n// This enables renderers like ReactNative to better manage redbox behavior.\nif(logError===false){return;}var error=errorInfo.value;if(true){var source=errorInfo.source;var stack=errorInfo.stack;var componentStack=stack!==null?stack:'';// Browsers support silencing uncaught errors by calling\n// `preventDefault()` in window `error` handler.\n// We record this information as an expando on the error.\nif(error!=null&&error._suppressLogging){if(boundary.tag===ClassComponent){// The error is recoverable and was silenced.\n// Ignore it and don't print the stack addendum.\n// This is handy for testing error boundaries without noise.\nreturn;}// The error is fatal. Since the silencing might have\n// been accidental, we'll surface it anyway.\n// However, the browser would have silenced the original error\n// so we'll print it first, and then print the stack addendum.\nconsole['error'](error);// Don't transform to our wrapper\n// For a more detailed description of this block, see:\n// https://github.com/facebook/react/pull/13384\n}var componentName=source?getComponentNameFromFiber(source):null;var componentNameMessage=componentName?\"The above error occurred in the <\"+componentName+\"> component:\":'The above error occurred in one of your React components:';var errorBoundaryMessage;if(boundary.tag===HostRoot){errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\\n'+'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';}else{var errorBoundaryName=getComponentNameFromFiber(boundary)||'Anonymous';errorBoundaryMessage=\"React will try to recreate this component tree from scratch \"+(\"using the error boundary you provided, \"+errorBoundaryName+\".\");}var combinedMessage=componentNameMessage+\"\\n\"+componentStack+\"\\n\\n\"+(\"\"+errorBoundaryMessage);// In development, we provide our own message with just the component stack.\n// We don't include the original error message and JS stack because the browser\n// has already printed it. Even if the application swallows the error, it is still\n// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\nconsole['error'](combinedMessage);// Don't transform to our wrapper\n}else{}}catch(e){// This method must not throw, or React internal state will get messed up.\n// If console.error is overridden, or logCapturedError() shows a dialog that throws,\n// we want to report this error outside of the normal stack as a last resort.\n// https://github.com/facebook/react/issues/13188\nsetTimeout(function(){throw e;});}}var PossiblyWeakMap$1=typeof WeakMap==='function'?WeakMap:Map;function createRootErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);// Unmount the root by rendering null.\nupdate.tag=CaptureUpdate;// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:null};var error=errorInfo.value;update.callback=function(){onUncaughtError(error);logCapturedError(fiber,errorInfo);};return update;}function createClassErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);update.tag=CaptureUpdate;var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if(typeof getDerivedStateFromError==='function'){var error$1=errorInfo.value;update.payload=function(){return getDerivedStateFromError(error$1);};update.callback=function(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);};}var inst=fiber.stateNode;if(inst!==null&&typeof inst.componentDidCatch==='function'){update.callback=function callback(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);if(typeof getDerivedStateFromError!=='function'){// To preserve the preexisting retry behavior of error boundaries,\n// we keep track of which ones already failed during this batch.\n// This gets reset before we yield back to the browser.\n// TODO: Warn in strict mode if getDerivedStateFromError is\n// not defined.\nmarkLegacyErrorBoundaryAsFailed(this);}var error$1=errorInfo.value;var stack=errorInfo.stack;this.componentDidCatch(error$1,{componentStack:stack!==null?stack:''});{if(typeof getDerivedStateFromError!=='function'){// If componentDidCatch is the only error boundary method defined,\n// then it needs to call setState to recover from errors.\n// If no state update is scheduled then the boundary will swallow the error.\nif(!includesSomeLane(fiber.lanes,SyncLane)){error('%s: Error boundaries should implement getDerivedStateFromError(). '+'In that method, return a state update to display an error message or fallback UI.',getComponentNameFromFiber(fiber)||'Unknown');}}}};}return update;}function attachPingListener(root,wakeable,lanes){// Attach a ping listener\n//\n// The data might resolve before we have a chance to commit the fallback. Or,\n// in the case of a refresh, we'll never commit a fallback. So we need to\n// attach a listener now. When it resolves (\"pings\"), we can decide whether to\n// try rendering the tree again.\n//\n// Only attach a listener if one does not already exist for the lanes\n// we're currently rendering (which acts like a \"thread ID\" here).\n//\n// We only need to do this in concurrent mode. Legacy Suspense always\n// commits fallbacks synchronously, so there are no pings.\nvar pingCache=root.pingCache;var threadIDs;if(pingCache===null){pingCache=root.pingCache=new PossiblyWeakMap$1();threadIDs=new Set();pingCache.set(wakeable,threadIDs);}else{threadIDs=pingCache.get(wakeable);if(threadIDs===undefined){threadIDs=new Set();pingCache.set(wakeable,threadIDs);}}if(!threadIDs.has(lanes)){// Memoize using the thread ID to prevent redundant listeners.\nthreadIDs.add(lanes);var ping=pingSuspendedRoot.bind(null,root,wakeable,lanes);{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\nrestorePendingUpdaters(root,lanes);}}wakeable.then(ping,ping);}}function attachRetryListener(suspenseBoundary,root,wakeable,lanes){// Retry listener\n//\n// If the fallback does commit, we need to attach a different type of\n// listener. This one schedules an update on the Suspense boundary to turn\n// the fallback state off.\n//\n// Stash the wakeable on the boundary fiber so we can access it in the\n// commit phase.\n//\n// When the wakeable resolves, we'll attempt to render the boundary\n// again (\"retry\").\nvar wakeables=suspenseBoundary.updateQueue;if(wakeables===null){var updateQueue=new Set();updateQueue.add(wakeable);suspenseBoundary.updateQueue=updateQueue;}else{wakeables.add(wakeable);}}function resetSuspendedComponent(sourceFiber,rootRenderLanes){// A legacy mode Suspense quirk, only relevant to hook components.\nvar tag=sourceFiber.tag;if((sourceFiber.mode&ConcurrentMode)===NoMode&&(tag===FunctionComponent||tag===ForwardRef||tag===SimpleMemoComponent)){var currentSource=sourceFiber.alternate;if(currentSource){sourceFiber.updateQueue=currentSource.updateQueue;sourceFiber.memoizedState=currentSource.memoizedState;sourceFiber.lanes=currentSource.lanes;}else{sourceFiber.updateQueue=null;sourceFiber.memoizedState=null;}}}function getNearestSuspenseBoundaryToCapture(returnFiber){var node=returnFiber;do{if(node.tag===SuspenseComponent&&shouldCaptureSuspense(node)){return node;}// This boundary already captured during this render. Continue to the next\n// boundary.\nnode=node.return;}while(node!==null);return null;}function markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes){// This marks a Suspense boundary so that when we're unwinding the stack,\n// it captures the suspended \"exception\" and does a second (fallback) pass.\nif((suspenseBoundary.mode&ConcurrentMode)===NoMode){// Legacy Mode Suspense\n//\n// If the boundary is in legacy mode, we should *not*\n// suspend the commit. Pretend as if the suspended component rendered\n// null and keep rendering. When the Suspense boundary completes,\n// we'll do a second pass to render the fallback.\nif(suspenseBoundary===returnFiber){// Special case where we suspended while reconciling the children of\n// a Suspense boundary's inner Offscreen wrapper fiber. This happens\n// when a React.lazy component is a direct child of a\n// Suspense boundary.\n//\n// Suspense boundaries are implemented as multiple fibers, but they\n// are a single conceptual unit. The legacy mode behavior where we\n// pretend the suspended fiber committed as `null` won't work,\n// because in this case the \"suspended\" fiber is the inner\n// Offscreen wrapper.\n//\n// Because the contents of the boundary haven't started rendering\n// yet (i.e. nothing in the tree has partially rendered) we can\n// switch to the regular, concurrent mode behavior: mark the\n// boundary with ShouldCapture and enter the unwind phase.\nsuspenseBoundary.flags|=ShouldCapture;}else{suspenseBoundary.flags|=DidCapture;sourceFiber.flags|=ForceUpdateForLegacySuspense;// We're going to commit this fiber even though it didn't complete.\n// But we shouldn't call any lifecycle methods or callbacks. Remove\n// all lifecycle effect tags.\nsourceFiber.flags&=~(LifecycleEffectMask|Incomplete);if(sourceFiber.tag===ClassComponent){var currentSourceFiber=sourceFiber.alternate;if(currentSourceFiber===null){// This is a new mount. Change the tag so it's not mistaken for a\n// completed class component. For example, we should not call\n// componentWillUnmount if it is deleted.\nsourceFiber.tag=IncompleteClassComponent;}else{// When we try rendering again, we should not reuse the current fiber,\n// since it's known to be in an inconsistent state. Use a force update to\n// prevent a bail out.\nvar update=createUpdate(NoTimestamp,SyncLane);update.tag=ForceUpdate;enqueueUpdate(sourceFiber,update,SyncLane);}}// The source fiber did not complete. Mark it with Sync priority to\n// indicate that it still has pending work.\nsourceFiber.lanes=mergeLanes(sourceFiber.lanes,SyncLane);}return suspenseBoundary;}// Confirmed that the boundary is in a concurrent mode tree. Continue\n// with the normal suspend path.\n//\n// After this we'll use a set of heuristics to determine whether this\n// render pass will run to completion or restart or \"suspend\" the commit.\n// The actual logic for this is spread out in different places.\n//\n// This first principle is that if we're going to suspend when we complete\n// a root, then we should also restart if we get an update or ping that\n// might unsuspend it, and vice versa. The only reason to suspend is\n// because you think you might want to restart before committing. However,\n// it doesn't make sense to restart only while in the period we're suspended.\n//\n// Restarting too aggressively is also not good because it starves out any\n// intermediate loading state. So we use heuristics to determine when.\n// Suspense Heuristics\n//\n// If nothing threw a Promise or all the same fallbacks are already showing,\n// then don't suspend/restart.\n//\n// If this is an initial render of a new tree of Suspense boundaries and\n// those trigger a fallback, then don't suspend/restart. We want to ensure\n// that we can show the initial loading state as quickly as possible.\n//\n// If we hit a \"Delayed\" case, such as when we'd switch from content back into\n// a fallback, then we should always suspend/restart. Transitions apply\n// to this case. If none is defined, JND is used instead.\n//\n// If we're already showing a fallback and it gets \"retried\", allowing us to show\n// another level, but there's still an inner boundary that would show a fallback,\n// then we suspend/restart for 500ms since the last time we showed a fallback\n// anywhere in the tree. This effectively throttles progressive loading into a\n// consistent train of commits. This also gives us an opportunity to restart to\n// get to the completed state slightly earlier.\n//\n// If there's ambiguity due to batching it's resolved in preference of:\n// 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n//\n// We want to ensure that a \"busy\" state doesn't get force committed. We want to\n// ensure that new initial loading states can commit as soon as possible.\nsuspenseBoundary.flags|=ShouldCapture;// TODO: I think we can remove this, since we now use `DidCapture` in\n// the begin phase to prevent an early bailout.\nsuspenseBoundary.lanes=rootRenderLanes;return suspenseBoundary;}function throwException(root,returnFiber,sourceFiber,value,rootRenderLanes){// The source fiber did not complete.\nsourceFiber.flags|=Incomplete;{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\nrestorePendingUpdaters(root,rootRenderLanes);}}if(value!==null&&typeof value==='object'&&typeof value.then==='function'){// This is a wakeable. The component suspended.\nvar wakeable=value;resetSuspendedComponent(sourceFiber);{if(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();}}var suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(suspenseBoundary!==null){suspenseBoundary.flags&=~ForceClientRender;markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// We only attach ping listeners in concurrent mode. Legacy Suspense always\n// commits fallbacks synchronously, so there are no pings.\nif(suspenseBoundary.mode&ConcurrentMode){attachPingListener(root,wakeable,rootRenderLanes);}attachRetryListener(suspenseBoundary,root,wakeable);return;}else{// No boundary was found. Unless this is a sync update, this is OK.\n// We can suspend and wait for more data to arrive.\nif(!includesSyncLane(rootRenderLanes)){// This is not a sync update. Suspend. Since we're not activating a\n// Suspense boundary, this will unwind all the way to the root without\n// performing a second pass to render a fallback. (This is arguably how\n// refresh transitions should work, too, since we're not going to commit\n// the fallbacks anyway.)\n//\n// This case also applies to initial hydration.\nattachPingListener(root,wakeable,rootRenderLanes);renderDidSuspendDelayIfPossible();return;}// This is a sync/discrete update. We treat this case like an error\n// because discrete renders are expected to produce a complete tree\n// synchronously to maintain consistency with external state.\nvar uncaughtSuspenseError=new Error('A component suspended while responding to synchronous input. This '+'will cause the UI to be replaced with a loading indicator. To '+'fix, updates that suspend should be wrapped '+'with startTransition.');// If we're outside a transition, fall through to the regular error path.\n// The error will be caught by the nearest suspense boundary.\nvalue=uncaughtSuspenseError;}}else{// This is a regular error, not a Suspense wakeable.\nif(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();var _suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);// If the error was thrown during hydration, we may be able to recover by\n// discarding the dehydrated content and switching to a client render.\n// Instead of surfacing the error, find the nearest Suspense boundary\n// and render it again without hydration.\nif(_suspenseBoundary!==null){if((_suspenseBoundary.flags&ShouldCapture)===NoFlags){// Set a flag to indicate that we should try rendering the normal\n// children again, not the fallback.\n_suspenseBoundary.flags|=ForceClientRender;}markSuspenseBoundaryShouldCapture(_suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// Even though the user may not be affected by this error, we should\n// still log it so it can be fixed.\nqueueHydrationError(createCapturedValueAtFiber(value,sourceFiber));return;}}}value=createCapturedValueAtFiber(value,sourceFiber);renderDidError(value);// We didn't find a boundary that could handle this type of exception. Start\n// over and traverse parent path again, this time treating the exception\n// as an error.\nvar workInProgress=returnFiber;do{switch(workInProgress.tag){case HostRoot:{var _errorInfo=value;workInProgress.flags|=ShouldCapture;var lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);var update=createRootErrorUpdate(workInProgress,_errorInfo,lane);enqueueCapturedUpdate(workInProgress,update);return;}case ClassComponent:// Capture and retry\nvar errorInfo=value;var ctor=workInProgress.type;var instance=workInProgress.stateNode;if((workInProgress.flags&DidCapture)===NoFlags&&(typeof ctor.getDerivedStateFromError==='function'||instance!==null&&typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress.flags|=ShouldCapture;var _lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,_lane);// Schedule the error boundary to re-render using updated state\nvar _update=createClassErrorUpdate(workInProgress,errorInfo,_lane);enqueueCapturedUpdate(workInProgress,_update);return;}break;}workInProgress=workInProgress.return;}while(workInProgress!==null);}function getSuspendedCache(){{return null;}// This function is called when a Suspense boundary suspends. It returns the\n}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner;var didReceiveUpdate=false;var didWarnAboutBadClass;var didWarnAboutModulePatternComponent;var didWarnAboutContextTypeOnFunctionComponent;var didWarnAboutGetDerivedStateOnFunctionComponent;var didWarnAboutFunctionRefs;var didWarnAboutReassigningProps;var didWarnAboutRevealOrder;var didWarnAboutTailOptions;var didWarnAboutDefaultPropsOnFunctionComponent;{didWarnAboutBadClass={};didWarnAboutModulePatternComponent={};didWarnAboutContextTypeOnFunctionComponent={};didWarnAboutGetDerivedStateOnFunctionComponent={};didWarnAboutFunctionRefs={};didWarnAboutReassigningProps=false;didWarnAboutRevealOrder={};didWarnAboutTailOptions={};didWarnAboutDefaultPropsOnFunctionComponent={};}function reconcileChildren(current,workInProgress,nextChildren,renderLanes){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we\n// won't update its child set by applying minimal side-effects. Instead,\n// we will add them all to the child before it gets rendered. That means\n// we can optimize this reconciliation pass by not tracking side-effects.\nworkInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);}else{// If the current child is the same as the work in progress, it means that\n// we haven't yet started any work on these children. Therefore, we use\n// the clone algorithm to create a copy of all the current children.\n// If we had any progressed work already, that is invalid at this point so\n// let's throw it out.\nworkInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderLanes);}}function forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes){// This function is fork of reconcileChildren. It's used in cases where we\n// want to reconcile without matching against the existing set. This has the\n// effect of all current children being unmounted; even if the type and key\n// are the same, the old child is unmounted and a new child is created.\n//\n// To do this, we're going to go through the reconcile algorithm twice. In\n// the first pass, we schedule a deletion for all the current children by\n// passing null.\nworkInProgress.child=reconcileChildFibers(workInProgress,current.child,null,renderLanes);// In the second pass, we mount the new children. The trick here is that we\n// pass null in place of where we usually pass the current child set. This has\n// the effect of remounting all children regardless of whether their\n// identities match.\nworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}function updateForwardRef(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n// hasn't yet mounted. This happens after the first render suspends.\n// We'll need to figure out if this is fine or can cause issues.\n{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}var render=Component.render;var ref=workInProgress.ref;// The rest is a fork of updateFunctionComponent\nvar nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMemoComponent(current,workInProgress,Component,nextProps,renderLanes){if(current===null){var type=Component.type;if(isSimpleFunctionComponent(type)&&Component.compare===null&&// SimpleMemoComponent codepath doesn't resolve outer props either.\nComponent.defaultProps===undefined){var resolvedType=type;{resolvedType=resolveFunctionForHotReloading(type);}// If this is a plain function component without default props,\n// and with only the default shallow comparison, we upgrade it\n// to a SimpleMemoComponent to allow fast path updates.\nworkInProgress.tag=SimpleMemoComponent;workInProgress.type=resolvedType;{validateFunctionComponentInDev(workInProgress,type);}return updateSimpleMemoComponent(current,workInProgress,resolvedType,nextProps,renderLanes);}{var innerPropTypes=type.propTypes;if(innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n// We could move it there, but we'd still need this for lazy code path.\ncheckPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(type));}if(Component.defaultProps!==undefined){var componentName=getComponentNameFromType(type)||'Unknown';if(!didWarnAboutDefaultPropsOnFunctionComponent[componentName]){error('%s: Support for defaultProps will be removed from memo components '+'in a future major release. Use JavaScript default parameters instead.',componentName);didWarnAboutDefaultPropsOnFunctionComponent[componentName]=true;}}}var child=createFiberFromTypeAndProps(Component.type,null,nextProps,workInProgress,workInProgress.mode,renderLanes);child.ref=workInProgress.ref;child.return=workInProgress;workInProgress.child=child;return child;}{var _type=Component.type;var _innerPropTypes=_type.propTypes;if(_innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n// We could move it there, but we'd still need this for lazy code path.\ncheckPropTypes(_innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(_type));}}var currentChild=current.child;// This is always exactly one child\nvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext){// This will be the props with resolved defaultProps,\n// unlike current.memoizedProps which will be the unresolved ones.\nvar prevProps=currentChild.memoizedProps;// Default to shallow comparison\nvar compare=Component.compare;compare=compare!==null?compare:shallowEqual;if(compare(prevProps,nextProps)&&current.ref===workInProgress.ref){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;var newChild=createWorkInProgress(currentChild,nextProps);newChild.ref=workInProgress.ref;newChild.return=workInProgress;workInProgress.child=newChild;return newChild;}function updateSimpleMemoComponent(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n// hasn't yet mounted. This happens when the inner render suspends.\n// We'll need to figure out if this is fine or can cause issues.\n{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar outerMemoType=workInProgress.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){// We warn when you define propTypes on lazy()\n// so let's just skip over it to find memo() outer wrapper.\n// Inner props for memo are validated later.\nvar lazyComponent=outerMemoType;var payload=lazyComponent._payload;var init=lazyComponent._init;try{outerMemoType=init(payload);}catch(x){outerMemoType=null;}// Inner propTypes will be validated in the function component path.\nvar outerPropTypes=outerMemoType&&outerMemoType.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,nextProps,// Resolved (SimpleMemoComponent has no defaultProps)\n'prop',getComponentNameFromType(outerMemoType));}}}}if(current!==null){var prevProps=current.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current.ref===workInProgress.ref&&// Prevent bailout if the implementation changed due to hot reload.\nworkInProgress.type===current.type){didReceiveUpdate=false;// The props are shallowly equal. Reuse the previous props object, like we\n// would during a normal fiber bailout.\n//\n// We don't have strong guarantees that the props object is referentially\n// equal during updates where we can't bail out anyway  like if the props\n// are shallowly equal, but there's a local state or context update in the\n// same batch.\n//\n// However, as a principle, we should aim to make the behavior consistent\n// across different ways of memoizing a component. For example, React.memo\n// has a different internal Fiber layout if you pass a normal function\n// component (SimpleMemoComponent) versus if you pass a different type\n// like forwardRef (MemoComponent). But this is an implementation detail.\n// Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n// affect whether the props object is reused during a bailout.\nworkInProgress.pendingProps=nextProps=prevProps;if(!checkScheduledUpdateOrContext(current,renderLanes)){// The pending lanes were cleared at the beginning of beginWork. We're\n// about to bail out, but there might be other lanes that weren't\n// included in the current render. Usually, the priority level of the\n// remaining updates is accumulated during the evaluation of the\n// component (i.e. when processing the update queue). But since since\n// we're bailing out early *without* evaluating the component, we need\n// to account for it here, too. Reset to the value of the current fiber.\n// NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n// because a MemoComponent fiber does not have hooks or an update queue;\n// rather, it wraps around an inner component, which may or may not\n// contains hooks.\n// TODO: Move the reset at in beginWork out of the common path so that\n// this is no longer necessary.\nworkInProgress.lanes=current.lanes;return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}else if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n// See https://github.com/facebook/react/pull/19216.\ndidReceiveUpdate=true;}}}return updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes);}function updateOffscreenComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;var prevState=current!==null?current.memoizedState:null;if(nextProps.mode==='hidden'||enableLegacyHidden){// Rendering a hidden tree.\nif((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy sync mode, don't defer the subtree. Render it now.\n// TODO: Consider how Offscreen should work with transitions in the future\nvar nextState={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=nextState;pushRenderLanes(workInProgress,renderLanes);}else if(!includesSomeLane(renderLanes,OffscreenLane)){var spawnedCachePool=null;// We're hidden, and we're not rendering at Offscreen. We will bail out\n// and resume this tree later.\nvar nextBaseLanes;if(prevState!==null){var prevBaseLanes=prevState.baseLanes;nextBaseLanes=mergeLanes(prevBaseLanes,renderLanes);}else{nextBaseLanes=renderLanes;}// Schedule this fiber to re-render at offscreen priority. Then bailout.\nworkInProgress.lanes=workInProgress.childLanes=laneToLanes(OffscreenLane);var _nextState={baseLanes:nextBaseLanes,cachePool:spawnedCachePool,transitions:null};workInProgress.memoizedState=_nextState;workInProgress.updateQueue=null;// to avoid a push/pop misalignment.\npushRenderLanes(workInProgress,nextBaseLanes);return null;}else{// This is the second render. The surrounding visible content has already\n// committed. Now we resume rendering the hidden tree.\n// Rendering at offscreen, so we can clear the base lanes.\nvar _nextState2={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=_nextState2;// Push the lanes that were skipped when we bailed out.\nvar subtreeRenderLanes=prevState!==null?prevState.baseLanes:renderLanes;pushRenderLanes(workInProgress,subtreeRenderLanes);}}else{// Rendering a visible tree.\nvar _subtreeRenderLanes;if(prevState!==null){// We're going from hidden -> visible.\n_subtreeRenderLanes=mergeLanes(prevState.baseLanes,renderLanes);workInProgress.memoizedState=null;}else{// We weren't previously hidden, and we still aren't, so there's nothing\n// special to do. Need to push to the stack regardless, though, to avoid\n// a push/pop misalignment.\n_subtreeRenderLanes=renderLanes;}pushRenderLanes(workInProgress,_subtreeRenderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}// Note: These happen to have identical begin phases, for now. We shouldn't hold\nfunction updateFragment(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMode(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateProfiler(current,workInProgress,renderLanes){{workInProgress.flags|=Update;{// Reset effect durations for the next eventual effect phase.\n// These are reset during render to allow the DevTools commit hook a chance to read them,\nvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(current===null&&ref!==null||current!==null&&current.ref!==ref){// Schedule a Ref effect\nworkInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}}function updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,true);context=getMaskedContext(workInProgress,unmaskedContext);}var nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateClassComponent(current,workInProgress,Component,nextProps,renderLanes){{// This is used by DevTools to force a boundary to error.\nswitch(shouldError(workInProgress)){case false:{var _instance=workInProgress.stateNode;var ctor=workInProgress.type;// TODO This way of resetting the error boundary state is a hack.\n// Is there a better way to do this?\nvar tempInstance=new ctor(workInProgress.memoizedProps,_instance.context);var state=tempInstance.state;_instance.updater.enqueueSetState(_instance,state,null);break;}case true:{workInProgress.flags|=DidCapture;workInProgress.flags|=ShouldCapture;// eslint-disable-next-line react-internal/prod-error-codes\nvar error$1=new Error('Simulated error coming from DevTools');var lane=pickArbitraryLane(renderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);// Schedule the error boundary to re-render using updated state\nvar update=createClassErrorUpdate(workInProgress,createCapturedValueAtFiber(error$1,workInProgress),lane);enqueueCapturedUpdate(workInProgress,update);break;}}if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);var instance=workInProgress.stateNode;var shouldUpdate;if(instance===null){resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress);// In the initial pass we might need to construct the instance.\nconstructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);shouldUpdate=true;}else if(current===null){// In a resume, we'll already have an instance we can reuse.\nshouldUpdate=resumeMountClassInstance(workInProgress,Component,nextProps,renderLanes);}else{shouldUpdate=updateClassInstance(current,workInProgress,Component,nextProps,renderLanes);}var nextUnitOfWork=finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes);{var inst=workInProgress.stateNode;if(shouldUpdate&&inst.props!==nextProps){if(!didWarnAboutReassigningProps){error('It looks like %s is reassigning its own `this.props` while rendering. '+'This is not supported and can lead to confusing bugs.',getComponentNameFromFiber(workInProgress)||'a component');}didWarnAboutReassigningProps=true;}}return nextUnitOfWork;}function finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes){// Refs should update even if shouldComponentUpdate returns false\nmarkRef(current,workInProgress);var didCaptureError=(workInProgress.flags&DidCapture)!==NoFlags;if(!shouldUpdate&&!didCaptureError){// Context providers should defer to sCU for rendering\nif(hasContext){invalidateContextProvider(workInProgress,Component,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}var instance=workInProgress.stateNode;// Rerender\nReactCurrentOwner$1.current=workInProgress;var nextChildren;if(didCaptureError&&typeof Component.getDerivedStateFromError!=='function'){// If we captured an error, but getDerivedStateFromError is not defined,\n// unmount all the children. componentDidCatch will schedule an update to\n// re-render a fallback. This is temporary until we migrate everyone to\n// the new API.\n// TODO: Warn in a future release.\nnextChildren=null;{stopProfilerTimerIfRunning();}}else{{markComponentRenderStarted(workInProgress);}{setIsRendering(true);nextChildren=instance.render();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance.render();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;if(current!==null&&didCaptureError){// If we're recovering from an error, reconcile without reusing any of\n// the existing children. Conceptually, the normal children and the children\n// that are shown on error are two different sets, so we shouldn't reuse\n// normal children even if their identities match.\nforceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}// Memoize state using the values we just used to render.\n// TODO: Restructure so we never read values from the instance.\nworkInProgress.memoizedState=instance.state;// The context might have changed so we need to recalculate it.\nif(hasContext){invalidateContextProvider(workInProgress,Component,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set\npushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderLanes){pushHostRootContext(workInProgress);if(current===null){throw new Error('Should have a current fiber. This is a bug in React.');}var nextProps=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;var prevChildren=prevState.element;cloneUpdateQueue(current,workInProgress);processUpdateQueue(workInProgress,nextProps,null,renderLanes);var nextState=workInProgress.memoizedState;var root=workInProgress.stateNode;// being called \"element\".\nvar nextChildren=nextState.element;if(prevState.isDehydrated){// This is a hydration root whose shell has not yet hydrated. We should\n// attempt to hydrate.\n// Flip isDehydrated to false to indicate that when this render\n// finishes, the root will no longer be dehydrated.\nvar overrideState={element:nextChildren,isDehydrated:false,cache:nextState.cache,pendingSuspenseBoundaries:nextState.pendingSuspenseBoundaries,transitions:nextState.transitions};var updateQueue=workInProgress.updateQueue;// `baseState` can always be the last state because the root doesn't\n// have reducer functions so it doesn't need rebasing.\nupdateQueue.baseState=overrideState;workInProgress.memoizedState=overrideState;if(workInProgress.flags&ForceClientRender){// Something errored during a previous attempt to hydrate the shell, so we\n// forced a client render.\nvar recoverableError=createCapturedValueAtFiber(new Error('There was an error while hydrating. Because the error happened outside '+'of a Suspense boundary, the entire root will switch to '+'client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError);}else if(nextChildren!==prevChildren){var _recoverableError=createCapturedValueAtFiber(new Error('This root received an early update, before anything was able '+'hydrate. Switched the entire root to client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,_recoverableError);}else{// The outermost shell has not hydrated yet. Start hydrating.\nenterHydrationState(workInProgress);var child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);workInProgress.child=child;var node=child;while(node){// Mark each child as hydrating. This is a fast path to know whether this\n// tree is part of a hydrating tree. This is used to determine if a child\n// node has fully mounted yet, and for scheduling event replaying.\n// Conceptually this is similar to Placement in that a new subtree is\n// inserted into the React tree here. It just happens to not need DOM\n// mutations because it already exists.\nnode.flags=node.flags&~Placement|Hydrating;node=node.sibling;}}}else{// Root is not dehydrated. Either this is a client-only root, or it\n// already hydrated.\nresetHydrationState();if(nextChildren===prevChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}function mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError){// Revert to client rendering.\nresetHydrationState();queueHydrationError(recoverableError);workInProgress.flags|=ForceClientRender;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostComponent(current,workInProgress,renderLanes){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var nextProps=workInProgress.pendingProps;var prevProps=current!==null?current.memoizedProps:null;var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common\n// case. We won't handle it as a reified child. We will instead handle\n// this in the host environment that also has access to this prop. That\n// avoids allocating another HostText fiber and traversing it.\nnextChildren=null;}else if(prevProps!==null&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to\n// empty, we need to schedule the text content to be reset.\nworkInProgress.flags|=ContentReset;}markRef(current,workInProgress);reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}// Nothing to do here. This is terminal. We'll do the completion step\n// immediately after.\nreturn null;}function mountLazyComponent(_current,workInProgress,elementType,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var lazyComponent=elementType;var payload=lazyComponent._payload;var init=lazyComponent._init;var Component=init(payload);// Store the unwrapped component in the type.\nworkInProgress.type=Component;var resolvedTag=workInProgress.tag=resolveLazyComponentTag(Component);var resolvedProps=resolveDefaultProps(Component,props);var child;switch(resolvedTag){case FunctionComponent:{{validateFunctionComponentInDev(workInProgress,Component);workInProgress.type=Component=resolveFunctionForHotReloading(Component);}child=updateFunctionComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ClassComponent:{{workInProgress.type=Component=resolveClassForHotReloading(Component);}child=updateClassComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ForwardRef:{{workInProgress.type=Component=resolveForwardRefForHotReloading(Component);}child=updateForwardRef(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case MemoComponent:{{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=Component.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,resolvedProps,// Resolved for outer only\n'prop',getComponentNameFromType(Component));}}}child=updateMemoComponent(null,workInProgress,Component,resolveDefaultProps(Component.type,resolvedProps),// The inner type can have defaults too\nrenderLanes);return child;}}var hint='';{if(Component!==null&&typeof Component==='object'&&Component.$$typeof===REACT_LAZY_TYPE){hint=' Did you wrap a component in React.lazy() more than once?';}}// This message intentionally doesn't mention ForwardRef or MemoComponent\n// because the fact that it's a separate type of work is an\n// implementation detail.\nthrow new Error(\"Element type is invalid. Received a promise that resolves to: \"+Component+\". \"+(\"Lazy element type must resolve to a class or function.\"+hint));}function mountIncompleteClassComponent(_current,workInProgress,Component,nextProps,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);// Promote the fiber to a class and try rendering again.\nworkInProgress.tag=ClassComponent;// The rest of this function is a fork of `updateClassComponent`\n// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}function mountIndeterminateComponent(_current,workInProgress,Component,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,false);context=getMaskedContext(workInProgress,unmaskedContext);}prepareToReadContext(workInProgress,renderLanes);var value;var hasId;{markComponentRenderStarted(workInProgress);}{if(Component.prototype&&typeof Component.prototype.render==='function'){var componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutBadClass[componentName]){error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \"+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);didWarnAboutBadClass[componentName]=true;}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);}setIsRendering(true);ReactCurrentOwner$1.current=workInProgress;value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;{// Support for module components is deprecated and is removed behind a flag.\n// Whether or not it would crash later, we want to show a good message in DEV first.\nif(typeof value==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){var _componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName,_componentName,_componentName);didWarnAboutModulePatternComponent[_componentName]=true;}}}if(// Run these checks in production only if the flag is off.\n// Eventually we'll delete this branch altogether.\ntypeof value==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){{var _componentName2=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName2]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName2,_componentName2,_componentName2);didWarnAboutModulePatternComponent[_componentName2]=true;}}// Proceed under the assumption that this is a class instance\nworkInProgress.tag=ClassComponent;// Throw out any hooks that were used.\nworkInProgress.memoizedState=null;workInProgress.updateQueue=null;// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext=false;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}workInProgress.memoizedState=value.state!==null&&value.state!==undefined?value.state:null;initializeUpdateQueue(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,Component,props,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}else{// Proceed under the assumption that this is a function component\nworkInProgress.tag=FunctionComponent;{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}reconcileChildren(null,workInProgress,value,renderLanes);{validateFunctionComponentInDev(workInProgress,Component);}return workInProgress.child;}}function validateFunctionComponentInDev(workInProgress,Component){{if(Component){if(Component.childContextTypes){error('%s(...): childContextTypes cannot be defined on a function component.',Component.displayName||Component.name||'Component');}}if(workInProgress.ref!==null){var info='';var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!didWarnAboutFunctionRefs[warningKey]){didWarnAboutFunctionRefs[warningKey]=true;error('Function components cannot be given refs. '+'Attempts to access this ref will fail. '+'Did you mean to use React.forwardRef()?%s',info);}}if(Component.defaultProps!==undefined){var componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutDefaultPropsOnFunctionComponent[componentName]){error('%s: Support for defaultProps will be removed from function components '+'in a future major release. Use JavaScript default parameters instead.',componentName);didWarnAboutDefaultPropsOnFunctionComponent[componentName]=true;}}if(typeof Component.getDerivedStateFromProps==='function'){var _componentName3=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]){error('%s: Function components do not support getDerivedStateFromProps.',_componentName3);didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]=true;}}if(typeof Component.contextType==='object'&&Component.contextType!==null){var _componentName4=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutContextTypeOnFunctionComponent[_componentName4]){error('%s: Function components do not support contextType.',_componentName4);didWarnAboutContextTypeOnFunctionComponent[_componentName4]=true;}}}}var SUSPENDED_MARKER={dehydrated:null,treeContext:null,retryLane:NoLane};function mountSuspenseOffscreenState(renderLanes){return{baseLanes:renderLanes,cachePool:getSuspendedCache(),transitions:null};}function updateSuspenseOffscreenState(prevOffscreenState,renderLanes){var cachePool=null;return{baseLanes:mergeLanes(prevOffscreenState.baseLanes,renderLanes),cachePool:cachePool,transitions:prevOffscreenState.transitions};}// TODO: Probably should inline this back\nfunction shouldRemainOnFallback(suspenseContext,current,workInProgress,renderLanes){// If we're already showing a fallback, there are cases where we need to\n// remain on that fallback regardless of whether the content has resolved.\n// For example, SuspenseList coordinates when nested content appears.\nif(current!==null){var suspenseState=current.memoizedState;if(suspenseState===null){// Currently showing content. Don't hide it, even if ForceSuspenseFallback\n// is true. More precise name might be \"ForceRemainSuspenseFallback\".\n// Note: This is a factoring smell. Can't remain on a fallback if there's\n// no fallback to remain on.\nreturn false;}}// Not currently showing content. Consult the Suspense context.\nreturn hasSuspenseContext(suspenseContext,ForceSuspenseFallback);}function getRemainingWorkInPrimaryTree(current,renderLanes){// TODO: Should not remove render lanes that were pinged during this render\nreturn removeLanes(current.childLanes,renderLanes);}function updateSuspenseComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;// This is used by DevTools to force a boundary to suspend.\n{if(shouldSuspend(workInProgress)){workInProgress.flags|=DidCapture;}}var suspenseContext=suspenseStackCursor.current;var showFallback=false;var didSuspend=(workInProgress.flags&DidCapture)!==NoFlags;if(didSuspend||shouldRemainOnFallback(suspenseContext,current)){// Something in this boundary's subtree already suspended. Switch to\n// rendering the fallback children.\nshowFallback=true;workInProgress.flags&=~DidCapture;}else{// Attempting the main content\nif(current===null||current.memoizedState!==null){// This is a new mount or this boundary is already showing a fallback state.\n// Mark this subtree context as having at least one invisible parent that could\n// handle the fallback state.\n// Avoided boundaries are not considered since they cannot handle preferred fallback states.\n{suspenseContext=addSubtreeSuspenseContext(suspenseContext,InvisibleParentSuspenseContext);}}}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);pushSuspenseContext(workInProgress,suspenseContext);// OK, the next part is confusing. We're about to reconcile the Suspense\n// boundary's children. This involves some custom reconciliation logic. Two\n// main reasons this is so complicated.\n//\n// First, Legacy Mode has different semantics for backwards compatibility. The\n// primary tree will commit in an inconsistent state, so when we do the\n// second pass to render the fallback, we do some exceedingly, uh, clever\n// hacks to make that not totally break. Like transferring effects and\n// deletions from hidden tree. In Concurrent Mode, it's much simpler,\n// because we bailout on the primary tree completely and leave it in its old\n// state, no effects. Same as what we do for Offscreen (except that\n// Offscreen doesn't have the first render pass).\n//\n// Second is hydration. During hydration, the Suspense fiber has a slightly\n// different layout, where the child points to a dehydrated fragment, which\n// contains the DOM rendered by the server.\n//\n// Third, even if you set all that aside, Suspense is like error boundaries in\n// that we first we try to render one tree, and if that fails, we render again\n// and switch to a different tree. Like a try/catch block. So we have to track\n// which branch we're currently rendering. Ideally we would model this using\n// a stack.\nif(current===null){// Initial mount\n// Special path for hydration\n// If we're currently hydrating, try to hydrate this boundary.\ntryToClaimNextHydratableInstance(workInProgress);// This could've been a dehydrated suspense component.\nvar suspenseState=workInProgress.memoizedState;if(suspenseState!==null){var dehydrated=suspenseState.dehydrated;if(dehydrated!==null){return mountDehydratedSuspenseComponent(workInProgress,dehydrated);}}var nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;if(showFallback){var fallbackFragment=mountSuspenseFallbackChildren(workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var primaryChildFragment=workInProgress.child;primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackFragment;}else{return mountSuspensePrimaryChildren(workInProgress,nextPrimaryChildren);}}else{// This is an update.\n// Special path for hydration\nvar prevState=current.memoizedState;if(prevState!==null){var _dehydrated=prevState.dehydrated;if(_dehydrated!==null){return updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,_dehydrated,prevState,renderLanes);}}if(showFallback){var _nextFallbackChildren=nextProps.fallback;var _nextPrimaryChildren=nextProps.children;var fallbackChildFragment=updateSuspenseFallbackChildren(current,workInProgress,_nextPrimaryChildren,_nextFallbackChildren,renderLanes);var _primaryChildFragment2=workInProgress.child;var prevOffscreenState=current.child.memoizedState;_primaryChildFragment2.memoizedState=prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes):updateSuspenseOffscreenState(prevOffscreenState,renderLanes);_primaryChildFragment2.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}else{var _nextPrimaryChildren2=nextProps.children;var _primaryChildFragment3=updateSuspensePrimaryChildren(current,workInProgress,_nextPrimaryChildren2,renderLanes);workInProgress.memoizedState=null;return _primaryChildFragment3;}}}function mountSuspensePrimaryChildren(workInProgress,primaryChildren,renderLanes){var mode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);primaryChildFragment.return=workInProgress;workInProgress.child=primaryChildFragment;return primaryChildFragment;}function mountSuspenseFallbackChildren(workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var progressedPrimaryFragment=workInProgress.child;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;var fallbackChildFragment;if((mode&ConcurrentMode)===NoMode&&progressedPrimaryFragment!==null){// In legacy mode, we commit the primary tree as if it successfully\n// completed, even though it's in an inconsistent state.\nprimaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n// final amounts. This seems counterintuitive, since we're intentionally\n// not measuring part of the render phase, but this makes it match what we\n// do in Concurrent Mode.\nprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=0;primaryChildFragment.treeBaseDuration=0;}fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}else{primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}primaryChildFragment.return=workInProgress;fallbackChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function mountWorkInProgressOffscreenFiber(offscreenProps,mode,renderLanes){// The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n// this wrapper function to constrain it.\nreturn createFiberFromOffscreen(offscreenProps,mode,NoLanes,null);}function updateWorkInProgressOffscreenFiber(current,offscreenProps){// The props argument to `createWorkInProgress` is `any` typed, so we use this\n// wrapper function to constrain it.\nreturn createWorkInProgress(current,offscreenProps);}function updateSuspensePrimaryChildren(current,workInProgress,primaryChildren,renderLanes){var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,{mode:'visible',children:primaryChildren});if((workInProgress.mode&ConcurrentMode)===NoMode){primaryChildFragment.lanes=renderLanes;}primaryChildFragment.return=workInProgress;primaryChildFragment.sibling=null;if(currentFallbackChildFragment!==null){// Delete the fallback child fragment\nvar deletions=workInProgress.deletions;if(deletions===null){workInProgress.deletions=[currentFallbackChildFragment];workInProgress.flags|=ChildDeletion;}else{deletions.push(currentFallbackChildFragment);}}workInProgress.child=primaryChildFragment;return primaryChildFragment;}function updateSuspenseFallbackChildren(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;if(// In legacy mode, we commit the primary tree as if it successfully\n// completed, even though it's in an inconsistent state.\n(mode&ConcurrentMode)===NoMode&&// Make sure we're on the second pass, i.e. the primary child fragment was\n// already cloned. In legacy mode, the only case where this isn't true is\n// when DevTools forces us to display a fallback; we skip the first render\n// pass entirely and go straight to rendering the fallback. (In Concurrent\n// Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n// only codepath.)\nworkInProgress.child!==currentPrimaryChildFragment){var progressedPrimaryFragment=workInProgress.child;primaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n// final amounts. This seems counterintuitive, since we're intentionally\n// not measuring part of the render phase, but this makes it match what we\n// do in Concurrent Mode.\nprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=currentPrimaryChildFragment.selfBaseDuration;primaryChildFragment.treeBaseDuration=currentPrimaryChildFragment.treeBaseDuration;}// The fallback fiber was added as a deletion during the first pass.\n// However, since we're going to remain on the fallback, we no longer want\n// to delete it.\nworkInProgress.deletions=null;}else{primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,primaryChildProps);// Since we're reusing a current tree, we need to reuse the flags, too.\n// (We don't do this in legacy mode, because in legacy mode we don't re-use\n// the current tree; see previous branch.)\nprimaryChildFragment.subtreeFlags=currentPrimaryChildFragment.subtreeFlags&StaticMask;}var fallbackChildFragment;if(currentFallbackChildFragment!==null){fallbackChildFragment=createWorkInProgress(currentFallbackChildFragment,fallbackChildren);}else{fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);// Needs a placement effect because the parent (the Suspense boundary) already\n// mounted but this is a new fiber.\nfallbackChildFragment.flags|=Placement;}fallbackChildFragment.return=workInProgress;primaryChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,recoverableError){// Falling back to client rendering. Because this has performance\n// implications, it's considered a recoverable error, even though the user\n// likely won't observe anything wrong with the UI.\n//\n// The error is passed in as an argument to enforce that every caller provide\n// a custom message, or explicitly opt out (currently the only path that opts\n// out is legacy mode; every concurrent path provides an error).\nif(recoverableError!==null){queueHydrationError(recoverableError);}// This will add the old fiber to the deletion list\nreconcileChildFibers(workInProgress,current.child,null,renderLanes);// We're now not suspended nor dehydrated.\nvar nextProps=workInProgress.pendingProps;var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Needs a placement effect because the parent (the Suspense boundary) already\n// mounted but this is a new fiber.\nprimaryChildFragment.flags|=Placement;workInProgress.memoizedState=null;return primaryChildFragment;}function mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var fiberMode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,fiberMode);var fallbackChildFragment=createFiberFromFragment(fallbackChildren,fiberMode,renderLanes,null);// Needs a placement effect because the parent (the Suspense\n// boundary) already mounted but this is a new fiber.\nfallbackChildFragment.flags|=Placement;primaryChildFragment.return=workInProgress;fallbackChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;if((workInProgress.mode&ConcurrentMode)!==NoMode){// We will have dropped the effect list which contains the\n// deletion. We need to reconcile to delete the current child.\nreconcileChildFibers(workInProgress,current.child,null,renderLanes);}return fallbackChildFragment;}function mountDehydratedSuspenseComponent(workInProgress,suspenseInstance,renderLanes){// During the first pass, we'll bail out and not drill into the children.\n// Instead, we'll leave the content in place and try to hydrate it later.\nif((workInProgress.mode&ConcurrentMode)===NoMode){{error('Cannot hydrate Suspense in legacy mode. Switch from '+'ReactDOM.hydrate(element, container) to '+'ReactDOMClient.hydrateRoot(container, <App />)'+'.render(element) or remove the Suspense components from '+'the server rendered components.');}workInProgress.lanes=laneToLanes(SyncLane);}else if(isSuspenseInstanceFallback(suspenseInstance)){// This is a client-only boundary. Since we won't get any content from the server\n// for this, we need to schedule that at a higher priority based on when it would\n// have timed out. In theory we could render it in this pass but it would have the\n// wrong priority associated with it and will prevent hydration of parent path.\n// Instead, we'll leave work left on it to render it in a separate commit.\n// TODO This time should be the time at which the server rendered response that is\n// a parent to this boundary was displayed. However, since we currently don't have\n// a protocol to transfer that time, we'll just estimate it by using the current\n// time. This will mean that Suspense timeouts are slightly shifted to later than\n// they should be.\n// Schedule a normal pri update to render this content.\nworkInProgress.lanes=laneToLanes(DefaultHydrationLane);}else{// We'll continue hydrating the rest at offscreen priority since we'll already\n// be showing the right content coming from the server, it is no rush.\nworkInProgress.lanes=laneToLanes(OffscreenLane);}return null;}function updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,suspenseInstance,suspenseState,renderLanes){if(!didSuspend){// This is the first render pass. Attempt to hydrate.\n// We should never be hydrating at this point because it is the first pass,\n// but after we've already committed once.\nwarnIfHydrating();if((workInProgress.mode&ConcurrentMode)===NoMode){return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,// TODO: When we delete legacy mode, we should make this error argument\n// required  every concurrent mode path that causes hydration to\n// de-opt to client rendering should have an error message.\nnull);}if(isSuspenseInstanceFallback(suspenseInstance)){// This boundary is in a permanent fallback state. In this case, we'll never\n// get an update and we'll never be able to hydrate the final content. Let's just try the\n// client side render instead.\nvar digest,message,stack;{var _getSuspenseInstanceF=getSuspenseInstanceFallbackErrorDetails(suspenseInstance);digest=_getSuspenseInstanceF.digest;message=_getSuspenseInstanceF.message;stack=_getSuspenseInstanceF.stack;}var error;if(message){// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error(message);}else{error=new Error('The server could not finish this Suspense boundary, likely '+'due to an error during server rendering. Switched to '+'client rendering.');}var capturedValue=createCapturedValue(error,digest,stack);return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,capturedValue);}// any context has changed, we need to treat is as if the input might have changed.\nvar hasContextChanged=includesSomeLane(renderLanes,current.childLanes);if(didReceiveUpdate||hasContextChanged){// This boundary has changed since the first render. This means that we are now unable to\n// hydrate it. We might still be able to hydrate it using a higher priority lane.\nvar root=getWorkInProgressRoot();if(root!==null){var attemptHydrationAtLane=getBumpedLaneForHydration(root,renderLanes);if(attemptHydrationAtLane!==NoLane&&attemptHydrationAtLane!==suspenseState.retryLane){// Intentionally mutating since this render will get interrupted. This\n// is one of the very rare times where we mutate the current tree\n// during the render phase.\nsuspenseState.retryLane=attemptHydrationAtLane;// TODO: Ideally this would inherit the event time of the current render\nvar eventTime=NoTimestamp;enqueueConcurrentRenderForLane(current,attemptHydrationAtLane);scheduleUpdateOnFiber(root,current,attemptHydrationAtLane,eventTime);}}// If we have scheduled higher pri work above, this will probably just abort the render\n// since we now have higher priority work, but in case it doesn't, we need to prepare to\n// render something, if we time out. Even if that requires us to delete everything and\n// skip hydration.\n// Delay having to do this as long as the suspense timeout allows us.\nrenderDidSuspendDelayIfPossible();var _capturedValue=createCapturedValue(new Error('This Suspense boundary received an update before it finished '+'hydrating. This caused the boundary to switch to client rendering. '+'The usual way to fix this is to wrap the original update '+'in startTransition.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue);}else if(isSuspenseInstancePending(suspenseInstance)){// This component is still pending more data from the server, so we can't hydrate its\n// content. We treat it as if this component suspended itself. It might seem as if\n// we could just try to render it client-side instead. However, this will perform a\n// lot of unnecessary work and is unlikely to complete since it often will suspend\n// on missing data anyway. Additionally, the server might be able to render more\n// than we can on the client yet. In that case we'd end up with more fallback states\n// on the client than if we just leave it alone. If the server times out or errors\n// these should update this boundary to the permanent Fallback state instead.\n// Mark it as having captured (i.e. suspended).\nworkInProgress.flags|=DidCapture;// Leave the child in place. I.e. the dehydrated fragment.\nworkInProgress.child=current.child;// Register a callback to retry this boundary once the server has sent the result.\nvar retry=retryDehydratedSuspenseBoundary.bind(null,current);registerSuspenseInstanceRetry(suspenseInstance,retry);return null;}else{// This is the first attempt.\nreenterHydrationStateFromDehydratedSuspenseInstance(workInProgress,suspenseInstance,suspenseState.treeContext);var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Mark the children as hydrating. This is a fast path to know whether this\n// tree is part of a hydrating tree. This is used to determine if a child\n// node has fully mounted yet, and for scheduling event replaying.\n// Conceptually this is similar to Placement in that a new subtree is\n// inserted into the React tree here. It just happens to not need DOM\n// mutations because it already exists.\nprimaryChildFragment.flags|=Hydrating;return primaryChildFragment;}}else{// This is the second render pass. We already attempted to hydrated, but\n// something either suspended or errored.\nif(workInProgress.flags&ForceClientRender){// Something errored during hydration. Try again without hydrating.\nworkInProgress.flags&=~ForceClientRender;var _capturedValue2=createCapturedValue(new Error('There was an error while hydrating this Suspense boundary. '+'Switched to client rendering.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue2);}else if(workInProgress.memoizedState!==null){// Something suspended and we should still be in dehydrated mode.\n// Leave the existing child in place.\nworkInProgress.child=current.child;// The dehydrated completion pass expects this flag to be there\n// but the normal suspense pass doesn't.\nworkInProgress.flags|=DidCapture;return null;}else{// Suspended but we should no longer be in dehydrated mode.\n// Therefore we now have to render the fallback.\nvar nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;var fallbackChildFragment=mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var _primaryChildFragment4=workInProgress.child;_primaryChildFragment4.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}}}function scheduleSuspenseWorkOnFiber(fiber,renderLanes,propagationRoot){fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber.return,renderLanes,propagationRoot);}function propagateSuspenseContextChange(workInProgress,firstChild,renderLanes){// Mark any Suspense boundaries with fallbacks as having work to do.\n// If they were previously forced into fallbacks, they may now be able\n// to unblock.\nvar node=firstChild;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){scheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}}else if(node.tag===SuspenseListComponent){// If the tail is hidden there might not be an Suspense boundaries\n// to schedule work on. In this case we have to schedule it on the\n// list itself.\n// We don't have to traverse to the children of the list since\n// the list will propagate the change when it rerenders.\nscheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function findLastContentRow(firstChild){// This is going to find the last row among these children that is already\n// showing content on the screen, as opposed to being in fallback state or\n// new. If a row has multiple Suspense boundaries, any of them being in the\n// fallback state, counts as the whole row being in a fallback state.\n// Note that the \"rows\" will be workInProgress, but any nested children\n// will still be current since we haven't rendered them yet. The mounted\n// order may not be the same as the new order. We use the new order.\nvar row=firstChild;var lastContentRow=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\nif(currentRow!==null&&findFirstSuspended(currentRow)===null){lastContentRow=row;}row=row.sibling;}return lastContentRow;}function validateRevealOrder(revealOrder){{if(revealOrder!==undefined&&revealOrder!=='forwards'&&revealOrder!=='backwards'&&revealOrder!=='together'&&!didWarnAboutRevealOrder[revealOrder]){didWarnAboutRevealOrder[revealOrder]=true;if(typeof revealOrder==='string'){switch(revealOrder.toLowerCase()){case'together':case'forwards':case'backwards':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'Use lowercase \"%s\" instead.',revealOrder,revealOrder.toLowerCase());break;}case'forward':case'backward':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'React uses the -s suffix in the spelling. Use \"%ss\" instead.',revealOrder,revealOrder.toLowerCase());break;}default:error('\"%s\" is not a supported revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);break;}}else{error('%s is not a supported value for revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);}}}}function validateTailOptions(tailMode,revealOrder){{if(tailMode!==undefined&&!didWarnAboutTailOptions[tailMode]){if(tailMode!=='collapsed'&&tailMode!=='hidden'){didWarnAboutTailOptions[tailMode]=true;error('\"%s\" is not a supported value for tail on <SuspenseList />. '+'Did you mean \"collapsed\" or \"hidden\"?',tailMode);}else if(revealOrder!=='forwards'&&revealOrder!=='backwards'){didWarnAboutTailOptions[tailMode]=true;error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is '+'\"forwards\" or \"backwards\". '+'Did you mean to specify revealOrder=\"forwards\"?',tailMode);}}}}function validateSuspenseListNestedChild(childSlot,index){{var isAnArray=isArray(childSlot);var isIterable=!isAnArray&&typeof getIteratorFn(childSlot)==='function';if(isAnArray||isIterable){var type=isAnArray?'array':'iterable';error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in '+'an additional SuspenseList to configure its revealOrder: '+'<SuspenseList revealOrder=...> ... '+'<SuspenseList revealOrder=...>{%s}</SuspenseList> ... '+'</SuspenseList>',type,index,type);return false;}}return true;}function validateSuspenseListChildren(children,revealOrder){{if((revealOrder==='forwards'||revealOrder==='backwards')&&children!==undefined&&children!==null&&children!==false){if(isArray(children)){for(var i=0;i<children.length;i++){if(!validateSuspenseListNestedChild(children[i],i)){return;}}}else{var iteratorFn=getIteratorFn(children);if(typeof iteratorFn==='function'){var childrenIterator=iteratorFn.call(children);if(childrenIterator){var step=childrenIterator.next();var _i=0;for(;!step.done;step=childrenIterator.next()){if(!validateSuspenseListNestedChild(step.value,_i)){return;}_i++;}}}else{error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. '+'This is not useful since it needs multiple rows. '+'Did you mean to pass multiple children or an array?',revealOrder);}}}}}function initSuspenseListRenderState(workInProgress,isBackwards,tail,lastContentRow,tailMode){var renderState=workInProgress.memoizedState;if(renderState===null){workInProgress.memoizedState={isBackwards:isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail:tail,tailMode:tailMode};}else{// We can reuse the existing object from previous renders.\nrenderState.isBackwards=isBackwards;renderState.rendering=null;renderState.renderingStartTime=0;renderState.last=lastContentRow;renderState.tail=tail;renderState.tailMode=tailMode;}}// This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\nfunction updateSuspenseListComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var revealOrder=nextProps.revealOrder;var tailMode=nextProps.tail;var newChildren=nextProps.children;validateRevealOrder(revealOrder);validateTailOptions(tailMode,revealOrder);validateSuspenseListChildren(newChildren,revealOrder);reconcileChildren(current,workInProgress,newChildren,renderLanes);var suspenseContext=suspenseStackCursor.current;var shouldForceFallback=hasSuspenseContext(suspenseContext,ForceSuspenseFallback);if(shouldForceFallback){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);workInProgress.flags|=DidCapture;}else{var didSuspendBefore=current!==null&&(current.flags&DidCapture)!==NoFlags;if(didSuspendBefore){// If we previously forced a fallback, we need to schedule work\n// on any nested boundaries to let them know to try to render\n// again. This is the same as context updating.\npropagateSuspenseContextChange(workInProgress,workInProgress.child,renderLanes);}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);if((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy mode, SuspenseList doesn't work so we just\n// use make it a noop by treating it as the default revealOrder.\nworkInProgress.memoizedState=null;}else{switch(revealOrder){case'forwards':{var lastContentRow=findLastContentRow(workInProgress.child);var tail;if(lastContentRow===null){// The whole list is part of the tail.\n// TODO: We could fast path by just rendering the tail now.\ntail=workInProgress.child;workInProgress.child=null;}else{// Disconnect the tail rows after the content row.\n// We're going to render them separately later.\ntail=lastContentRow.sibling;lastContentRow.sibling=null;}initSuspenseListRenderState(workInProgress,false,// isBackwards\ntail,lastContentRow,tailMode);break;}case'backwards':{// We're going to find the first row that has existing content.\n// At the same time we're going to reverse the list of everything\n// we pass in the meantime. That's going to be our tail in reverse\n// order.\nvar _tail=null;var row=workInProgress.child;workInProgress.child=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\nif(currentRow!==null&&findFirstSuspended(currentRow)===null){// This is the beginning of the main content.\nworkInProgress.child=row;break;}var nextRow=row.sibling;row.sibling=_tail;_tail=row;row=nextRow;}// TODO: If workInProgress.child is null, we can continue on the tail immediately.\ninitSuspenseListRenderState(workInProgress,true,// isBackwards\n_tail,null,// last\ntailMode);break;}case'together':{initSuspenseListRenderState(workInProgress,false,// isBackwards\nnull,// tail\nnull,// last\nundefined);break;}default:{// The default reveal order is the same as not having\n// a boundary.\nworkInProgress.memoizedState=null;}}}return workInProgress.child;}function updatePortalComponent(current,workInProgress,renderLanes){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(current===null){// Portals are special because we don't append the children during mount\n// but at commit. Therefore we need to track insertions which the normal\n// flow doesn't do during mount. This doesn't happen at the root because\n// the root always starts with a \"current\" with a null child.\n// TODO: Consider unifying this with how the root works.\nworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}var hasWarnedAboutUsingNoValuePropOnContextProvider=false;function updateContextProvider(current,workInProgress,renderLanes){var providerType=workInProgress.type;var context=providerType._context;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var newValue=newProps.value;{if(!('value'in newProps)){if(!hasWarnedAboutUsingNoValuePropOnContextProvider){hasWarnedAboutUsingNoValuePropOnContextProvider=true;error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');}}var providerPropTypes=workInProgress.type.propTypes;if(providerPropTypes){checkPropTypes(providerPropTypes,newProps,'prop','Context.Provider');}}pushProvider(workInProgress,context,newValue);{if(oldProps!==null){var oldValue=oldProps.value;if(objectIs(oldValue,newValue)){// No change. Bailout early if children are the same.\nif(oldProps.children===newProps.children&&!hasContextChanged()){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}else{// The context value changed. Search for matching consumers and schedule\n// them to update.\npropagateContextChange(workInProgress,context,renderLanes);}}}var newChildren=newProps.children;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}var hasWarnedAboutUsingContextAsConsumer=false;function updateContextConsumer(current,workInProgress,renderLanes){var context=workInProgress.type;// The logic below for Context differs depending on PROD or DEV mode. In\n// DEV mode, we create a separate object for Context.Consumer that acts\n// like a proxy to Context. This proxy object adds unnecessary code in PROD\n// so we use the old behaviour (Context.Consumer references Context) to\n// reduce size and overhead. The separate object references context via\n// a property called \"_context\", which also gives us the ability to check\n// in DEV mode if this property exists or not and warn if it does not.\n{if(context._context===undefined){// This may be because it's a Context (rather than a Consumer).\n// Or it may be because it's older React where they're the same thing.\n// We only want to warn if we're sure it's a new React.\nif(context!==context.Consumer){if(!hasWarnedAboutUsingContextAsConsumer){hasWarnedAboutUsingContextAsConsumer=true;error('Rendering <Context> directly is not supported and will be removed in '+'a future major release. Did you mean to render <Context.Consumer> instead?');}}}else{context=context._context;}}var newProps=workInProgress.pendingProps;var render=newProps.children;{if(typeof render!=='function'){error('A context consumer was rendered with multiple children, or a child '+\"that isn't a function. A context consumer expects a single child \"+'that is a function. If you did pass a function, make sure there '+'is no trailing or leading whitespace around it.');}}prepareToReadContext(workInProgress,renderLanes);var newValue=readContext(context);{markComponentRenderStarted(workInProgress);}var newChildren;{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);newChildren=render(newValue);setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}function markWorkInProgressReceivedUpdate(){didReceiveUpdate=true;}function resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress){if((workInProgress.mode&ConcurrentMode)===NoMode){if(current!==null){// A lazy component only mounts if it suspended inside a non-\n// concurrent tree, in an inconsistent state. We want to treat it like\n// a new mount, even though an empty version of it already committed.\n// Disconnect the alternate pointers.\ncurrent.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect\nworkInProgress.flags|=Placement;}}}function bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes){if(current!==null){// Reuse previous dependencies\nworkInProgress.dependencies=current.dependencies;}{// Don't update \"base\" render times for bailouts.\nstopProfilerTimerIfRunning();}markSkippedUpdateLanes(workInProgress.lanes);// Check if the children have any pending work.\nif(!includesSomeLane(renderLanes,workInProgress.childLanes)){// The children don't have any work either. We can skip them.\n// TODO: Once we add back resuming, we should check if the children are\n// a work-in-progress set. If so, we need to transfer their effects.\n{return null;}}// This fiber doesn't have work, but its subtree does. Clone the child\n// fibers and continue.\ncloneChildFibers(current,workInProgress);return workInProgress.child;}function remountFiber(current,oldWorkInProgress,newWorkInProgress){{var returnFiber=oldWorkInProgress.return;if(returnFiber===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Cannot swap the root fiber.');}// Disconnect from the old current.\n// It will get deleted.\ncurrent.alternate=null;oldWorkInProgress.alternate=null;// Connect to the new tree.\nnewWorkInProgress.index=oldWorkInProgress.index;newWorkInProgress.sibling=oldWorkInProgress.sibling;newWorkInProgress.return=oldWorkInProgress.return;newWorkInProgress.ref=oldWorkInProgress.ref;// Replace the child/sibling pointers above it.\nif(oldWorkInProgress===returnFiber.child){returnFiber.child=newWorkInProgress;}else{var prevSibling=returnFiber.child;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Expected parent to have a child.');}while(prevSibling.sibling!==oldWorkInProgress){prevSibling=prevSibling.sibling;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Expected to find the previous sibling.');}}prevSibling.sibling=newWorkInProgress;}// Delete the old fiber and place the new one.\n// Since the old fiber is disconnected, we have to schedule it manually.\nvar deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[current];returnFiber.flags|=ChildDeletion;}else{deletions.push(current);}newWorkInProgress.flags|=Placement;// Restart work from the new fiber.\nreturn newWorkInProgress;}}function checkScheduledUpdateOrContext(current,renderLanes){// Before performing an early bailout, we must check if there are pending\n// updates or context.\nvar updateLanes=current.lanes;if(includesSomeLane(updateLanes,renderLanes)){return true;}// No pending update, but because context is propagated lazily, we need\nreturn false;}function attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes){// This fiber does not have any pending work. Bailout without entering\n// the begin phase. There's still some bookkeeping we that needs to be done\n// in this optimized path, mostly pushing stuff onto the stack.\nswitch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);var root=workInProgress.stateNode;resetHydrationState();break;case HostComponent:pushHostContext(workInProgress);break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){pushContextProvider(workInProgress);}break;}case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress.memoizedProps.value;var context=workInProgress.type._context;pushProvider(workInProgress,context,newValue);break;}case Profiler:{// Profiler should only call onRender when one of its descendants actually rendered.\nvar hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(hasChildWork){workInProgress.flags|=Update;}{// Reset effect durations for the next eventual effect phase.\n// These are reset during render to allow the DevTools commit hook a chance to read them,\nvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}break;case SuspenseComponent:{var state=workInProgress.memoizedState;if(state!==null){if(state.dehydrated!==null){pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// We know that this component will suspend again because if it has\n// been unsuspended it has committed as a resolved Suspense component.\n// If it needs to be retried, it should have work scheduled on it.\nworkInProgress.flags|=DidCapture;// We should never render the children of a dehydrated boundary until we\n// upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\nreturn null;}// If this boundary is currently timed out, we need to decide\n// whether to retry the primary children, or to skip over it and\n// go straight to the fallback. Check the priority of the primary\n// child fragment.\nvar primaryChildFragment=workInProgress.child;var primaryChildLanes=primaryChildFragment.childLanes;if(includesSomeLane(renderLanes,primaryChildLanes)){// The primary children have pending work. Use the normal path\n// to attempt to render the primary children again.\nreturn updateSuspenseComponent(current,workInProgress,renderLanes);}else{// The primary child fragment does not have pending work marked\n// on it\npushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// The primary children do not have pending work with sufficient\n// priority. Bailout.\nvar child=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);if(child!==null){// The fallback children have pending work. Skip over the\n// primary children and work on the fallback.\nreturn child.sibling;}else{// Note: We can return `null` here because we already checked\n// whether there were nested context consumers, via the call to\n// `bailoutOnAlreadyFinishedWork` above.\nreturn null;}}}else{pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));}break;}case SuspenseListComponent:{var didSuspendBefore=(current.flags&DidCapture)!==NoFlags;var _hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(didSuspendBefore){if(_hasChildWork){// If something was in fallback state last time, and we have all the\n// same children then we're still in progressive loading state.\n// Something might get unblocked by state updates or retries in the\n// tree which will affect the tail. So we need to use the normal\n// path to compute the correct tail.\nreturn updateSuspenseListComponent(current,workInProgress,renderLanes);}// If none of the children had any work, that means that none of\n// them got retried so they'll still be blocked in the same way\n// as before. We can fast bail out.\nworkInProgress.flags|=DidCapture;}// If nothing suspended before and we're rendering the same children,\n// then the tail doesn't matter. Anything new that suspends will work\n// in the \"together\" mode, so we can continue from the state we had.\nvar renderState=workInProgress.memoizedState;if(renderState!==null){// Reset to the \"together\" mode in case we've started a different\n// update in the past but didn't complete it.\nrenderState.rendering=null;renderState.tail=null;renderState.lastEffect=null;}pushSuspenseContext(workInProgress,suspenseStackCursor.current);if(_hasChildWork){break;}else{// If none of the children had any work, that means that none of\n// them got retried so they'll still be blocked in the same way\n// as before. We can fast bail out.\nreturn null;}}case OffscreenComponent:case LegacyHiddenComponent:{// Need to check if the tree still needs to be deferred. This is\n// almost identical to the logic used in the normal update path,\n// so we'll just enter that. The only difference is we'll bail out\n// at the next level instead of this one, because the child props\n// have not changed. Which is fine.\n// TODO: Probably should refactor `beginWork` to split the bailout\n// path from the normal path. I'm tempted to do a labeled break here\n// but I won't :)\nworkInProgress.lanes=NoLanes;return updateOffscreenComponent(current,workInProgress,renderLanes);}}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}function beginWork(current,workInProgress,renderLanes){{if(workInProgress._debugNeedsRemount&&current!==null){// This will restart the begin phase with a new fiber.\nreturn remountFiber(current,workInProgress,createFiberFromTypeAndProps(workInProgress.type,workInProgress.key,workInProgress.pendingProps,workInProgress._debugOwner||null,workInProgress.mode,workInProgress.lanes));}}if(current!==null){var oldProps=current.memoizedProps;var newProps=workInProgress.pendingProps;if(oldProps!==newProps||hasContextChanged()||// Force a re-render if the implementation changed due to hot reload:\nworkInProgress.type!==current.type){// If props or context changed, mark the fiber as having performed work.\n// This may be unset if the props are determined to be equal later (memo).\ndidReceiveUpdate=true;}else{// Neither props nor legacy context changes. Check if there's a pending\n// update or context change.\nvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext&&// If this is the second pass of an error or suspense boundary, there\n// may not be work scheduled on `current`, so we check for this flag.\n(workInProgress.flags&DidCapture)===NoFlags){// No pending updates or context. Bail out now.\ndidReceiveUpdate=false;return attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes);}if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n// See https://github.com/facebook/react/pull/19216.\ndidReceiveUpdate=true;}else{// An update was scheduled on this fiber, but there are no new props\n// nor legacy context. Set this to false. If an update queue or context\n// consumer produces a changed value, it will set this to true. Otherwise,\n// the component will assume the children have not changed and bail out.\ndidReceiveUpdate=false;}}}else{didReceiveUpdate=false;if(getIsHydrating()&&isForkedChild(workInProgress)){// Check if this child belongs to a list of muliple children in\n// its parent.\n//\n// In a true multi-threaded implementation, we would render children on\n// parallel threads. This would represent the beginning of a new render\n// thread for this subtree.\n//\n// We only use this for id generation during hydration, which is why the\n// logic is located in this special branch.\nvar slotIndex=workInProgress.index;var numberOfForks=getForksAtLevel();pushTreeId(workInProgress,numberOfForks,slotIndex);}}// Before entering the begin phase, clear pending update priority.\n// TODO: This assumes that we're about to evaluate the component and process\n// the update queue. However, there's an exception: SimpleMemoComponent\n// sometimes bails out later in the begin phase. This indicates that we should\n// move this assignment out of the common path and into each branch.\nworkInProgress.lanes=NoLanes;switch(workInProgress.tag){case IndeterminateComponent:{return mountIndeterminateComponent(current,workInProgress,workInProgress.type,renderLanes);}case LazyComponent:{var elementType=workInProgress.elementType;return mountLazyComponent(current,workInProgress,elementType,renderLanes);}case FunctionComponent:{var Component=workInProgress.type;var unresolvedProps=workInProgress.pendingProps;var resolvedProps=workInProgress.elementType===Component?unresolvedProps:resolveDefaultProps(Component,unresolvedProps);return updateFunctionComponent(current,workInProgress,Component,resolvedProps,renderLanes);}case ClassComponent:{var _Component=workInProgress.type;var _unresolvedProps=workInProgress.pendingProps;var _resolvedProps=workInProgress.elementType===_Component?_unresolvedProps:resolveDefaultProps(_Component,_unresolvedProps);return updateClassComponent(current,workInProgress,_Component,_resolvedProps,renderLanes);}case HostRoot:return updateHostRoot(current,workInProgress,renderLanes);case HostComponent:return updateHostComponent(current,workInProgress,renderLanes);case HostText:return updateHostText(current,workInProgress);case SuspenseComponent:return updateSuspenseComponent(current,workInProgress,renderLanes);case HostPortal:return updatePortalComponent(current,workInProgress,renderLanes);case ForwardRef:{var type=workInProgress.type;var _unresolvedProps2=workInProgress.pendingProps;var _resolvedProps2=workInProgress.elementType===type?_unresolvedProps2:resolveDefaultProps(type,_unresolvedProps2);return updateForwardRef(current,workInProgress,type,_resolvedProps2,renderLanes);}case Fragment:return updateFragment(current,workInProgress,renderLanes);case Mode:return updateMode(current,workInProgress,renderLanes);case Profiler:return updateProfiler(current,workInProgress,renderLanes);case ContextProvider:return updateContextProvider(current,workInProgress,renderLanes);case ContextConsumer:return updateContextConsumer(current,workInProgress,renderLanes);case MemoComponent:{var _type2=workInProgress.type;var _unresolvedProps3=workInProgress.pendingProps;// Resolve outer props first, then resolve inner props.\nvar _resolvedProps3=resolveDefaultProps(_type2,_unresolvedProps3);{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=_type2.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,_resolvedProps3,// Resolved for outer only\n'prop',getComponentNameFromType(_type2));}}}_resolvedProps3=resolveDefaultProps(_type2.type,_resolvedProps3);return updateMemoComponent(current,workInProgress,_type2,_resolvedProps3,renderLanes);}case SimpleMemoComponent:{return updateSimpleMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,renderLanes);}case IncompleteClassComponent:{var _Component2=workInProgress.type;var _unresolvedProps4=workInProgress.pendingProps;var _resolvedProps4=workInProgress.elementType===_Component2?_unresolvedProps4:resolveDefaultProps(_Component2,_unresolvedProps4);return mountIncompleteClassComponent(current,workInProgress,_Component2,_resolvedProps4,renderLanes);}case SuspenseListComponent:{return updateSuspenseListComponent(current,workInProgress,renderLanes);}case ScopeComponent:{break;}case OffscreenComponent:{return updateOffscreenComponent(current,workInProgress,renderLanes);}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into\n// a PlacementAndUpdate.\nworkInProgress.flags|=Update;}function markRef$1(workInProgress){workInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}var appendAllChildren;var updateHostContainer;var updateHostComponent$1;var updateHostText$1;{// Mutation mode\nappendAllChildren=function(parent,workInProgress,needsVisibilityToggle,isHidden){// We only have the top Fiber that was created but we need recurse down its\n// children to find all the terminal nodes.\nvar node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal);else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}};updateHostContainer=function(current,workInProgress){// Noop\n};updateHostComponent$1=function(current,workInProgress,type,newProps,rootContainerInstance){// If we have an alternate, that means this is an update and we need to\n// schedule a side-effect to do the updates.\nvar oldProps=current.memoizedProps;if(oldProps===newProps){// In mutation mode, this is sufficient for a bailout because\n// we won't touch this node even if children changed.\nreturn;}// If we get updated because one of our children updated, we don't\n// have newProps so we'll have to reuse them.\n// TODO: Split the update API as separate for the props vs. children.\n// Even better would be if children weren't special cased at all tho.\nvar instance=workInProgress.stateNode;var currentHostContext=getHostContext();// TODO: Experiencing an error where oldProps is null. Suggests a host\n// component is hitting the resume path. Figure out why. Possibly\n// related to `hidden`.\nvar updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);// TODO: Type this specific to this type of component.\nworkInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update. All the work is done in commitWork.\nif(updatePayload){markUpdate(workInProgress);}};updateHostText$1=function(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.\nif(oldText!==newText){markUpdate(workInProgress);}};}function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){if(getIsHydrating()){// If we're hydrating, we should consume as many items as we can\n// so we don't leave any behind.\nreturn;}switch(renderState.tailMode){case'hidden':{// Any insertions at the end of the tail list after this point\n// should be invisible. If there are already mounted boundaries\n// anything before them are not considered for collapsing.\n// Therefore we need to go through the whole tail to find if\n// there are any.\nvar tailNode=renderState.tail;var lastTailNode=null;while(tailNode!==null){if(tailNode.alternate!==null){lastTailNode=tailNode;}tailNode=tailNode.sibling;}// Next we're simply going to delete all insertions after the\n// last rendered item.\nif(lastTailNode===null){// All remaining items in the tail are insertions.\nrenderState.tail=null;}else{// Detach the insertion after the last node that was already\n// inserted.\nlastTailNode.sibling=null;}break;}case'collapsed':{// Any insertions at the end of the tail list after this point\n// should be invisible. If there are already mounted boundaries\n// anything before them are not considered for collapsing.\n// Therefore we need to go through the whole tail to find if\n// there are any.\nvar _tailNode=renderState.tail;var _lastTailNode=null;while(_tailNode!==null){if(_tailNode.alternate!==null){_lastTailNode=_tailNode;}_tailNode=_tailNode.sibling;}// Next we're simply going to delete all insertions after the\n// last rendered item.\nif(_lastTailNode===null){// All remaining items in the tail are insertions.\nif(!hasRenderedATailFallback&&renderState.tail!==null){// We suspended during the head. We want to show at least one\n// row at the tail. So we'll keep on and cut off the rest.\nrenderState.tail.sibling=null;}else{renderState.tail=null;}}else{// Detach the insertion after the last node that was already\n// inserted.\n_lastTailNode.sibling=null;}break;}}}function bubbleProperties(completedWork){var didBailout=completedWork.alternate!==null&&completedWork.alternate.child===completedWork.child;var newChildLanes=NoLanes;var subtreeFlags=NoFlags;if(!didBailout){// Bubble up the earliest expiration time.\nif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n// profiler durations.\nvar actualDuration=completedWork.actualDuration;var treeBaseDuration=completedWork.selfBaseDuration;var child=completedWork.child;while(child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(child.lanes,child.childLanes));subtreeFlags|=child.subtreeFlags;subtreeFlags|=child.flags;// When a fiber is cloned, its actualDuration is reset to 0. This value will\n// only be updated if work is done on the fiber (i.e. it doesn't bailout).\n// When work is done, it should bubble to the parent's actualDuration. If\n// the fiber has not been cloned though, (meaning no work was done), then\n// this value will reflect the amount of time spent working on a previous\n// render. In that case it should not bubble. We determine whether it was\n// cloned by comparing the child pointer.\nactualDuration+=child.actualDuration;treeBaseDuration+=child.treeBaseDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;completedWork.treeBaseDuration=treeBaseDuration;}else{var _child=completedWork.child;while(_child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child.lanes,_child.childLanes));subtreeFlags|=_child.subtreeFlags;subtreeFlags|=_child.flags;// Update the return pointer so the tree is consistent. This is a code\n// smell because it assumes the commit phase is never concurrent with\n// the render phase. Will address during refactor to alternate model.\n_child.return=completedWork;_child=_child.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}else{// Bubble up the earliest expiration time.\nif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n// profiler durations.\nvar _treeBaseDuration=completedWork.selfBaseDuration;var _child2=completedWork.child;while(_child2!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child2.lanes,_child2.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n// so we should bubble those up even during a bailout. All the other\n// flags have a lifetime only of a single render + commit, so we should\n// ignore them.\nsubtreeFlags|=_child2.subtreeFlags&StaticMask;subtreeFlags|=_child2.flags&StaticMask;_treeBaseDuration+=_child2.treeBaseDuration;_child2=_child2.sibling;}completedWork.treeBaseDuration=_treeBaseDuration;}else{var _child3=completedWork.child;while(_child3!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child3.lanes,_child3.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n// so we should bubble those up even during a bailout. All the other\n// flags have a lifetime only of a single render + commit, so we should\n// ignore them.\nsubtreeFlags|=_child3.subtreeFlags&StaticMask;subtreeFlags|=_child3.flags&StaticMask;// Update the return pointer so the tree is consistent. This is a code\n// smell because it assumes the commit phase is never concurrent with\n// the render phase. Will address during refactor to alternate model.\n_child3.return=completedWork;_child3=_child3.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}completedWork.childLanes=newChildLanes;return didBailout;}function completeDehydratedSuspenseBoundary(current,workInProgress,nextState){if(hasUnhydratedTailNodes()&&(workInProgress.mode&ConcurrentMode)!==NoMode&&(workInProgress.flags&DidCapture)===NoFlags){warnIfUnhydratedTailNodes(workInProgress);resetHydrationState();workInProgress.flags|=ForceClientRender|Incomplete|ShouldCapture;return false;}var wasHydrated=popHydrationState(workInProgress);if(nextState!==null&&nextState.dehydrated!==null){// We might be inside a hydration state the first time we're picking up this\n// Suspense boundary, and also after we've reentered it for further hydration.\nif(current===null){if(!wasHydrated){throw new Error('A dehydrated suspense component was completed without a hydrated node. '+'This is probably a bug in React.');}prepareToHydrateHostSuspenseInstance(workInProgress);bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var isTimedOutSuspense=nextState!==null;if(isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return false;}else{// We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n// state since we're now exiting out of it. popHydrationState doesn't do that for us.\nresetHydrationState();if((workInProgress.flags&DidCapture)===NoFlags){// This boundary did not suspend so it's now hydrated and unsuspended.\nworkInProgress.memoizedState=null;}// If nothing suspended, we need to schedule an effect to mark this boundary\n// as having hydrated so events know that they're free to be invoked.\n// It's also a signal to replay events and the suspense callback.\n// If something suspended, schedule an effect to attach retry listeners.\n// So we might as well always mark this.\nworkInProgress.flags|=Update;bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var _isTimedOutSuspense=nextState!==null;if(_isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar _primaryChildFragment=workInProgress.child;if(_primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=_primaryChildFragment.treeBaseDuration;}}}}return false;}}else{// Successfully completed this tree. If this was a forced client render,\n// there may have been recoverable errors during first hydration\n// attempt. If so, add them to a queue so we can log them in the\n// commit phase.\nupgradeHydrationErrorsToRecoverable();// Fall through to normal Suspense path\nreturn true;}}function completeWork(current,workInProgress,renderLanes){var newProps=workInProgress.pendingProps;// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(workInProgress);switch(workInProgress.tag){case IndeterminateComponent:case LazyComponent:case SimpleMemoComponent:case FunctionComponent:case ForwardRef:case Fragment:case Mode:case Profiler:case ContextConsumer:case MemoComponent:bubbleProperties(workInProgress);return null;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case HostRoot:{var fiberRoot=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children\n// that weren't hydrated.\nvar wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// If we hydrated, then we'll need to schedule an update for\n// the commit side-effects on the root.\nmarkUpdate(workInProgress);}else{if(current!==null){var prevState=current.memoizedState;if(// Check if this is a client root\n!prevState.isDehydrated||// Check if we reverted to client rendering (e.g. due to an error)\n(workInProgress.flags&ForceClientRender)!==NoFlags){// Schedule an effect to clear this container at the start of the\n// next commit. This handles the case of React rendering into a\n// container with previous children. It's also safe to do for\n// updates too, because current.child would only be null if the\n// previous render was null (so the container would already\n// be empty).\nworkInProgress.flags|=Snapshot;// If this was a forced client render, there may have been\n// recoverable errors during first hydration attempt. If so, add\n// them to a queue so we can log them in the commit phase.\nupgradeHydrationErrorsToRecoverable();}}}}updateHostContainer(current,workInProgress);bubbleProperties(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef$1(workInProgress);}}else{if(!newProps){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\nbubbleProperties(workInProgress);return null;}var currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context\n// \"stack\" as the parent. Then append children as we go in beginWork\n// or completeWork depending on whether we want to add them top->down or\n// bottom->up. Top->down is faster in IE11.\nvar _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){// TODO: Move this and createInstance step into the beginPhase\n// to consolidate.\nif(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,currentHostContext)){// If changes to the hydrated node need to be applied at the\n// commit-phase we mark this as such.\nmarkUpdate(workInProgress);}}else{var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress);appendAllChildren(instance,workInProgress,false,false);workInProgress.stateNode=instance;// Certain renderers require commit-time effects for initial mount.\n// (eg DOM renderer supports auto-focus for certain elements).\n// Make sure such renderers get scheduled for later work.\nif(finalizeInitialChildren(instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback\nmarkRef$1(workInProgress);}}bubbleProperties(workInProgress);return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need\n// to schedule a side-effect to do the updates.\nupdateHostText$1(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\n}var _rootContainerInstance=getRootHostContainer();var _currentHostContext=getHostContext();var _wasHydrated2=popHydrationState(workInProgress);if(_wasHydrated2){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress);}}bubbleProperties(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var nextState=workInProgress.memoizedState;// Special path for dehydrated boundaries. We may eventually move this\n// to its own fiber type so that we can add other kinds of hydration\n// boundaries that aren't associated with a Suspense tree. In anticipation\n// of such a refactor, all the hydration logic is contained in\n// this branch.\nif(current===null||current.memoizedState!==null&&current.memoizedState.dehydrated!==null){var fallthroughToNormalSuspensePath=completeDehydratedSuspenseBoundary(current,workInProgress,nextState);if(!fallthroughToNormalSuspensePath){if(workInProgress.flags&ShouldCapture){// Special case. There were remaining unhydrated nodes. We treat\n// this as a mismatch. Revert to client rendering.\nreturn workInProgress;}else{// Did not finish hydrating, either because this is the initial\n// render or because something suspended.\nreturn null;}}// Continue with the normal Suspense path.\n}if((workInProgress.flags&DidCapture)!==NoFlags){// Something suspended. Re-render with the fallback children.\nworkInProgress.lanes=renderLanes;// Do not reset the effect list.\nif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}// Don't bubble properties in this case.\nreturn workInProgress;}var nextDidTimeout=nextState!==null;var prevDidTimeout=current!==null&&current.memoizedState!==null;// a passive effect, which is when we process the transitions\nif(nextDidTimeout!==prevDidTimeout){// an effect to toggle the subtree's visibility. When we switch from\n// fallback -> primary, the inner Offscreen fiber schedules this effect\n// as part of its normal complete phase. But when we switch from\n// primary -> fallback, the inner Offscreen fiber does not have a complete\n// phase. So we need to schedule its effect here.\n//\n// We also use this flag to connect/disconnect the effects, but the same\n// logic applies: when re-connecting, the Offscreen fiber's complete\n// phase will handle scheduling the effect. It's only when the fallback\n// is active that we have to do anything special.\nif(nextDidTimeout){var _offscreenFiber2=workInProgress.child;_offscreenFiber2.flags|=Visibility;// TODO: This will still suspend a synchronous tree if anything\n// in the concurrent tree already suspended during this render.\n// This is a known bug.\nif((workInProgress.mode&ConcurrentMode)!==NoMode){// TODO: Move this back to throwException because this is too late\n// if this is a large tree which is common for initial loads. We\n// don't know if we should restart a render or not until we get\n// this marker, and this is too late.\n// If this render already had a ping or lower pri updates,\n// and this is the first time we know we're going to suspend we\n// should be able to immediately restart from within throwException.\nvar hasInvisibleChildContext=current===null&&(workInProgress.memoizedProps.unstable_avoidThisFallback!==true||!enableSuspenseAvoidThisFallback);if(hasInvisibleChildContext||hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext)){// If this was in an invisible tree or a new render, then showing\n// this boundary is ok.\nrenderDidSuspend();}else{// Otherwise, we're going to have to hide content so we should\n// suspend for longer if possible.\nrenderDidSuspendDelayIfPossible();}}}}var wakeables=workInProgress.updateQueue;if(wakeables!==null){// Schedule an effect to attach a retry listener to the promise.\n// TODO: Move to passive phase\nworkInProgress.flags|=Update;}bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){if(nextDidTimeout){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return null;}case HostPortal:popHostContainer(workInProgress);updateHostContainer(current,workInProgress);if(current===null){preparePortalMount(workInProgress.stateNode.containerInfo);}bubbleProperties(workInProgress);return null;case ContextProvider:// Pop provider fiber\nvar context=workInProgress.type._context;popProvider(context,workInProgress);bubbleProperties(workInProgress);return null;case IncompleteClassComponent:{// Same as class component case. I put it down here so that the tags are\n// sequential to ensure this switch is compiled to a jump table.\nvar _Component=workInProgress.type;if(isContextProvider(_Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);var renderState=workInProgress.memoizedState;if(renderState===null){// We're running in the default, \"independent\" mode.\n// We don't do anything in this mode.\nbubbleProperties(workInProgress);return null;}var didSuspendAlready=(workInProgress.flags&DidCapture)!==NoFlags;var renderedTail=renderState.rendering;if(renderedTail===null){// We just rendered the head.\nif(!didSuspendAlready){// This is the first pass. We need to figure out if anything is still\n// suspended in the rendered set.\n// If new content unsuspended, but there's still some content that\n// didn't. Then we need to do a second pass that forces everything\n// to keep showing their fallbacks.\n// We might be suspended if something in this render pass suspended, or\n// something in the previous committed pass suspended. Otherwise,\n// there's no chance so we can skip the expensive call to\n// findFirstSuspended.\nvar cannotBeSuspended=renderHasNotSuspendedYet()&&(current===null||(current.flags&DidCapture)===NoFlags);if(!cannotBeSuspended){var row=workInProgress.child;while(row!==null){var suspended=findFirstSuspended(row);if(suspended!==null){didSuspendAlready=true;workInProgress.flags|=DidCapture;cutOffTailIfNeeded(renderState,false);// If this is a newly suspended tree, it might not get committed as\n// part of the second pass. In that case nothing will subscribe to\n// its thenables. Instead, we'll transfer its thenables to the\n// SuspenseList so that it can retry if they resolve.\n// There might be multiple of these in the list but since we're\n// going to wait for all of them anyway, it doesn't really matter\n// which ones gets to ping. In theory we could get clever and keep\n// track of how many dependencies remain but it gets tricky because\n// in the meantime, we can add/remove/change items and dependencies.\n// We might bail out of the loop before finding any but that\n// doesn't matter since that means that the other boundaries that\n// we did find already has their listeners attached.\nvar newThenables=suspended.updateQueue;if(newThenables!==null){workInProgress.updateQueue=newThenables;workInProgress.flags|=Update;}// Rerender the whole list, but this time, we'll force fallbacks\n// to stay in place.\n// Reset the effect flags before doing the second pass since that's now invalid.\n// Reset the child fibers to their original state.\nworkInProgress.subtreeFlags=NoFlags;resetChildFibers(workInProgress,renderLanes);// Set up the Suspense Context to force suspense and immediately\n// rerender the children.\npushSuspenseContext(workInProgress,setShallowSuspenseContext(suspenseStackCursor.current,ForceSuspenseFallback));// Don't bubble properties in this case.\nreturn workInProgress.child;}row=row.sibling;}}if(renderState.tail!==null&&now()>getRenderTargetTime()){// We have already passed our CPU deadline but we still have rows\n// left in the tail. We'll just give up further attempts to render\n// the main content and only render fallbacks.\nworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n// to get it started back up to attempt the next item. While in terms\n// of priority this work has the same priority as this current render,\n// it's not part of the same transition once the transition has\n// committed. If it's sync, we still want to yield so that it can be\n// painted. Conceptually, this is really the same as pinging.\n// We can use any RetryLane even if it's the one currently rendering\n// since we're leaving it behind on this node.\nworkInProgress.lanes=SomeRetryLane;}}else{cutOffTailIfNeeded(renderState,false);}// Next we're going to render the tail.\n}else{// Append the rendered row to the child list.\nif(!didSuspendAlready){var _suspended=findFirstSuspended(renderedTail);if(_suspended!==null){workInProgress.flags|=DidCapture;didSuspendAlready=true;// Ensure we transfer the update queue to the parent so that it doesn't\n// get lost if this row ends up dropped during a second pass.\nvar _newThenables=_suspended.updateQueue;if(_newThenables!==null){workInProgress.updateQueue=_newThenables;workInProgress.flags|=Update;}cutOffTailIfNeeded(renderState,true);// This might have been modified.\nif(renderState.tail===null&&renderState.tailMode==='hidden'&&!renderedTail.alternate&&!getIsHydrating()// We don't cut it if we're hydrating.\n){// We're done.\nbubbleProperties(workInProgress);return null;}}else if(// The time it took to render last row is greater than the remaining\n// time we have to render. So rendering one more row would likely\n// exceed it.\nnow()*2-renderState.renderingStartTime>getRenderTargetTime()&&renderLanes!==OffscreenLane){// We have now passed our CPU deadline and we'll just give up further\n// attempts to render the main content and only render fallbacks.\n// The assumption is that this is usually faster.\nworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n// to get it started back up to attempt the next item. While in terms\n// of priority this work has the same priority as this current render,\n// it's not part of the same transition once the transition has\n// committed. If it's sync, we still want to yield so that it can be\n// painted. Conceptually, this is really the same as pinging.\n// We can use any RetryLane even if it's the one currently rendering\n// since we're leaving it behind on this node.\nworkInProgress.lanes=SomeRetryLane;}}if(renderState.isBackwards){// The effect list of the backwards tail will have been added\n// to the end. This breaks the guarantee that life-cycles fire in\n// sibling order but that isn't a strong guarantee promised by React.\n// Especially since these might also just pop in during future commits.\n// Append to the beginning of the list.\nrenderedTail.sibling=workInProgress.child;workInProgress.child=renderedTail;}else{var previousSibling=renderState.last;if(previousSibling!==null){previousSibling.sibling=renderedTail;}else{workInProgress.child=renderedTail;}renderState.last=renderedTail;}}if(renderState.tail!==null){// We still have tail rows to render.\n// Pop a row.\nvar next=renderState.tail;renderState.rendering=next;renderState.tail=next.sibling;renderState.renderingStartTime=now();next.sibling=null;// Restore the context.\n// TODO: We can probably just avoid popping it instead and only\n// setting it the first time we go from not suspended to suspended.\nvar suspenseContext=suspenseStackCursor.current;if(didSuspendAlready){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);}else{suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);// Do a pass over the next row.\n// Don't bubble properties in this case.\nreturn next;}bubbleProperties(workInProgress);return null;}case ScopeComponent:{break;}case OffscreenComponent:case LegacyHiddenComponent:{popRenderLanes(workInProgress);var _nextState=workInProgress.memoizedState;var nextIsHidden=_nextState!==null;if(current!==null){var _prevState=current.memoizedState;var prevIsHidden=_prevState!==null;if(prevIsHidden!==nextIsHidden&&// LegacyHidden doesn't do any hiding  it only pre-renders.\n!enableLegacyHidden){workInProgress.flags|=Visibility;}}if(!nextIsHidden||(workInProgress.mode&ConcurrentMode)===NoMode){bubbleProperties(workInProgress);}else{// Don't bubble properties for hidden children unless we're rendering\n// at offscreen priority.\nif(includesSomeLane(subtreeRenderLanes,OffscreenLane)){bubbleProperties(workInProgress);{// Check if there was an insertion or update in the hidden subtree.\n// If so, we need to hide those nodes in the commit phase, so\n// schedule a visibility effect.\nif(workInProgress.subtreeFlags&(Placement|Update)){workInProgress.flags|=Visibility;}}}}return null;}case CacheComponent:{return null;}case TracingMarkerComponent:{return null;}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}function unwindWork(current,workInProgress,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(workInProgress);switch(workInProgress.tag){case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}var flags=workInProgress.flags;if(flags&ShouldCapture){workInProgress.flags=flags&~ShouldCapture|DidCapture;if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case HostRoot:{var root=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();var _flags=workInProgress.flags;if((_flags&ShouldCapture)!==NoFlags&&(_flags&DidCapture)===NoFlags){// There was an error during render that wasn't captured by a suspense\n// boundary. Do a second pass on the root to unmount the children.\nworkInProgress.flags=_flags&~ShouldCapture|DidCapture;return workInProgress;}// We unwound to the root without completing it. Exit.\nreturn null;}case HostComponent:{// TODO: popHydrationState\npopHostContext(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var suspenseState=workInProgress.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){if(workInProgress.alternate===null){throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in '+'React. Please file an issue.');}resetHydrationState();}var _flags2=workInProgress.flags;if(_flags2&ShouldCapture){workInProgress.flags=_flags2&~ShouldCapture|DidCapture;// Captured a suspense effect. Re-render the boundary.\nif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);// SuspenseList doesn't actually catch anything. It should've been\n// caught by a nested boundary. If not, it should bubble through.\nreturn null;}case HostPortal:popHostContainer(workInProgress);return null;case ContextProvider:var context=workInProgress.type._context;popProvider(context,workInProgress);return null;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(workInProgress);return null;case CacheComponent:return null;default:return null;}}function unwindInterruptedWork(current,interruptedWork,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(interruptedWork);switch(interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;if(childContextTypes!==null&&childContextTypes!==undefined){popContext(interruptedWork);}break;}case HostRoot:{var root=interruptedWork.stateNode;popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);resetWorkInProgressVersions();break;}case HostComponent:{popHostContext(interruptedWork);break;}case HostPortal:popHostContainer(interruptedWork);break;case SuspenseComponent:popSuspenseContext(interruptedWork);break;case SuspenseListComponent:popSuspenseContext(interruptedWork);break;case ContextProvider:var context=interruptedWork.type._context;popProvider(context,interruptedWork);break;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(interruptedWork);break;}}var didWarnAboutUndefinedSnapshotBeforeUpdate=null;{didWarnAboutUndefinedSnapshotBeforeUpdate=new Set();}// Used during the commit phase to track the state of the Offscreen component stack.\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n// Only used when enableSuspenseLayoutEffectSemantics is enabled.\nvar offscreenSubtreeIsHidden=false;var offscreenSubtreeWasHidden=false;var PossiblyWeakSet=typeof WeakSet==='function'?WeakSet:Set;var nextEffect=null;// Used for Profiling builds to track updaters.\nvar inProgressLanes=null;var inProgressRoot=null;function reportUncaughtErrorInDEV(error){// Wrapping each small part of the commit phase into a guarded\n// callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n// But we rely on it to surface errors to DEV tools like overlays\n// (https://github.com/facebook/react/issues/21712).\n// As a compromise, rethrow only caught errors in a guard.\n{invokeGuardedCallback(null,function(){throw error;});clearCaughtError();}}var callComponentWillUnmountWithTimer=function(current,instance){instance.props=current.memoizedProps;instance.state=current.memoizedState;if(current.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentWillUnmount();}finally{recordLayoutEffectDuration(current);}}else{instance.componentWillUnmount();}};// Capture errors so they don't interrupt mounting.\nfunction safelyCallCommitHookLayoutEffectListMount(current,nearestMountedAncestor){try{commitHookEffectListMount(Layout,current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current,nearestMountedAncestor,instance){try{callComponentWillUnmountWithTimer(current,instance);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\nfunction safelyCallComponentDidMount(current,nearestMountedAncestor,instance){try{instance.componentDidMount();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\nfunction safelyAttachRef(current,nearestMountedAncestor){try{commitAttachRef(current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}function safelyDetachRef(current,nearestMountedAncestor){var ref=current.ref;if(ref!==null){if(typeof ref==='function'){var retVal;try{if(enableProfilerTimer&&enableProfilerCommitHooks&&current.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(null);}finally{recordLayoutEffectDuration(current);}}else{retVal=ref(null);}}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(current));}}}else{ref.current=null;}}}function safelyCallDestroy(current,nearestMountedAncestor,destroy){try{destroy();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}var focusedInstanceHandle=null;var shouldFireAfterActiveInstanceBlur=false;function commitBeforeMutationEffects(root,firstChild){focusedInstanceHandle=prepareForCommit(root.containerInfo);nextEffect=firstChild;commitBeforeMutationEffects_begin();// We no longer need to track the active instance fiber\nvar shouldFire=shouldFireAfterActiveInstanceBlur;shouldFireAfterActiveInstanceBlur=false;focusedInstanceHandle=null;return shouldFire;}function commitBeforeMutationEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;// This phase is only used for beforeActiveInstanceBlur.\nvar child=fiber.child;if((fiber.subtreeFlags&BeforeMutationMask)!==NoFlags&&child!==null){child.return=fiber;nextEffect=child;}else{commitBeforeMutationEffects_complete();}}}function commitBeforeMutationEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;setCurrentFiber(fiber);try{commitBeforeMutationEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitBeforeMutationEffectsOnFiber(finishedWork){var current=finishedWork.alternate;var flags=finishedWork.flags;if((flags&Snapshot)!==NoFlags){setCurrentFiber(finishedWork);switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{break;}case ClassComponent:{if(current!==null){var prevProps=current.memoizedProps;var prevState=current.memoizedState;var instance=finishedWork.stateNode;// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}var snapshot=instance.getSnapshotBeforeUpdate(finishedWork.elementType===finishedWork.type?prevProps:resolveDefaultProps(finishedWork.type,prevProps),prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;if(snapshot===undefined&&!didWarnSet.has(finishedWork.type)){didWarnSet.add(finishedWork.type);error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '+'must be returned. You have returned undefined.',getComponentNameFromFiber(finishedWork));}}instance.__reactInternalSnapshotBeforeUpdate=snapshot;}break;}case HostRoot:{{var root=finishedWork.stateNode;clearContainer(root.containerInfo);}break;}case HostComponent:case HostText:case HostPortal:case IncompleteClassComponent:// Nothing to do for these component types\nbreak;default:{throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}resetCurrentFiber();}}function commitHookEffectListUnmount(flags,finishedWork,nearestMountedAncestor){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){// Unmount\nvar destroy=effect.destroy;effect.destroy=undefined;if(destroy!==undefined){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStarted(finishedWork);}}{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}safelyCallDestroy(finishedWork,nearestMountedAncestor,destroy);{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStopped();}}}}effect=effect.next;}while(effect!==firstEffect);}}function commitHookEffectListMount(flags,finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStarted(finishedWork);}}// Mount\nvar create=effect.create;{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}effect.destroy=create();{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStopped();}}{var destroy=effect.destroy;if(destroy!==undefined&&typeof destroy!=='function'){var hookName=void 0;if((effect.tag&Layout)!==NoFlags){hookName='useLayoutEffect';}else if((effect.tag&Insertion)!==NoFlags){hookName='useInsertionEffect';}else{hookName='useEffect';}var addendum=void 0;if(destroy===null){addendum=' You returned null. If your effect does not require clean '+'up, return undefined (or nothing).';}else if(typeof destroy.then==='function'){addendum='\\n\\nIt looks like you wrote '+hookName+'(async () => ...) or returned a Promise. '+'Instead, write the async function inside your effect '+'and call it immediately:\\n\\n'+hookName+'(() => {\\n'+'  async function fetchData() {\\n'+'    // You can await here\\n'+'    const response = await MyAPI.getData(someId);\\n'+'    // ...\\n'+'  }\\n'+'  fetchData();\\n'+\"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\"+'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';}else{addendum=' You returned: '+destroy;}error('%s must not return anything besides a function, '+'which is used for clean-up.%s',hookName,addendum);}}}effect=effect.next;}while(effect!==firstEffect);}}function commitPassiveEffectDurations(finishedRoot,finishedWork){{// Only Profilers with work in their subtree will have an Update effect scheduled.\nif((finishedWork.flags&Update)!==NoFlags){switch(finishedWork.tag){case Profiler:{var passiveEffectDuration=finishedWork.stateNode.passiveEffectDuration;var _finishedWork$memoize=finishedWork.memoizedProps,id=_finishedWork$memoize.id,onPostCommit=_finishedWork$memoize.onPostCommit;// This value will still reflect the previous commit phase.\n// It does not get reset until the start of the next commit phase.\nvar commitTime=getCommitTime();var phase=finishedWork.alternate===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onPostCommit==='function'){onPostCommit(id,phase,passiveEffectDuration,commitTime);}// Bubble times to the next nearest ancestor Profiler.\n// After we process that Profiler, we'll bubble further up.\nvar parentFiber=finishedWork.return;outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.passiveEffectDuration+=passiveEffectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.passiveEffectDuration+=passiveEffectDuration;break outer;}parentFiber=parentFiber.return;}break;}}}}}function commitLayoutEffectOnFiber(finishedRoot,current,finishedWork,committedLanes){if((finishedWork.flags&LayoutMask)!==NoFlags){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){// At this point layout effects have already been destroyed (during mutation phase).\n// This is done to prevent sibling component effects from interfering with each other,\n// e.g. a destroy function in one component should never override a ref set\n// by a create function in another component during the same commit.\nif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListMount(Layout|HasEffect,finishedWork);}finally{recordLayoutEffectDuration(finishedWork);}}else{commitHookEffectListMount(Layout|HasEffect,finishedWork);}}break;}case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.flags&Update){if(!offscreenSubtreeWasHidden){if(current===null){// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidMount();}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidMount();}}else{var prevProps=finishedWork.elementType===finishedWork.type?current.memoizedProps:resolveDefaultProps(finishedWork.type,current.memoizedProps);var prevState=current.memoizedState;// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}}}}// TODO: I think this is now always non-null by the time it reaches the\n// commit phase. Consider removing the type check.\nvar updateQueue=finishedWork.updateQueue;if(updateQueue!==null){{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\ncommitUpdateQueue(finishedWork,updateQueue,instance);}break;}case HostRoot:{// TODO: I think this is now always non-null by the time it reaches the\n// commit phase. Consider removing the type check.\nvar _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null){switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:_instance=finishedWork.child.stateNode;break;}}commitUpdateQueue(finishedWork,_updateQueue,_instance);}break;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted\n// (eg DOM renderer may schedule auto-focus for inputs and form controls).\n// These effects should only be committed when components are first mounted,\n// aka when there is no current/alternate.\nif(current===null&&finishedWork.flags&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props);}break;}case HostText:{// We have no life-cycles associated with text.\nbreak;}case HostPortal:{// We have no life-cycles associated with portals.\nbreak;}case Profiler:{{var _finishedWork$memoize2=finishedWork.memoizedProps,onCommit=_finishedWork$memoize2.onCommit,onRender=_finishedWork$memoize2.onRender;var effectDuration=finishedWork.stateNode.effectDuration;var commitTime=getCommitTime();var phase=current===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onRender==='function'){onRender(finishedWork.memoizedProps.id,phase,finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,commitTime);}{if(typeof onCommit==='function'){onCommit(finishedWork.memoizedProps.id,phase,effectDuration,commitTime);}// Schedule a passive effect for this Profiler to call onPostCommit hooks.\n// This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n// because the effect is also where times bubble to parent Profilers.\nenqueuePendingPassiveProfilerEffect(finishedWork);// Propagate layout effect durations to the next nearest Profiler ancestor.\n// Do not reset these values until the next render so DevTools has a chance to read them first.\nvar parentFiber=finishedWork.return;outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=effectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=effectDuration;break outer;}parentFiber=parentFiber.return;}}}break;}case SuspenseComponent:{commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);break;}case SuspenseListComponent:case IncompleteClassComponent:case ScopeComponent:case OffscreenComponent:case LegacyHiddenComponent:case TracingMarkerComponent:{break;}default:throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}if(!offscreenSubtreeWasHidden){{if(finishedWork.flags&Ref){commitAttachRef(finishedWork);}}}}function reappearLayoutEffectsOnFiber(node){// Turn on layout effects in a tree that previously disappeared.\n// TODO (Offscreen) Check: flags & LayoutStatic\nswitch(node.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(node.mode&ProfileMode){try{startLayoutEffectTimer();safelyCallCommitHookLayoutEffectListMount(node,node.return);}finally{recordLayoutEffectDuration(node);}}else{safelyCallCommitHookLayoutEffectListMount(node,node.return);}break;}case ClassComponent:{var instance=node.stateNode;if(typeof instance.componentDidMount==='function'){safelyCallComponentDidMount(node,node.return,instance);}safelyAttachRef(node,node.return);break;}case HostComponent:{safelyAttachRef(node,node.return);break;}}}function hideOrUnhideAllChildren(finishedWork,isHidden){// Only hide or unhide the top-most host nodes.\nvar hostSubtreeRoot=null;{// We only have the top Fiber that was inserted but we need to recurse down its\n// children to find all the terminal nodes.\nvar node=finishedWork;while(true){if(node.tag===HostComponent){if(hostSubtreeRoot===null){hostSubtreeRoot=node;try{var instance=node.stateNode;if(isHidden){hideInstance(instance);}else{unhideInstance(node.stateNode,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}else if(node.tag===HostText){if(hostSubtreeRoot===null){try{var _instance3=node.stateNode;if(isHidden){hideTextInstance(_instance3);}else{unhideTextInstance(_instance3,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}else if((node.tag===OffscreenComponent||node.tag===LegacyHiddenComponent)&&node.memoizedState!==null&&node!==finishedWork);else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node=node.return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node.sibling.return=node.return;node=node.sibling;}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;var instanceToUse;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance;}// Moved outside to ensure DCE works with this flag\nif(typeof ref==='function'){var retVal;if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(instanceToUse);}finally{recordLayoutEffectDuration(finishedWork);}}else{retVal=ref(instanceToUse);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(finishedWork));}}}else{{if(!ref.hasOwnProperty('current')){error('Unexpected ref object provided for %s. '+'Use either a ref-setter function or React.createRef().',getComponentNameFromFiber(finishedWork));}}ref.current=instanceToUse;}}}function detachFiberMutation(fiber){// Cut off the return pointer to disconnect it from the tree.\n// This enables us to detect and warn against state updates on an unmounted component.\n// It also prevents events from bubbling from within disconnected components.\n//\n// Ideally, we should also clear the child pointer of the parent alternate to let this\n// get GC:ed but we don't know which for sure which parent is the current\n// one so we'll settle for GC:ing the subtree of this child.\n// This child itself will be GC:ed when the parent updates the next time.\n//\n// Note that we can't clear child or sibling pointers yet.\n// They're needed for passive effects and for findDOMNode.\n// We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n//\n// Don't reset the alternate yet, either. We need that so we can detach the\n// alternate's fields in the passive phase. Clearing the return pointer is\n// sufficient for findDOMNode semantics.\nvar alternate=fiber.alternate;if(alternate!==null){alternate.return=null;}fiber.return=null;}function detachFiberAfterEffects(fiber){var alternate=fiber.alternate;if(alternate!==null){fiber.alternate=null;detachFiberAfterEffects(alternate);}// Note: Defensively using negation instead of < in case\n// `deletedTreeCleanUpLevel` is undefined.\n{// Clear cyclical Fiber fields. This level alone is designed to roughly\n// approximate the planned Fiber refactor. In that world, `setState` will be\n// bound to a special \"instance\" object instead of a Fiber. The Instance\n// object will not have any of these fields. It will only be connected to\n// the fiber tree via a single link at the root. So if this level alone is\n// sufficient to fix memory issues, that bodes well for our plans.\nfiber.child=null;fiber.deletions=null;fiber.sibling=null;// The `stateNode` is cyclical because on host nodes it points to the host\n// tree, which has its own pointers to children, parents, and siblings.\n// The other host nodes also point back to fibers, so we should detach that\n// one, too.\nif(fiber.tag===HostComponent){var hostInstance=fiber.stateNode;if(hostInstance!==null){detachDeletedInstance(hostInstance);}}fiber.stateNode=null;// I'm intentionally not clearing the `return` field in this level. We\n// already disconnect the `return` pointer at the root of the deleted\n// subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n// cyclical  it's only cyclical when combined with `child`, `sibling`, and\n// `alternate`. But we'll clear it in the next level anyway, just in case.\n{fiber._debugOwner=null;}{// Theoretically, nothing in here should be necessary, because we already\n// disconnected the fiber from the tree. So even if something leaks this\n// particular fiber, it won't leak anything else\n//\n// The purpose of this branch is to be super aggressive so we can measure\n// if there's any difference in memory impact. If there is, that could\n// indicate a React leak we don't know about.\nfiber.return=null;fiber.dependencies=null;fiber.memoizedProps=null;fiber.memoizedState=null;fiber.pendingProps=null;fiber.stateNode=null;// TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\nfiber.updateQueue=null;}}}function getHostParentFiber(fiber){var parent=fiber.return;while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent.return;}throw new Error('Expected to find a host parent. This error is likely caused by a bug '+'in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host\n// node. Unfortunately, if multiple insertions are done in a row we have to\n// search past them. This leads to exponential search for the next sibling.\n// TODO: Find a more efficient way to do this.\nvar node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.\nwhile(node.sibling===null){if(node.return===null||isHostParent(node.return)){// If we pop out of the root or hit the parent the fiber we are the\n// last sibling.\nreturn null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText&&node.tag!==DehydratedFragment){// If it is not host node and, we might have a host node inside it.\n// Try to search down until we find one.\nif(node.flags&Placement){// If we don't have a child, try the siblings instead.\ncontinue siblings;}// If we don't have a child, try the siblings instead.\n// We also skip portals because they are not part of this host tree.\nif(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child.return=node;node=node.child;}}// Check if this host node is stable or about to be placed.\nif(!(node.flags&Placement)){// Found it!\nreturn node.stateNode;}}}function commitPlacement(finishedWork){var parentFiber=getHostParentFiber(finishedWork);// Note: these two variables *must* always be updated together.\nswitch(parentFiber.tag){case HostComponent:{var parent=parentFiber.stateNode;if(parentFiber.flags&ContentReset){// Reset the text content of the parent before doing any insertions\nresetTextContent(parent);// Clear ContentReset from the effect tag\nparentFiber.flags&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need to recurse down its\n// children to find all the terminal nodes.\ninsertOrAppendPlacementNode(finishedWork,before,parent);break;}case HostRoot:case HostPortal:{var _parent=parentFiber.stateNode.containerInfo;var _before=getHostSibling(finishedWork);insertOrAppendPlacementNodeIntoContainer(finishedWork,_before,_parent);break;}// eslint-disable-next-line-no-fallthrough\ndefault:throw new Error('Invalid host parent fiber. This error is likely caused by a bug '+'in React. Please file an issue.');}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertInContainerBefore(parent,stateNode,before);}else{appendChildToContainer(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNodeIntoContainer(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNodeIntoContainer(sibling,before,parent);sibling=sibling.sibling;}}}}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertBefore(parent,stateNode,before);}else{appendChild(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNode(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNode(sibling,before,parent);sibling=sibling.sibling;}}}}// These are tracked on the stack as we recursively traverse a\n// deleted subtree.\n// TODO: Update these during the whole mutation phase, not just during\n// a deletion.\nvar hostParent=null;var hostParentIsContainer=false;function commitDeletionEffects(root,returnFiber,deletedFiber){{// We only have the top Fiber that was deleted but we need to recurse down its\n// children to find all the terminal nodes.\n// Recursively delete all host nodes from the parent, detach refs, clean\n// up mounted layout effects, and call componentWillUnmount.\n// We only need to remove the topmost host child in each branch. But then we\n// still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n// could split this into two separate traversals functions, where the second\n// one doesn't include any removeChild logic. This is maybe the same\n// function as \"disappearLayoutEffects\" (or whatever that turns into after\n// the layout phase is refactored to use recursion).\n// Before starting, find the nearest host parent on the stack so we know\n// which instance/container to remove the children from.\n// TODO: Instead of searching up the fiber return path on every deletion, we\n// can track the nearest host component on the JS stack as we traverse the\n// tree during the commit phase. This would make insertions faster, too.\nvar parent=returnFiber;findParent:while(parent!==null){switch(parent.tag){case HostComponent:{hostParent=parent.stateNode;hostParentIsContainer=false;break findParent;}case HostRoot:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}case HostPortal:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}}parent=parent.return;}if(hostParent===null){throw new Error('Expected to find a host parent. This error is likely caused by '+'a bug in React. Please file an issue.');}commitDeletionEffectsOnFiber(root,returnFiber,deletedFiber);hostParent=null;hostParentIsContainer=false;}detachFiberMutation(deletedFiber);}function recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,parent){// TODO: Use a static flag to skip trees that don't have unmount effects\nvar child=parent.child;while(child!==null){commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,child);child=child.sibling;}}function commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,deletedFiber){onCommitUnmount(deletedFiber);// The cases in this outer switch modify the stack before they traverse\n// into their subtree. There are simpler cases in the inner switch\n// that don't modify the stack.\nswitch(deletedFiber.tag){case HostComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);}// Intentional fallthrough to next branch\n}// eslint-disable-next-line-no-fallthrough\ncase HostText:{// We only need to remove the nearest host child. Set the host parent\n// to `null` on the stack to indicate that nested children don't\n// need to be removed.\n{var prevHostParent=hostParent;var prevHostParentIsContainer=hostParentIsContainer;hostParent=null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=prevHostParent;hostParentIsContainer=prevHostParentIsContainer;if(hostParent!==null){// Now that all the child effects have unmounted, we can remove the\n// node from the tree.\nif(hostParentIsContainer){removeChildFromContainer(hostParent,deletedFiber.stateNode);}else{removeChild(hostParent,deletedFiber.stateNode);}}}return;}case DehydratedFragment:{// Delete the dehydrated suspense boundary and all of its content.\n{if(hostParent!==null){if(hostParentIsContainer){clearSuspenseBoundaryFromContainer(hostParent,deletedFiber.stateNode);}else{clearSuspenseBoundary(hostParent,deletedFiber.stateNode);}}}return;}case HostPortal:{{// When we go into a portal, it becomes the parent to remove from.\nvar _prevHostParent=hostParent;var _prevHostParentIsContainer=hostParentIsContainer;hostParent=deletedFiber.stateNode.containerInfo;hostParentIsContainer=true;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=_prevHostParent;hostParentIsContainer=_prevHostParentIsContainer;}return;}case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){var updateQueue=deletedFiber.updateQueue;if(updateQueue!==null){var lastEffect=updateQueue.lastEffect;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{var _effect=effect,destroy=_effect.destroy,tag=_effect.tag;if(destroy!==undefined){if((tag&Insertion)!==NoFlags$1){safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}else if((tag&Layout)!==NoFlags$1){{markComponentLayoutEffectUnmountStarted(deletedFiber);}if(deletedFiber.mode&ProfileMode){startLayoutEffectTimer();safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);recordLayoutEffectDuration(deletedFiber);}else{safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}{markComponentLayoutEffectUnmountStopped();}}}effect=effect.next;}while(effect!==firstEffect);}}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ClassComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);var instance=deletedFiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(deletedFiber,nearestMountedAncestor,instance);}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ScopeComponent:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case OffscreenComponent:{if(// TODO: Remove this dead flag\ndeletedFiber.mode&ConcurrentMode){// If this offscreen component is hidden, we already unmounted it. Before\n// deleting the children, track that it's already unmounted so that we\n// don't attempt to unmount the effects again.\n// TODO: If the tree is hidden, in most cases we should be able to skip\n// over the nested children entirely. An exception is we haven't yet found\n// the topmost host node to delete, which we already track on the stack.\n// But the other case is portals, which need to be detached no matter how\n// deeply they are nested. We should use a subtree flag to track whether a\n// subtree includes a nested portal.\nvar prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||deletedFiber.memoizedState!==null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);}break;}default:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}}}function commitSuspenseCallback(finishedWork){// TODO: Move this to passive phase\nvar newState=finishedWork.memoizedState;}function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork){var newState=finishedWork.memoizedState;if(newState===null){var current=finishedWork.alternate;if(current!==null){var prevState=current.memoizedState;if(prevState!==null){var suspenseInstance=prevState.dehydrated;if(suspenseInstance!==null){commitHydratedSuspenseInstance(suspenseInstance);}}}}}function attachSuspenseRetryListeners(finishedWork){// If this boundary just timed out, then it will have a set of wakeables.\n// For each wakeable, attach a listener so that when it resolves, React\n// attempts to re-render the boundary in the primary (pre-timeout) state.\nvar wakeables=finishedWork.updateQueue;if(wakeables!==null){finishedWork.updateQueue=null;var retryCache=finishedWork.stateNode;if(retryCache===null){retryCache=finishedWork.stateNode=new PossiblyWeakSet();}wakeables.forEach(function(wakeable){// Memoize using the boundary fiber to prevent redundant listeners.\nvar retry=resolveRetryWakeable.bind(null,finishedWork,wakeable);if(!retryCache.has(wakeable)){retryCache.add(wakeable);{if(isDevToolsPresent){if(inProgressLanes!==null&&inProgressRoot!==null){// If we have pending work still, associate the original updaters with it.\nrestorePendingUpdaters(inProgressRoot,inProgressLanes);}else{throw Error('Expected finished root and lanes to be set. This is a bug in React.');}}}wakeable.then(retry,retry);}});}}// This function detects when a Suspense boundary goes from visible to hidden.\nfunction commitMutationEffects(root,finishedWork,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;setCurrentFiber(finishedWork);commitMutationEffectsOnFiber(finishedWork,root);setCurrentFiber(finishedWork);inProgressLanes=null;inProgressRoot=null;}function recursivelyTraverseMutationEffects(root,parentFiber,lanes){// Deletions effects can be scheduled on any fiber type. They need to happen\n// before the children effects hae fired.\nvar deletions=parentFiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var childToDelete=deletions[i];try{commitDeletionEffects(root,parentFiber,childToDelete);}catch(error){captureCommitPhaseError(childToDelete,parentFiber,error);}}}var prevDebugFiber=getCurrentFiber();if(parentFiber.subtreeFlags&MutationMask){var child=parentFiber.child;while(child!==null){setCurrentFiber(child);commitMutationEffectsOnFiber(child,root);child=child.sibling;}}setCurrentFiber(prevDebugFiber);}function commitMutationEffectsOnFiber(finishedWork,root,lanes){var current=finishedWork.alternate;var flags=finishedWork.flags;// The effect flag should be checked *after* we refine the type of fiber,\n// because the fiber tag is more specific. An exception is any flag related\n// to reconcilation, because those can be set on all fiber types.\nswitch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){try{commitHookEffectListUnmount(Insertion|HasEffect,finishedWork,finishedWork.return);commitHookEffectListMount(Insertion|HasEffect,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}// Layout effects are destroyed during the mutation phase so that all\n// destroy functions for all fibers are called before any create functions.\n// This prevents sibling component effects from interfering with each other,\n// e.g. a destroy function in one component should never override a ref set\n// by a create function in another component during the same commit.\nif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}recordLayoutEffectDuration(finishedWork);}else{try{commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}return;}case ClassComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current.return);}}return;}case HostComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current.return);}}{// TODO: ContentReset gets cleared by the children during the commit\n// phase. This is a refactor hazard because it means we must read\n// flags the flags after `commitReconciliationEffects` has already run;\n// the order matters. We should refactor so that ContentReset does not\n// rely on mutating the flag during commit. Like by setting a flag\n// during the render phase instead.\nif(finishedWork.flags&ContentReset){var instance=finishedWork.stateNode;try{resetTextContent(instance);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}if(flags&Update){var _instance4=finishedWork.stateNode;if(_instance4!=null){// Commit the work prepared earlier.\nvar newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.\nvar updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){try{commitUpdate(_instance4,updatePayload,type,oldProps,newProps,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}}}return;}case HostText:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(finishedWork.stateNode===null){throw new Error('This should have a text node initialized. This error is likely '+'caused by a bug in React. Please file an issue.');}var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldText=current!==null?current.memoizedProps:newText;try{commitTextUpdate(textInstance,oldText,newText);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}return;}case HostRoot:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(current!==null){var prevRootState=current.memoizedState;if(prevRootState.isDehydrated){try{commitHydratedContainer(root.containerInfo);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}}}return;}case HostPortal:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}case SuspenseComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);var offscreenFiber=finishedWork.child;if(offscreenFiber.flags&Visibility){var offscreenInstance=offscreenFiber.stateNode;var newState=offscreenFiber.memoizedState;var isHidden=newState!==null;// Track the current state on the Offscreen instance so we can\n// read it during an event\noffscreenInstance.isHidden=isHidden;if(isHidden){var wasHidden=offscreenFiber.alternate!==null&&offscreenFiber.alternate.memoizedState!==null;if(!wasHidden){// TODO: Move to passive phase\nmarkCommitTimeOfFallback();}}}if(flags&Update){try{commitSuspenseCallback(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}attachSuspenseRetryListeners(finishedWork);}return;}case OffscreenComponent:{var _wasHidden=current!==null&&current.memoizedState!==null;if(// TODO: Remove this dead flag\nfinishedWork.mode&ConcurrentMode){// Before committing the children, track on the stack whether this\n// offscreen subtree was already hidden, so that we don't unmount the\n// effects again.\nvar prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||_wasHidden;recursivelyTraverseMutationEffects(root,finishedWork);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else{recursivelyTraverseMutationEffects(root,finishedWork);}commitReconciliationEffects(finishedWork);if(flags&Visibility){var _offscreenInstance=finishedWork.stateNode;var _newState=finishedWork.memoizedState;var _isHidden=_newState!==null;var offscreenBoundary=finishedWork;// Track the current state on the Offscreen instance so we can\n// read it during an event\n_offscreenInstance.isHidden=_isHidden;{if(_isHidden){if(!_wasHidden){if((offscreenBoundary.mode&ConcurrentMode)!==NoMode){nextEffect=offscreenBoundary;var offscreenChild=offscreenBoundary.child;while(offscreenChild!==null){nextEffect=offscreenChild;disappearLayoutEffects_begin(offscreenChild);offscreenChild=offscreenChild.sibling;}}}}}{// TODO: This needs to run whenever there's an insertion or update\n// inside a hidden Offscreen tree.\nhideOrUnhideAllChildren(offscreenBoundary,_isHidden);}}return;}case SuspenseListComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){attachSuspenseRetryListeners(finishedWork);}return;}case ScopeComponent:{return;}default:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}}}function commitReconciliationEffects(finishedWork){// Placement effects (insertions, reorders) can be scheduled on any fiber\n// type. They needs to happen after the children effects have fired, but\n// before the effects on this fiber have fired.\nvar flags=finishedWork.flags;if(flags&Placement){try{commitPlacement(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}// Clear the \"placement\" from effect tag so that we know that this is\n// inserted, before any life-cycles like componentDidMount gets called.\n// TODO: findDOMNode doesn't rely on this any more but isMounted does\n// and isMounted is deprecated anyway so we should be able to kill this.\nfinishedWork.flags&=~Placement;}if(flags&Hydrating){finishedWork.flags&=~Hydrating;}}function commitLayoutEffects(finishedWork,root,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;nextEffect=finishedWork;commitLayoutEffects_begin(finishedWork,root,committedLanes);inProgressLanes=null;inProgressRoot=null;}function commitLayoutEffects_begin(subtreeRoot,root,committedLanes){// Suspense layout effects semantics don't change for legacy roots.\nvar isModernRoot=(subtreeRoot.mode&ConcurrentMode)!==NoMode;while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent&&isModernRoot){// Keep track of the current Offscreen stack's state.\nvar isHidden=fiber.memoizedState!==null;var newOffscreenSubtreeIsHidden=isHidden||offscreenSubtreeIsHidden;if(newOffscreenSubtreeIsHidden){// The Offscreen tree is hidden. Skip over its layout effects.\ncommitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}else{// TODO (Offscreen) Also check: subtreeFlags & LayoutMask\nvar current=fiber.alternate;var wasHidden=current!==null&&current.memoizedState!==null;var newOffscreenSubtreeWasHidden=wasHidden||offscreenSubtreeWasHidden;var prevOffscreenSubtreeIsHidden=offscreenSubtreeIsHidden;var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;// Traverse the Offscreen subtree with the current Offscreen as the root.\noffscreenSubtreeIsHidden=newOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=newOffscreenSubtreeWasHidden;if(offscreenSubtreeWasHidden&&!prevOffscreenSubtreeWasHidden){// This is the root of a reappearing boundary. Turn its layout effects\n// back on.\nnextEffect=fiber;reappearLayoutEffects_begin(fiber);}var child=firstChild;while(child!==null){nextEffect=child;commitLayoutEffects_begin(child,// New root; bubble back up to here and stop.\nroot,committedLanes);child=child.sibling;}// Restore Offscreen state and resume in our-progress traversal.\nnextEffect=fiber;offscreenSubtreeIsHidden=prevOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}}if((fiber.subtreeFlags&LayoutMask)!==NoFlags&&firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else{commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);}}}function commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&LayoutMask)!==NoFlags){var current=fiber.alternate;setCurrentFiber(fiber);try{commitLayoutEffectOnFiber(root,current,fiber,committedLanes);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function disappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;// TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(fiber.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout,fiber,fiber.return);}finally{recordLayoutEffectDuration(fiber);}}else{commitHookEffectListUnmount(Layout,fiber,fiber.return);}break;}case ClassComponent:{// TODO (Offscreen) Check: flags & RefStatic\nsafelyDetachRef(fiber,fiber.return);var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber.return,instance);}break;}case HostComponent:{safelyDetachRef(fiber,fiber.return);break;}case OffscreenComponent:{// Check if this is a\nvar isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is already hidden. Don't disappear\n// its effects.\ndisappearLayoutEffects_complete(subtreeRoot);continue;}break;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\nif(firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else{disappearLayoutEffects_complete(subtreeRoot);}}}function disappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function reappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent){var isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is still hidden. Don't re-appear its effects.\nreappearLayoutEffects_complete(subtreeRoot);continue;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\nif(firstChild!==null){// This node may have been reused from a previous render, so we can't\n// assume its return pointer is correct.\nfirstChild.return=fiber;nextEffect=firstChild;}else{reappearLayoutEffects_complete(subtreeRoot);}}}function reappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;// TODO (Offscreen) Check: flags & LayoutStatic\nsetCurrentFiber(fiber);try{reappearLayoutEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){// This node may have been reused from a previous render, so we can't\n// assume its return pointer is correct.\nsibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveMountEffects(root,finishedWork,committedLanes,committedTransitions){nextEffect=finishedWork;commitPassiveMountEffects_begin(finishedWork,root,committedLanes,committedTransitions);}function commitPassiveMountEffects_begin(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else{commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions);}}}function commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);try{commitPassiveMountOnFiber(root,fiber,committedLanes,committedTransitions);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveMountOnFiber(finishedRoot,finishedWork,committedLanes,committedTransitions){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();try{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}finally{recordPassiveEffectDuration(finishedWork);}}else{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}break;}}}function commitPassiveUnmountEffects(firstChild){nextEffect=firstChild;commitPassiveUnmountEffects_begin();}function commitPassiveUnmountEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;var child=fiber.child;if((nextEffect.flags&ChildDeletion)!==NoFlags){var deletions=fiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var fiberToDelete=deletions[i];nextEffect=fiberToDelete;commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete,fiber);}{// A fiber was deleted from this parent fiber, but it's still part of\n// the previous (alternate) parent fiber's list of children. Because\n// children are a linked list, an earlier sibling that's still alive\n// will be connected to the deleted fiber via its `alternate`:\n//\n//   live fiber\n//   --alternate--> previous live fiber\n//   --sibling--> deleted fiber\n//\n// We can't disconnect `alternate` on nodes that haven't been deleted\n// yet, but we can disconnect the `sibling` and `child` pointers.\nvar previousFiber=fiber.alternate;if(previousFiber!==null){var detachedChild=previousFiber.child;if(detachedChild!==null){previousFiber.child=null;do{var detachedSibling=detachedChild.sibling;detachedChild.sibling=null;detachedChild=detachedSibling;}while(detachedChild!==null);}}}nextEffect=fiber;}}if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&child!==null){child.return=fiber;nextEffect=child;}else{commitPassiveUnmountEffects_complete();}}}function commitPassiveUnmountEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);commitPassiveUnmountOnFiber(fiber);resetCurrentFiber();}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveUnmountOnFiber(finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return);recordPassiveEffectDuration(finishedWork);}else{commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return);}break;}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot,nearestMountedAncestor){while(nextEffect!==null){var fiber=nextEffect;// Deletion effects fire in parent -> child order\n// TODO: Check if fiber has a PassiveStatic flag\nsetCurrentFiber(fiber);commitPassiveUnmountInsideDeletedTreeOnFiber(fiber,nearestMountedAncestor);resetCurrentFiber();var child=fiber.child;// TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n// do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\nif(child!==null){child.return=fiber;nextEffect=child;}else{commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var sibling=fiber.sibling;var returnFiber=fiber.return;{// Recursively traverse the entire deleted tree and clean up fiber fields.\n// This is more aggressive than ideal, and the long term goal is to only\n// have to detach the deleted tree at the root.\ndetachFiberAfterEffects(fiber);if(fiber===deletedSubtreeRoot){nextEffect=null;return;}}if(sibling!==null){sibling.return=returnFiber;nextEffect=sibling;return;}nextEffect=returnFiber;}}function commitPassiveUnmountInsideDeletedTreeOnFiber(current,nearestMountedAncestor){switch(current.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(current.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);recordPassiveEffectDuration(current);}else{commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);}break;}}}// TODO: Reuse reappearLayoutEffects traversal here?\nfunction invokeLayoutEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Layout|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}case ClassComponent:{var instance=fiber.stateNode;try{instance.componentDidMount();}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}}}}function invokePassiveEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Passive$1|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}}}}function invokeLayoutEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Layout|HasEffect,fiber,fiber.return);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}case ClassComponent:{var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber.return,instance);}break;}}}}function invokePassiveEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Passive$1|HasEffect,fiber,fiber.return);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}}}}}var COMPONENT_TYPE=0;var HAS_PSEUDO_CLASS_TYPE=1;var ROLE_TYPE=2;var TEST_NAME_TYPE=3;var TEXT_TYPE=4;if(typeof Symbol==='function'&&Symbol.for){var symbolFor=Symbol.for;COMPONENT_TYPE=symbolFor('selector.component');HAS_PSEUDO_CLASS_TYPE=symbolFor('selector.has_pseudo_class');ROLE_TYPE=symbolFor('selector.role');TEST_NAME_TYPE=symbolFor('selector.test_id');TEXT_TYPE=symbolFor('selector.text');}var commitHooks=[];function onCommitRoot$1(){{commitHooks.forEach(function(commitHook){return commitHook();});}}var ReactCurrentActQueue=ReactSharedInternals.ReactCurrentActQueue;function isLegacyActEnvironment(fiber){{// Legacy mode. We preserve the behavior of React 17's act. It assumes an\n// act environment whenever `jest` is defined, but you can still turn off\n// spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly\n// to false.\nvar isReactActEnvironmentGlobal=// $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\ntypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;// $FlowExpectedError - Flow doesn't know about jest\nvar jestIsDefined=typeof jest!=='undefined';return jestIsDefined&&isReactActEnvironmentGlobal!==false;}}function isConcurrentActEnvironment(){{var isReactActEnvironmentGlobal=// $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\ntypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;if(!isReactActEnvironmentGlobal&&ReactCurrentActQueue.current!==null){// TODO: Include link to relevant documentation page.\nerror('The current testing environment is not configured to support '+'act(...)');}return isReactActEnvironmentGlobal;}}var ceil=Math.ceil;var ReactCurrentDispatcher$2=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner,ReactCurrentBatchConfig$3=ReactSharedInternals.ReactCurrentBatchConfig,ReactCurrentActQueue$1=ReactSharedInternals.ReactCurrentActQueue;var NoContext=/*             */0;var BatchedContext=/*               */1;var RenderContext=/*                */2;var CommitContext=/*                */4;var RootInProgress=0;var RootFatalErrored=1;var RootErrored=2;var RootSuspended=3;var RootSuspendedWithDelay=4;var RootCompleted=5;var RootDidNotComplete=6;// Describes where we are in the React execution stack\nvar executionContext=NoContext;// The root we're working on\nvar workInProgressRoot=null;// The fiber we're working on\nvar workInProgress=null;// The lanes we're rendering\nvar workInProgressRootRenderLanes=NoLanes;// Stack that allows components to change the render lanes for its subtree\n// This is a superset of the lanes we started working on at the root. The only\n// case where it's different from `workInProgressRootRenderLanes` is when we\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\n// Offscreen component.\n//\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\nvar subtreeRenderLanes=NoLanes;var subtreeRenderLanesCursor=createCursor(NoLanes);// Whether to root completed, errored, suspended, etc.\nvar workInProgressRootExitStatus=RootInProgress;// A fatal error, if one is thrown\nvar workInProgressRootFatalError=null;// \"Included\" lanes refer to lanes that were worked on during this render. It's\n// slightly different than `renderLanes` because `renderLanes` can change as you\n// enter and exit an Offscreen tree. This value is the combination of all render\n// lanes for the entire render phase.\nvar workInProgressRootIncludedLanes=NoLanes;// The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\nvar workInProgressRootSkippedLanes=NoLanes;// Lanes that were updated (in an interleaved event) during this render.\nvar workInProgressRootInterleavedUpdatedLanes=NoLanes;// Lanes that were updated during the render phase (*not* an interleaved event).\nvar workInProgressRootPingedLanes=NoLanes;// Errors that are thrown during the render phase.\nvar workInProgressRootConcurrentErrors=null;// These are errors that we recovered from without surfacing them to the UI.\n// We will log them once the tree commits.\nvar workInProgressRootRecoverableErrors=null;// The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\nvar globalMostRecentFallbackTime=0;var FALLBACK_THROTTLE_MS=500;// The absolute time for when we should start giving up on rendering\n// more and prefer CPU suspense heuristics instead.\nvar workInProgressRootRenderTargetTime=Infinity;// How long a render is supposed to take before we start following CPU\n// suspense heuristics and opt out of rendering more content.\nvar RENDER_TIMEOUT_MS=500;var workInProgressTransitions=null;function resetRenderTimer(){workInProgressRootRenderTargetTime=now()+RENDER_TIMEOUT_MS;}function getRenderTargetTime(){return workInProgressRootRenderTargetTime;}var hasUncaughtError=false;var firstUncaughtError=null;var legacyErrorBoundariesThatAlreadyFailed=null;// Only used when enableProfilerNestedUpdateScheduledHook is true;\nvar rootDoesHavePassiveEffects=false;var rootWithPendingPassiveEffects=null;var pendingPassiveEffectsLanes=NoLanes;var pendingPassiveProfilerEffects=[];var pendingPassiveTransitions=null;// Use these to prevent an infinite loop of nested updates\nvar NESTED_UPDATE_LIMIT=50;var nestedUpdateCount=0;var rootWithNestedUpdates=null;var isFlushingPassiveEffects=false;var didScheduleUpdateDuringPassiveEffects=false;var NESTED_PASSIVE_UPDATE_LIMIT=50;var nestedPassiveUpdateCount=0;var rootWithPassiveNestedUpdates=null;// If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\nvar currentEventTime=NoTimestamp;var currentEventTransitionLane=NoLanes;var isRunningInsertionEffect=false;function getWorkInProgressRoot(){return workInProgressRoot;}function requestEventTime(){if((executionContext&(RenderContext|CommitContext))!==NoContext){// We're inside React, so it's fine to read the actual time.\nreturn now();}// We're not inside React, so we may be in the middle of a browser event.\nif(currentEventTime!==NoTimestamp){// Use the same start time for all updates until we enter React again.\nreturn currentEventTime;}// This is the first update since React yielded. Compute a new start time.\ncurrentEventTime=now();return currentEventTime;}function requestUpdateLane(fiber){// Special cases\nvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}else if((executionContext&RenderContext)!==NoContext&&workInProgressRootRenderLanes!==NoLanes){// This is a render phase update. These are not officially supported. The\n// old behavior is to give this the same \"thread\" (lanes) as\n// whatever is currently rendering. So if you call `setState` on a component\n// that happens later in the same render, it will flush. Ideally, we want to\n// remove the special case and treat them as if they came from an\n// interleaved event. Regardless, this pattern is not officially supported.\n// This behavior is only a fallback. The flag only exists until we can roll\n// out the setState warning, since existing code might accidentally rely on\n// the current behavior.\nreturn pickArbitraryLane(workInProgressRootRenderLanes);}var isTransition=requestCurrentTransition()!==NoTransition;if(isTransition){if(ReactCurrentBatchConfig$3.transition!==null){var transition=ReactCurrentBatchConfig$3.transition;if(!transition._updatedFibers){transition._updatedFibers=new Set();}transition._updatedFibers.add(fiber);}// The algorithm for assigning an update to a lane should be stable for all\n// updates at the same priority within the same event. To do this, the\n// inputs to the algorithm must be the same.\n//\n// The trick we use is to cache the first of each of these inputs within an\n// event. Then reset the cached values once we can be sure the event is\n// over. Our heuristic for that is whenever we enter a concurrent work loop.\nif(currentEventTransitionLane===NoLane){// All transitions within the same event are assigned the same lane.\ncurrentEventTransitionLane=claimNextTransitionLane();}return currentEventTransitionLane;}// Updates originating inside certain React methods, like flushSync, have\n// their priority set by tracking it with a context variable.\n//\n// The opaque type returned by the host config is internally a lane, so we can\n// use that directly.\n// TODO: Move this type conversion to the event priority module.\nvar updateLane=getCurrentUpdatePriority();if(updateLane!==NoLane){return updateLane;}// This update originated outside React. Ask the host environment for an\n// appropriate priority, based on the type of event.\n//\n// The opaque type returned by the host config is internally a lane, so we can\n// use that directly.\n// TODO: Move this type conversion to the event priority module.\nvar eventLane=getCurrentEventPriority();return eventLane;}function requestRetryLane(fiber){// This is a fork of `requestUpdateLane` designed specifically for Suspense\n// \"retries\"  a special update that attempts to flip a Suspense boundary\n// from its placeholder state to its primary/resolved state.\n// Special cases\nvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}return claimNextRetryLane();}function scheduleUpdateOnFiber(root,fiber,lane,eventTime){checkForNestedUpdates();{if(isRunningInsertionEffect){error('useInsertionEffect must not schedule updates.');}}{if(isFlushingPassiveEffects){didScheduleUpdateDuringPassiveEffects=true;}}// Mark that the root has a pending update.\nmarkRootUpdated(root,lane,eventTime);if((executionContext&RenderContext)!==NoLanes&&root===workInProgressRoot){// This update was dispatched during the render phase. This is a mistake\n// if the update originates from user space (with the exception of local\n// hook updates, which are handled differently and don't reach this\n// function), but there are some internal React features that use this as\n// an implementation detail, like selective hydration.\nwarnAboutRenderPhaseUpdatesInDEV(fiber);// Track lanes that were updated during the render phase\n}else{// This is a normal update, scheduled from outside the render phase. For\n// example, during an input event.\n{if(isDevToolsPresent){addFiberToLanesMap(root,fiber,lane);}}warnIfUpdatesNotWrappedWithActDEV(fiber);if(root===workInProgressRoot){// Received an update to a tree that's in the middle of rendering. Mark\n// that there was an interleaved update work on this root. Unless the\n// `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n// phase update. In that case, we don't treat render phase updates as if\n// they were interleaved, for backwards compat reasons.\nif((executionContext&RenderContext)===NoContext){workInProgressRootInterleavedUpdatedLanes=mergeLanes(workInProgressRootInterleavedUpdatedLanes,lane);}if(workInProgressRootExitStatus===RootSuspendedWithDelay){// The root already suspended with a delay, which means this render\n// definitely won't finish. Since we have a new update, let's mark it as\n// suspended now, right before marking the incoming update. This has the\n// effect of interrupting the current render and switching to the update.\n// TODO: Make sure this doesn't override pings that happen while we've\n// already started rendering.\nmarkRootSuspended$1(root,workInProgressRootRenderLanes);}}ensureRootIsScheduled(root,eventTime);if(lane===SyncLane&&executionContext===NoContext&&(fiber.mode&ConcurrentMode)===NoMode&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n!ReactCurrentActQueue$1.isBatchingLegacy){// Flush the synchronous work now, unless we're already working or inside\n// a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n// scheduleCallbackForFiber to preserve the ability to schedule a callback\n// without immediately flushing it. We only do this for user-initiated\n// updates, to preserve historical behavior of legacy mode.\nresetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function scheduleInitialHydrationOnRoot(root,lane,eventTime){// This is a special fork of scheduleUpdateOnFiber that is only used to\n// schedule the initial hydration of a root that has just been created. Most\n// of the stuff in scheduleUpdateOnFiber can be skipped.\n//\n// The main reason for this separate path, though, is to distinguish the\n// initial children from subsequent updates. In fully client-rendered roots\n// (createRoot instead of hydrateRoot), all top-level renders are modeled as\n// updates, but hydration roots are special because the initial render must\n// match what was rendered on the server.\nvar current=root.current;current.lanes=lane;markRootUpdated(root,lane,eventTime);ensureRootIsScheduled(root,eventTime);}function isUnsafeClassRenderPhaseUpdate(fiber){// Check if this is a render phase update. Only called by class components,\n// which special (deprecated) behavior for UNSAFE_componentWillReceive props.\nreturn(// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We\n// decided not to enable it.\n(executionContext&RenderContext)!==NoContext);}// Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\nfunction ensureRootIsScheduled(root,currentTime){var existingCallbackNode=root.callbackNode;// Check if any lanes are being starved by other work. If so, mark them as\n// expired so we know to work on those next.\nmarkStarvedLanesAsExpired(root,currentTime);// Determine the next lanes to work on, and their priority.\nvar nextLanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(nextLanes===NoLanes){// Special case: There's nothing to work on.\nif(existingCallbackNode!==null){cancelCallback$1(existingCallbackNode);}root.callbackNode=null;root.callbackPriority=NoLane;return;}// We use the highest priority lane to represent the priority of the callback.\nvar newCallbackPriority=getHighestPriorityLane(nextLanes);// Check if there's an existing task. We may be able to reuse it.\nvar existingCallbackPriority=root.callbackPriority;if(existingCallbackPriority===newCallbackPriority&&// Special case related to `act`. If the currently scheduled task is a\n// Scheduler task, rather than an `act` task, cancel it and re-scheduled\n// on the `act` queue.\n!(ReactCurrentActQueue$1.current!==null&&existingCallbackNode!==fakeActCallbackNode)){{// If we're going to re-use an existing task, it needs to exist.\n// Assume that discrete update microtasks are non-cancellable and null.\n// TODO: Temporary until we confirm this warning is not fired.\nif(existingCallbackNode==null&&existingCallbackPriority!==SyncLane){error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');}}// The priority hasn't changed. We can reuse the existing task. Exit.\nreturn;}if(existingCallbackNode!=null){// Cancel the existing callback. We'll schedule a new one below.\ncancelCallback$1(existingCallbackNode);}// Schedule a new callback.\nvar newCallbackNode;if(newCallbackPriority===SyncLane){// Special case: Sync React callbacks are scheduled on a special\n// internal queue\nif(root.tag===LegacyRoot){if(ReactCurrentActQueue$1.isBatchingLegacy!==null){ReactCurrentActQueue$1.didScheduleLegacyUpdate=true;}scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null,root));}else{scheduleSyncCallback(performSyncWorkOnRoot.bind(null,root));}{// Flush the queue in a microtask.\nif(ReactCurrentActQueue$1.current!==null){// Inside `act`, use our internal `act` queue so that these get flushed\n// at the end of the current scope even when using the sync version\n// of `act`.\nReactCurrentActQueue$1.current.push(flushSyncCallbacks);}else{scheduleMicrotask(function(){// In Safari, appending an iframe forces microtasks to run.\n// https://github.com/facebook/react/issues/22459\n// We don't support running callbacks in the middle of render\n// or commit so we need to check against that.\nif((executionContext&(RenderContext|CommitContext))===NoContext){// Note that this would still prematurely flush the callbacks\n// if this happens outside render or commit phase (e.g. in an event).\nflushSyncCallbacks();}});}}newCallbackNode=null;}else{var schedulerPriorityLevel;switch(lanesToEventPriority(nextLanes)){case DiscreteEventPriority:schedulerPriorityLevel=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriorityLevel=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriorityLevel=NormalPriority;break;case IdleEventPriority:schedulerPriorityLevel=IdlePriority;break;default:schedulerPriorityLevel=NormalPriority;break;}newCallbackNode=scheduleCallback$1(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null,root));}root.callbackPriority=newCallbackPriority;root.callbackNode=newCallbackNode;}// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root,didTimeout){{resetNestedUpdateFlag();}// Since we know we're in a React event, we can clear the current\n// event time. The next update will compute a new event time.\ncurrentEventTime=NoTimestamp;currentEventTransitionLane=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}// Flush any pending passive effects before deciding which lanes to work on,\n// in case they schedule additional work.\nvar originalCallbackNode=root.callbackNode;var didFlushPassiveEffects=flushPassiveEffects();if(didFlushPassiveEffects){// Something in the passive effect phase may have canceled the current task.\n// Check if the task node for this root was changed.\nif(root.callbackNode!==originalCallbackNode){// The current task was canceled. Exit. We don't need to call\n// `ensureRootIsScheduled` because the check above implies either that\n// there's a new task, or that there's no remaining work on this root.\nreturn null;}}// Determine the next lanes to work on, using the fields stored\n// on the root.\nvar lanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(lanes===NoLanes){// Defensive coding. This is never expected to happen.\nreturn null;}// We disable time-slicing in some cases: if the work has been CPU-bound\n// for too long (\"expired\" work, to prevent starvation), or we're in\n// sync-updates-by-default mode.\n// TODO: We only check `didTimeout` defensively, to account for a Scheduler\n// bug we're still investigating. Once the bug in Scheduler is fixed,\n// we can remove this, since we track expiration ourselves.\nvar shouldTimeSlice=!includesBlockingLane(root,lanes)&&!includesExpiredLane(root,lanes)&&!didTimeout;var exitStatus=shouldTimeSlice?renderRootConcurrent(root,lanes):renderRootSync(root,lanes);if(exitStatus!==RootInProgress){if(exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll\n// render synchronously to block concurrent data mutations, and we'll\n// includes all pending updates are included. If it still fails after\n// the second attempt, we'll give up and commit the resulting tree.\nvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){// The render unwound without completing the tree. This happens in special\n// cases where need to exit the current render without producing a\n// consistent tree or committing.\n//\n// This should only happen during a concurrent render, not a discrete or\n// synchronous update. We should have already checked for this when we\n// unwound the stack.\nmarkRootSuspended$1(root,lanes);}else{// The render completed.\n// Check if this render may have yielded to a concurrent event, and if so,\n// confirm that any newly rendered stores are consistent.\n// TODO: It's possible that even a concurrent render may never have yielded\n// to the main thread, if it was fast enough, or if it expired. We could\n// skip the consistency check in that case, too.\nvar renderWasConcurrent=!includesBlockingLane(root,lanes);var finishedWork=root.current.alternate;if(renderWasConcurrent&&!isRenderConsistentWithExternalStores(finishedWork)){// A store was mutated in an interleaved event. Render again,\n// synchronously, to block further mutations.\nexitStatus=renderRootSync(root,lanes);// We need to check again if something threw\nif(exitStatus===RootErrored){var _errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(_errorRetryLanes!==NoLanes){lanes=_errorRetryLanes;exitStatus=recoverFromConcurrentError(root,_errorRetryLanes);// We assume the tree is now consistent because we didn't yield to any\n// concurrent events.\n}}if(exitStatus===RootFatalErrored){var _fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw _fatalError;}}// We now have a consistent tree. The next step is either to commit it,\n// or, if something suspended, wait to commit it after a timeout.\nroot.finishedWork=finishedWork;root.finishedLanes=lanes;finishConcurrentRender(root,exitStatus,lanes);}}ensureRootIsScheduled(root,now());if(root.callbackNode===originalCallbackNode){// The task node scheduled for this root is the same one that's\n// currently executed. Need to return a continuation.\nreturn performConcurrentWorkOnRoot.bind(null,root);}return null;}function recoverFromConcurrentError(root,errorRetryLanes){// If an error occurred during hydration, discard server response and fall\n// back to client side render.\n// Before rendering again, save the errors from the previous attempt.\nvar errorsFromFirstAttempt=workInProgressRootConcurrentErrors;if(isRootDehydrated(root)){// The shell failed to hydrate. Set a flag to force a client rendering\n// during the next attempt. To do this, we call prepareFreshStack now\n// to create the root work-in-progress fiber. This is a bit weird in terms\n// of factoring, because it relies on renderRootSync not calling\n// prepareFreshStack again in the call below, which happens because the\n// root and lanes haven't changed.\n//\n// TODO: I think what we should do is set ForceClientRender inside\n// throwException, like we do for nested Suspense boundaries. The reason\n// it's here instead is so we can switch to the synchronous work loop, too.\n// Something to consider for a future refactor.\nvar rootWorkInProgress=prepareFreshStack(root,errorRetryLanes);rootWorkInProgress.flags|=ForceClientRender;{errorHydratingContainer(root.containerInfo);}}var exitStatus=renderRootSync(root,errorRetryLanes);if(exitStatus!==RootErrored){// Successfully finished rendering on retry\n// The errors from the failed first attempt have been recovered. Add\n// them to the collection of recoverable errors. We'll log them in the\n// commit phase.\nvar errorsFromSecondAttempt=workInProgressRootRecoverableErrors;workInProgressRootRecoverableErrors=errorsFromFirstAttempt;// The errors from the second attempt should be queued after the errors\n// from the first attempt, to preserve the causal sequence.\nif(errorsFromSecondAttempt!==null){queueRecoverableErrors(errorsFromSecondAttempt);}}return exitStatus;}function queueRecoverableErrors(errors){if(workInProgressRootRecoverableErrors===null){workInProgressRootRecoverableErrors=errors;}else{workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors,errors);}}function finishConcurrentRender(root,exitStatus,lanes){switch(exitStatus){case RootInProgress:case RootFatalErrored:{throw new Error('Root did not complete. This is a bug in React.');}// Flow knows about invariant, so it complains if I add a break\n// statement, but eslint doesn't know about invariant, so it complains\n// if I do. eslint-disable-next-line no-fallthrough\ncase RootErrored:{// We should have already attempted to retry this tree. If we reached\n// this point, it errored again. Commit it.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspended:{markRootSuspended$1(root,lanes);// We have an acceptable loading state. We need to figure out if we\n// should immediately commit it or wait a bit.\nif(includesOnlyRetries(lanes)&&// do not delay if we're inside an act() scope\n!shouldForceFlushFallbacksInDEV()){// This render only included retries, no updates. Throttle committing\n// retries so that we don't show too many loading states too quickly.\nvar msUntilTimeout=globalMostRecentFallbackTime+FALLBACK_THROTTLE_MS-now();// Don't bother with a very short suspense time.\nif(msUntilTimeout>10){var nextLanes=getNextLanes(root,NoLanes);if(nextLanes!==NoLanes){// There's additional work on this root.\nbreak;}var suspendedLanes=root.suspendedLanes;if(!isSubsetOfLanes(suspendedLanes,lanes)){// We should prefer to render the fallback of at the last\n// suspended level. Ping the last suspended level to try\n// rendering it again.\n// FIXME: What if the suspended lanes are Idle? Should not restart.\nvar eventTime=requestEventTime();markRootPinged(root,suspendedLanes);break;}// The render is suspended, it hasn't timed out, and there's no\n// lower priority work to do. Instead of committing the fallback\n// immediately, wait for more data to arrive.\nroot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),msUntilTimeout);break;}}// The work expired. Commit immediately.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspendedWithDelay:{markRootSuspended$1(root,lanes);if(includesOnlyTransitions(lanes)){// This is a transition, so we should exit without committing a\n// placeholder and without scheduling a timeout. Delay indefinitely\n// until we receive more data.\nbreak;}if(!shouldForceFlushFallbacksInDEV()){// This is not a transition, but we did trigger an avoided state.\n// Schedule a placeholder to display after a short delay, using the Just\n// Noticeable Difference.\n// TODO: Is the JND optimization worth the added complexity? If this is\n// the only reason we track the event time, then probably not.\n// Consider removing.\nvar mostRecentEventTime=getMostRecentEventTime(root,lanes);var eventTimeMs=mostRecentEventTime;var timeElapsedMs=now()-eventTimeMs;var _msUntilTimeout=jnd(timeElapsedMs)-timeElapsedMs;// Don't bother with a very short suspense time.\nif(_msUntilTimeout>10){// Instead of committing the fallback immediately, wait for more data\n// to arrive.\nroot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),_msUntilTimeout);break;}}// Commit the placeholder.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootCompleted:{// The work completed. Ready to commit.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}default:{throw new Error('Unknown root exit status.');}}}function isRenderConsistentWithExternalStores(finishedWork){// Search the rendered tree for external store reads, and check whether the\n// stores were mutated in a concurrent event. Intentionally using an iterative\n// loop instead of recursion so we can exit early.\nvar node=finishedWork;while(true){if(node.flags&StoreConsistency){var updateQueue=node.updateQueue;if(updateQueue!==null){var checks=updateQueue.stores;if(checks!==null){for(var i=0;i<checks.length;i++){var check=checks[i];var getSnapshot=check.getSnapshot;var renderedValue=check.value;try{if(!objectIs(getSnapshot(),renderedValue)){// Found an inconsistent store.\nreturn false;}}catch(error){// If `getSnapshot` throws, return `false`. This will schedule\n// a re-render, and the error will be rethrown during render.\nreturn false;}}}}}var child=node.child;if(node.subtreeFlags&StoreConsistency&&child!==null){child.return=node;node=child;continue;}if(node===finishedWork){return true;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return true;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow doesn't know this is unreachable, but eslint does\n// eslint-disable-next-line no-unreachable\nreturn true;}function markRootSuspended$1(root,suspendedLanes){// When suspending, we should always exclude lanes that were pinged or (more\n// rarely, since we try to avoid it) updated during the render phase.\n// TODO: Lol maybe there's a better way to factor this besides this\n// obnoxiously named function :)\nsuspendedLanes=removeLanes(suspendedLanes,workInProgressRootPingedLanes);suspendedLanes=removeLanes(suspendedLanes,workInProgressRootInterleavedUpdatedLanes);markRootSuspended(root,suspendedLanes);}// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root){{syncNestedUpdateFlag();}if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}flushPassiveEffects();var lanes=getNextLanes(root,NoLanes);if(!includesSomeLane(lanes,SyncLane)){// There's no remaining sync work left.\nensureRootIsScheduled(root,now());return null;}var exitStatus=renderRootSync(root,lanes);if(root.tag!==LegacyRoot&&exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll render\n// synchronously to block concurrent data mutations, and we'll includes\n// all pending updates are included. If it still fails after the second\n// attempt, we'll give up and commit the resulting tree.\nvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){throw new Error('Root did not complete. This is a bug in React.');}// We now have a consistent tree. Because this is a sync render, we\n// will commit it even if something suspended.\nvar finishedWork=root.current.alternate;root.finishedWork=finishedWork;root.finishedLanes=lanes;commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);// Before exiting, make sure there's a callback scheduled for the next\n// pending level.\nensureRootIsScheduled(root,now());return null;}function flushRoot(root,lanes){if(lanes!==NoLanes){markRootEntangled(root,mergeLanes(lanes,SyncLane));ensureRootIsScheduled(root,now());if((executionContext&(RenderContext|CommitContext))===NoContext){resetRenderTimer();flushSyncCallbacks();}}}function batchedUpdates$1(fn,a){var prevExecutionContext=executionContext;executionContext|=BatchedContext;try{return fn(a);}finally{executionContext=prevExecutionContext;// If there were legacy sync updates, flush them at the end of the outer\n// most batchedUpdates-like method.\nif(executionContext===NoContext&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n!ReactCurrentActQueue$1.isBatchingLegacy){resetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function discreteUpdates(fn,a,b,c,d){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);return fn(a,b,c,d);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;if(executionContext===NoContext){resetRenderTimer();}}}// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-redeclare\nfunction flushSync(fn){// In legacy mode, we flush pending passive effects at the beginning of the\n// next event, not at the end of the previous one.\nif(rootWithPendingPassiveEffects!==null&&rootWithPendingPassiveEffects.tag===LegacyRoot&&(executionContext&(RenderContext|CommitContext))===NoContext){flushPassiveEffects();}var prevExecutionContext=executionContext;executionContext|=BatchedContext;var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);if(fn){return fn();}else{return undefined;}}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;executionContext=prevExecutionContext;// Flush the immediate callbacks that were scheduled during this batch.\n// Note that this will happen even if batchedUpdates is higher up\n// the stack.\nif((executionContext&(RenderContext|CommitContext))===NoContext){flushSyncCallbacks();}}}function isAlreadyRendering(){// Used by the renderer to print a warning if certain APIs are called from\n// the wrong context.\nreturn(executionContext&(RenderContext|CommitContext))!==NoContext;}function pushRenderLanes(fiber,lanes){push(subtreeRenderLanesCursor,subtreeRenderLanes,fiber);subtreeRenderLanes=mergeLanes(subtreeRenderLanes,lanes);workInProgressRootIncludedLanes=mergeLanes(workInProgressRootIncludedLanes,lanes);}function popRenderLanes(fiber){subtreeRenderLanes=subtreeRenderLanesCursor.current;pop(subtreeRenderLanesCursor,fiber);}function prepareFreshStack(root,lanes){root.finishedWork=null;root.finishedLanes=NoLanes;var timeoutHandle=root.timeoutHandle;if(timeoutHandle!==noTimeout){// The root previous suspended and scheduled a timeout to commit a fallback\n// state. Now that we have additional work, cancel the timeout.\nroot.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\ncancelTimeout(timeoutHandle);}if(workInProgress!==null){var interruptedWork=workInProgress.return;while(interruptedWork!==null){var current=interruptedWork.alternate;unwindInterruptedWork(current,interruptedWork);interruptedWork=interruptedWork.return;}}workInProgressRoot=root;var rootWorkInProgress=createWorkInProgress(root.current,null);workInProgress=rootWorkInProgress;workInProgressRootRenderLanes=subtreeRenderLanes=workInProgressRootIncludedLanes=lanes;workInProgressRootExitStatus=RootInProgress;workInProgressRootFatalError=null;workInProgressRootSkippedLanes=NoLanes;workInProgressRootInterleavedUpdatedLanes=NoLanes;workInProgressRootPingedLanes=NoLanes;workInProgressRootConcurrentErrors=null;workInProgressRootRecoverableErrors=null;finishQueueingConcurrentUpdates();{ReactStrictModeWarnings.discardPendingWarnings();}return rootWorkInProgress;}function handleError(root,thrownValue){do{var erroredWork=workInProgress;try{// Reset module-level state that was set during the render phase.\nresetContextDependencies();resetHooksAfterThrow();resetCurrentFiber();// TODO: I found and added this missing line while investigating a\n// separate issue. Write a regression test using string refs.\nReactCurrentOwner$2.current=null;if(erroredWork===null||erroredWork.return===null){// Expected to be working on a non-root fiber. This is a fatal error\n// because there's no ancestor that can handle it; the root is\n// supposed to capture all errors that weren't caught by an error\n// boundary.\nworkInProgressRootExitStatus=RootFatalErrored;workInProgressRootFatalError=thrownValue;// Set `workInProgress` to null. This represents advancing to the next\n// sibling, or the parent if there are no siblings. But since the root\n// has no siblings nor a parent, we set it to null. Usually this is\n// handled by `completeUnitOfWork` or `unwindWork`, but since we're\n// intentionally not calling those, we need set it here.\n// TODO: Consider calling `unwindWork` to pop the contexts.\nworkInProgress=null;return;}if(enableProfilerTimer&&erroredWork.mode&ProfileMode){// Record the time spent rendering before an error was thrown. This\n// avoids inaccurate Profiler durations in the case of a\n// suspended render.\nstopProfilerTimerIfRunningAndRecordDelta(erroredWork,true);}if(enableSchedulingProfiler){markComponentRenderStopped();if(thrownValue!==null&&typeof thrownValue==='object'&&typeof thrownValue.then==='function'){var wakeable=thrownValue;markComponentSuspended(erroredWork,wakeable,workInProgressRootRenderLanes);}else{markComponentErrored(erroredWork,thrownValue,workInProgressRootRenderLanes);}}throwException(root,erroredWork.return,erroredWork,thrownValue,workInProgressRootRenderLanes);completeUnitOfWork(erroredWork);}catch(yetAnotherThrownValue){// Something in the return path also threw.\nthrownValue=yetAnotherThrownValue;if(workInProgress===erroredWork&&erroredWork!==null){// If this boundary has already errored, then we had trouble processing\n// the error. Bubble it to the next boundary.\nerroredWork=erroredWork.return;workInProgress=erroredWork;}else{erroredWork=workInProgress;}continue;}// Return to the normal work loop.\nreturn;}while(true);}function pushDispatcher(){var prevDispatcher=ReactCurrentDispatcher$2.current;ReactCurrentDispatcher$2.current=ContextOnlyDispatcher;if(prevDispatcher===null){// The React isomorphic package does not include a default dispatcher.\n// Instead the first renderer will lazily attach one, in order to give\n// nicer error messages.\nreturn ContextOnlyDispatcher;}else{return prevDispatcher;}}function popDispatcher(prevDispatcher){ReactCurrentDispatcher$2.current=prevDispatcher;}function markCommitTimeOfFallback(){globalMostRecentFallbackTime=now();}function markSkippedUpdateLanes(lane){workInProgressRootSkippedLanes=mergeLanes(lane,workInProgressRootSkippedLanes);}function renderDidSuspend(){if(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootSuspended;}}function renderDidSuspendDelayIfPossible(){if(workInProgressRootExitStatus===RootInProgress||workInProgressRootExitStatus===RootSuspended||workInProgressRootExitStatus===RootErrored){workInProgressRootExitStatus=RootSuspendedWithDelay;}// Check if there are updates that we skipped tree that might have unblocked\n// this render.\nif(workInProgressRoot!==null&&(includesNonIdleWork(workInProgressRootSkippedLanes)||includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))){// Mark the current render as suspended so that we switch to working on\n// the updates that were skipped. Usually we only suspend at the end of\n// the render phase.\n// TODO: We should probably always mark the root as suspended immediately\n// (inside this function), since by suspending at the end of the render\n// phase introduces a potential mistake where we suspend lanes that were\n// pinged or updated while we were rendering.\nmarkRootSuspended$1(workInProgressRoot,workInProgressRootRenderLanes);}}function renderDidError(error){if(workInProgressRootExitStatus!==RootSuspendedWithDelay){workInProgressRootExitStatus=RootErrored;}if(workInProgressRootConcurrentErrors===null){workInProgressRootConcurrentErrors=[error];}else{workInProgressRootConcurrentErrors.push(error);}}// Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\nfunction renderHasNotSuspendedYet(){// If something errored or completed, we can't really be sure,\n// so those are false.\nreturn workInProgressRootExitStatus===RootInProgress;}function renderRootSync(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n// If we bailout on this work, we'll move them back (like above).\n// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n// That way we can keep the current update and future updates separate.\nmovePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopSync();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();executionContext=prevExecutionContext;popDispatcher(prevDispatcher);if(workInProgress!==null){// This is a sync render, so we should have finished the whole tree.\nthrow new Error('Cannot commit an incomplete root. This error is likely caused by a '+'bug in React. Please file an issue.');}{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\nworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;return workInProgressRootExitStatus;}// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */function workLoopSync(){// Already timed out, so perform work without checking if we need to yield.\nwhile(workInProgress!==null){performUnitOfWork(workInProgress);}}function renderRootConcurrent(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n// If we bailout on this work, we'll move them back (like above).\n// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n// That way we can keep the current update and future updates separate.\nmovePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();resetRenderTimer();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopConcurrent();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();popDispatcher(prevDispatcher);executionContext=prevExecutionContext;if(workInProgress!==null){// Still work remaining.\n{markRenderYielded();}return RootInProgress;}else{// Completed the tree.\n{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\nworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;// Return the final exit status.\nreturn workInProgressRootExitStatus;}}/** @noinline */function workLoopConcurrent(){// Perform work until Scheduler asks us to yield\nwhile(workInProgress!==null&&!shouldYield()){performUnitOfWork(workInProgress);}}function performUnitOfWork(unitOfWork){// The current, flushed, state of this fiber is the alternate. Ideally\n// nothing should rely on this, but relying on it here means that we don't\n// need an additional field on the work in progress.\nvar current=unitOfWork.alternate;setCurrentFiber(unitOfWork);var next;if((unitOfWork.mode&ProfileMode)!==NoMode){startProfilerTimer(unitOfWork);next=beginWork$1(current,unitOfWork,subtreeRenderLanes);stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,true);}else{next=beginWork$1(current,unitOfWork,subtreeRenderLanes);}resetCurrentFiber();unitOfWork.memoizedProps=unitOfWork.pendingProps;if(next===null){// If this doesn't spawn new work, complete the current work.\ncompleteUnitOfWork(unitOfWork);}else{workInProgress=next;}ReactCurrentOwner$2.current=null;}function completeUnitOfWork(unitOfWork){// Attempt to complete the current unit of work, then move to the next\n// sibling. If there are no more siblings, return to the parent fiber.\nvar completedWork=unitOfWork;do{// The current, flushed, state of this fiber is the alternate. Ideally\n// nothing should rely on this, but relying on it here means that we don't\n// need an additional field on the work in progress.\nvar current=completedWork.alternate;var returnFiber=completedWork.return;// Check if the work completed or if something threw.\nif((completedWork.flags&Incomplete)===NoFlags){setCurrentFiber(completedWork);var next=void 0;if((completedWork.mode&ProfileMode)===NoMode){next=completeWork(current,completedWork,subtreeRenderLanes);}else{startProfilerTimer(completedWork);next=completeWork(current,completedWork,subtreeRenderLanes);// Update render duration assuming we didn't error.\nstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);}resetCurrentFiber();if(next!==null){// Completing this fiber spawned new work. Work on that next.\nworkInProgress=next;return;}}else{// This fiber did not complete because something threw. Pop values off\n// the stack without entering the complete phase. If this is a boundary,\n// capture values if possible.\nvar _next=unwindWork(current,completedWork);// Because this fiber did not complete, don't reset its lanes.\nif(_next!==null){// If completing this work spawned new work, do that next. We'll come\n// back here again.\n// Since we're restarting, remove anything that is not a host effect\n// from the effect tag.\n_next.flags&=HostEffectMask;workInProgress=_next;return;}if((completedWork.mode&ProfileMode)!==NoMode){// Record the render duration for the fiber that errored.\nstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);// Include the time spent working on failed children before continuing.\nvar actualDuration=completedWork.actualDuration;var child=completedWork.child;while(child!==null){actualDuration+=child.actualDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;}if(returnFiber!==null){// Mark the parent fiber as incomplete and clear its subtree flags.\nreturnFiber.flags|=Incomplete;returnFiber.subtreeFlags=NoFlags;returnFiber.deletions=null;}else{// We've unwound all the way to the root.\nworkInProgressRootExitStatus=RootDidNotComplete;workInProgress=null;return;}}var siblingFiber=completedWork.sibling;if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.\nworkInProgress=siblingFiber;return;}// Otherwise, return to the parent\ncompletedWork=returnFiber;// Update the next thing we're working on in case something throws.\nworkInProgress=completedWork;}while(completedWork!==null);// We've reached the root.\nif(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootCompleted;}}function commitRoot(root,recoverableErrors,transitions){// TODO: This no longer makes any sense. We already wrap the mutation and\n// layout phases. Should be able to remove.\nvar previousUpdateLanePriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);commitRootImpl(root,recoverableErrors,transitions,previousUpdateLanePriority);}finally{ReactCurrentBatchConfig$3.transition=prevTransition;setCurrentUpdatePriority(previousUpdateLanePriority);}return null;}function commitRootImpl(root,recoverableErrors,transitions,renderPriorityLevel){do{// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n// means `flushPassiveEffects` will sometimes result in additional\n// passive effects. So we need to keep flushing in a loop until there are\n// no more pending effects.\n// TODO: Might be better if `flushPassiveEffects` did not automatically\n// flush synchronous work at the end, to avoid factoring hazards like this.\nflushPassiveEffects();}while(rootWithPendingPassiveEffects!==null);flushRenderPhaseStrictModeWarningsInDEV();if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}var finishedWork=root.finishedWork;var lanes=root.finishedLanes;{markCommitStarted(lanes);}if(finishedWork===null){{markCommitStopped();}return null;}else{{if(lanes===NoLanes){error('root.finishedLanes should not be empty during a commit. This is a '+'bug in React.');}}}root.finishedWork=null;root.finishedLanes=NoLanes;if(finishedWork===root.current){throw new Error('Cannot commit the same tree as before. This error is likely caused by '+'a bug in React. Please file an issue.');}// commitRoot never returns a continuation; it always finishes synchronously.\n// So we can clear these now to allow a new callback to be scheduled.\nroot.callbackNode=null;root.callbackPriority=NoLane;// Update the first and last pending times on this root. The new first\n// pending time is whatever is left on the root fiber.\nvar remainingLanes=mergeLanes(finishedWork.lanes,finishedWork.childLanes);markRootFinished(root,remainingLanes);if(root===workInProgressRoot){// We can reset these now that they are finished.\nworkInProgressRoot=null;workInProgress=null;workInProgressRootRenderLanes=NoLanes;}// If there are pending passive effects, schedule a callback to process them.\n// Do this as early as possible, so it is queued before anything else that\n// might get scheduled in the commit phase. (See #16714.)\n// TODO: Delete all other places that schedule the passive effect callback\n// They're redundant.\nif((finishedWork.subtreeFlags&PassiveMask)!==NoFlags||(finishedWork.flags&PassiveMask)!==NoFlags){if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;// to store it in pendingPassiveTransitions until they get processed\n// We need to pass this through as an argument to commitRoot\n// because workInProgressTransitions might have changed between\n// the previous render and commit if we throttle the commit\n// with setTimeout\npendingPassiveTransitions=transitions;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();// This render triggered passive effects: release the root cache pool\n// *after* passive effects fire to avoid freeing a cache pool that may\n// be referenced by a node in the tree (HostRoot, Cache boundary etc)\nreturn null;});}}// Check if there are any effects in the whole tree.\n// TODO: This is left over from the effect list implementation, where we had\n// to check for the existence of `firstEffect` to satisfy Flow. I think the\n// only other reason this optimization exists is because it affects profiling.\n// Reconsider whether this is necessary.\nvar subtreeHasEffects=(finishedWork.subtreeFlags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;var rootHasEffect=(finishedWork.flags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;if(subtreeHasEffects||rootHasEffect){var prevTransition=ReactCurrentBatchConfig$3.transition;ReactCurrentBatchConfig$3.transition=null;var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(DiscreteEventPriority);var prevExecutionContext=executionContext;executionContext|=CommitContext;// Reset this to null before calling lifecycles\nReactCurrentOwner$2.current=null;// The commit phase is broken into several sub-phases. We do a separate pass\n// of the effect list for each phase: all mutation effects come before all\n// layout effects, and so on.\n// The first phase a \"before mutation\" phase. We use this phase to read the\n// state of the host tree right before we mutate it. This is where\n// getSnapshotBeforeUpdate is called.\nvar shouldFireAfterActiveInstanceBlur=commitBeforeMutationEffects(root,finishedWork);{// Mark the current commit time to be shared by all Profilers in this\n// batch. This enables them to be grouped later.\nrecordCommitTime();}commitMutationEffects(root,finishedWork,lanes);resetAfterCommit(root.containerInfo);// The work-in-progress tree is now the current tree. This must come after\n// the mutation phase, so that the previous tree is still current during\n// componentWillUnmount, but before the layout phase, so that the finished\n// work is current during componentDidMount/Update.\nroot.current=finishedWork;// The next phase is the layout phase, where we call effects that read\n{markLayoutEffectsStarted(lanes);}commitLayoutEffects(finishedWork,root,lanes);{markLayoutEffectsStopped();}// opportunity to paint.\nrequestPaint();executionContext=prevExecutionContext;// Reset the priority to the previous non-sync value.\nsetCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;}else{// No effects.\nroot.current=finishedWork;// Measure these anyway so the flamegraph explicitly shows that there were\n// no effects.\n// TODO: Maybe there's a better way to report this.\n{recordCommitTime();}}var rootDidHavePassiveEffects=rootDoesHavePassiveEffects;if(rootDoesHavePassiveEffects){// This commit has passive effects. Stash a reference to them. But don't\n// schedule a callback until after flushing layout work.\nrootDoesHavePassiveEffects=false;rootWithPendingPassiveEffects=root;pendingPassiveEffectsLanes=lanes;}else{{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;}}// Read this again, since an effect might have updated it\nremainingLanes=root.pendingLanes;// Check if there's remaining work on this root\n// TODO: This is part of the `componentDidCatch` implementation. Its purpose\n// is to detect whether something might have called setState inside\n// `componentDidCatch`. The mechanism is known to be flawed because `setState`\n// inside `componentDidCatch` is itself flawed  that's why we recommend\n// `getDerivedStateFromError` instead. However, it could be improved by\n// checking if remainingLanes includes Sync work, instead of whether there's\n// any work remaining at all (which would also include stuff like Suspense\n// retries or transitions). It's been like this for a while, though, so fixing\n// it probably isn't that urgent.\nif(remainingLanes===NoLanes){// If there's no remaining work, we can clear the set of already failed\n// error boundaries.\nlegacyErrorBoundariesThatAlreadyFailed=null;}{if(!rootDidHavePassiveEffects){commitDoubleInvokeEffectsInDEV(root.current,false);}}onCommitRoot(finishedWork.stateNode,renderPriorityLevel);{if(isDevToolsPresent){root.memoizedUpdaters.clear();}}{onCommitRoot$1();}// Always call this before exiting `commitRoot`, to ensure that any\n// additional work on this root is scheduled.\nensureRootIsScheduled(root,now());if(recoverableErrors!==null){// There were errors during this render, but recovered from them without\n// needing to surface it to the UI. We log them here.\nvar onRecoverableError=root.onRecoverableError;for(var i=0;i<recoverableErrors.length;i++){var recoverableError=recoverableErrors[i];var componentStack=recoverableError.stack;var digest=recoverableError.digest;onRecoverableError(recoverableError.value,{componentStack:componentStack,digest:digest});}}if(hasUncaughtError){hasUncaughtError=false;var error$1=firstUncaughtError;firstUncaughtError=null;throw error$1;}// If the passive effects are the result of a discrete render, flush them\n// synchronously at the end of the current task so that the result is\n// immediately observable. Otherwise, we assume that they are not\n// order-dependent and do not need to be observed by external systems, so we\n// can wait until after paint.\n// TODO: We can optimize this by not scheduling the callback earlier. Since we\n// currently schedule the callback in multiple places, will wait until those\n// are consolidated.\nif(includesSomeLane(pendingPassiveEffectsLanes,SyncLane)&&root.tag!==LegacyRoot){flushPassiveEffects();}// Read this again, since a passive effect might have updated it\nremainingLanes=root.pendingLanes;if(includesSomeLane(remainingLanes,SyncLane)){{markNestedUpdateScheduled();}// Count the number of times the root synchronously re-renders without\n// finishing. If there are too many, it indicates an infinite update loop.\nif(root===rootWithNestedUpdates){nestedUpdateCount++;}else{nestedUpdateCount=0;rootWithNestedUpdates=root;}}else{nestedUpdateCount=0;}// If layout work was scheduled, flush it now.\nflushSyncCallbacks();{markCommitStopped();}return null;}function flushPassiveEffects(){// Returns whether passive effects were flushed.\n// TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n// probably just combine the two functions. I believe they were only separate\n// in the first place because we used to wrap it with\n// `Scheduler.runWithPriority`, which accepts a function. But now we track the\n// priority within React itself, so we can mutate the variable directly.\nif(rootWithPendingPassiveEffects!==null){var renderPriority=lanesToEventPriority(pendingPassiveEffectsLanes);var priority=lowerEventPriority(DefaultEventPriority,renderPriority);var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(priority);return flushPassiveEffectsImpl();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;// Once passive effects have run for the tree - giving components a\n}}return false;}function enqueuePendingPassiveProfilerEffect(fiber){{pendingPassiveProfilerEffects.push(fiber);if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();return null;});}}}function flushPassiveEffectsImpl(){if(rootWithPendingPassiveEffects===null){return false;}// Cache and clear the transitions flag\nvar transitions=pendingPassiveTransitions;pendingPassiveTransitions=null;var root=rootWithPendingPassiveEffects;var lanes=pendingPassiveEffectsLanes;rootWithPendingPassiveEffects=null;// TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n// Figure out why and fix it. It's not causing any known issues (probably\n// because it's only used for profiling), but it's a refactor hazard.\npendingPassiveEffectsLanes=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Cannot flush passive effects while already rendering.');}{isFlushingPassiveEffects=true;didScheduleUpdateDuringPassiveEffects=false;}{markPassiveEffectsStarted(lanes);}var prevExecutionContext=executionContext;executionContext|=CommitContext;commitPassiveUnmountEffects(root.current);commitPassiveMountEffects(root,root.current,lanes,transitions);// TODO: Move to commitPassiveMountEffects\n{var profilerEffects=pendingPassiveProfilerEffects;pendingPassiveProfilerEffects=[];for(var i=0;i<profilerEffects.length;i++){var _fiber=profilerEffects[i];commitPassiveEffectDurations(root,_fiber);}}{markPassiveEffectsStopped();}{commitDoubleInvokeEffectsInDEV(root.current,true);}executionContext=prevExecutionContext;flushSyncCallbacks();{// If additional passive effects were scheduled, increment a counter. If this\n// exceeds the limit, we'll fire a warning.\nif(didScheduleUpdateDuringPassiveEffects){if(root===rootWithPassiveNestedUpdates){nestedPassiveUpdateCount++;}else{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=root;}}else{nestedPassiveUpdateCount=0;}isFlushingPassiveEffects=false;didScheduleUpdateDuringPassiveEffects=false;}// TODO: Move to commitPassiveMountEffects\nonPostCommitRoot(root);{var stateNode=root.current.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}return true;}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance);}function markLegacyErrorBoundaryAsFailed(instance){if(legacyErrorBoundariesThatAlreadyFailed===null){legacyErrorBoundariesThatAlreadyFailed=new Set([instance]);}else{legacyErrorBoundariesThatAlreadyFailed.add(instance);}}function prepareToThrowUncaughtError(error){if(!hasUncaughtError){hasUncaughtError=true;firstUncaughtError=error;}}var onUncaughtError=prepareToThrowUncaughtError;function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error){var errorInfo=createCapturedValueAtFiber(error,sourceFiber);var update=createRootErrorUpdate(rootFiber,errorInfo,SyncLane);var root=enqueueUpdate(rootFiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function captureCommitPhaseError(sourceFiber,nearestMountedAncestor,error$1){{reportUncaughtErrorInDEV(error$1);setIsRunningInsertionEffect(false);}if(sourceFiber.tag===HostRoot){// Error was thrown at the root. There is no parent, so the root\n// itself should capture it.\ncaptureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error$1);return;}var fiber=null;{fiber=nearestMountedAncestor;}while(fiber!==null){if(fiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(fiber,sourceFiber,error$1);return;}else if(fiber.tag===ClassComponent){var ctor=fiber.type;var instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromError==='function'||typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValueAtFiber(error$1,sourceFiber);var update=createClassErrorUpdate(fiber,errorInfo,SyncLane);var root=enqueueUpdate(fiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}return;}}fiber=fiber.return;}{// TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n// will fire for errors that are thrown by destroy functions inside deleted\n// trees. What it should instead do is propagate the error to the parent of\n// the deleted tree. In the meantime, do not add this warning to the\n// allowlist; this is only for our internal use.\nerror('Internal React error: Attempted to capture a commit phase error '+'inside a detached tree. This indicates a bug in React. Likely '+'causes include deleting the same fiber more than once, committing an '+'already-finished tree, or an inconsistent return pointer.\\n\\n'+'Error message:\\n\\n%s',error$1);}}function pingSuspendedRoot(root,wakeable,pingedLanes){var pingCache=root.pingCache;if(pingCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n// never be thrown again.\npingCache.delete(wakeable);}var eventTime=requestEventTime();markRootPinged(root,pingedLanes);warnIfSuspenseResolutionNotWrappedWithActDEV(root);if(workInProgressRoot===root&&isSubsetOfLanes(workInProgressRootRenderLanes,pingedLanes)){// Received a ping at the same priority level at which we're currently\n// rendering. We might want to restart this render. This should mirror\n// the logic of whether or not a root suspends once it completes.\n// TODO: If we're rendering sync either due to Sync, Batched or expired,\n// we should probably never restart.\n// If we're suspended with delay, or if it's a retry, we'll always suspend\n// so we can always restart.\nif(workInProgressRootExitStatus===RootSuspendedWithDelay||workInProgressRootExitStatus===RootSuspended&&includesOnlyRetries(workInProgressRootRenderLanes)&&now()-globalMostRecentFallbackTime<FALLBACK_THROTTLE_MS){// Restart from the root.\nprepareFreshStack(root,NoLanes);}else{// Even though we can't restart right now, we might get an\n// opportunity later. So we mark this render as having a ping.\nworkInProgressRootPingedLanes=mergeLanes(workInProgressRootPingedLanes,pingedLanes);}}ensureRootIsScheduled(root,eventTime);}function retryTimedOutBoundary(boundaryFiber,retryLane){// The boundary fiber (a Suspense component or SuspenseList component)\n// previously was rendered in its fallback state. One of the promises that\n// suspended it has resolved, which means at least part of the tree was\n// likely unblocked. Try rendering again, at a new lanes.\nif(retryLane===NoLane){// TODO: Assign this to `suspenseState.retryLane`? to avoid\n// unnecessary entanglement?\nretryLane=requestRetryLane(boundaryFiber);}// TODO: Special case idle priority?\nvar eventTime=requestEventTime();var root=enqueueConcurrentRenderForLane(boundaryFiber,retryLane);if(root!==null){markRootUpdated(root,retryLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function retryDehydratedSuspenseBoundary(boundaryFiber){var suspenseState=boundaryFiber.memoizedState;var retryLane=NoLane;if(suspenseState!==null){retryLane=suspenseState.retryLane;}retryTimedOutBoundary(boundaryFiber,retryLane);}function resolveRetryWakeable(boundaryFiber,wakeable){var retryLane=NoLane;// Default\nvar retryCache;switch(boundaryFiber.tag){case SuspenseComponent:retryCache=boundaryFiber.stateNode;var suspenseState=boundaryFiber.memoizedState;if(suspenseState!==null){retryLane=suspenseState.retryLane;}break;case SuspenseListComponent:retryCache=boundaryFiber.stateNode;break;default:throw new Error('Pinged unknown suspense boundary type. '+'This is probably a bug in React.');}if(retryCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n// never be thrown again.\nretryCache.delete(wakeable);}retryTimedOutBoundary(boundaryFiber,retryLane);}// Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\nfunction jnd(timeElapsed){return timeElapsed<120?120:timeElapsed<480?480:timeElapsed<1080?1080:timeElapsed<1920?1920:timeElapsed<3000?3000:timeElapsed<4320?4320:ceil(timeElapsed/1960)*1960;}function checkForNestedUpdates(){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){nestedUpdateCount=0;rootWithNestedUpdates=null;throw new Error('Maximum update depth exceeded. This can happen when a component '+'repeatedly calls setState inside componentWillUpdate or '+'componentDidUpdate. React limits the number of nested updates to '+'prevent infinite loops.');}{if(nestedPassiveUpdateCount>NESTED_PASSIVE_UPDATE_LIMIT){nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;error('Maximum update depth exceeded. This can happen when a component '+\"calls setState inside useEffect, but useEffect either doesn't \"+'have a dependency array, or one of the dependencies changes on '+'every render.');}}}function flushRenderPhaseStrictModeWarningsInDEV(){{ReactStrictModeWarnings.flushLegacyContextWarning();{ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();}}}function commitDoubleInvokeEffectsInDEV(fiber,hasPassiveEffects){{// TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n// so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n// Maybe not a big deal since this is DEV only behavior.\nsetCurrentFiber(fiber);invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectUnmountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectUnmountInDEV);}invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectMountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectMountInDEV);}resetCurrentFiber();}}function invokeEffectsInDev(firstChild,fiberFlags,invokeEffectFn){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nvar current=firstChild;var subtreeRoot=null;while(current!==null){var primarySubtreeFlag=current.subtreeFlags&fiberFlags;if(current!==subtreeRoot&&current.child!==null&&primarySubtreeFlag!==NoFlags){current=current.child;}else{if((current.flags&fiberFlags)!==NoFlags){invokeEffectFn(current);}if(current.sibling!==null){current=current.sibling;}else{current=subtreeRoot=current.return;}}}}}var didWarnStateUpdateForNotYetMountedComponent=null;function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber){{if((executionContext&RenderContext)!==NoContext){// We let the other warning about render phase updates deal with this one.\nreturn;}if(!(fiber.mode&ConcurrentMode)){return;}var tag=fiber.tag;if(tag!==IndeterminateComponent&&tag!==HostRoot&&tag!==ClassComponent&&tag!==FunctionComponent&&tag!==ForwardRef&&tag!==MemoComponent&&tag!==SimpleMemoComponent){// Only warn for user-defined components, not internal ones like Suspense.\nreturn;}// We show the whole stack but dedupe on the top component's name because\n// the problematic code almost always lies inside that component.\nvar componentName=getComponentNameFromFiber(fiber)||'ReactComponent';if(didWarnStateUpdateForNotYetMountedComponent!==null){if(didWarnStateUpdateForNotYetMountedComponent.has(componentName)){return;}didWarnStateUpdateForNotYetMountedComponent.add(componentName);}else{didWarnStateUpdateForNotYetMountedComponent=new Set([componentName]);}var previousFiber=current;try{setCurrentFiber(fiber);error(\"Can't perform a React state update on a component that hasn't mounted yet. \"+'This indicates that you have a side-effect in your render function that '+'asynchronously later calls tries to update the component. Move this work to '+'useEffect instead.');}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}var beginWork$1;{var dummyFiber=null;beginWork$1=function(current,unitOfWork,lanes){// If a component throws an error, we replay it again in a synchronously\n// dispatched event, so that the debugger will treat it as an uncaught\n// error See ReactErrorUtils for more information.\n// Before entering the begin phase, copy the work-in-progress onto a dummy\n// fiber. If beginWork throws, we'll use this to reset the state.\nvar originalWorkInProgressCopy=assignFiberPropertiesInDEV(dummyFiber,unitOfWork);try{return beginWork(current,unitOfWork,lanes);}catch(originalError){if(didSuspendOrErrorWhileHydratingDEV()||originalError!==null&&typeof originalError==='object'&&typeof originalError.then==='function'){// Don't replay promises.\n// Don't replay errors if we are hydrating and have already suspended or handled an error\nthrow originalError;}// Keep this code in sync with handleError; any changes here must have\n// corresponding changes there.\nresetContextDependencies();resetHooksAfterThrow();// Don't reset current debug fiber, since we're about to work on the\n// same fiber again.\n// Unwind the failed stack frame\nunwindInterruptedWork(current,unitOfWork);// Restore the original properties of the fiber.\nassignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy);if(unitOfWork.mode&ProfileMode){// Reset the profiler timer.\nstartProfilerTimer(unitOfWork);}// Run beginWork again.\ninvokeGuardedCallback(null,beginWork,null,current,unitOfWork,lanes);if(hasCaughtError()){var replayError=clearCaughtError();if(typeof replayError==='object'&&replayError!==null&&replayError._suppressLogging&&typeof originalError==='object'&&originalError!==null&&!originalError._suppressLogging){// If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\noriginalError._suppressLogging=true;}}// We always throw the original error in case the second render pass is not idempotent.\n// This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\nthrow originalError;}};}var didWarnAboutUpdateInRender=false;var didWarnAboutUpdateInRenderForAnotherComponent;{didWarnAboutUpdateInRenderForAnotherComponent=new Set();}function warnAboutRenderPhaseUpdatesInDEV(fiber){{if(isRendering&&!getIsUpdatingOpaqueValueInRenderPhaseInDEV()){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{var renderingComponentName=workInProgress&&getComponentNameFromFiber(workInProgress)||'Unknown';// Dedupe by the rendering component because it's the one that needs to be fixed.\nvar dedupeKey=renderingComponentName;if(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)){didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);var setStateComponentName=getComponentNameFromFiber(fiber)||'Unknown';error('Cannot update a component (`%s`) while rendering a '+'different component (`%s`). To locate the bad setState() call inside `%s`, '+'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',setStateComponentName,renderingComponentName,renderingComponentName);}break;}case ClassComponent:{if(!didWarnAboutUpdateInRender){error('Cannot update during an existing state transition (such as '+'within `render`). Render methods should be a pure '+'function of props and state.');didWarnAboutUpdateInRender=true;}break;}}}}}function restorePendingUpdaters(root,lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;memoizedUpdaters.forEach(function(schedulingFiber){addFiberToLanesMap(root,schedulingFiber,lanes);});// This function intentionally does not clear memoized updaters.\n// Those may still be relevant to the current commit\n// and a future one (e.g. Suspense).\n}}}var fakeActCallbackNode={};function scheduleCallback$1(priorityLevel,callback){{// If we're currently inside an `act` scope, bypass Scheduler and push to\n// the `act` queue instead.\nvar actQueue=ReactCurrentActQueue$1.current;if(actQueue!==null){actQueue.push(callback);return fakeActCallbackNode;}else{return scheduleCallback(priorityLevel,callback);}}}function cancelCallback$1(callbackNode){if(callbackNode===fakeActCallbackNode){return;}// In production, always call Scheduler. This function will be stripped out.\nreturn cancelCallback(callbackNode);}function shouldForceFlushFallbacksInDEV(){// Never force flush in production. This function should get stripped out.\nreturn ReactCurrentActQueue$1.current!==null;}function warnIfUpdatesNotWrappedWithActDEV(fiber){{if(fiber.mode&ConcurrentMode){if(!isConcurrentActEnvironment()){// Not in an act environment. No need to warn.\nreturn;}}else{// Legacy mode has additional cases where we suppress a warning.\nif(!isLegacyActEnvironment()){// Not in an act environment. No need to warn.\nreturn;}if(executionContext!==NoContext){// Legacy mode doesn't warn if the update is batched, i.e.\n// batchedUpdates or flushSync.\nreturn;}if(fiber.tag!==FunctionComponent&&fiber.tag!==ForwardRef&&fiber.tag!==SimpleMemoComponent){// For backwards compatibility with pre-hooks code, legacy mode only\n// warns for updates that originate from a hook.\nreturn;}}if(ReactCurrentActQueue$1.current===null){var previousFiber=current;try{setCurrentFiber(fiber);error('An update to %s inside a test was not wrapped in act(...).\\n\\n'+'When testing, code that causes React state updates should be '+'wrapped into act(...):\\n\\n'+'act(() => {\\n'+'  /* fire events that update state */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act',getComponentNameFromFiber(fiber));}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}}function warnIfSuspenseResolutionNotWrappedWithActDEV(root){{if(root.tag!==LegacyRoot&&isConcurrentActEnvironment()&&ReactCurrentActQueue$1.current===null){error('A suspended resource finished loading inside a test, but the event '+'was not wrapped in act(...).\\n\\n'+'When testing, code that resolves suspended data should be wrapped '+'into act(...):\\n\\n'+'act(() => {\\n'+'  /* finish loading suspended data */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act');}}}function setIsRunningInsertionEffect(isRunning){{isRunningInsertionEffect=isRunning;}}/* eslint-disable react-internal/prod-error-codes */var resolveFamily=null;// $FlowFixMe Flow gets confused by a WeakSet feature check below.\nvar failedBoundaries=null;var setRefreshHandler=function(handler){{resolveFamily=handler;}};function resolveFunctionForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn type;}var family=resolveFamily(type);if(family===undefined){return type;}// Use the latest known implementation.\nreturn family.current;}}function resolveClassForHotReloading(type){// No implementation differences.\nreturn resolveFunctionForHotReloading(type);}function resolveForwardRefForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn type;}var family=resolveFamily(type);if(family===undefined){// Check if we're dealing with a real forwardRef. Don't want to crash early.\nif(type!==null&&type!==undefined&&typeof type.render==='function'){// ForwardRef is special because its resolved .type is an object,\n// but it's possible that we only have its inner render function in the map.\n// If that inner render function is different, we'll build a new forwardRef type.\nvar currentRender=resolveFunctionForHotReloading(type.render);if(type.render!==currentRender){var syntheticType={$$typeof:REACT_FORWARD_REF_TYPE,render:currentRender};if(type.displayName!==undefined){syntheticType.displayName=type.displayName;}return syntheticType;}}return type;}// Use the latest known implementation.\nreturn family.current;}}function isCompatibleFamilyForHotReloading(fiber,element){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn false;}var prevType=fiber.elementType;var nextType=element.type;// If we got here, we know types aren't === equal.\nvar needsCompareFamilies=false;var $$typeofNextType=typeof nextType==='object'&&nextType!==null?nextType.$$typeof:null;switch(fiber.tag){case ClassComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}break;}case FunctionComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){// We don't know the inner type yet.\n// We're going to assume that the lazy inner type is stable,\n// and so it is sufficient to avoid reconciling it away.\n// We're not going to unwrap or actually use the new lazy type.\nneedsCompareFamilies=true;}break;}case ForwardRef:{if($$typeofNextType===REACT_FORWARD_REF_TYPE){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}case MemoComponent:case SimpleMemoComponent:{if($$typeofNextType===REACT_MEMO_TYPE){// TODO: if it was but can no longer be simple,\n// we shouldn't set this.\nneedsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}default:return false;}// Check if both types have a family and it's the same one.\nif(needsCompareFamilies){// Note: memo() and forwardRef() we'll compare outer rather than inner type.\n// This means both of them need to be registered to preserve state.\n// If we unwrapped and compared the inner types for wrappers instead,\n// then we would risk falsely saying two separate memo(Foo)\n// calls are equivalent because they wrap the same Foo function.\nvar prevFamily=resolveFamily(prevType);if(prevFamily!==undefined&&prevFamily===resolveFamily(nextType)){return true;}}return false;}}function markFailedErrorBoundaryForHotReloading(fiber){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn;}if(typeof WeakSet!=='function'){return;}if(failedBoundaries===null){failedBoundaries=new WeakSet();}failedBoundaries.add(fiber);}}var scheduleRefresh=function(root,update){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn;}var staleFamilies=update.staleFamilies,updatedFamilies=update.updatedFamilies;flushPassiveEffects();flushSync(function(){scheduleFibersWithFamiliesRecursively(root.current,updatedFamilies,staleFamilies);});}};var scheduleRoot=function(root,element){{if(root.context!==emptyContextObject){// Super edge case: root has a legacy _renderSubtree context\n// but we don't know the parentComponent so we can't pass it.\n// Just ignore. We'll delete this with _renderSubtree code path later.\nreturn;}flushPassiveEffects();flushSync(function(){updateContainer(element,root,null,null);});}};function scheduleFibersWithFamiliesRecursively(fiber,updatedFamilies,staleFamilies){{var alternate=fiber.alternate,child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}if(resolveFamily===null){throw new Error('Expected resolveFamily to be set during hot reload.');}var needsRender=false;var needsRemount=false;if(candidateType!==null){var family=resolveFamily(candidateType);if(family!==undefined){if(staleFamilies.has(family)){needsRemount=true;}else if(updatedFamilies.has(family)){if(tag===ClassComponent){needsRemount=true;}else{needsRender=true;}}}}if(failedBoundaries!==null){if(failedBoundaries.has(fiber)||alternate!==null&&failedBoundaries.has(alternate)){needsRemount=true;}}if(needsRemount){fiber._debugNeedsRemount=true;}if(needsRemount||needsRender){var _root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(_root!==null){scheduleUpdateOnFiber(_root,fiber,SyncLane,NoTimestamp);}}if(child!==null&&!needsRemount){scheduleFibersWithFamiliesRecursively(child,updatedFamilies,staleFamilies);}if(sibling!==null){scheduleFibersWithFamiliesRecursively(sibling,updatedFamilies,staleFamilies);}}}var findHostInstancesForRefresh=function(root,families){{var hostInstances=new Set();var types=new Set(families.map(function(family){return family.current;}));findHostInstancesForMatchingFibersRecursively(root.current,types,hostInstances);return hostInstances;}};function findHostInstancesForMatchingFibersRecursively(fiber,types,hostInstances){{var child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}var didMatch=false;if(candidateType!==null){if(types.has(candidateType)){didMatch=true;}}if(didMatch){// We have a match. This only drills down to the closest host components.\n// There's no need to search deeper because for the purpose of giving\n// visual feedback, \"flashing\" outermost parent rectangles is sufficient.\nfindHostInstancesForFiberShallowly(fiber,hostInstances);}else{// If there's no match, maybe there will be one further down in the child tree.\nif(child!==null){findHostInstancesForMatchingFibersRecursively(child,types,hostInstances);}}if(sibling!==null){findHostInstancesForMatchingFibersRecursively(sibling,types,hostInstances);}}}function findHostInstancesForFiberShallowly(fiber,hostInstances){{var foundHostInstances=findChildHostInstancesForFiberShallowly(fiber,hostInstances);if(foundHostInstances){return;}// If we didn't find any host children, fallback to closest host parent.\nvar node=fiber;while(true){switch(node.tag){case HostComponent:hostInstances.add(node.stateNode);return;case HostPortal:hostInstances.add(node.stateNode.containerInfo);return;case HostRoot:hostInstances.add(node.stateNode.containerInfo);return;}if(node.return===null){throw new Error('Expected to reach root first.');}node=node.return;}}}function findChildHostInstancesForFiberShallowly(fiber,hostInstances){{var node=fiber;var foundHostInstances=false;while(true){if(node.tag===HostComponent){// We got a match.\nfoundHostInstances=true;hostInstances.add(node.stateNode);// There may still be more, so keep searching.\n}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===fiber){return foundHostInstances;}while(node.sibling===null){if(node.return===null||node.return===fiber){return foundHostInstances;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}return false;}var hasBadMapPolyfill;{hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new */new Map([[nonExtensibleObject,null]]);new Set([nonExtensibleObject]);/* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills\nhasBadMapPolyfill=true;}}function FiberNode(tag,pendingProps,key,mode){// Instance\nthis.tag=tag;this.key=key;this.elementType=null;this.type=null;this.stateNode=null;// Fiber\nthis.return=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=pendingProps;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.dependencies=null;this.mode=mode;// Effects\nthis.flags=NoFlags;this.subtreeFlags=NoFlags;this.deletions=null;this.lanes=NoLanes;this.childLanes=NoLanes;this.alternate=null;{// Note: The following is done to avoid a v8 performance cliff.\n//\n// Initializing the fields below to smis and later updating them with\n// double values will cause Fibers to end up having separate shapes.\n// This behavior/bug has something to do with Object.preventExtension().\n// Fortunately this only impacts DEV builds.\n// Unfortunately it makes React unusably slow for some applications.\n// To work around this, initialize the fields below with doubles.\n//\n// Learn more about this here:\n// https://github.com/facebook/react/issues/14365\n// https://bugs.chromium.org/p/v8/issues/detail?id=8538\nthis.actualDuration=Number.NaN;this.actualStartTime=Number.NaN;this.selfBaseDuration=Number.NaN;this.treeBaseDuration=Number.NaN;// It's okay to replace the initial doubles with smis after initialization.\n// This won't trigger the performance cliff mentioned above,\n// and it simplifies other profiler code (including DevTools).\nthis.actualDuration=0;this.actualStartTime=-1;this.selfBaseDuration=0;this.treeBaseDuration=0;}{// This isn't directly used but is handy for debugging internals:\nthis._debugSource=null;this._debugOwner=null;this._debugNeedsRemount=false;this._debugHookTypes=null;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber=function(tag,pendingProps,key,mode){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\nreturn new FiberNode(tag,pendingProps,key,mode);};function shouldConstruct$1(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function isSimpleFunctionComponent(type){return typeof type==='function'&&!shouldConstruct$1(type)&&type.defaultProps===undefined;}function resolveLazyComponentTag(Component){if(typeof Component==='function'){return shouldConstruct$1(Component)?ClassComponent:FunctionComponent;}else if(Component!==undefined&&Component!==null){var $$typeof=Component.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE){return ForwardRef;}if($$typeof===REACT_MEMO_TYPE){return MemoComponent;}}return IndeterminateComponent;}// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current,pendingProps){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll\n// only ever need at most two versions of a tree. We pool the \"other\" unused\n// node that we're free to reuse. This is lazily created to avoid allocating\n// extra objects for things that are never updated. It also allow us to\n// reclaim the extra memory if needed.\nworkInProgress=createFiber(current.tag,pendingProps,current.key,current.mode);workInProgress.elementType=current.elementType;workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields\nworkInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;workInProgress._debugHookTypes=current._debugHookTypes;}workInProgress.alternate=current;current.alternate=workInProgress;}else{workInProgress.pendingProps=pendingProps;// Needed because Blocks store data on type.\nworkInProgress.type=current.type;// We already have an alternate.\n// Reset the effect tag.\nworkInProgress.flags=NoFlags;// The effects are no longer valid.\nworkInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;{// We intentionally reset, rather than copy, actualDuration & actualStartTime.\n// This prevents time from endlessly accumulating in new commits.\n// This has the downside of resetting values for different priority renders,\n// But works for yielding (the common case) and should support resuming.\nworkInProgress.actualDuration=0;workInProgress.actualStartTime=-1;}}// Reset all effects except static ones.\n// Static effects are not specific to a render.\nworkInProgress.flags=current.flags&StaticMask;workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Clone the dependencies object. This is mutated during the render phase, so\n// it cannot be shared with the current fiber.\nvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};// These will be overridden during the parent's reconciliation\nworkInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;{workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}{workInProgress._debugNeedsRemount=current._debugNeedsRemount;switch(workInProgress.tag){case IndeterminateComponent:case FunctionComponent:case SimpleMemoComponent:workInProgress.type=resolveFunctionForHotReloading(current.type);break;case ClassComponent:workInProgress.type=resolveClassForHotReloading(current.type);break;case ForwardRef:workInProgress.type=resolveForwardRefForHotReloading(current.type);break;}}return workInProgress;}// Used to reuse a Fiber for a second pass.\nfunction resetWorkInProgress(workInProgress,renderLanes){// This resets the Fiber to what createFiber or createWorkInProgress would\n// have set the values to before during the first pass. Ideally this wouldn't\n// be necessary but unfortunately many code paths reads from the workInProgress\n// when they should be reading from current and writing to workInProgress.\n// We assume pendingProps, index, key, ref, return are still untouched to\n// avoid doing another reconciliation.\n// Reset the effect flags but keep any Placement tags, since that's something\n// that child fiber is setting, not the reconciliation.\nworkInProgress.flags&=StaticMask|Placement;// The effects are no longer valid.\nvar current=workInProgress.alternate;if(current===null){// Reset to createFiber's initial values.\nworkInProgress.childLanes=NoLanes;workInProgress.lanes=renderLanes;workInProgress.child=null;workInProgress.subtreeFlags=NoFlags;workInProgress.memoizedProps=null;workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.dependencies=null;workInProgress.stateNode=null;{// Note: We don't reset the actualTime counts. It's useful to accumulate\n// actual time across multiple render passes.\nworkInProgress.selfBaseDuration=0;workInProgress.treeBaseDuration=0;}}else{// Reset to the cloned values that createWorkInProgress would've.\nworkInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Needed because Blocks store data on type.\nworkInProgress.type=current.type;// Clone the dependencies object. This is mutated during the render phase, so\n// it cannot be shared with the current fiber.\nvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};{// Note: We don't reset the actualTime counts. It's useful to accumulate\n// actual time across multiple render passes.\nworkInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}}return workInProgress;}function createHostRootFiber(tag,isStrictMode,concurrentUpdatesByDefaultOverride){var mode;if(tag===ConcurrentRoot){mode=ConcurrentMode;if(isStrictMode===true){mode|=StrictLegacyMode;{mode|=StrictEffectsMode;}}}else{mode=NoMode;}if(isDevToolsPresent){// Always collect profile timings when DevTools are present.\n// This enables DevTools to start capturing timing at any point\n// Without some nodes in the tree having empty base times.\nmode|=ProfileMode;}return createFiber(HostRoot,null,null,mode);}function createFiberFromTypeAndProps(type,// React$ElementType\nkey,pendingProps,owner,mode,lanes){var fiberTag=IndeterminateComponent;// The resolved type is set if we know what the final type will be. I.e. it's not lazy.\nvar resolvedType=type;if(typeof type==='function'){if(shouldConstruct$1(type)){fiberTag=ClassComponent;{resolvedType=resolveClassForHotReloading(resolvedType);}}else{{resolvedType=resolveFunctionForHotReloading(resolvedType);}}}else if(typeof type==='string'){fiberTag=HostComponent;}else{getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,lanes,key);case REACT_STRICT_MODE_TYPE:fiberTag=Mode;mode|=StrictLegacyMode;if((mode&ConcurrentMode)!==NoMode){// Strict effects should never run on legacy roots\nmode|=StrictEffectsMode;}break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,lanes,key);case REACT_SUSPENSE_TYPE:return createFiberFromSuspense(pendingProps,mode,lanes,key);case REACT_SUSPENSE_LIST_TYPE:return createFiberFromSuspenseList(pendingProps,mode,lanes,key);case REACT_OFFSCREEN_TYPE:return createFiberFromOffscreen(pendingProps,mode,lanes,key);case REACT_LEGACY_HIDDEN_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_SCOPE_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_CACHE_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_TRACING_MARKER_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_DEBUG_TRACING_MODE_TYPE:// eslint-disable-next-line no-fallthrough\ndefault:{if(typeof type==='object'&&type!==null){switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:// This is a consumer\nfiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef;{resolvedType=resolveForwardRefForHotReloading(resolvedType);}break getTag;case REACT_MEMO_TYPE:fiberTag=MemoComponent;break getTag;case REACT_LAZY_TYPE:fiberTag=LazyComponent;resolvedType=null;break getTag;}}var info='';{if(type===undefined||typeof type==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+\"it's defined in, or you might have mixed up default and \"+'named imports.';}var ownerName=owner?getComponentNameFromFiber(owner):null;if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}}throw new Error('Element type is invalid: expected a string (for built-in '+'components) or a class/function (for composite components) '+(\"but got: \"+(type==null?type:typeof type)+\".\"+info));}}}var fiber=createFiber(fiberTag,pendingProps,key,mode);fiber.elementType=type;fiber.type=resolvedType;fiber.lanes=lanes;{fiber._debugOwner=owner;}return fiber;}function createFiberFromElement(element,mode,lanes){var owner=null;{owner=element._owner;}var type=element.type;var key=element.key;var pendingProps=element.props;var fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes);{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}return fiber;}function createFiberFromFragment(elements,mode,lanes,key){var fiber=createFiber(Fragment,elements,key,mode);fiber.lanes=lanes;return fiber;}function createFiberFromProfiler(pendingProps,mode,lanes,key){{if(typeof pendingProps.id!=='string'){error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.',typeof pendingProps.id);}}var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);fiber.elementType=REACT_PROFILER_TYPE;fiber.lanes=lanes;{fiber.stateNode={effectDuration:0,passiveEffectDuration:0};}return fiber;}function createFiberFromSuspense(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromSuspenseList(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseListComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_LIST_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromOffscreen(pendingProps,mode,lanes,key){var fiber=createFiber(OffscreenComponent,pendingProps,key,mode);fiber.elementType=REACT_OFFSCREEN_TYPE;fiber.lanes=lanes;var primaryChildInstance={isHidden:false};fiber.stateNode=primaryChildInstance;return fiber;}function createFiberFromText(content,mode,lanes){var fiber=createFiber(HostText,content,null,mode);fiber.lanes=lanes;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoMode);fiber.elementType='DELETED';return fiber;}function createFiberFromDehydratedFragment(dehydratedNode){var fiber=createFiber(DehydratedFragment,null,null,NoMode);fiber.stateNode=dehydratedNode;return fiber;}function createFiberFromPortal(portal,mode,lanes){var pendingProps=portal.children!==null?portal.children:[];var fiber=createFiber(HostPortal,pendingProps,portal.key,mode);fiber.lanes=lanes;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates\nimplementation:portal.implementation};return fiber;}// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target,source){if(target===null){// This Fiber's initial properties will always be overwritten.\n// We only use a Fiber to ensure the same hidden class so DEV isn't slow.\ntarget=createFiber(IndeterminateComponent,null,null,NoMode);}// This is intentionally written as a list of all properties.\n// We tried to use Object.assign() instead but this is called in\n// the hottest path, and Object.assign() was too slow:\n// https://github.com/facebook/react/issues/12502\n// This code is DEV-only so size is not a concern.\ntarget.tag=source.tag;target.key=source.key;target.elementType=source.elementType;target.type=source.type;target.stateNode=source.stateNode;target.return=source.return;target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.dependencies=source.dependencies;target.mode=source.mode;target.flags=source.flags;target.subtreeFlags=source.subtreeFlags;target.deletions=source.deletions;target.lanes=source.lanes;target.childLanes=source.childLanes;target.alternate=source.alternate;{target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseDuration=source.selfBaseDuration;target.treeBaseDuration=source.treeBaseDuration;}target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugNeedsRemount=source._debugNeedsRemount;target._debugHookTypes=source._debugHookTypes;return target;}function FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError){this.tag=tag;this.containerInfo=containerInfo;this.pendingChildren=null;this.current=null;this.pingCache=null;this.finishedWork=null;this.timeoutHandle=noTimeout;this.context=null;this.pendingContext=null;this.callbackNode=null;this.callbackPriority=NoLane;this.eventTimes=createLaneMap(NoLanes);this.expirationTimes=createLaneMap(NoTimestamp);this.pendingLanes=NoLanes;this.suspendedLanes=NoLanes;this.pingedLanes=NoLanes;this.expiredLanes=NoLanes;this.mutableReadLanes=NoLanes;this.finishedLanes=NoLanes;this.entangledLanes=NoLanes;this.entanglements=createLaneMap(NoLanes);this.identifierPrefix=identifierPrefix;this.onRecoverableError=onRecoverableError;{this.mutableSourceEagerHydrationData=null;}{this.effectDuration=0;this.passiveEffectDuration=0;}{this.memoizedUpdaters=new Set();var pendingUpdatersLaneMap=this.pendingUpdatersLaneMap=[];for(var _i=0;_i<TotalLanes;_i++){pendingUpdatersLaneMap.push(new Set());}}{switch(tag){case ConcurrentRoot:this._debugRootType=hydrate?'hydrateRoot()':'createRoot()';break;case LegacyRoot:this._debugRootType=hydrate?'hydrate()':'render()';break;}}}function createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,// TODO: We have several of these arguments that are conceptually part of the\n// host config, but because they are passed in at runtime, we have to thread\n// them through the root constructor. Perhaps we should put them all into a\n// single type, like a DynamicHostConfig that is defined by the renderer.\nidentifierPrefix,onRecoverableError,transitionCallbacks){var root=new FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError);// stateNode is any.\nvar uninitializedFiber=createHostRootFiber(tag,isStrictMode);root.current=uninitializedFiber;uninitializedFiber.stateNode=root;{var _initialState={element:initialChildren,isDehydrated:hydrate,cache:null,// not enabled yet\ntransitions:null,pendingSuspenseBoundaries:null};uninitializedFiber.memoizedState=_initialState;}initializeUpdateQueue(uninitializedFiber);return root;}var ReactVersion='18.3.1';function createPortal(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.\nimplementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;{checkKeyStringCoercion(key);}return{// This tag allow us to uniquely identify this as a React Portal\n$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}var didWarnAboutNestedUpdates;var didWarnAboutFindNodeInStrictMode;{didWarnAboutNestedUpdates=false;didWarnAboutFindNodeInStrictMode={};}function getContextForSubtree(parentComponent){if(!parentComponent){return emptyContextObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component)){return processChildContext(fiber,Component,parentContext);}}return parentContext;}function findHostInstanceWithWarning(component,methodName){{var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){throw new Error('Unable to find node on an unmounted component.');}else{var keys=Object.keys(component).join(',');throw new Error(\"Argument appears to not be a ReactComponent. Keys: \"+keys);}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}if(hostFiber.mode&StrictLegacyMode){var componentName=getComponentNameFromFiber(fiber)||'Component';if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=true;var previousFiber=current;try{setCurrentFiber(hostFiber);if(fiber.mode&StrictLegacyMode){error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which is inside StrictMode. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}else{error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which renders StrictMode children. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}}finally{// Ideally this should reset to previous but this shouldn't be called in\n// render and there's another warning for that anyway.\nif(previousFiber){setCurrentFiber(previousFiber);}else{resetCurrentFiber();}}}}return hostFiber.stateNode;}}function createContainer(containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=false;var initialChildren=null;return createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);}function createHydrationContainer(initialChildren,// TODO: Remove `callback` when we delete legacy mode.\ncallback,containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=true;var root=createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);// TODO: Move this to FiberRoot constructor\nroot.context=getContextForSubtree(null);// Schedule the initial render. In a hydration root, this is different from\n// a regular update because the initial render must match was was rendered\n// on the server.\n// NOTE: This update intentionally doesn't have a payload. We're only using\n// the update to schedule work on the root fiber (and, for legacy roots, to\n// enqueue the callback if one is provided).\nvar current=root.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current);var update=createUpdate(eventTime,lane);update.callback=callback!==undefined&&callback!==null?callback:null;enqueueUpdate(current,update,lane);scheduleInitialHydrationOnRoot(root,lane,eventTime);return root;}function updateContainer(element,container,parentComponent,callback){{onScheduleRoot(container,element);}var current$1=container.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current$1);{markRenderScheduled(lane);}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}{if(isRendering&&current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;error('Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\\n\\n'+'Check the render method of %s.',getComponentNameFromFiber(current)||'Unknown');}}var update=createUpdate(eventTime,lane);// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:element};callback=callback===undefined?null:callback;if(callback!==null){{if(typeof callback!=='function'){error('render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}}update.callback=callback;}var root=enqueueUpdate(current$1,update,lane);if(root!==null){scheduleUpdateOnFiber(root,current$1,lane,eventTime);entangleTransitions(root,current$1,lane);}return lane;}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}}function attemptSynchronousHydration$1(fiber){switch(fiber.tag){case HostRoot:{var root=fiber.stateNode;if(isRootDehydrated(root)){// Flush the first scheduled \"update\".\nvar lanes=getHighestPriorityPendingLanes(root);flushRoot(root,lanes);}break;}case SuspenseComponent:{flushSync(function(){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,SyncLane,eventTime);}});// If we're still blocked after this, we need to increase\n// the priority of any promises resolving within this\n// boundary so that they next attempt also has higher pri.\nvar retryLane=SyncLane;markRetryLaneIfNotHydrated(fiber,retryLane);break;}}}function markRetryLaneImpl(fiber,retryLane){var suspenseState=fiber.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){suspenseState.retryLane=higherPriorityLane(suspenseState.retryLane,retryLane);}}// Increases the priority of thenables when they resolve within this boundary.\nfunction markRetryLaneIfNotHydrated(fiber,retryLane){markRetryLaneImpl(fiber,retryLane);var alternate=fiber.alternate;if(alternate){markRetryLaneImpl(alternate,retryLane);}}function attemptContinuousHydration$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n// their priority and they should not suspend on I/O,\n// since you have to wrap anything that might suspend in\n// Suspense.\nreturn;}var lane=SelectiveHydrationLane;var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function attemptHydrationAtCurrentPriority$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n// their priority other than synchronously flush it.\nreturn;}var lane=requestUpdateLane(fiber);var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}var shouldErrorImpl=function(fiber){return null;};function shouldError(fiber){return shouldErrorImpl(fiber);}var shouldSuspendImpl=function(fiber){return false;};function shouldSuspend(fiber){return shouldSuspendImpl(fiber);}var overrideHookState=null;var overrideHookStateDeletePath=null;var overrideHookStateRenamePath=null;var overrideProps=null;var overridePropsDeletePath=null;var overridePropsRenamePath=null;var scheduleUpdate=null;var setErrorHandler=null;var setSuspenseHandler=null;{var copyWithDeleteImpl=function(obj,path,index){var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===path.length){if(isArray(updated)){updated.splice(key,1);}else{delete updated[key];}return updated;}// $FlowFixMe number or string is fine here\nupdated[key]=copyWithDeleteImpl(obj[key],path,index+1);return updated;};var copyWithDelete=function(obj,path){return copyWithDeleteImpl(obj,path,0);};var copyWithRenameImpl=function(obj,oldPath,newPath,index){var oldKey=oldPath[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===oldPath.length){var newKey=newPath[index];// $FlowFixMe number or string is fine here\nupdated[newKey]=updated[oldKey];if(isArray(updated)){updated.splice(oldKey,1);}else{delete updated[oldKey];}}else{// $FlowFixMe number or string is fine here\nupdated[oldKey]=copyWithRenameImpl(// $FlowFixMe number or string is fine here\nobj[oldKey],oldPath,newPath,index+1);}return updated;};var copyWithRename=function(obj,oldPath,newPath){if(oldPath.length!==newPath.length){warn('copyWithRename() expects paths of the same length');return;}else{for(var i=0;i<newPath.length-1;i++){if(oldPath[i]!==newPath[i]){warn('copyWithRename() expects paths to be the same except for the deepest key');return;}}}return copyWithRenameImpl(obj,oldPath,newPath,0);};var copyWithSetImpl=function(obj,path,index,value){if(index>=path.length){return value;}var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);// $FlowFixMe number or string is fine here\nupdated[key]=copyWithSetImpl(obj[key],path,index+1,value);return updated;};var copyWithSet=function(obj,path,value){return copyWithSetImpl(obj,path,0,value);};var findHook=function(fiber,id){// For now, the \"id\" of stateful hooks is just the stateful hook index.\n// This may change in the future with e.g. nested hooks.\nvar currentHook=fiber.memoizedState;while(currentHook!==null&&id>0){currentHook=currentHook.next;id--;}return currentHook;};// Support DevTools editable values for useState and useReducer.\noverrideHookState=function(fiber,id,path,value){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithSet(hook.memoizedState,path,value);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateDeletePath=function(fiber,id,path){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithDelete(hook.memoizedState,path);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateRenamePath=function(fiber,id,oldPath,newPath){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithRename(hook.memoizedState,oldPath,newPath);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};// Support DevTools props for function components, forwardRef, memo, host components, etc.\noverrideProps=function(fiber,path,value){fiber.pendingProps=copyWithSet(fiber.memoizedProps,path,value);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsDeletePath=function(fiber,path){fiber.pendingProps=copyWithDelete(fiber.memoizedProps,path);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsRenamePath=function(fiber,oldPath,newPath){fiber.pendingProps=copyWithRename(fiber.memoizedProps,oldPath,newPath);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};scheduleUpdate=function(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};setErrorHandler=function(newShouldErrorImpl){shouldErrorImpl=newShouldErrorImpl;};setSuspenseHandler=function(newShouldSuspendImpl){shouldSuspendImpl=newShouldSuspendImpl;};}function findHostInstanceByFiber(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function emptyFindFiberByHostInstance(instance){return null;}function getCurrentFiberForDevTools(){return current;}function injectIntoDevTools(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;return injectInternals({bundleType:devToolsConfig.bundleType,version:devToolsConfig.version,rendererPackageName:devToolsConfig.rendererPackageName,rendererConfig:devToolsConfig.rendererConfig,overrideHookState:overrideHookState,overrideHookStateDeletePath:overrideHookStateDeletePath,overrideHookStateRenamePath:overrideHookStateRenamePath,overrideProps:overrideProps,overridePropsDeletePath:overridePropsDeletePath,overridePropsRenamePath:overridePropsRenamePath,setErrorHandler:setErrorHandler,setSuspenseHandler:setSuspenseHandler,scheduleUpdate:scheduleUpdate,currentDispatcherRef:ReactCurrentDispatcher,findHostInstanceByFiber:findHostInstanceByFiber,findFiberByHostInstance:findFiberByHostInstance||emptyFindFiberByHostInstance,// React Refresh\nfindHostInstancesForRefresh:findHostInstancesForRefresh,scheduleRefresh:scheduleRefresh,scheduleRoot:scheduleRoot,setRefreshHandler:setRefreshHandler,// Enables DevTools to append owner stacks to error messages in DEV mode.\ngetCurrentFiber:getCurrentFiberForDevTools,// Enables DevTools to detect reconciler version rather than renderer version\n// which may not match for third party renderers.\nreconcilerVersion:ReactVersion});}/* global reportError */var defaultOnRecoverableError=typeof reportError==='function'?// In modern browsers, reportError will dispatch an error event,\n// emulating an uncaught JavaScript error.\nreportError:function(error){// In older browsers and test environments, fallback to console.error.\n// eslint-disable-next-line react-internal/no-production-logging\nconsole['error'](error);};function ReactDOMRoot(internalRoot){this._internalRoot=internalRoot;}ReactDOMHydrationRoot.prototype.render=ReactDOMRoot.prototype.render=function(children){var root=this._internalRoot;if(root===null){throw new Error('Cannot update an unmounted root.');}{if(typeof arguments[1]==='function'){error('render(...): does not support the second callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}else if(isValidContainer(arguments[1])){error('You passed a container to the second argument of root.render(...). '+\"You don't need to pass it again since you already passed it to create the root.\");}else if(typeof arguments[1]!=='undefined'){error('You passed a second argument to root.render(...) but it only accepts '+'one argument.');}var container=root.containerInfo;if(container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(root.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of the '+'root container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+\"root.unmount() to empty a root's container.\");}}}}updateContainer(children,root,null,null);};ReactDOMHydrationRoot.prototype.unmount=ReactDOMRoot.prototype.unmount=function(){{if(typeof arguments[0]==='function'){error('unmount(...): does not support a callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}}var root=this._internalRoot;if(root!==null){this._internalRoot=null;var container=root.containerInfo;{if(isAlreadyRendering()){error('Attempted to synchronously unmount a root while React was already '+'rendering. React cannot finish unmounting the root until the '+'current render has completed, which may lead to a race condition.');}}flushSync(function(){updateContainer(null,root,null,null);});unmarkContainerAsRoot(container);}};function createRoot(container,options){if(!isValidContainer(container)){throw new Error('createRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;var transitionCallbacks=null;if(options!==null&&options!==undefined){{if(options.hydrate){warn('hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.');}else{if(typeof options==='object'&&options!==null&&options.$$typeof===REACT_ELEMENT_TYPE){error('You passed a JSX element to createRoot. You probably meant to '+'call root.render instead. '+'Example usage:\\n\\n'+'  let root = createRoot(domContainer);\\n'+'  root.render(<App />);');}}}if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}if(options.transitionCallbacks!==undefined){transitionCallbacks=options.transitionCallbacks;}}var root=createContainer(container,ConcurrentRoot,null,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);return new ReactDOMRoot(root);}function ReactDOMHydrationRoot(internalRoot){this._internalRoot=internalRoot;}function scheduleHydration(target){if(target){queueExplicitHydrationTarget(target);}}ReactDOMHydrationRoot.prototype.unstable_scheduleHydration=scheduleHydration;function hydrateRoot(container,initialChildren,options){if(!isValidContainer(container)){throw new Error('hydrateRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);{if(initialChildren===undefined){error('Must provide initial children as second argument to hydrateRoot. '+'Example usage: hydrateRoot(domContainer, <App />)');}}// For now we reuse the whole bag of options since they contain\n// the hydration callbacks.\nvar hydrationCallbacks=options!=null?options:null;// TODO: Delete this option\nvar mutableSources=options!=null&&options.hydratedSources||null;var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;if(options!==null&&options!==undefined){if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}}var root=createHydrationContainer(initialChildren,null,container,ConcurrentRoot,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);// This can't be a comment node since hydration doesn't work on comment nodes anyway.\nlistenToAllSupportedEvents(container);if(mutableSources){for(var i=0;i<mutableSources.length;i++){var mutableSource=mutableSources[i];registerMutableSourceForHydration(root,mutableSource);}}return new ReactDOMHydrationRoot(root);}function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||!disableCommentsAsDOMContainers));}// TODO: Remove this function which also includes comment nodes.\n// We only use it in places that are currently more relaxed.\nfunction isValidContainerLegacy(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function warnIfReactDOMContainerInDEV(container){{if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('createRoot(): Creating roots directly with document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try using a container element created '+'for your app.');}if(isContainerMarkedAsRoot(container)){if(container._reactRootContainer){error('You are calling ReactDOMClient.createRoot() on a container that was previously '+'passed to ReactDOM.render(). This is not supported.');}else{error('You are calling ReactDOMClient.createRoot() on a container that '+'has already been passed to createRoot() before. Instead, call '+'root.render() on the existing root instead if you want to update it.');}}}}var ReactCurrentOwner$3=ReactSharedInternals.ReactCurrentOwner;var topLevelUpdateWarnings;{topLevelUpdateWarnings=function(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode(rootEl));if(hasNonRootReactChild&&!isRootRenderedBySomeReact){error('render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');}if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}};}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function noopOnRecoverableError(){// This isn't reachable because onRecoverableError isn't called in the\n// legacy API.\n}function legacyCreateRootFromDOMContainer(container,initialChildren,parentComponent,callback,isHydrationContainer){if(isHydrationContainer){if(typeof callback==='function'){var originalCallback=callback;callback=function(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}var root=createHydrationContainer(initialChildren,callback,container,LegacyRoot,null,// hydrationCallbacks\nfalse,// isStrictMode\nfalse,// concurrentUpdatesByDefaultOverride,\n'',// identifierPrefix\nnoopOnRecoverableError);container._reactRootContainer=root;markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);flushSync();return root;}else{// First clear any existing content.\nvar rootSibling;while(rootSibling=container.lastChild){container.removeChild(rootSibling);}if(typeof callback==='function'){var _originalCallback=callback;callback=function(){var instance=getPublicRootInstance(_root);_originalCallback.call(instance);};}var _root=createContainer(container,LegacyRoot,null,// hydrationCallbacks\nfalse,// isStrictMode\nfalse,// concurrentUpdatesByDefaultOverride,\n'',// identifierPrefix\nnoopOnRecoverableError);container._reactRootContainer=_root;markContainerAsRoot(_root.current,container);var _rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(_rootContainerElement);// Initial mount should not be batched.\nflushSync(function(){updateContainer(initialChildren,_root,parentComponent,callback);});return _root;}}function warnOnInvalidCallback$1(callback,callerName){{if(callback!==null&&typeof callback!=='function'){error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}}}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){{topLevelUpdateWarnings(container);warnOnInvalidCallback$1(callback===undefined?null:callback,'render');}var maybeRoot=container._reactRootContainer;var root;if(!maybeRoot){// Initial mount\nroot=legacyCreateRootFromDOMContainer(container,children,parentComponent,callback,forceHydrate);}else{root=maybeRoot;if(typeof callback==='function'){var originalCallback=callback;callback=function(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}// Update\nupdateContainer(children,root,parentComponent,callback);}return getPublicRootInstance(root);}var didWarnAboutFindDOMNode=false;function findDOMNode(componentOrElement){{if(!didWarnAboutFindDOMNode){didWarnAboutFindDOMNode=true;error('findDOMNode is deprecated and will be removed in the next major '+'release. Instead, add a ref directly to the element you want '+'to reference. Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node');}var owner=ReactCurrentOwner$3.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;if(!warnedAboutRefsInRender){error('%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromType(owner.type)||'A component');}owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}{return findHostInstanceWithWarning(componentOrElement,'findDOMNode');}}function hydrate(element,container,callback){{error('ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.hydrate() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call hydrateRoot(container, element)?');}}// TODO: throw or warn if we couldn't hydrate?\nreturn legacyRenderSubtreeIntoContainer(null,element,container,true,callback);}function render(element,container,callback){{error('ReactDOM.render is no longer supported in React 18. Use createRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.render() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call root.render(element)?');}}return legacyRenderSubtreeIntoContainer(null,element,container,false,callback);}function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){{error('ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported '+'in React 18. Consider using a portal instead. Until you switch to '+\"the createRoot API, your app will behave as if it's running React \"+'17. Learn more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(containerNode)){throw new Error('Target container is not a DOM element.');}if(parentComponent==null||!has(parentComponent)){throw new Error('parentComponent must be a valid React Component');}return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);}var didWarnAboutUnmountComponentAtNode=false;function unmountComponentAtNode(container){{if(!didWarnAboutUnmountComponentAtNode){didWarnAboutUnmountComponentAtNode=true;error('unmountComponentAtNode is deprecated and will be removed in the '+'next major release. Switch to the createRoot API. Learn '+'more: https://reactjs.org/link/switch-to-createroot');}}if(!isValidContainerLegacy(container)){throw new Error('unmountComponentAtNode(...): Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?');}}if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode(rootEl);if(renderedByDifferentReact){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by another copy of React.');}}// Unmount should not be batched.\nflushSync(function(){legacyRenderSubtreeIntoContainer(null,null,container,false,function(){// $FlowFixMe This should probably use `delete container._reactRootContainer`\ncontainer._reactRootContainer=null;unmarkContainerAsRoot(container);});});// If you call unmountComponentAtNode twice in quick succession, you'll\n// get `true` twice. That's probably fine?\nreturn true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode(_rootEl));// Check if the container itself is a React root node.\nvar isContainerReactRoot=container.nodeType===ELEMENT_NODE&&isValidContainerLegacy(container.parentNode)&&!!container.parentNode._reactRootContainer;if(hasNonRootReactChild){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}}return false;}}setAttemptSynchronousHydration(attemptSynchronousHydration$1);setAttemptContinuousHydration(attemptContinuousHydration$1);setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);setGetCurrentUpdatePriority(getCurrentUpdatePriority);setAttemptHydrationAtPriority(runWithPriority);{if(typeof Map!=='function'||// $FlowIssue Flow incorrectly thinks Map has no prototype\nMap.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||// $FlowIssue Flow incorrectly thinks Set has no prototype\nSet.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){error('React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. https://reactjs.org/link/react-polyfills');}}setRestoreImplementation(restoreControlledState$3);setBatchingImplementation(batchedUpdates$1,discreteUpdates,flushSync);function createPortal$1(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(!isValidContainer(container)){throw new Error('Target container is not a DOM element.');}// TODO: pass ReactDOM portal implementation as third argument\n// $FlowFixMe The Flow type is opaque but there's no way to actually create it.\nreturn createPortal(children,container,null,key);}function renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){return unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback);}var Internals={usingClientEntryPoint:false,// Keep in sync with ReactTestUtils.js.\n// This is an array for better minification.\nEvents:[getInstanceFromNode,getNodeFromInstance,getFiberCurrentPropsFromNode,enqueueStateRestore,restoreStateIfNeeded,batchedUpdates$1]};function createRoot$1(container,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing createRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return createRoot(container,options);}function hydrateRoot$1(container,initialChildren,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing hydrateRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return hydrateRoot(container,initialChildren,options);}// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-redeclare\nfunction flushSync$1(fn){{if(isAlreadyRendering()){error('flushSync was called from inside a lifecycle method. React cannot '+'flush when React is already rendering. Consider moving this call to '+'a scheduler task or micro task.');}}return flushSync(fn);}var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.\nif(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.\nif(/^(https?|file):$/.test(protocol)){// eslint-disable-next-line react-internal/no-production-logging\nconsole.info('%cDownload the React DevTools '+'for a better development experience: '+'https://reactjs.org/link/react-devtools'+(protocol==='file:'?'\\nYou might need to use a local HTTP server (instead of file://): '+'https://reactjs.org/link/react-devtools-faq':''),'font-weight:bold');}}}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Internals;exports.createPortal=createPortal$1;exports.createRoot=createRoot$1;exports.findDOMNode=findDOMNode;exports.flushSync=flushSync$1;exports.hydrate=hydrate;exports.hydrateRoot=hydrateRoot$1;exports.render=render;exports.unmountComponentAtNode=unmountComponentAtNode;exports.unstable_batchedUpdates=batchedUpdates$1;exports.unstable_renderSubtreeIntoContainer=renderSubtreeIntoContainer;exports.version=ReactVersion;/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());}})();}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQWdCLEdBQUcsSUFBbUMsRUFBRSxZQUFZLGFBQWEsbUxBQW1MLHlFQUF5RSxVQUFVLG1CQUFPLENBQUMsNENBQU8sRUFBRSxjQUFjLG1CQUFPLENBQUMsb0RBQVcsRUFBRSxrRkFBa0YsMEJBQTBCLGlEQUFpRCxxQ0FBcUM7QUFDN2tCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQixxRUFBcUUsVUFBVSxRQUFRLDhCQUE4QixvQ0FBb0Msd0JBQXdCLHFCQUFxQix5RUFBeUUsWUFBWSxTQUFTLGdDQUFnQyxxQ0FBcUMseUNBQXlDO0FBQzliO0FBQ0EsQ0FBQyx1RUFBdUUsb0RBQW9ELGVBQWUsYUFBYSwyQkFBMkI7QUFDbkwsMkNBQTJDLHFCQUFxQixFQUFFO0FBQ2xFLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsdUVBQXVFLHdCQUF3QixxQkFBcUIsNkJBQTZCO0FBQ2pKLGVBQWU7QUFDZixpQkFBaUI7QUFDakIsb0JBQW9CLGVBQWUsZUFBZSxXQUFXLHNCQUFzQix1QkFBdUIsa0JBQWtCLGdCQUFnQix5QkFBeUIscUJBQXFCLDJCQUEyQixxQkFBcUIsZ0NBQWdDLDBCQUEwQiw2QkFBNkIsc0JBQXNCLDBCQUEwQiw2QkFBNkIsc0JBQXNCLDhCQUE4QjtBQUNsYyxrREFBa0Q7QUFDbEQ7QUFDQSw4QkFBOEI7QUFDOUIsdUNBQXVDO0FBQ3ZDLDZCQUE2QjtBQUM3QiwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyw2QkFBNkI7QUFDN0IsbUNBQW1DO0FBQ25D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RkFBZ0YsOEZBQThGLDJSQUEyUiwyQ0FBMkMsMkRBQTJELGlEQUFpRCxvRUFBb0UsK0ZBQStGLDZDQUE2Qyw0Q0FBNEMsd0NBQXdDLHdDQUF3Qyw2TEFBNkwsdUNBQXVDLHlGQUF5RiwrRkFBK0YsaUJBQWlCLHNNQUFzTSxtQ0FBbUMscURBQXFELGtFQUFrRSw2QkFBNkIscUhBQXFIO0FBQ3JrRixxQkFBcUIsc0VBQXNFO0FBQzNGLG1DQUFtQyxrQ0FBa0MsR0FBRyxFQUFFO0FBQzFFO0FBQ0EsYUFBYSxNQUFNLHNEQUFzRCxtRUFBbUU7QUFDNUkscUpBQXFKLHlCQUF5Qiw0VkFBNFYsZUFBZSw4REFBOEQsNERBQTRELDBFQUEwRSxzREFBc0QsZ0RBQWdEO0FBQ24wQjtBQUNBLHlHQUF5RywwSkFBMEosbURBQW1ELHNFQUFzRSw0Q0FBNEMsdUVBQXVFLGlDQUFpQywyREFBMkQ7QUFDM2tCO0FBQ0Esa0RBQWtELG9GQUFvRiw0RkFBNEYsZUFBZTtBQUNqUDtBQUNBLHlJQUF5SSwwQ0FBMEMsNkNBQTZDLDBJQUEwSSxzQ0FBc0MsMkRBQTJELDZDQUE2QywySUFBMkksdURBQXVEO0FBQzFyQjtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5Qix1TEFBdUwsc0JBQXNCLHNDQUFzQyxxSEFBcUgsR0FBRyx3REFBd0Q7QUFDdGQsa0lBQWtJLHNDQUFzQztBQUN4SyxzQ0FBc0M7QUFDdEMsbVNBQW1TLDBEQUEwRCxXQUFXLG9CQUFvQixnQkFBZ0Isa0JBQWtCLGNBQWMsbUJBQW1CLGFBQWEsaUJBQWlCLGFBQWEsZUFBZSxTQUFTLG1CQUFtQixlQUFlLGNBQWMsUUFBUSw4QkFBOEIsd0JBQXdCLCtCQUErQixrQkFBa0IsMkNBQTJDLDRCQUE0QixlQUFlLGNBQWMsa0xBQWtMLHlFQUF5RSIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcz9hODk1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWRvbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovJ3VzZSBzdHJpY3QnO2lmKHByb2Nlc3MuZW52Lk5PREVfRU5WIT09XCJwcm9kdWN0aW9uXCIpeyhmdW5jdGlvbigpeyd1c2Ugc3RyaWN0JzsvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovaWYodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyE9PSd1bmRlZmluZWQnJiZ0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydD09PSdmdW5jdGlvbicpe19fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO312YXIgUmVhY3Q9cmVxdWlyZSgncmVhY3QnKTt2YXIgU2NoZWR1bGVyPXJlcXVpcmUoJ3NjaGVkdWxlcicpO3ZhciBSZWFjdFNoYXJlZEludGVybmFscz1SZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDt2YXIgc3VwcHJlc3NXYXJuaW5nPWZhbHNlO2Z1bmN0aW9uIHNldFN1cHByZXNzV2FybmluZyhuZXdTdXBwcmVzc1dhcm5pbmcpe3tzdXBwcmVzc1dhcm5pbmc9bmV3U3VwcHJlc3NXYXJuaW5nO319Ly8gSW4gREVWLCBjYWxscyB0byBjb25zb2xlLndhcm4gYW5kIGNvbnNvbGUuZXJyb3IgZ2V0IHJlcGxhY2VkXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCl7e2lmKCFzdXBwcmVzc1dhcm5pbmcpe2Zvcih2YXIgX2xlbj1hcmd1bWVudHMubGVuZ3RoLGFyZ3M9bmV3IEFycmF5KF9sZW4+MT9fbGVuLTE6MCksX2tleT0xO19rZXk8X2xlbjtfa2V5Kyspe2FyZ3NbX2tleS0xXT1hcmd1bWVudHNbX2tleV07fXByaW50V2FybmluZygnd2FybicsZm9ybWF0LGFyZ3MpO319fWZ1bmN0aW9uIGVycm9yKGZvcm1hdCl7e2lmKCFzdXBwcmVzc1dhcm5pbmcpe2Zvcih2YXIgX2xlbjI9YXJndW1lbnRzLmxlbmd0aCxhcmdzPW5ldyBBcnJheShfbGVuMj4xP19sZW4yLTE6MCksX2tleTI9MTtfa2V5MjxfbGVuMjtfa2V5MisrKXthcmdzW19rZXkyLTFdPWFyZ3VtZW50c1tfa2V5Ml07fXByaW50V2FybmluZygnZXJyb3InLGZvcm1hdCxhcmdzKTt9fX1mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsZm9ybWF0LGFyZ3Mpey8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG57dmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWU9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTt2YXIgc3RhY2s9UmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7aWYoc3RhY2shPT0nJyl7Zm9ybWF0Kz0nJXMnO2FyZ3M9YXJncy5jb25jYXQoW3N0YWNrXSk7fS8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxudmFyIGFyZ3NXaXRoRm9ybWF0PWFyZ3MubWFwKGZ1bmN0aW9uKGl0ZW0pe3JldHVybiBTdHJpbmcoaXRlbSk7fSk7Ly8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcbmFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcrZm9ybWF0KTsvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sY29uc29sZSxhcmdzV2l0aEZvcm1hdCk7fX12YXIgRnVuY3Rpb25Db21wb25lbnQ9MDt2YXIgQ2xhc3NDb21wb25lbnQ9MTt2YXIgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudD0yOy8vIEJlZm9yZSB3ZSBrbm93IHdoZXRoZXIgaXQgaXMgZnVuY3Rpb24gb3IgY2xhc3NcbnZhciBIb3N0Um9vdD0zOy8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxudmFyIEhvc3RQb3J0YWw9NDsvLyBBIHN1YnRyZWUuIENvdWxkIGJlIGFuIGVudHJ5IHBvaW50IHRvIGEgZGlmZmVyZW50IHJlbmRlcmVyLlxudmFyIEhvc3RDb21wb25lbnQ9NTt2YXIgSG9zdFRleHQ9Njt2YXIgRnJhZ21lbnQ9Nzt2YXIgTW9kZT04O3ZhciBDb250ZXh0Q29uc3VtZXI9OTt2YXIgQ29udGV4dFByb3ZpZGVyPTEwO3ZhciBGb3J3YXJkUmVmPTExO3ZhciBQcm9maWxlcj0xMjt2YXIgU3VzcGVuc2VDb21wb25lbnQ9MTM7dmFyIE1lbW9Db21wb25lbnQ9MTQ7dmFyIFNpbXBsZU1lbW9Db21wb25lbnQ9MTU7dmFyIExhenlDb21wb25lbnQ9MTY7dmFyIEluY29tcGxldGVDbGFzc0NvbXBvbmVudD0xNzt2YXIgRGVoeWRyYXRlZEZyYWdtZW50PTE4O3ZhciBTdXNwZW5zZUxpc3RDb21wb25lbnQ9MTk7dmFyIFNjb3BlQ29tcG9uZW50PTIxO3ZhciBPZmZzY3JlZW5Db21wb25lbnQ9MjI7dmFyIExlZ2FjeUhpZGRlbkNvbXBvbmVudD0yMzt2YXIgQ2FjaGVDb21wb25lbnQ9MjQ7dmFyIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ9MjU7Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBlbmFibGVDbGllbnRSZW5kZXJGYWxsYmFja09uVGV4dE1pc21hdGNoPXRydWU7Ly8gVE9ETzogTmVlZCB0byByZXZpZXcgdGhpcyBjb2RlIG9uZSBtb3JlIHRpbWUgYmVmb3JlIGxhbmRpbmdcbi8vIHRoZSByZWFjdC1yZWNvbmNpbGVyIHBhY2thZ2UuXG52YXIgZW5hYmxlTmV3UmVjb25jaWxlcj1mYWxzZTsvLyBTdXBwb3J0IGxlZ2FjeSBQcmltZXIgc3VwcG9ydCBvbiBpbnRlcm5hbCBGQiB3d3dcbnZhciBlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uPWZhbHNlOy8vIEZCLW9ubHkgdXNhZ2UuIFRoZSBuZXcgQVBJIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzLlxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbj1mYWxzZTsvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbnZhciBlbmFibGVTdXNwZW5zZUF2b2lkVGhpc0ZhbGxiYWNrPWZhbHNlOy8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaXp6XG4vLyBSZWFjdCBET00gQ2hvcHBpbmcgQmxvY2tcbi8vXG4vLyBTaW1pbGFyIHRvIG1haW4gQ2hvcHBpbmcgQmxvY2sgYnV0IG9ubHkgZmxhZ3MgcmVsYXRlZCB0byBSZWFjdCBET00uIFRoZXNlIGFyZVxuLy8gZ3JvdXBlZCBiZWNhdXNlIHdlIHdpbGwgbGlrZWx5IGJhdGNoIGFsbCBvZiB0aGVtIGludG8gYSBzaW5nbGUgbWFqb3IgcmVsZWFzZS5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEaXNhYmxlIHN1cHBvcnQgZm9yIGNvbW1lbnQgbm9kZXMgYXMgUmVhY3QgRE9NIGNvbnRhaW5lcnMuIEFscmVhZHkgZGlzYWJsZWRcbi8vIGluIG9wZW4gc291cmNlLCBidXQgd3d3IGNvZGViYXNlIHN0aWxsIHJlbGllcyBvbiBpdC4gTmVlZCB0byByZW1vdmUuXG52YXIgZGlzYWJsZUNvbW1lbnRzQXNET01Db250YWluZXJzPXRydWU7Ly8gRGlzYWJsZSBqYXZhc2NyaXB0OiBVUkwgc3RyaW5ncyBpbiBocmVmIGZvciBYU1MgcHJvdGVjdGlvbi5cbi8vIGFuZCBjbGllbnQgcmVuZGVyaW5nLCBtb3N0bHkgdG8gYWxsb3cgSlNYIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGN1c3RvbVxuLy8gZWxlbWVudCdzIG9iamVjdCBwcm9wZXJ0aWVzIGluc3RlYWQgb2Ygb25seSBIVE1MIGF0dHJpYnV0ZXMuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExMzQ3XG52YXIgZW5hYmxlQ3VzdG9tRWxlbWVudFByb3BlcnR5U3VwcG9ydD1mYWxzZTsvLyBEaXNhYmxlcyBjaGlsZHJlbiBmb3IgPHRleHRhcmVhPiBlbGVtZW50c1xudmFyIHdhcm5BYm91dFN0cmluZ1JlZnM9dHJ1ZTsvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVidWdnaW5nIGFuZCBEZXZUb29sc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEFkZHMgdXNlciB0aW1pbmcgbWFya3MgZm9yIGUuZy4gc3RhdGUgdXBkYXRlcywgc3VzcGVuc2UsIGFuZCB3b3JrIGxvb3Agc3R1ZmYsXG4vLyBmb3IgYW4gZXhwZXJpbWVudGFsIHRpbWVsaW5lIHRvb2wuXG52YXIgZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyPXRydWU7Ly8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIHJlbmRlci1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlXG52YXIgZW5hYmxlUHJvZmlsZXJUaW1lcj10cnVlOy8vIFJlY29yZCBkdXJhdGlvbnMgZm9yIGNvbW1pdCBhbmQgcGFzc2l2ZSBlZmZlY3RzIHBoYXNlcy5cbnZhciBlbmFibGVQcm9maWxlckNvbW1pdEhvb2tzPXRydWU7Ly8gUGhhc2UgcGFyYW0gcGFzc2VkIHRvIG9uUmVuZGVyIGNhbGxiYWNrIGRpZmZlcmVudGlhdGVzIGJldHdlZW4gYW4gXCJ1cGRhdGVcIiBhbmQgYSBcImNhc2NhZGluZy11cGRhdGVcIi5cbnZhciBhbGxOYXRpdmVFdmVudHM9bmV3IFNldCgpOy8qKlxuICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIGV2ZW50IG5hbWVcbiAqL3ZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzPXt9Oy8qKlxuICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gKiBvbmx5IGluIHRydWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovdmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM9e307Ly8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIHRydWVcbmZ1bmN0aW9uIHJlZ2lzdGVyVHdvUGhhc2VFdmVudChyZWdpc3RyYXRpb25OYW1lLGRlcGVuZGVuY2llcyl7cmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lLGRlcGVuZGVuY2llcyk7cmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lKydDYXB0dXJlJyxkZXBlbmRlbmNpZXMpO31mdW5jdGlvbiByZWdpc3RlckRpcmVjdEV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsZGVwZW5kZW5jaWVzKXt7aWYocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSl7ZXJyb3IoJ0V2ZW50UmVnaXN0cnk6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lICcrJ3JlZ2lzdHJhdGlvbiBuYW1lLCBgJXNgLicscmVnaXN0cmF0aW9uTmFtZSk7fX1yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdPWRlcGVuZGVuY2llczt7dmFyIGxvd2VyQ2FzZWROYW1lPXJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXT1yZWdpc3RyYXRpb25OYW1lO2lmKHJlZ2lzdHJhdGlvbk5hbWU9PT0nb25Eb3VibGVDbGljaycpe3Bvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljaz1yZWdpc3RyYXRpb25OYW1lO319Zm9yKHZhciBpPTA7aTxkZXBlbmRlbmNpZXMubGVuZ3RoO2krKyl7YWxsTmF0aXZlRXZlbnRzLmFkZChkZXBlbmRlbmNpZXNbaV0pO319dmFyIGNhblVzZURPTT0hISh0eXBlb2Ygd2luZG93IT09J3VuZGVmaW5lZCcmJnR5cGVvZiB3aW5kb3cuZG9jdW1lbnQhPT0ndW5kZWZpbmVkJyYmdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50IT09J3VuZGVmaW5lZCcpO3ZhciBoYXNPd25Qcm9wZXJ0eT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5Oy8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKXt7Ly8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxudmFyIGhhc1RvU3RyaW5nVGFnPXR5cGVvZiBTeW1ib2w9PT0nZnVuY3Rpb24nJiZTeW1ib2wudG9TdHJpbmdUYWc7dmFyIHR5cGU9aGFzVG9TdHJpbmdUYWcmJnZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ118fHZhbHVlLmNvbnN0cnVjdG9yLm5hbWV8fCdPYmplY3QnO3JldHVybiB0eXBlO319Ly8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKXt7dHJ5e3Rlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7cmV0dXJuIGZhbHNlO31jYXRjaChlKXtyZXR1cm4gdHJ1ZTt9fX1mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpey8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbi8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbi8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuLy9cbi8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbi8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4vLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbi8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4vL1xuLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuLy9cbi8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4vLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbi8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbi8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4vLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4vLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4vL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5yZXR1cm4nJyt2YWx1ZTt9ZnVuY3Rpb24gY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSxhdHRyaWJ1dGVOYW1lKXt7aWYod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKXtlcnJvcignVGhlIHByb3ZpZGVkIGAlc2AgYXR0cmlidXRlIGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJysnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLGF0dHJpYnV0ZU5hbWUsdHlwZU5hbWUodmFsdWUpKTtyZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxufX19ZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSl7e2lmKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSl7ZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nKycgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsdHlwZU5hbWUodmFsdWUpKTtyZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxufX19ZnVuY3Rpb24gY2hlY2tQcm9wU3RyaW5nQ29lcmNpb24odmFsdWUscHJvcE5hbWUpe3tpZih3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpe2Vycm9yKCdUaGUgcHJvdmlkZWQgYCVzYCBwcm9wIGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJysnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLHByb3BOYW1lLHR5cGVOYW1lKHZhbHVlKSk7cmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7Ly8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbn19fWZ1bmN0aW9uIGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbih2YWx1ZSxwcm9wTmFtZSl7e2lmKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSl7ZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIENTUyBwcm9wZXJ0eSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicrJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJyxwcm9wTmFtZSx0eXBlTmFtZSh2YWx1ZSkpO3JldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOy8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG59fX1mdW5jdGlvbiBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbih2YWx1ZSl7e2lmKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSl7ZXJyb3IoJ1RoZSBwcm92aWRlZCBIVE1MIG1hcmt1cCB1c2VzIGEgdmFsdWUgb2YgdW5zdXBwb3J0ZWQgdHlwZSAlcy4nKycgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsdHlwZU5hbWUodmFsdWUpKTtyZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxufX19ZnVuY3Rpb24gY2hlY2tGb3JtRmllbGRWYWx1ZVN0cmluZ0NvZXJjaW9uKHZhbHVlKXt7aWYod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKXtlcnJvcignRm9ybSBmaWVsZCB2YWx1ZXMgKHZhbHVlLCBjaGVja2VkLCBkZWZhdWx0VmFsdWUsIG9yIGRlZmF1bHRDaGVja2VkIHByb3BzKScrJyBtdXN0IGJlIHN0cmluZ3MsIG5vdCAlcy4nKycgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsdHlwZU5hbWUodmFsdWUpKTtyZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxufX19Ly8gQSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4vLyBJdCBpcyBoYW5kbGVkIGJ5IFJlYWN0IHNlcGFyYXRlbHkgYW5kIHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG52YXIgUkVTRVJWRUQ9MDsvLyBBIHNpbXBsZSBzdHJpbmcgYXR0cmlidXRlLlxuLy8gQXR0cmlidXRlcyB0aGF0IGFyZW4ndCBpbiB0aGUgZmlsdGVyIGFyZSBwcmVzdW1lZCB0byBoYXZlIHRoaXMgdHlwZS5cbnZhciBTVFJJTkc9MTsvLyBBIHN0cmluZyBhdHRyaWJ1dGUgdGhhdCBhY2NlcHRzIGJvb2xlYW5zIGluIFJlYWN0LiBJbiBIVE1MLCB0aGVzZSBhcmUgY2FsbGVkXG4vLyBcImVudW1lcmF0ZWRcIiBhdHRyaWJ1dGVzIHdpdGggXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIiBhcyBwb3NzaWJsZSB2YWx1ZXMuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcInRydWVcIiBzdHJpbmcuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJmYWxzZVwiIHN0cmluZy5cbnZhciBCT09MRUFOSVNIX1NUUklORz0yOy8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxudmFyIEJPT0xFQU49MzsvLyBBbiBhdHRyaWJ1dGUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cbi8vIEZvciBhbnkgb3RoZXIgdmFsdWUsIHNob3VsZCBiZSBwcmVzZW50IHdpdGggdGhhdCB2YWx1ZS5cbnZhciBPVkVSTE9BREVEX0JPT0xFQU49NDsvLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG52YXIgTlVNRVJJQz01Oy8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cbnZhciBQT1NJVElWRV9OVU1FUklDPTY7LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL3ZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSPVwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiOy8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL3ZhciBBVFRSSUJVVEVfTkFNRV9DSEFSPUFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIrXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO3ZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWD1uZXcgUmVnRXhwKCdeWycrQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUisnXVsnK0FUVFJJQlVURV9OQU1FX0NIQVIrJ10qJCcpO3ZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlPXt9O3ZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGU9e307ZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKXtpZihoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSxhdHRyaWJ1dGVOYW1lKSl7cmV0dXJuIHRydWU7fWlmKGhhc093blByb3BlcnR5LmNhbGwoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSxhdHRyaWJ1dGVOYW1lKSl7cmV0dXJuIGZhbHNlO31pZihWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKXt2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9aWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXT10cnVlO3tlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsYXR0cmlidXRlTmFtZSk7fXJldHVybiBmYWxzZTt9ZnVuY3Rpb24gc2hvdWxkSWdub3JlQXR0cmlidXRlKG5hbWUscHJvcGVydHlJbmZvLGlzQ3VzdG9tQ29tcG9uZW50VGFnKXtpZihwcm9wZXJ0eUluZm8hPT1udWxsKXtyZXR1cm4gcHJvcGVydHlJbmZvLnR5cGU9PT1SRVNFUlZFRDt9aWYoaXNDdXN0b21Db21wb25lbnRUYWcpe3JldHVybiBmYWxzZTt9aWYobmFtZS5sZW5ndGg+MiYmKG5hbWVbMF09PT0nbyd8fG5hbWVbMF09PT0nTycpJiYobmFtZVsxXT09PSduJ3x8bmFtZVsxXT09PSdOJykpe3JldHVybiB0cnVlO31yZXR1cm4gZmFsc2U7fWZ1bmN0aW9uIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsdmFsdWUscHJvcGVydHlJbmZvLGlzQ3VzdG9tQ29tcG9uZW50VGFnKXtpZihwcm9wZXJ0eUluZm8hPT1udWxsJiZwcm9wZXJ0eUluZm8udHlwZT09PVJFU0VSVkVEKXtyZXR1cm4gZmFsc2U7fXN3aXRjaCh0eXBlb2YgdmFsdWUpe2Nhc2UnZnVuY3Rpb24nOi8vICRGbG93SXNzdWUgc3ltYm9sIGlzIHBlcmZlY3RseSB2YWxpZCBoZXJlXG5jYXNlJ3N5bWJvbCc6Ly8gZXNsaW50LWRpc2FibGUtbGluZVxucmV0dXJuIHRydWU7Y2FzZSdib29sZWFuJzp7aWYoaXNDdXN0b21Db21wb25lbnRUYWcpe3JldHVybiBmYWxzZTt9aWYocHJvcGVydHlJbmZvIT09bnVsbCl7cmV0dXJuIXByb3BlcnR5SW5mby5hY2NlcHRzQm9vbGVhbnM7fWVsc2V7dmFyIHByZWZpeD1uYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCw1KTtyZXR1cm4gcHJlZml4IT09J2RhdGEtJyYmcHJlZml4IT09J2FyaWEtJzt9fWRlZmF1bHQ6cmV0dXJuIGZhbHNlO319ZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsdmFsdWUscHJvcGVydHlJbmZvLGlzQ3VzdG9tQ29tcG9uZW50VGFnKXtpZih2YWx1ZT09PW51bGx8fHR5cGVvZiB2YWx1ZT09PSd1bmRlZmluZWQnKXtyZXR1cm4gdHJ1ZTt9aWYoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSx2YWx1ZSxwcm9wZXJ0eUluZm8saXNDdXN0b21Db21wb25lbnRUYWcpKXtyZXR1cm4gdHJ1ZTt9aWYoaXNDdXN0b21Db21wb25lbnRUYWcpe3JldHVybiBmYWxzZTt9aWYocHJvcGVydHlJbmZvIT09bnVsbCl7c3dpdGNoKHByb3BlcnR5SW5mby50eXBlKXtjYXNlIEJPT0xFQU46cmV0dXJuIXZhbHVlO2Nhc2UgT1ZFUkxPQURFRF9CT09MRUFOOnJldHVybiB2YWx1ZT09PWZhbHNlO2Nhc2UgTlVNRVJJQzpyZXR1cm4gaXNOYU4odmFsdWUpO2Nhc2UgUE9TSVRJVkVfTlVNRVJJQzpyZXR1cm4gaXNOYU4odmFsdWUpfHx2YWx1ZTwxO319cmV0dXJuIGZhbHNlO31mdW5jdGlvbiBnZXRQcm9wZXJ0eUluZm8obmFtZSl7cmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSk/cHJvcGVydGllc1tuYW1lXTpudWxsO31mdW5jdGlvbiBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSx0eXBlLG11c3RVc2VQcm9wZXJ0eSxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZU5hbWVzcGFjZSxzYW5pdGl6ZVVSTCxyZW1vdmVFbXB0eVN0cmluZyl7dGhpcy5hY2NlcHRzQm9vbGVhbnM9dHlwZT09PUJPT0xFQU5JU0hfU1RSSU5HfHx0eXBlPT09Qk9PTEVBTnx8dHlwZT09PU9WRVJMT0FERURfQk9PTEVBTjt0aGlzLmF0dHJpYnV0ZU5hbWU9YXR0cmlidXRlTmFtZTt0aGlzLmF0dHJpYnV0ZU5hbWVzcGFjZT1hdHRyaWJ1dGVOYW1lc3BhY2U7dGhpcy5tdXN0VXNlUHJvcGVydHk9bXVzdFVzZVByb3BlcnR5O3RoaXMucHJvcGVydHlOYW1lPW5hbWU7dGhpcy50eXBlPXR5cGU7dGhpcy5zYW5pdGl6ZVVSTD1zYW5pdGl6ZVVSTDt0aGlzLnJlbW92ZUVtcHR5U3RyaW5nPXJlbW92ZUVtcHR5U3RyaW5nO30vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4vLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuLy8gbmFtZSB3YXJuaW5ncy5cbnZhciBwcm9wZXJ0aWVzPXt9Oy8vIFRoZXNlIHByb3BzIGFyZSByZXNlcnZlZCBieSBSZWFjdC4gVGhleSBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxudmFyIHJlc2VydmVkUHJvcHM9WydjaGlsZHJlbicsJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJywvLyBUT0RPOiBUaGlzIHByZXZlbnRzIHRoZSBhc3NpZ25tZW50IG9mIGRlZmF1bHRWYWx1ZSB0byByZWd1bGFyXG4vLyBlbGVtZW50cyAobm90IGp1c3QgaW5wdXRzKS4gTm93IHRoYXQgUmVhY3RET01JbnB1dCBhc3NpZ25zIHRvIHRoZVxuLy8gZGVmYXVsdFZhbHVlIHByb3BlcnR5IC0tIGRvIHdlIG5lZWQgdGhpcz9cbidkZWZhdWx0VmFsdWUnLCdkZWZhdWx0Q2hlY2tlZCcsJ2lubmVySFRNTCcsJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsJ3N0eWxlJ107cmVzZXJ2ZWRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe3Byb3BlcnRpZXNbbmFtZV09bmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLFJFU0VSVkVELGZhbHNlLC8vIG11c3RVc2VQcm9wZXJ0eVxubmFtZSwvLyBhdHRyaWJ1dGVOYW1lXG5udWxsLC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTsvLyBBIGZldyBSZWFjdCBzdHJpbmcgYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5hbWUuXG4vLyBUaGlzIGlzIGEgbWFwcGluZyBmcm9tIFJlYWN0IHByb3AgbmFtZXMgdG8gdGhlIGF0dHJpYnV0ZSBuYW1lcy5cbltbJ2FjY2VwdENoYXJzZXQnLCdhY2NlcHQtY2hhcnNldCddLFsnY2xhc3NOYW1lJywnY2xhc3MnXSxbJ2h0bWxGb3InLCdmb3InXSxbJ2h0dHBFcXVpdicsJ2h0dHAtZXF1aXYnXV0uZm9yRWFjaChmdW5jdGlvbihfcmVmKXt2YXIgbmFtZT1fcmVmWzBdLGF0dHJpYnV0ZU5hbWU9X3JlZlsxXTtwcm9wZXJ0aWVzW25hbWVdPW5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSxTVFJJTkcsZmFsc2UsLy8gbXVzdFVzZVByb3BlcnR5XG5hdHRyaWJ1dGVOYW1lLC8vIGF0dHJpYnV0ZU5hbWVcbm51bGwsLy8gYXR0cmlidXRlTmFtZXNwYWNlXG5mYWxzZSwvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO30pOy8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG5bJ2NvbnRlbnRFZGl0YWJsZScsJ2RyYWdnYWJsZScsJ3NwZWxsQ2hlY2snLCd2YWx1ZSddLmZvckVhY2goZnVuY3Rpb24obmFtZSl7cHJvcGVydGllc1tuYW1lXT1uZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsQk9PTEVBTklTSF9TVFJJTkcsZmFsc2UsLy8gbXVzdFVzZVByb3BlcnR5XG5uYW1lLnRvTG93ZXJDYXNlKCksLy8gYXR0cmlidXRlTmFtZVxubnVsbCwvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbmZhbHNlLC8vIHNhbml0aXplVVJMXG5mYWxzZSk7fSk7Ly8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIFNWRyBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuLy8gU2luY2UgdGhlc2UgYXJlIFNWRyBhdHRyaWJ1dGVzLCB0aGVpciBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Utc2Vuc2l0aXZlLlxuWydhdXRvUmV2ZXJzZScsJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCdmb2N1c2FibGUnLCdwcmVzZXJ2ZUFscGhhJ10uZm9yRWFjaChmdW5jdGlvbihuYW1lKXtwcm9wZXJ0aWVzW25hbWVdPW5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSxCT09MRUFOSVNIX1NUUklORyxmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbm5hbWUsLy8gYXR0cmlidXRlTmFtZVxubnVsbCwvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbmZhbHNlLC8vIHNhbml0aXplVVJMXG5mYWxzZSk7fSk7Ly8gVGhlc2UgYXJlIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzLlxuWydhbGxvd0Z1bGxTY3JlZW4nLCdhc3luYycsLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuLy8gb24gdGhlIGNsaWVudCBzaWRlIGJlY2F1c2UgdGhlIGJyb3dzZXJzIGFyZSBpbmNvbnNpc3RlbnQuIEluc3RlYWQgd2UgY2FsbCBmb2N1cygpLlxuJ2F1dG9Gb2N1cycsJ2F1dG9QbGF5JywnY29udHJvbHMnLCdkZWZhdWx0JywnZGVmZXInLCdkaXNhYmxlZCcsJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJywnZGlzYWJsZVJlbW90ZVBsYXliYWNrJywnZm9ybU5vVmFsaWRhdGUnLCdoaWRkZW4nLCdsb29wJywnbm9Nb2R1bGUnLCdub1ZhbGlkYXRlJywnb3BlbicsJ3BsYXlzSW5saW5lJywncmVhZE9ubHknLCdyZXF1aXJlZCcsJ3JldmVyc2VkJywnc2NvcGVkJywnc2VhbWxlc3MnLC8vIE1pY3JvZGF0YVxuJ2l0ZW1TY29wZSddLmZvckVhY2goZnVuY3Rpb24obmFtZSl7cHJvcGVydGllc1tuYW1lXT1uZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsQk9PTEVBTixmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbm5hbWUudG9Mb3dlckNhc2UoKSwvLyBhdHRyaWJ1dGVOYW1lXG5udWxsLC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTsvLyBUaGVzZSBhcmUgdGhlIGZldyBSZWFjdCBwcm9wcyB0aGF0IHdlIHNldCBhcyBET00gcHJvcGVydGllc1xuLy8gcmF0aGVyIHRoYW4gYXR0cmlidXRlcy4gVGhlc2UgYXJlIGFsbCBib29sZWFucy5cblsnY2hlY2tlZCcsLy8gTm90ZTogYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbi8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuIFdlIGhhdmUgc3BlY2lhbCBsb2dpYyBmb3IgaGFuZGxpbmcgdGhpcy5cbidtdWx0aXBsZScsJ211dGVkJywnc2VsZWN0ZWQnLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24obmFtZSl7cHJvcGVydGllc1tuYW1lXT1uZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsQk9PTEVBTix0cnVlLC8vIG11c3RVc2VQcm9wZXJ0eVxubmFtZSwvLyBhdHRyaWJ1dGVOYW1lXG5udWxsLC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTsvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYXJlIFwib3ZlcmxvYWRlZCBib29sZWFuc1wiOiB0aGV5IGJlaGF2ZSBsaWtlXG4vLyBib29sZWFucywgYnV0IGNhbiBhbHNvIGFjY2VwdCBhIHN0cmluZyB2YWx1ZS5cblsnY2FwdHVyZScsJ2Rvd25sb2FkJy8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe3Byb3BlcnRpZXNbbmFtZV09bmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLE9WRVJMT0FERURfQk9PTEVBTixmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbm5hbWUsLy8gYXR0cmlidXRlTmFtZVxubnVsbCwvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbmZhbHNlLC8vIHNhbml0aXplVVJMXG5mYWxzZSk7fSk7Ly8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtYmVycy5cblsnY29scycsJ3Jvd3MnLCdzaXplJywnc3BhbicvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbihuYW1lKXtwcm9wZXJ0aWVzW25hbWVdPW5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSxQT1NJVElWRV9OVU1FUklDLGZhbHNlLC8vIG11c3RVc2VQcm9wZXJ0eVxubmFtZSwvLyBhdHRyaWJ1dGVOYW1lXG5udWxsLC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTsvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBudW1iZXJzLlxuWydyb3dTcGFuJywnc3RhcnQnXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe3Byb3BlcnRpZXNbbmFtZV09bmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLE5VTUVSSUMsZmFsc2UsLy8gbXVzdFVzZVByb3BlcnR5XG5uYW1lLnRvTG93ZXJDYXNlKCksLy8gYXR0cmlidXRlTmFtZVxubnVsbCwvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbmZhbHNlLC8vIHNhbml0aXplVVJMXG5mYWxzZSk7fSk7dmFyIENBTUVMSVpFPS9bXFwtXFw6XShbYS16XSkvZzt2YXIgY2FwaXRhbGl6ZT1mdW5jdGlvbih0b2tlbil7cmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7fTsvLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLCBuYW1lc3BhY2luZyxcbi8vIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC4gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5nc1xuLy8gYW5kIGhhdmUgdGhlIHNhbWUgbmFtZXMgYXJlIG9taXR0ZWQsIGp1c3QgbGlrZSBpbiB0aGUgSFRNTCBhdHRyaWJ1dGUgZmlsdGVyLlxuLy8gU29tZSBvZiB0aGVzZSBhdHRyaWJ1dGVzIGNhbiBiZSBoYXJkIHRvIGZpbmQuIFRoaXMgbGlzdCB3YXMgY3JlYXRlZCBieVxuLy8gc2NyYXBpbmcgdGhlIE1ETiBkb2N1bWVudGF0aW9uLlxuWydhY2NlbnQtaGVpZ2h0JywnYWxpZ25tZW50LWJhc2VsaW5lJywnYXJhYmljLWZvcm0nLCdiYXNlbGluZS1zaGlmdCcsJ2NhcC1oZWlnaHQnLCdjbGlwLXBhdGgnLCdjbGlwLXJ1bGUnLCdjb2xvci1pbnRlcnBvbGF0aW9uJywnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywnY29sb3ItcHJvZmlsZScsJ2NvbG9yLXJlbmRlcmluZycsJ2RvbWluYW50LWJhc2VsaW5lJywnZW5hYmxlLWJhY2tncm91bmQnLCdmaWxsLW9wYWNpdHknLCdmaWxsLXJ1bGUnLCdmbG9vZC1jb2xvcicsJ2Zsb29kLW9wYWNpdHknLCdmb250LWZhbWlseScsJ2ZvbnQtc2l6ZScsJ2ZvbnQtc2l6ZS1hZGp1c3QnLCdmb250LXN0cmV0Y2gnLCdmb250LXN0eWxlJywnZm9udC12YXJpYW50JywnZm9udC13ZWlnaHQnLCdnbHlwaC1uYW1lJywnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywnaG9yaXotYWR2LXgnLCdob3Jpei1vcmlnaW4teCcsJ2ltYWdlLXJlbmRlcmluZycsJ2xldHRlci1zcGFjaW5nJywnbGlnaHRpbmctY29sb3InLCdtYXJrZXItZW5kJywnbWFya2VyLW1pZCcsJ21hcmtlci1zdGFydCcsJ292ZXJsaW5lLXBvc2l0aW9uJywnb3ZlcmxpbmUtdGhpY2tuZXNzJywncGFpbnQtb3JkZXInLCdwYW5vc2UtMScsJ3BvaW50ZXItZXZlbnRzJywncmVuZGVyaW5nLWludGVudCcsJ3NoYXBlLXJlbmRlcmluZycsJ3N0b3AtY29sb3InLCdzdG9wLW9wYWNpdHknLCdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLCdzdHJva2UtZGFzaGFycmF5Jywnc3Ryb2tlLWRhc2hvZmZzZXQnLCdzdHJva2UtbGluZWNhcCcsJ3N0cm9rZS1saW5lam9pbicsJ3N0cm9rZS1taXRlcmxpbWl0Jywnc3Ryb2tlLW9wYWNpdHknLCdzdHJva2Utd2lkdGgnLCd0ZXh0LWFuY2hvcicsJ3RleHQtZGVjb3JhdGlvbicsJ3RleHQtcmVuZGVyaW5nJywndW5kZXJsaW5lLXBvc2l0aW9uJywndW5kZXJsaW5lLXRoaWNrbmVzcycsJ3VuaWNvZGUtYmlkaScsJ3VuaWNvZGUtcmFuZ2UnLCd1bml0cy1wZXItZW0nLCd2LWFscGhhYmV0aWMnLCd2LWhhbmdpbmcnLCd2LWlkZW9ncmFwaGljJywndi1tYXRoZW1hdGljYWwnLCd2ZWN0b3ItZWZmZWN0JywndmVydC1hZHYteScsJ3ZlcnQtb3JpZ2luLXgnLCd2ZXJ0LW9yaWdpbi15Jywnd29yZC1zcGFjaW5nJywnd3JpdGluZy1tb2RlJywneG1sbnM6eGxpbmsnLCd4LWhlaWdodCcvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbihhdHRyaWJ1dGVOYW1lKXt2YXIgbmFtZT1hdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsY2FwaXRhbGl6ZSk7cHJvcGVydGllc1tuYW1lXT1uZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsU1RSSU5HLGZhbHNlLC8vIG11c3RVc2VQcm9wZXJ0eVxuYXR0cmlidXRlTmFtZSxudWxsLC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTsvLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeGxpbmsgbmFtZXNwYWNlLlxuWyd4bGluazphY3R1YXRlJywneGxpbms6YXJjcm9sZScsJ3hsaW5rOnJvbGUnLCd4bGluazpzaG93JywneGxpbms6dGl0bGUnLCd4bGluazp0eXBlJy8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZU5hbWUpe3ZhciBuYW1lPWF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSxjYXBpdGFsaXplKTtwcm9wZXJ0aWVzW25hbWVdPW5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSxTVFJJTkcsZmFsc2UsLy8gbXVzdFVzZVByb3BlcnR5XG5hdHRyaWJ1dGVOYW1lLCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxmYWxzZSwvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO30pOy8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bWwgbmFtZXNwYWNlLlxuWyd4bWw6YmFzZScsJ3htbDpsYW5nJywneG1sOnNwYWNlJy8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZU5hbWUpe3ZhciBuYW1lPWF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSxjYXBpdGFsaXplKTtwcm9wZXJ0aWVzW25hbWVdPW5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSxTVFJJTkcsZmFsc2UsLy8gbXVzdFVzZVByb3BlcnR5XG5hdHRyaWJ1dGVOYW1lLCdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLGZhbHNlLC8vIHNhbml0aXplVVJMXG5mYWxzZSk7fSk7Ly8gVGhlc2UgYXR0cmlidXRlIGV4aXN0cyBib3RoIGluIEhUTUwgYW5kIFNWRy5cbi8vIFRoZSBhdHRyaWJ1dGUgbmFtZSBpcyBjYXNlLXNlbnNpdGl2ZSBpbiBTVkcgc28gd2UgY2FuJ3QganVzdCB1c2Vcbi8vIHRoZSBSZWFjdCBuYW1lIGxpa2Ugd2UgZG8gZm9yIGF0dHJpYnV0ZXMgdGhhdCBleGlzdCBvbmx5IGluIEhUTUwuXG5bJ3RhYkluZGV4JywnY3Jvc3NPcmlnaW4nXS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZU5hbWUpe3Byb3BlcnRpZXNbYXR0cmlidXRlTmFtZV09bmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLFNUUklORyxmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbmF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwvLyBhdHRyaWJ1dGVOYW1lXG5udWxsLC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTsvLyBUaGVzZSBhdHRyaWJ1dGVzIGFjY2VwdCBVUkxzLiBUaGVzZSBtdXN0IG5vdCBhbGxvdyBqYXZhc2NyaXB0OiBVUkxTLlxuLy8gVGhlc2Ugd2lsbCBhbHNvIG5lZWQgdG8gYWNjZXB0IFRydXN0ZWQgVHlwZXMgb2JqZWN0IGluIHRoZSBmdXR1cmUuXG52YXIgeGxpbmtIcmVmPSd4bGlua0hyZWYnO3Byb3BlcnRpZXNbeGxpbmtIcmVmXT1uZXcgUHJvcGVydHlJbmZvUmVjb3JkKCd4bGlua0hyZWYnLFNUUklORyxmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbid4bGluazpocmVmJywnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsdHJ1ZSwvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO1snc3JjJywnaHJlZicsJ2FjdGlvbicsJ2Zvcm1BY3Rpb24nXS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZU5hbWUpe3Byb3BlcnRpZXNbYXR0cmlidXRlTmFtZV09bmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLFNUUklORyxmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbmF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwvLyBhdHRyaWJ1dGVOYW1lXG5udWxsLC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxudHJ1ZSwvLyBzYW5pdGl6ZVVSTFxudHJ1ZSk7fSk7Ly8gYW5kIGFueSBuZXdsaW5lIG9yIHRhYiBhcmUgZmlsdGVyZWQgb3V0IGFzIGlmIHRoZXkncmUgbm90IHBhcnQgb2YgdGhlIFVSTC5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLXBhcnNpbmdcbi8vIFRhYiBvciBuZXdsaW5lIGFyZSBkZWZpbmVkIGFzIFxcclxcblxcdDpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS10YWItb3ItbmV3bGluZVxuLy8gQSBDMCBjb250cm9sIGlzIGEgY29kZSBwb2ludCBpbiB0aGUgcmFuZ2UgXFx1MDAwMCBOVUxMIHRvIFxcdTAwMUZcbi8vIElORk9STUFUSU9OIFNFUEFSQVRPUiBPTkUsIGluY2x1c2l2ZTpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNjMC1jb250cm9sLW9yLXNwYWNlXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovdmFyIGlzSmF2YVNjcmlwdFByb3RvY29sPS9eW1xcdTAwMDAtXFx1MDAxRiBdKmpbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qdltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSpzW1xcclxcblxcdF0qY1tcXHJcXG5cXHRdKnJbXFxyXFxuXFx0XSppW1xcclxcblxcdF0qcFtcXHJcXG5cXHRdKnRbXFxyXFxuXFx0XSpcXDovaTt2YXIgZGlkV2Fybj1mYWxzZTtmdW5jdGlvbiBzYW5pdGl6ZVVSTCh1cmwpe3tpZighZGlkV2FybiYmaXNKYXZhU2NyaXB0UHJvdG9jb2wudGVzdCh1cmwpKXtkaWRXYXJuPXRydWU7ZXJyb3IoJ0EgZnV0dXJlIHZlcnNpb24gb2YgUmVhY3Qgd2lsbCBibG9jayBqYXZhc2NyaXB0OiBVUkxzIGFzIGEgc2VjdXJpdHkgcHJlY2F1dGlvbi4gJysnVXNlIGV2ZW50IGhhbmRsZXJzIGluc3RlYWQgaWYgeW91IGNhbi4gSWYgeW91IG5lZWQgdG8gZ2VuZXJhdGUgdW5zYWZlIEhUTUwgdHJ5ICcrJ3VzaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGluc3RlYWQuIFJlYWN0IHdhcyBwYXNzZWQgJXMuJyxKU09OLnN0cmluZ2lmeSh1cmwpKTt9fX0vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLiBPbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqIFRoZSBcImV4cGVjdGVkXCIgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuXG4gKiBTb21lIHByb3BlcnRpZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL2Z1bmN0aW9uIGdldFZhbHVlRm9yUHJvcGVydHkobm9kZSxuYW1lLGV4cGVjdGVkLHByb3BlcnR5SW5mbyl7e2lmKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpe3ZhciBwcm9wZXJ0eU5hbWU9cHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtyZXR1cm4gbm9kZVtwcm9wZXJ0eU5hbWVdO31lbHNley8vIFRoaXMgY2hlY2sgcHJvdGVjdHMgbXVsdGlwbGUgdXNlcyBvZiBgZXhwZWN0ZWRgLCB3aGljaCBpcyB3aHkgdGhlXG4vLyByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvbiBydWxlIGlzIGRpc2FibGVkIGluIHNldmVyYWwgc3BvdHNcbi8vIGJlbG93Llxue2NoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oZXhwZWN0ZWQsbmFtZSk7fWlmKHByb3BlcnR5SW5mby5zYW5pdGl6ZVVSTCl7Ly8gSWYgd2UgaGF2ZW4ndCBmdWxseSBkaXNhYmxlZCBqYXZhc2NyaXB0OiBVUkxzLCBhbmQgaWZcbi8vIHRoZSBoeWRyYXRpb24gaXMgc3VjY2Vzc2Z1bCBvZiBhIGphdmFzY3JpcHQ6IFVSTCwgd2Vcbi8vIHN0aWxsIHdhbnQgdG8gd2FybiBvbiB0aGUgY2xpZW50LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5zYW5pdGl6ZVVSTCgnJytleHBlY3RlZCk7fXZhciBhdHRyaWJ1dGVOYW1lPXByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO3ZhciBzdHJpbmdWYWx1ZT1udWxsO2lmKHByb3BlcnR5SW5mby50eXBlPT09T1ZFUkxPQURFRF9CT09MRUFOKXtpZihub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSl7dmFyIHZhbHVlPW5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO2lmKHZhbHVlPT09Jycpe3JldHVybiB0cnVlO31pZihzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSxleHBlY3RlZCxwcm9wZXJ0eUluZm8sZmFsc2UpKXtyZXR1cm4gdmFsdWU7fS8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuaWYodmFsdWU9PT0nJytleHBlY3RlZCl7cmV0dXJuIGV4cGVjdGVkO31yZXR1cm4gdmFsdWU7fX1lbHNlIGlmKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKXtpZihzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSxleHBlY3RlZCxwcm9wZXJ0eUluZm8sZmFsc2UpKXsvLyBXZSBoYWQgYW4gYXR0cmlidXRlIGJ1dCBzaG91bGRuJ3QgaGF2ZSBoYWQgb25lLCBzbyByZWFkIGl0XG4vLyBmb3IgdGhlIGVycm9yIG1lc3NhZ2UuXG5yZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7fWlmKHByb3BlcnR5SW5mby50eXBlPT09Qk9PTEVBTil7Ly8gSWYgdGhpcyB3YXMgYSBib29sZWFuLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IHRoZSB2YWx1ZSBpc1xuLy8gdGhlIGZhY3QgdGhhdCB3ZSBoYXZlIGl0IGlzIHRoZSBzYW1lIGFzIHRoZSBleHBlY3RlZC5cbnJldHVybiBleHBlY3RlZDt9Ly8gRXZlbiBpZiB0aGlzIHByb3BlcnR5IHVzZXMgYSBuYW1lc3BhY2Ugd2UgdXNlIGdldEF0dHJpYnV0ZVxuLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuLy8gVG8gdXNlIGdldEF0dHJpYnV0ZU5TIHdlIG5lZWQgdGhlIGxvY2FsIG5hbWUgd2hpY2ggd2UgZG9uJ3QgaGF2ZVxuLy8gaW4gb3VyIGNvbmZpZyBhdG0uXG5zdHJpbmdWYWx1ZT1ub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTt9aWYoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsZXhwZWN0ZWQscHJvcGVydHlJbmZvLGZhbHNlKSl7cmV0dXJuIHN0cmluZ1ZhbHVlPT09bnVsbD9leHBlY3RlZDpzdHJpbmdWYWx1ZTsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbn1lbHNlIGlmKHN0cmluZ1ZhbHVlPT09JycrZXhwZWN0ZWQpe3JldHVybiBleHBlY3RlZDt9ZWxzZXtyZXR1cm4gc3RyaW5nVmFsdWU7fX19fS8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBhdHRyaWJ1dGUgb24gYSBub2RlLiBPbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqIFRoZSB0aGlyZCBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy4gU29tZVxuICogYXR0cmlidXRlcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovZnVuY3Rpb24gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSxuYW1lLGV4cGVjdGVkLGlzQ3VzdG9tQ29tcG9uZW50VGFnKXt7aWYoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpe3JldHVybjt9aWYoIW5vZGUuaGFzQXR0cmlidXRlKG5hbWUpKXtyZXR1cm4gZXhwZWN0ZWQ9PT11bmRlZmluZWQ/dW5kZWZpbmVkOm51bGw7fXZhciB2YWx1ZT1ub2RlLmdldEF0dHJpYnV0ZShuYW1lKTt7Y2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihleHBlY3RlZCxuYW1lKTt9aWYodmFsdWU9PT0nJytleHBlY3RlZCl7cmV0dXJuIGV4cGVjdGVkO31yZXR1cm4gdmFsdWU7fX0vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9mdW5jdGlvbiBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsbmFtZSx2YWx1ZSxpc0N1c3RvbUNvbXBvbmVudFRhZyl7dmFyIHByb3BlcnR5SW5mbz1nZXRQcm9wZXJ0eUluZm8obmFtZSk7aWYoc2hvdWxkSWdub3JlQXR0cmlidXRlKG5hbWUscHJvcGVydHlJbmZvLGlzQ3VzdG9tQ29tcG9uZW50VGFnKSl7cmV0dXJuO31pZihzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSx2YWx1ZSxwcm9wZXJ0eUluZm8saXNDdXN0b21Db21wb25lbnRUYWcpKXt2YWx1ZT1udWxsO31pZihpc0N1c3RvbUNvbXBvbmVudFRhZ3x8cHJvcGVydHlJbmZvPT09bnVsbCl7aWYoaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSl7dmFyIF9hdHRyaWJ1dGVOYW1lPW5hbWU7aWYodmFsdWU9PT1udWxsKXtub2RlLnJlbW92ZUF0dHJpYnV0ZShfYXR0cmlidXRlTmFtZSk7fWVsc2V7e2NoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsbmFtZSk7fW5vZGUuc2V0QXR0cmlidXRlKF9hdHRyaWJ1dGVOYW1lLCcnK3ZhbHVlKTt9fXJldHVybjt9dmFyIG11c3RVc2VQcm9wZXJ0eT1wcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5O2lmKG11c3RVc2VQcm9wZXJ0eSl7dmFyIHByb3BlcnR5TmFtZT1wcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO2lmKHZhbHVlPT09bnVsbCl7dmFyIHR5cGU9cHJvcGVydHlJbmZvLnR5cGU7bm9kZVtwcm9wZXJ0eU5hbWVdPXR5cGU9PT1CT09MRUFOP2ZhbHNlOicnO31lbHNley8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbi8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbm5vZGVbcHJvcGVydHlOYW1lXT12YWx1ZTt9cmV0dXJuO30vLyBUaGUgcmVzdCBhcmUgdHJlYXRlZCBhcyBhdHRyaWJ1dGVzIHdpdGggc3BlY2lhbCBjYXNlcy5cbnZhciBhdHRyaWJ1dGVOYW1lPXByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZU5hbWVzcGFjZT1wcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO2lmKHZhbHVlPT09bnVsbCl7bm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7fWVsc2V7dmFyIF90eXBlPXByb3BlcnR5SW5mby50eXBlO3ZhciBhdHRyaWJ1dGVWYWx1ZTtpZihfdHlwZT09PUJPT0xFQU58fF90eXBlPT09T1ZFUkxPQURFRF9CT09MRUFOJiZ2YWx1ZT09PXRydWUpey8vIElmIGF0dHJpYnV0ZSB0eXBlIGlzIGJvb2xlYW4sIHdlIGtub3cgZm9yIHN1cmUgaXQgd29uJ3QgYmUgYW4gZXhlY3V0aW9uIHNpbmtcbi8vIGFuZCB3ZSB3b24ndCByZXF1aXJlIFRydXN0ZWQgVHlwZSBoZXJlLlxuYXR0cmlidXRlVmFsdWU9Jyc7fWVsc2V7Ly8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuLy8gKCcnICsgdmFsdWUpIG1ha2VzIGl0IG91dHB1dCB0aGUgY29ycmVjdCB0b1N0cmluZygpLXZhbHVlLlxue3tjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLGF0dHJpYnV0ZU5hbWUpO31hdHRyaWJ1dGVWYWx1ZT0nJyt2YWx1ZTt9aWYocHJvcGVydHlJbmZvLnNhbml0aXplVVJMKXtzYW5pdGl6ZVVSTChhdHRyaWJ1dGVWYWx1ZS50b1N0cmluZygpKTt9fWlmKGF0dHJpYnV0ZU5hbWVzcGFjZSl7bm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyaWJ1dGVOYW1lc3BhY2UsYXR0cmlidXRlTmFtZSxhdHRyaWJ1dGVWYWx1ZSk7fWVsc2V7bm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSxhdHRyaWJ1dGVWYWx1ZSk7fX19Ly8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEU9U3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO3ZhciBSRUFDVF9QT1JUQUxfVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTt2YXIgUkVBQ1RfRlJBR01FTlRfVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO3ZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7dmFyIFJFQUNUX1BST0ZJTEVSX1RZUEU9U3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTt2YXIgUkVBQ1RfUFJPVklERVJfVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO3ZhciBSRUFDVF9DT05URVhUX1RZUEU9U3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO3ZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7dmFyIFJFQUNUX1NVU1BFTlNFX1RZUEU9U3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTt2YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTt2YXIgUkVBQ1RfTUVNT19UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTt2YXIgUkVBQ1RfTEFaWV9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTt2YXIgUkVBQ1RfU0NPUEVfVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpO3ZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7dmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO3ZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU9U3ltYm9sLmZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO3ZhciBSRUFDVF9DQUNIRV9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7dmFyIFJFQUNUX1RSQUNJTkdfTUFSS0VSX1RZUEU9U3ltYm9sLmZvcigncmVhY3QudHJhY2luZ19tYXJrZXInKTt2YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MPVN5bWJvbC5pdGVyYXRvcjt2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0w9J0BAaXRlcmF0b3InO2Z1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSl7aWYobWF5YmVJdGVyYWJsZT09PW51bGx8fHR5cGVvZiBtYXliZUl0ZXJhYmxlIT09J29iamVjdCcpe3JldHVybiBudWxsO312YXIgbWF5YmVJdGVyYXRvcj1NQVlCRV9JVEVSQVRPUl9TWU1CT0wmJm1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXXx8bWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07aWYodHlwZW9mIG1heWJlSXRlcmF0b3I9PT0nZnVuY3Rpb24nKXtyZXR1cm4gbWF5YmVJdGVyYXRvcjt9cmV0dXJuIG51bGw7fXZhciBhc3NpZ249T2JqZWN0LmFzc2lnbjsvLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aD0wO3ZhciBwcmV2TG9nO3ZhciBwcmV2SW5mbzt2YXIgcHJldldhcm47dmFyIHByZXZFcnJvcjt2YXIgcHJldkdyb3VwO3ZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7dmFyIHByZXZHcm91cEVuZDtmdW5jdGlvbiBkaXNhYmxlZExvZygpe31kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2c9dHJ1ZTtmdW5jdGlvbiBkaXNhYmxlTG9ncygpe3tpZihkaXNhYmxlZERlcHRoPT09MCl7LyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovcHJldkxvZz1jb25zb2xlLmxvZztwcmV2SW5mbz1jb25zb2xlLmluZm87cHJldldhcm49Y29uc29sZS53YXJuO3ByZXZFcnJvcj1jb25zb2xlLmVycm9yO3ByZXZHcm91cD1jb25zb2xlLmdyb3VwO3ByZXZHcm91cENvbGxhcHNlZD1jb25zb2xlLmdyb3VwQ29sbGFwc2VkO3ByZXZHcm91cEVuZD1jb25zb2xlLmdyb3VwRW5kOy8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcbnZhciBwcm9wcz17Y29uZmlndXJhYmxlOnRydWUsZW51bWVyYWJsZTp0cnVlLHZhbHVlOmRpc2FibGVkTG9nLHdyaXRhYmxlOnRydWV9Oy8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLHtpbmZvOnByb3BzLGxvZzpwcm9wcyx3YXJuOnByb3BzLGVycm9yOnByb3BzLGdyb3VwOnByb3BzLGdyb3VwQ29sbGFwc2VkOnByb3BzLGdyb3VwRW5kOnByb3BzfSk7LyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi99ZGlzYWJsZWREZXB0aCsrO319ZnVuY3Rpb24gcmVlbmFibGVMb2dzKCl7e2Rpc2FibGVkRGVwdGgtLTtpZihkaXNhYmxlZERlcHRoPT09MCl7LyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovdmFyIHByb3BzPXtjb25maWd1cmFibGU6dHJ1ZSxlbnVtZXJhYmxlOnRydWUsd3JpdGFibGU6dHJ1ZX07Ly8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUse2xvZzphc3NpZ24oe30scHJvcHMse3ZhbHVlOnByZXZMb2d9KSxpbmZvOmFzc2lnbih7fSxwcm9wcyx7dmFsdWU6cHJldkluZm99KSx3YXJuOmFzc2lnbih7fSxwcm9wcyx7dmFsdWU6cHJldldhcm59KSxlcnJvcjphc3NpZ24oe30scHJvcHMse3ZhbHVlOnByZXZFcnJvcn0pLGdyb3VwOmFzc2lnbih7fSxwcm9wcyx7dmFsdWU6cHJldkdyb3VwfSksZ3JvdXBDb2xsYXBzZWQ6YXNzaWduKHt9LHByb3BzLHt2YWx1ZTpwcmV2R3JvdXBDb2xsYXBzZWR9KSxncm91cEVuZDphc3NpZ24oe30scHJvcHMse3ZhbHVlOnByZXZHcm91cEVuZH0pfSk7LyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi99aWYoZGlzYWJsZWREZXB0aDwwKXtlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcrJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO319fXZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7dmFyIHByZWZpeDtmdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLHNvdXJjZSxvd25lckZuKXt7aWYocHJlZml4PT09dW5kZWZpbmVkKXsvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG50cnl7dGhyb3cgRXJyb3IoKTt9Y2F0Y2goeCl7dmFyIG1hdGNoPXguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7cHJlZml4PW1hdGNoJiZtYXRjaFsxXXx8Jyc7fX0vLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cbnJldHVybidcXG4nK3ByZWZpeCtuYW1lO319dmFyIHJlZW50cnk9ZmFsc2U7dmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7e3ZhciBQb3NzaWJseVdlYWtNYXA9dHlwZW9mIFdlYWtNYXA9PT0nZnVuY3Rpb24nP1dlYWtNYXA6TWFwO2NvbXBvbmVudEZyYW1lQ2FjaGU9bmV3IFBvc3NpYmx5V2Vha01hcCgpO31mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLGNvbnN0cnVjdCl7Ly8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG5pZighZm58fHJlZW50cnkpe3JldHVybicnO317dmFyIGZyYW1lPWNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtpZihmcmFtZSE9PXVuZGVmaW5lZCl7cmV0dXJuIGZyYW1lO319dmFyIGNvbnRyb2w7cmVlbnRyeT10cnVlO3ZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlPUVycm9yLnByZXBhcmVTdGFja1RyYWNlOy8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U9dW5kZWZpbmVkO3ZhciBwcmV2aW91c0Rpc3BhdGNoZXI7e3ByZXZpb3VzRGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7Ly8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4vLyBmb3Igd2FybmluZ3MuXG5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ9bnVsbDtkaXNhYmxlTG9ncygpO310cnl7Ly8gVGhpcyBzaG91bGQgdGhyb3cuXG5pZihjb25zdHJ1Y3Qpey8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxudmFyIEZha2U9ZnVuY3Rpb24oKXt0aHJvdyBFcnJvcigpO307Ly8gJEZsb3dGaXhNZVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCdwcm9wcycse3NldDpmdW5jdGlvbigpey8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbi8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbnRocm93IEVycm9yKCk7fX0pO2lmKHR5cGVvZiBSZWZsZWN0PT09J29iamVjdCcmJlJlZmxlY3QuY29uc3RydWN0KXsvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4vLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxudHJ5e1JlZmxlY3QuY29uc3RydWN0KEZha2UsW10pO31jYXRjaCh4KXtjb250cm9sPXg7fVJlZmxlY3QuY29uc3RydWN0KGZuLFtdLEZha2UpO31lbHNle3RyeXtGYWtlLmNhbGwoKTt9Y2F0Y2goeCl7Y29udHJvbD14O31mbi5jYWxsKEZha2UucHJvdG90eXBlKTt9fWVsc2V7dHJ5e3Rocm93IEVycm9yKCk7fWNhdGNoKHgpe2NvbnRyb2w9eDt9Zm4oKTt9fWNhdGNoKHNhbXBsZSl7Ly8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbmlmKHNhbXBsZSYmY29udHJvbCYmdHlwZW9mIHNhbXBsZS5zdGFjaz09PSdzdHJpbmcnKXsvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG52YXIgc2FtcGxlTGluZXM9c2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTt2YXIgY29udHJvbExpbmVzPWNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO3ZhciBzPXNhbXBsZUxpbmVzLmxlbmd0aC0xO3ZhciBjPWNvbnRyb2xMaW5lcy5sZW5ndGgtMTt3aGlsZShzPj0xJiZjPj0wJiZzYW1wbGVMaW5lc1tzXSE9PWNvbnRyb2xMaW5lc1tjXSl7Ly8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4vLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4vLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbi8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4vLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbmMtLTt9Zm9yKDtzPj0xJiZjPj0wO3MtLSxjLS0pey8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG5pZihzYW1wbGVMaW5lc1tzXSE9PWNvbnRyb2xMaW5lc1tjXSl7Ly8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbi8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbi8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4vLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4vLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuaWYocyE9PTF8fGMhPT0xKXtkb3tzLS07Yy0tOy8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbi8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuaWYoYzwwfHxzYW1wbGVMaW5lc1tzXSE9PWNvbnRyb2xMaW5lc1tjXSl7Ly8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG52YXIgX2ZyYW1lPSdcXG4nK3NhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywnIGF0ICcpOy8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbi8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbi8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuaWYoZm4uZGlzcGxheU5hbWUmJl9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSl7X2ZyYW1lPV9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsZm4uZGlzcGxheU5hbWUpO317aWYodHlwZW9mIGZuPT09J2Z1bmN0aW9uJyl7Y29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sX2ZyYW1lKTt9fS8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cbnJldHVybiBfZnJhbWU7fX13aGlsZShzPj0xJiZjPj0wKTt9YnJlYWs7fX19fWZpbmFsbHl7cmVlbnRyeT1mYWxzZTt7UmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50PXByZXZpb3VzRGlzcGF0Y2hlcjtyZWVuYWJsZUxvZ3MoKTt9RXJyb3IucHJlcGFyZVN0YWNrVHJhY2U9cHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTt9Ly8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxudmFyIG5hbWU9Zm4/Zm4uZGlzcGxheU5hbWV8fGZuLm5hbWU6Jyc7dmFyIHN5bnRoZXRpY0ZyYW1lPW5hbWU/ZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSk6Jyc7e2lmKHR5cGVvZiBmbj09PSdmdW5jdGlvbicpe2NvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLHN5bnRoZXRpY0ZyYW1lKTt9fXJldHVybiBzeW50aGV0aWNGcmFtZTt9ZnVuY3Rpb24gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKGN0b3Isc291cmNlLG93bmVyRm4pe3tyZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShjdG9yLHRydWUpO319ZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLHNvdXJjZSxvd25lckZuKXt7cmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sZmFsc2UpO319ZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCl7dmFyIHByb3RvdHlwZT1Db21wb25lbnQucHJvdG90eXBlO3JldHVybiEhKHByb3RvdHlwZSYmcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO31mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSxzb3VyY2Usb3duZXJGbil7aWYodHlwZT09bnVsbCl7cmV0dXJuJyc7fWlmKHR5cGVvZiB0eXBlPT09J2Z1bmN0aW9uJyl7e3JldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsc2hvdWxkQ29uc3RydWN0KHR5cGUpKTt9fWlmKHR5cGVvZiB0eXBlPT09J3N0cmluZycpe3JldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTt9c3dpdGNoKHR5cGUpe2Nhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpyZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7Y2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6cmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTt9aWYodHlwZW9mIHR5cGU9PT0nb2JqZWN0Jyl7c3dpdGNoKHR5cGUuJCR0eXBlb2Ype2Nhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpyZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtjYXNlIFJFQUNUX01FTU9fVFlQRTovLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxucmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsc291cmNlLG93bmVyRm4pO2Nhc2UgUkVBQ1RfTEFaWV9UWVBFOnt2YXIgbGF6eUNvbXBvbmVudD10eXBlO3ZhciBwYXlsb2FkPWxhenlDb21wb25lbnQuX3BheWxvYWQ7dmFyIGluaXQ9bGF6eUNvbXBvbmVudC5faW5pdDt0cnl7Ly8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbnJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSxzb3VyY2Usb3duZXJGbik7fWNhdGNoKHgpe319fX1yZXR1cm4nJzt9ZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcil7dmFyIG93bmVyPWZpYmVyLl9kZWJ1Z093bmVyP2ZpYmVyLl9kZWJ1Z093bmVyLnR5cGU6bnVsbDt2YXIgc291cmNlPWZpYmVyLl9kZWJ1Z1NvdXJjZTtzd2l0Y2goZmliZXIudGFnKXtjYXNlIEhvc3RDb21wb25lbnQ6cmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO2Nhc2UgTGF6eUNvbXBvbmVudDpyZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ0xhenknKTtjYXNlIFN1c3BlbnNlQ29tcG9uZW50OnJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpyZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpyZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO2Nhc2UgRm9yd2FyZFJlZjpyZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUucmVuZGVyKTtjYXNlIENsYXNzQ29tcG9uZW50OnJldHVybiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7ZGVmYXVsdDpyZXR1cm4nJzt9fWZ1bmN0aW9uIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrSW5Qcm9ncmVzcyl7dHJ5e3ZhciBpbmZvPScnO3ZhciBub2RlPXdvcmtJblByb2dyZXNzO2Rve2luZm8rPWRlc2NyaWJlRmliZXIobm9kZSk7bm9kZT1ub2RlLnJldHVybjt9d2hpbGUobm9kZSk7cmV0dXJuIGluZm87fWNhdGNoKHgpe3JldHVybidcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiAnK3gubWVzc2FnZSsnXFxuJyt4LnN0YWNrO319ZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLGlubmVyVHlwZSx3cmFwcGVyTmFtZSl7dmFyIGRpc3BsYXlOYW1lPW91dGVyVHlwZS5kaXNwbGF5TmFtZTtpZihkaXNwbGF5TmFtZSl7cmV0dXJuIGRpc3BsYXlOYW1lO312YXIgZnVuY3Rpb25OYW1lPWlubmVyVHlwZS5kaXNwbGF5TmFtZXx8aW5uZXJUeXBlLm5hbWV8fCcnO3JldHVybiBmdW5jdGlvbk5hbWUhPT0nJz93cmFwcGVyTmFtZStcIihcIitmdW5jdGlvbk5hbWUrXCIpXCI6d3JhcHBlck5hbWU7fS8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSl7cmV0dXJuIHR5cGUuZGlzcGxheU5hbWV8fCdDb250ZXh0Jzt9Ly8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpe2lmKHR5cGU9PW51bGwpey8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxucmV0dXJuIG51bGw7fXtpZih0eXBlb2YgdHlwZS50YWc9PT0nbnVtYmVyJyl7ZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnKydUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fX1pZih0eXBlb2YgdHlwZT09PSdmdW5jdGlvbicpe3JldHVybiB0eXBlLmRpc3BsYXlOYW1lfHx0eXBlLm5hbWV8fG51bGw7fWlmKHR5cGVvZiB0eXBlPT09J3N0cmluZycpe3JldHVybiB0eXBlO31zd2l0Y2godHlwZSl7Y2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOnJldHVybidGcmFnbWVudCc7Y2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpyZXR1cm4nUG9ydGFsJztjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6cmV0dXJuJ1Byb2ZpbGVyJztjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6cmV0dXJuJ1N0cmljdE1vZGUnO2Nhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpyZXR1cm4nU3VzcGVuc2UnO2Nhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOnJldHVybidTdXNwZW5zZUxpc3QnO31pZih0eXBlb2YgdHlwZT09PSdvYmplY3QnKXtzd2l0Y2godHlwZS4kJHR5cGVvZil7Y2FzZSBSRUFDVF9DT05URVhUX1RZUEU6dmFyIGNvbnRleHQ9dHlwZTtyZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkrJy5Db25zdW1lcic7Y2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOnZhciBwcm92aWRlcj10eXBlO3JldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkrJy5Qcm92aWRlcic7Y2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOnJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLHR5cGUucmVuZGVyLCdGb3J3YXJkUmVmJyk7Y2FzZSBSRUFDVF9NRU1PX1RZUEU6dmFyIG91dGVyTmFtZT10eXBlLmRpc3BsYXlOYW1lfHxudWxsO2lmKG91dGVyTmFtZSE9PW51bGwpe3JldHVybiBvdXRlck5hbWU7fXJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKXx8J01lbW8nO2Nhc2UgUkVBQ1RfTEFaWV9UWVBFOnt2YXIgbGF6eUNvbXBvbmVudD10eXBlO3ZhciBwYXlsb2FkPWxhenlDb21wb25lbnQuX3BheWxvYWQ7dmFyIGluaXQ9bGF6eUNvbXBvbmVudC5faW5pdDt0cnl7cmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTt9Y2F0Y2goeCl7cmV0dXJuIG51bGw7fX0vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbn19cmV0dXJuIG51bGw7fWZ1bmN0aW9uIGdldFdyYXBwZWROYW1lJDEob3V0ZXJUeXBlLGlubmVyVHlwZSx3cmFwcGVyTmFtZSl7dmFyIGZ1bmN0aW9uTmFtZT1pbm5lclR5cGUuZGlzcGxheU5hbWV8fGlubmVyVHlwZS5uYW1lfHwnJztyZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lfHwoZnVuY3Rpb25OYW1lIT09Jyc/d3JhcHBlck5hbWUrXCIoXCIrZnVuY3Rpb25OYW1lK1wiKVwiOndyYXBwZXJOYW1lKTt9Ly8gS2VlcCBpbiBzeW5jIHdpdGggc2hhcmVkL2dldENvbXBvbmVudE5hbWVGcm9tVHlwZVxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUkMSh0eXBlKXtyZXR1cm4gdHlwZS5kaXNwbGF5TmFtZXx8J0NvbnRleHQnO31mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXt2YXIgdGFnPWZpYmVyLnRhZyx0eXBlPWZpYmVyLnR5cGU7c3dpdGNoKHRhZyl7Y2FzZSBDYWNoZUNvbXBvbmVudDpyZXR1cm4nQ2FjaGUnO2Nhc2UgQ29udGV4dENvbnN1bWVyOnZhciBjb250ZXh0PXR5cGU7cmV0dXJuIGdldENvbnRleHROYW1lJDEoY29udGV4dCkrJy5Db25zdW1lcic7Y2FzZSBDb250ZXh0UHJvdmlkZXI6dmFyIHByb3ZpZGVyPXR5cGU7cmV0dXJuIGdldENvbnRleHROYW1lJDEocHJvdmlkZXIuX2NvbnRleHQpKycuUHJvdmlkZXInO2Nhc2UgRGVoeWRyYXRlZEZyYWdtZW50OnJldHVybidEZWh5ZHJhdGVkRnJhZ21lbnQnO2Nhc2UgRm9yd2FyZFJlZjpyZXR1cm4gZ2V0V3JhcHBlZE5hbWUkMSh0eXBlLHR5cGUucmVuZGVyLCdGb3J3YXJkUmVmJyk7Y2FzZSBGcmFnbWVudDpyZXR1cm4nRnJhZ21lbnQnO2Nhc2UgSG9zdENvbXBvbmVudDovLyBIb3N0IGNvbXBvbmVudCB0eXBlIGlzIHRoZSBkaXNwbGF5IG5hbWUgKGUuZy4gXCJkaXZcIiwgXCJWaWV3XCIpXG5yZXR1cm4gdHlwZTtjYXNlIEhvc3RQb3J0YWw6cmV0dXJuJ1BvcnRhbCc7Y2FzZSBIb3N0Um9vdDpyZXR1cm4nUm9vdCc7Y2FzZSBIb3N0VGV4dDpyZXR1cm4nVGV4dCc7Y2FzZSBMYXp5Q29tcG9uZW50Oi8vIE5hbWUgY29tZXMgZnJvbSB0aGUgdHlwZSBpbiB0aGlzIGNhc2U7IHdlIGRvbid0IGhhdmUgYSB0YWcuXG5yZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO2Nhc2UgTW9kZTppZih0eXBlPT09UkVBQ1RfU1RSSUNUX01PREVfVFlQRSl7Ly8gRG9uJ3QgYmUgbGVzcyBzcGVjaWZpYyB0aGFuIHNoYXJlZC9nZXRDb21wb25lbnROYW1lRnJvbVR5cGVcbnJldHVybidTdHJpY3RNb2RlJzt9cmV0dXJuJ01vZGUnO2Nhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OnJldHVybidPZmZzY3JlZW4nO2Nhc2UgUHJvZmlsZXI6cmV0dXJuJ1Byb2ZpbGVyJztjYXNlIFNjb3BlQ29tcG9uZW50OnJldHVybidTY29wZSc7Y2FzZSBTdXNwZW5zZUNvbXBvbmVudDpyZXR1cm4nU3VzcGVuc2UnO2Nhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OnJldHVybidTdXNwZW5zZUxpc3QnO2Nhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDpyZXR1cm4nVHJhY2luZ01hcmtlcic7Ly8gVGhlIGRpc3BsYXkgbmFtZSBmb3IgdGhpcyB0YWdzIGNvbWUgZnJvbSB0aGUgdXNlci1wcm92aWRlZCB0eXBlOlxuY2FzZSBDbGFzc0NvbXBvbmVudDpjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OmNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpjYXNlIE1lbW9Db21wb25lbnQ6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OmlmKHR5cGVvZiB0eXBlPT09J2Z1bmN0aW9uJyl7cmV0dXJuIHR5cGUuZGlzcGxheU5hbWV8fHR5cGUubmFtZXx8bnVsbDt9aWYodHlwZW9mIHR5cGU9PT0nc3RyaW5nJyl7cmV0dXJuIHR5cGU7fWJyZWFrO31yZXR1cm4gbnVsbDt9dmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWU9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTt2YXIgY3VycmVudD1udWxsO3ZhciBpc1JlbmRlcmluZz1mYWxzZTtmdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpe3tpZihjdXJyZW50PT09bnVsbCl7cmV0dXJuIG51bGw7fXZhciBvd25lcj1jdXJyZW50Ll9kZWJ1Z093bmVyO2lmKG93bmVyIT09bnVsbCYmdHlwZW9mIG93bmVyIT09J3VuZGVmaW5lZCcpe3JldHVybiBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyKTt9fXJldHVybiBudWxsO31mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCl7e2lmKGN1cnJlbnQ9PT1udWxsKXtyZXR1cm4nJzt9Ly8gU2FmZSBiZWNhdXNlIGlmIGN1cnJlbnQgZmliZXIgZXhpc3RzLCB3ZSBhcmUgcmVjb25jaWxpbmcsXG4vLyBhbmQgaXQgaXMgZ3VhcmFudGVlZCB0byBiZSB0aGUgd29yay1pbi1wcm9ncmVzcyB2ZXJzaW9uLlxucmV0dXJuIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChjdXJyZW50KTt9fWZ1bmN0aW9uIHJlc2V0Q3VycmVudEZpYmVyKCl7e1JlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrPW51bGw7Y3VycmVudD1udWxsO2lzUmVuZGVyaW5nPWZhbHNlO319ZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKXt7UmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s9ZmliZXI9PT1udWxsP251bGw6Z2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldjtjdXJyZW50PWZpYmVyO2lzUmVuZGVyaW5nPWZhbHNlO319ZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyKCl7e3JldHVybiBjdXJyZW50O319ZnVuY3Rpb24gc2V0SXNSZW5kZXJpbmcocmVuZGVyaW5nKXt7aXNSZW5kZXJpbmc9cmVuZGVyaW5nO319Ly8gRmxvdyBkb2VzIG5vdCBhbGxvdyBzdHJpbmcgY29uY2F0ZW5hdGlvbiBvZiBtb3N0IG5vbi1zdHJpbmcgdHlwZXMuIFRvIHdvcmtcbi8vIGFyb3VuZCB0aGlzIGxpbWl0YXRpb24sIHdlIHVzZSBhbiBvcGFxdWUgdHlwZSB0aGF0IGNhbiBvbmx5IGJlIG9idGFpbmVkIGJ5XG4vLyBwYXNzaW5nIHRoZSB2YWx1ZSB0aHJvdWdoIGdldFRvU3RyaW5nVmFsdWUgZmlyc3QuXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSl7Ly8gVGhlIGNvZXJjaW9uIHNhZmV0eSBjaGVjayBpcyBwZXJmb3JtZWQgaW4gZ2V0VG9TdHJpbmdWYWx1ZSgpLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5yZXR1cm4nJyt2YWx1ZTt9ZnVuY3Rpb24gZ2V0VG9TdHJpbmdWYWx1ZSh2YWx1ZSl7c3dpdGNoKHR5cGVvZiB2YWx1ZSl7Y2FzZSdib29sZWFuJzpjYXNlJ251bWJlcic6Y2FzZSdzdHJpbmcnOmNhc2UndW5kZWZpbmVkJzpyZXR1cm4gdmFsdWU7Y2FzZSdvYmplY3QnOntjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24odmFsdWUpO31yZXR1cm4gdmFsdWU7ZGVmYXVsdDovLyBmdW5jdGlvbiwgc3ltYm9sIGFyZSBhc3NpZ25lZCBhcyBlbXB0eSBzdHJpbmdzXG5yZXR1cm4nJzt9fXZhciBoYXNSZWFkT25seVZhbHVlPXtidXR0b246dHJ1ZSxjaGVja2JveDp0cnVlLGltYWdlOnRydWUsaGlkZGVuOnRydWUscmFkaW86dHJ1ZSxyZXNldDp0cnVlLHN1Ym1pdDp0cnVlfTtmdW5jdGlvbiBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKHRhZ05hbWUscHJvcHMpe3tpZighKGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV18fHByb3BzLm9uQ2hhbmdlfHxwcm9wcy5vbklucHV0fHxwcm9wcy5yZWFkT25seXx8cHJvcHMuZGlzYWJsZWR8fHByb3BzLnZhbHVlPT1udWxsKSl7ZXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnKydgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcrJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJysnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7fWlmKCEocHJvcHMub25DaGFuZ2V8fHByb3BzLnJlYWRPbmx5fHxwcm9wcy5kaXNhYmxlZHx8cHJvcHMuY2hlY2tlZD09bnVsbCkpe2Vycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnKydgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcrJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnKydzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTt9fX1mdW5jdGlvbiBpc0NoZWNrYWJsZShlbGVtKXt2YXIgdHlwZT1lbGVtLnR5cGU7dmFyIG5vZGVOYW1lPWVsZW0ubm9kZU5hbWU7cmV0dXJuIG5vZGVOYW1lJiZub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09J2lucHV0JyYmKHR5cGU9PT0nY2hlY2tib3gnfHx0eXBlPT09J3JhZGlvJyk7fWZ1bmN0aW9uIGdldFRyYWNrZXIobm9kZSl7cmV0dXJuIG5vZGUuX3ZhbHVlVHJhY2tlcjt9ZnVuY3Rpb24gZGV0YWNoVHJhY2tlcihub2RlKXtub2RlLl92YWx1ZVRyYWNrZXI9bnVsbDt9ZnVuY3Rpb24gZ2V0VmFsdWVGcm9tTm9kZShub2RlKXt2YXIgdmFsdWU9Jyc7aWYoIW5vZGUpe3JldHVybiB2YWx1ZTt9aWYoaXNDaGVja2FibGUobm9kZSkpe3ZhbHVlPW5vZGUuY2hlY2tlZD8ndHJ1ZSc6J2ZhbHNlJzt9ZWxzZXt2YWx1ZT1ub2RlLnZhbHVlO31yZXR1cm4gdmFsdWU7fWZ1bmN0aW9uIHRyYWNrVmFsdWVPbk5vZGUobm9kZSl7dmFyIHZhbHVlRmllbGQ9aXNDaGVja2FibGUobm9kZSk/J2NoZWNrZWQnOid2YWx1ZSc7dmFyIGRlc2NyaXB0b3I9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSx2YWx1ZUZpZWxkKTt7Y2hlY2tGb3JtRmllbGRWYWx1ZVN0cmluZ0NvZXJjaW9uKG5vZGVbdmFsdWVGaWVsZF0pO312YXIgY3VycmVudFZhbHVlPScnK25vZGVbdmFsdWVGaWVsZF07Ly8gaWYgc29tZW9uZSBoYXMgYWxyZWFkeSBkZWZpbmVkIGEgdmFsdWUgb3IgU2FmYXJpLCB0aGVuIGJhaWxcbi8vIGFuZCBkb24ndCB0cmFjayB2YWx1ZSB3aWxsIGNhdXNlIG92ZXIgcmVwb3J0aW5nIG9mIGNoYW5nZXMsXG4vLyBidXQgaXQncyBiZXR0ZXIgdGhlbiBhIGhhcmQgZmFpbHVyZVxuLy8gKG5lZWRlZCBmb3IgY2VydGFpbiB0ZXN0cyB0aGF0IHNweU9uIGlucHV0IHZhbHVlcyBhbmQgU2FmYXJpKVxuaWYobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKXx8dHlwZW9mIGRlc2NyaXB0b3I9PT0ndW5kZWZpbmVkJ3x8dHlwZW9mIGRlc2NyaXB0b3IuZ2V0IT09J2Z1bmN0aW9uJ3x8dHlwZW9mIGRlc2NyaXB0b3Iuc2V0IT09J2Z1bmN0aW9uJyl7cmV0dXJuO312YXIgZ2V0PWRlc2NyaXB0b3IuZ2V0LHNldD1kZXNjcmlwdG9yLnNldDtPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSx2YWx1ZUZpZWxkLHtjb25maWd1cmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZ2V0LmNhbGwodGhpcyk7fSxzZXQ6ZnVuY3Rpb24odmFsdWUpe3tjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24odmFsdWUpO31jdXJyZW50VmFsdWU9JycrdmFsdWU7c2V0LmNhbGwodGhpcyx2YWx1ZSk7fX0pOy8vIFdlIGNvdWxkJ3ZlIHBhc3NlZCB0aGlzIHRoZSBmaXJzdCB0aW1lXG4vLyBidXQgaXQgdHJpZ2dlcnMgYSBidWcgaW4gSUUxMSBhbmQgRWRnZSAxNC8xNS5cbi8vIENhbGxpbmcgZGVmaW5lUHJvcGVydHkoKSBhZ2FpbiBzaG91bGQgYmUgZXF1aXZhbGVudC5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE3Njhcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLHZhbHVlRmllbGQse2VudW1lcmFibGU6ZGVzY3JpcHRvci5lbnVtZXJhYmxlfSk7dmFyIHRyYWNrZXI9e2dldFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGN1cnJlbnRWYWx1ZTt9LHNldFZhbHVlOmZ1bmN0aW9uKHZhbHVlKXt7Y2hlY2tGb3JtRmllbGRWYWx1ZVN0cmluZ0NvZXJjaW9uKHZhbHVlKTt9Y3VycmVudFZhbHVlPScnK3ZhbHVlO30sc3RvcFRyYWNraW5nOmZ1bmN0aW9uKCl7ZGV0YWNoVHJhY2tlcihub2RlKTtkZWxldGUgbm9kZVt2YWx1ZUZpZWxkXTt9fTtyZXR1cm4gdHJhY2tlcjt9ZnVuY3Rpb24gdHJhY2sobm9kZSl7aWYoZ2V0VHJhY2tlcihub2RlKSl7cmV0dXJuO30vLyBUT0RPOiBPbmNlIGl0J3MganVzdCBGaWJlciB3ZSBjYW4gbW92ZSB0aGlzIHRvIG5vZGUuX3dyYXBwZXJTdGF0ZVxubm9kZS5fdmFsdWVUcmFja2VyPXRyYWNrVmFsdWVPbk5vZGUobm9kZSk7fWZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpe2lmKCFub2RlKXtyZXR1cm4gZmFsc2U7fXZhciB0cmFja2VyPWdldFRyYWNrZXIobm9kZSk7Ly8gaWYgdGhlcmUgaXMgbm8gdHJhY2tlciBhdCB0aGlzIHBvaW50IGl0J3MgdW5saWtlbHlcbi8vIHRoYXQgdHJ5aW5nIGFnYWluIHdpbGwgc3VjY2VlZFxuaWYoIXRyYWNrZXIpe3JldHVybiB0cnVlO312YXIgbGFzdFZhbHVlPXRyYWNrZXIuZ2V0VmFsdWUoKTt2YXIgbmV4dFZhbHVlPWdldFZhbHVlRnJvbU5vZGUobm9kZSk7aWYobmV4dFZhbHVlIT09bGFzdFZhbHVlKXt0cmFja2VyLnNldFZhbHVlKG5leHRWYWx1ZSk7cmV0dXJuIHRydWU7fXJldHVybiBmYWxzZTt9ZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2Mpe2RvYz1kb2N8fCh0eXBlb2YgZG9jdW1lbnQhPT0ndW5kZWZpbmVkJz9kb2N1bWVudDp1bmRlZmluZWQpO2lmKHR5cGVvZiBkb2M9PT0ndW5kZWZpbmVkJyl7cmV0dXJuIG51bGw7fXRyeXtyZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnR8fGRvYy5ib2R5O31jYXRjaChlKXtyZXR1cm4gZG9jLmJvZHk7fX12YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlPWZhbHNlO3ZhciBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkPWZhbHNlO3ZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkPWZhbHNlO3ZhciBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkPWZhbHNlO2Z1bmN0aW9uIGlzQ29udHJvbGxlZChwcm9wcyl7dmFyIHVzZXNDaGVja2VkPXByb3BzLnR5cGU9PT0nY2hlY2tib3gnfHxwcm9wcy50eXBlPT09J3JhZGlvJztyZXR1cm4gdXNlc0NoZWNrZWQ/cHJvcHMuY2hlY2tlZCE9bnVsbDpwcm9wcy52YWx1ZSE9bnVsbDt9LyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQscHJvcHMpe3ZhciBub2RlPWVsZW1lbnQ7dmFyIGNoZWNrZWQ9cHJvcHMuY2hlY2tlZDt2YXIgaG9zdFByb3BzPWFzc2lnbih7fSxwcm9wcyx7ZGVmYXVsdENoZWNrZWQ6dW5kZWZpbmVkLGRlZmF1bHRWYWx1ZTp1bmRlZmluZWQsdmFsdWU6dW5kZWZpbmVkLGNoZWNrZWQ6Y2hlY2tlZCE9bnVsbD9jaGVja2VkOm5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZH0pO3JldHVybiBob3N0UHJvcHM7fWZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUoZWxlbWVudCxwcm9wcyl7e2NoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ2lucHV0Jyxwcm9wcyk7aWYocHJvcHMuY2hlY2tlZCE9PXVuZGVmaW5lZCYmcHJvcHMuZGVmYXVsdENoZWNrZWQhPT11bmRlZmluZWQmJiFkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkKXtlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcrJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcrJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnKydib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnKydlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCl8fCdBIGNvbXBvbmVudCcscHJvcHMudHlwZSk7ZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZD10cnVlO31pZihwcm9wcy52YWx1ZSE9PXVuZGVmaW5lZCYmcHJvcHMuZGVmYXVsdFZhbHVlIT09dW5kZWZpbmVkJiYhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKXtlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJysnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJysnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJysnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJysnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnKydodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyxnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpfHwnQSBjb21wb25lbnQnLHByb3BzLnR5cGUpO2RpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZT10cnVlO319dmFyIG5vZGU9ZWxlbWVudDt2YXIgZGVmYXVsdFZhbHVlPXByb3BzLmRlZmF1bHRWYWx1ZT09bnVsbD8nJzpwcm9wcy5kZWZhdWx0VmFsdWU7bm9kZS5fd3JhcHBlclN0YXRlPXtpbml0aWFsQ2hlY2tlZDpwcm9wcy5jaGVja2VkIT1udWxsP3Byb3BzLmNoZWNrZWQ6cHJvcHMuZGVmYXVsdENoZWNrZWQsaW5pdGlhbFZhbHVlOmdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUhPW51bGw/cHJvcHMudmFsdWU6ZGVmYXVsdFZhbHVlKSxjb250cm9sbGVkOmlzQ29udHJvbGxlZChwcm9wcyl9O31mdW5jdGlvbiB1cGRhdGVDaGVja2VkKGVsZW1lbnQscHJvcHMpe3ZhciBub2RlPWVsZW1lbnQ7dmFyIGNoZWNrZWQ9cHJvcHMuY2hlY2tlZDtpZihjaGVja2VkIT1udWxsKXtzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsJ2NoZWNrZWQnLGNoZWNrZWQsZmFsc2UpO319ZnVuY3Rpb24gdXBkYXRlV3JhcHBlcihlbGVtZW50LHByb3BzKXt2YXIgbm9kZT1lbGVtZW50O3t2YXIgY29udHJvbGxlZD1pc0NvbnRyb2xsZWQocHJvcHMpO2lmKCFub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCYmY29udHJvbGxlZCYmIWRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQpe2Vycm9yKCdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgdG8gYmUgY29udHJvbGxlZC4gJysnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IHRoZSB2YWx1ZSBjaGFuZ2luZyBmcm9tIHVuZGVmaW5lZCB0byAnKydhIGRlZmluZWQgdmFsdWUsIHdoaWNoIHNob3VsZCBub3QgaGFwcGVuLiAnKydEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcrJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkPXRydWU7fWlmKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkJiYhY29udHJvbGxlZCYmIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpe2Vycm9yKCdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgdG8gYmUgdW5jb250cm9sbGVkLiAnKydUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgdGhlIHZhbHVlIGNoYW5naW5nIGZyb20gYSBkZWZpbmVkIHRvICcrJ3VuZGVmaW5lZCwgd2hpY2ggc2hvdWxkIG5vdCBoYXBwZW4uICcrJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJysnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO2RpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQ9dHJ1ZTt9fXVwZGF0ZUNoZWNrZWQoZWxlbWVudCxwcm9wcyk7dmFyIHZhbHVlPWdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpO3ZhciB0eXBlPXByb3BzLnR5cGU7aWYodmFsdWUhPW51bGwpe2lmKHR5cGU9PT0nbnVtYmVyJyl7aWYodmFsdWU9PT0wJiZub2RlLnZhbHVlPT09Jyd8fC8vIFdlIGV4cGxpY2l0bHkgd2FudCB0byBjb2VyY2UgdG8gbnVtYmVyIGhlcmUgaWYgcG9zc2libGUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbm5vZGUudmFsdWUhPXZhbHVlKXtub2RlLnZhbHVlPXRvU3RyaW5nKHZhbHVlKTt9fWVsc2UgaWYobm9kZS52YWx1ZSE9PXRvU3RyaW5nKHZhbHVlKSl7bm9kZS52YWx1ZT10b1N0cmluZyh2YWx1ZSk7fX1lbHNlIGlmKHR5cGU9PT0nc3VibWl0J3x8dHlwZT09PSdyZXNldCcpey8vIFN1Ym1pdC9yZXNldCBpbnB1dHMgbmVlZCB0aGUgYXR0cmlidXRlIHJlbW92ZWQgY29tcGxldGVseSB0byBhdm9pZFxuLy8gYmxhbmstdGV4dCBidXR0b25zLlxubm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7cmV0dXJuO317Ly8gV2hlbiBzeW5jaW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUsIHRoZSB2YWx1ZSBjb21lcyBmcm9tIGEgY2FzY2FkZSBvZlxuLy8gcHJvcGVydGllczpcbi8vICAxLiBUaGUgdmFsdWUgUmVhY3QgcHJvcGVydHlcbi8vICAyLiBUaGUgZGVmYXVsdFZhbHVlIFJlYWN0IHByb3BlcnR5XG4vLyAgMy4gT3RoZXJ3aXNlIHRoZXJlIHNob3VsZCBiZSBubyBjaGFuZ2VcbmlmKHByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpKXtzZXREZWZhdWx0VmFsdWUobm9kZSxwcm9wcy50eXBlLHZhbHVlKTt9ZWxzZSBpZihwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpe3NldERlZmF1bHRWYWx1ZShub2RlLHByb3BzLnR5cGUsZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpKTt9fXsvLyBXaGVuIHN5bmNpbmcgdGhlIGNoZWNrZWQgYXR0cmlidXRlLCBpdCBvbmx5IGNoYW5nZXMgd2hlbiBpdCBuZWVkc1xuLy8gdG8gYmUgcmVtb3ZlZCwgc3VjaCBhcyB0cmFuc2l0aW9uaW5nIGZyb20gYSBjaGVja2JveCBpbnRvIGEgdGV4dCBpbnB1dFxuaWYocHJvcHMuY2hlY2tlZD09bnVsbCYmcHJvcHMuZGVmYXVsdENoZWNrZWQhPW51bGwpe25vZGUuZGVmYXVsdENoZWNrZWQ9ISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDt9fX1mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyKGVsZW1lbnQscHJvcHMsaXNIeWRyYXRpbmcpe3ZhciBub2RlPWVsZW1lbnQ7Ly8gRG8gbm90IGFzc2lnbiB2YWx1ZSBpZiBpdCBpcyBhbHJlYWR5IHNldC4gVGhpcyBwcmV2ZW50cyB1c2VyIHRleHQgaW5wdXRcbi8vIGZyb20gYmVpbmcgbG9zdCBkdXJpbmcgU1NSIGh5ZHJhdGlvbi5cbmlmKHByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpfHxwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpe3ZhciB0eXBlPXByb3BzLnR5cGU7dmFyIGlzQnV0dG9uPXR5cGU9PT0nc3VibWl0J3x8dHlwZT09PSdyZXNldCc7Ly8gQXZvaWQgc2V0dGluZyB2YWx1ZSBhdHRyaWJ1dGUgb24gc3VibWl0L3Jlc2V0IGlucHV0cyBhcyBpdCBvdmVycmlkZXMgdGhlXG4vLyBkZWZhdWx0IHZhbHVlIHByb3ZpZGVkIGJ5IHRoZSBicm93c2VyLiBTZWU6ICMxMjg3MlxuaWYoaXNCdXR0b24mJihwcm9wcy52YWx1ZT09PXVuZGVmaW5lZHx8cHJvcHMudmFsdWU9PT1udWxsKSl7cmV0dXJuO312YXIgaW5pdGlhbFZhbHVlPXRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpOy8vIERvIG5vdCBhc3NpZ24gdmFsdWUgaWYgaXQgaXMgYWxyZWFkeSBzZXQuIFRoaXMgcHJldmVudHMgdXNlciB0ZXh0IGlucHV0XG4vLyBmcm9tIGJlaW5nIGxvc3QgZHVyaW5nIFNTUiBoeWRyYXRpb24uXG5pZighaXNIeWRyYXRpbmcpe3svLyBXaGVuIHN5bmNpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgdGhlIHZhbHVlIHByb3BlcnR5IHNob3VsZCB1c2Vcbi8vIHRoZSB3cmFwcGVyU3RhdGUuX2luaXRpYWxWYWx1ZSBwcm9wZXJ0eS4gVGhpcyB1c2VzOlxuLy9cbi8vICAgMS4gVGhlIHZhbHVlIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuLy8gICAyLiBUaGUgZGVmYXVsdFZhbHVlIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuLy8gICAzLiBBbiBlbXB0eSBzdHJpbmdcbmlmKGluaXRpYWxWYWx1ZSE9PW5vZGUudmFsdWUpe25vZGUudmFsdWU9aW5pdGlhbFZhbHVlO319fXsvLyBPdGhlcndpc2UsIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgaXMgc3luY2hyb25pemVkIHRvIHRoZSBwcm9wZXJ0eSxcbi8vIHNvIHdlIGFzc2lnbiBkZWZhdWx0VmFsdWUgdG8gdGhlIHNhbWUgdGhpbmcgYXMgdGhlIHZhbHVlIHByb3BlcnR5XG4vLyBhc3NpZ25tZW50IHN0ZXAgYWJvdmUuXG5ub2RlLmRlZmF1bHRWYWx1ZT1pbml0aWFsVmFsdWU7fX0vLyBOb3JtYWxseSwgd2UnZCBqdXN0IGRvIGBub2RlLmNoZWNrZWQgPSBub2RlLmNoZWNrZWRgIHVwb24gaW5pdGlhbCBtb3VudCwgbGVzcyB0aGlzIGJ1Z1xuLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbi8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbi8vIFJlZmVyZW5jZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjA4NDE2XG4vLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxudmFyIG5hbWU9bm9kZS5uYW1lO2lmKG5hbWUhPT0nJyl7bm9kZS5uYW1lPScnO317Ly8gV2hlbiBzeW5jaW5nIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSwgYm90aCB0aGUgY2hlY2tlZCBwcm9wZXJ0eSBhbmRcbi8vIGF0dHJpYnV0ZSBhcmUgYXNzaWduZWQgYXQgdGhlIHNhbWUgdGltZSB1c2luZyBkZWZhdWx0Q2hlY2tlZC4gVGhpcyB1c2VzOlxuLy9cbi8vICAgMS4gVGhlIGNoZWNrZWQgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4vLyAgIDIuIFRoZSBkZWZhdWx0Q2hlY2tlZCBSZWFjdCBwcm9wZXJ0eSB3aGVuIHByZXNlbnRcbi8vICAgMy4gT3RoZXJ3aXNlLCBmYWxzZVxubm9kZS5kZWZhdWx0Q2hlY2tlZD0hbm9kZS5kZWZhdWx0Q2hlY2tlZDtub2RlLmRlZmF1bHRDaGVja2VkPSEhbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkO31pZihuYW1lIT09Jycpe25vZGUubmFtZT1uYW1lO319ZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShlbGVtZW50LHByb3BzKXt2YXIgbm9kZT1lbGVtZW50O3VwZGF0ZVdyYXBwZXIobm9kZSxwcm9wcyk7dXBkYXRlTmFtZWRDb3VzaW5zKG5vZGUscHJvcHMpO31mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUscHJvcHMpe3ZhciBuYW1lPXByb3BzLm5hbWU7aWYocHJvcHMudHlwZT09PSdyYWRpbycmJm5hbWUhPW51bGwpe3ZhciBxdWVyeVJvb3Q9cm9vdE5vZGU7d2hpbGUocXVlcnlSb290LnBhcmVudE5vZGUpe3F1ZXJ5Um9vdD1xdWVyeVJvb3QucGFyZW50Tm9kZTt9Ly8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbi8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbi8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4vLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbi8vIGRvY3VtZW50LiBMZXQncyBqdXN0IHVzZSB0aGUgbG9jYWwgYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndFxuLy8gbWlzcyBhbnl0aGluZy5cbntjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKG5hbWUsJ25hbWUnKTt9dmFyIGdyb3VwPXF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScrSlNPTi5zdHJpbmdpZnkoJycrbmFtZSkrJ11bdHlwZT1cInJhZGlvXCJdJyk7Zm9yKHZhciBpPTA7aTxncm91cC5sZW5ndGg7aSsrKXt2YXIgb3RoZXJOb2RlPWdyb3VwW2ldO2lmKG90aGVyTm9kZT09PXJvb3ROb2RlfHxvdGhlck5vZGUuZm9ybSE9PXJvb3ROb2RlLmZvcm0pe2NvbnRpbnVlO30vLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XG4vLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cbi8vIFRoYXQncyBwcm9iYWJseSBva2F5OyB3ZSBkb24ndCBzdXBwb3J0IGl0IGp1c3QgYXMgd2UgZG9uJ3Qgc3VwcG9ydFxuLy8gbWl4aW5nIFJlYWN0IHJhZGlvIGJ1dHRvbnMgd2l0aCBub24tUmVhY3Qgb25lcy5cbnZhciBvdGhlclByb3BzPWdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUob3RoZXJOb2RlKTtpZighb3RoZXJQcm9wcyl7dGhyb3cgbmV3IEVycm9yKCdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgJysnc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKTt9Ly8gV2UgbmVlZCB1cGRhdGUgdGhlIHRyYWNrZWQgdmFsdWUgb24gdGhlIG5hbWVkIGNvdXNpbiBzaW5jZSB0aGUgdmFsdWVcbi8vIHdhcyBjaGFuZ2VkIGJ1dCB0aGUgaW5wdXQgc2F3IG5vIGV2ZW50IG9yIHZhbHVlIHNldFxudXBkYXRlVmFsdWVJZkNoYW5nZWQob3RoZXJOb2RlKTsvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCByYWRpbyBidXR0b24gZ3JvdXAsIGZvcmNpbmcgdGhlIGlucHV0IHRoYXRcbi8vIHdhcyBwcmV2aW91c2x5IGNoZWNrZWQgdG8gdXBkYXRlIHdpbGwgY2F1c2UgaXQgdG8gYmUgY29tZSByZS1jaGVja2VkXG4vLyBhcyBhcHByb3ByaWF0ZS5cbnVwZGF0ZVdyYXBwZXIob3RoZXJOb2RlLG90aGVyUHJvcHMpO319fS8vIEluIENocm9tZSwgYXNzaWduaW5nIGRlZmF1bHRWYWx1ZSB0byBjZXJ0YWluIGlucHV0IHR5cGVzIHRyaWdnZXJzIGlucHV0IHZhbGlkYXRpb24uXG4vLyBGb3IgbnVtYmVyIGlucHV0cywgdGhlIGRpc3BsYXkgdmFsdWUgbG9zZXMgdHJhaWxpbmcgZGVjaW1hbCBwb2ludHMuIEZvciBlbWFpbCBpbnB1dHMsXG4vLyBDaHJvbWUgcmFpc2VzIFwiVGhlIHNwZWNpZmllZCB2YWx1ZSA8eD4gaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiLlxuLy9cbi8vIEhlcmUgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZSBkZWZhdWx0VmFsdWUgaGFzIGFjdHVhbGx5IGNoYW5nZWQsIGF2b2lkaW5nIHRoZXNlIHByb2JsZW1zXG4vLyB3aGVuIHRoZSB1c2VyIGlzIGlucHV0dGluZyB0ZXh0XG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzXG5mdW5jdGlvbiBzZXREZWZhdWx0VmFsdWUobm9kZSx0eXBlLHZhbHVlKXtpZigvLyBGb2N1c2VkIG51bWJlciBpbnB1dHMgc3luY2hyb25pemUgb24gYmx1ci4gU2VlIENoYW5nZUV2ZW50UGx1Z2luLmpzXG50eXBlIT09J251bWJlcid8fGdldEFjdGl2ZUVsZW1lbnQobm9kZS5vd25lckRvY3VtZW50KSE9PW5vZGUpe2lmKHZhbHVlPT1udWxsKXtub2RlLmRlZmF1bHRWYWx1ZT10b1N0cmluZyhub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKTt9ZWxzZSBpZihub2RlLmRlZmF1bHRWYWx1ZSE9PXRvU3RyaW5nKHZhbHVlKSl7bm9kZS5kZWZhdWx0VmFsdWU9dG9TdHJpbmcodmFsdWUpO319fXZhciBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbj1mYWxzZTt2YXIgZGlkV2FybkludmFsaWRDaGlsZD1mYWxzZTt2YXIgZGlkV2FybkludmFsaWRJbm5lckhUTUw9ZmFsc2U7LyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL2Z1bmN0aW9uIHZhbGlkYXRlUHJvcHMoZWxlbWVudCxwcm9wcyl7ey8vIElmIGEgdmFsdWUgaXMgbm90IHByb3ZpZGVkLCB0aGVuIHRoZSBjaGlsZHJlbiBtdXN0IGJlIHNpbXBsZS5cbmlmKHByb3BzLnZhbHVlPT1udWxsKXtpZih0eXBlb2YgcHJvcHMuY2hpbGRyZW49PT0nb2JqZWN0JyYmcHJvcHMuY2hpbGRyZW4hPT1udWxsKXtSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKHByb3BzLmNoaWxkcmVuLGZ1bmN0aW9uKGNoaWxkKXtpZihjaGlsZD09bnVsbCl7cmV0dXJuO31pZih0eXBlb2YgY2hpbGQ9PT0nc3RyaW5nJ3x8dHlwZW9mIGNoaWxkPT09J251bWJlcicpe3JldHVybjt9aWYoIWRpZFdhcm5JbnZhbGlkQ2hpbGQpe2RpZFdhcm5JbnZhbGlkQ2hpbGQ9dHJ1ZTtlcnJvcignQ2Fubm90IGluZmVyIHRoZSBvcHRpb24gdmFsdWUgb2YgY29tcGxleCBjaGlsZHJlbi4gJysnUGFzcyBhIGB2YWx1ZWAgcHJvcCBvciB1c2UgYSBwbGFpbiBzdHJpbmcgYXMgY2hpbGRyZW4gdG8gPG9wdGlvbj4uJyk7fX0pO31lbHNlIGlmKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIT1udWxsKXtpZighZGlkV2FybkludmFsaWRJbm5lckhUTUwpe2RpZFdhcm5JbnZhbGlkSW5uZXJIVE1MPXRydWU7ZXJyb3IoJ1Bhc3MgYSBgdmFsdWVgIHByb3AgaWYgeW91IHNldCBkYW5nZXJvdXNseUlubmVySFRNTCBzbyBSZWFjdCBrbm93cyAnKyd3aGljaCB2YWx1ZSBzaG91bGQgYmUgc2VsZWN0ZWQuJyk7fX19Ly8gVE9ETzogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG5pZihwcm9wcy5zZWxlY3RlZCE9bnVsbCYmIWRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uKXtlcnJvcignVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJysnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO2RpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uPXRydWU7fX19ZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQxKGVsZW1lbnQscHJvcHMpey8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuaWYocHJvcHMudmFsdWUhPW51bGwpe2VsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsdG9TdHJpbmcoZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSkpKTt9fXZhciBpc0FycmF5SW1wbD1BcnJheS5pc0FycmF5Oy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmZ1bmN0aW9uIGlzQXJyYXkoYSl7cmV0dXJuIGlzQXJyYXlJbXBsKGEpO312YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDE7e2RpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxPWZhbHNlO31mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKXt2YXIgb3duZXJOYW1lPWdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCk7aWYob3duZXJOYW1lKXtyZXR1cm4nXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcrb3duZXJOYW1lKydgLic7fXJldHVybicnO312YXIgdmFsdWVQcm9wTmFtZXM9Wyd2YWx1ZScsJ2RlZmF1bHRWYWx1ZSddOy8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKi9mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcyl7e2NoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3NlbGVjdCcscHJvcHMpO2Zvcih2YXIgaT0wO2k8dmFsdWVQcm9wTmFtZXMubGVuZ3RoO2krKyl7dmFyIHByb3BOYW1lPXZhbHVlUHJvcE5hbWVzW2ldO2lmKHByb3BzW3Byb3BOYW1lXT09bnVsbCl7Y29udGludWU7fXZhciBwcm9wTmFtZUlzQXJyYXk9aXNBcnJheShwcm9wc1twcm9wTmFtZV0pO2lmKHByb3BzLm11bHRpcGxlJiYhcHJvcE5hbWVJc0FycmF5KXtlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcrJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycscHJvcE5hbWUsZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO31lbHNlIGlmKCFwcm9wcy5tdWx0aXBsZSYmcHJvcE5hbWVJc0FycmF5KXtlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcrJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLHByb3BOYW1lLGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTt9fX19ZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhub2RlLG11bHRpcGxlLHByb3BWYWx1ZSxzZXREZWZhdWx0U2VsZWN0ZWQpe3ZhciBvcHRpb25zPW5vZGUub3B0aW9ucztpZihtdWx0aXBsZSl7dmFyIHNlbGVjdGVkVmFsdWVzPXByb3BWYWx1ZTt2YXIgc2VsZWN0ZWRWYWx1ZT17fTtmb3IodmFyIGk9MDtpPHNlbGVjdGVkVmFsdWVzLmxlbmd0aDtpKyspey8vIFByZWZpeCB0byBhdm9pZCBjaGFvcyB3aXRoIHNwZWNpYWwga2V5cy5cbnNlbGVjdGVkVmFsdWVbJyQnK3NlbGVjdGVkVmFsdWVzW2ldXT10cnVlO31mb3IodmFyIF9pPTA7X2k8b3B0aW9ucy5sZW5ndGg7X2krKyl7dmFyIHNlbGVjdGVkPXNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkoJyQnK29wdGlvbnNbX2ldLnZhbHVlKTtpZihvcHRpb25zW19pXS5zZWxlY3RlZCE9PXNlbGVjdGVkKXtvcHRpb25zW19pXS5zZWxlY3RlZD1zZWxlY3RlZDt9aWYoc2VsZWN0ZWQmJnNldERlZmF1bHRTZWxlY3RlZCl7b3B0aW9uc1tfaV0uZGVmYXVsdFNlbGVjdGVkPXRydWU7fX19ZWxzZXsvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbnZhciBfc2VsZWN0ZWRWYWx1ZT10b1N0cmluZyhnZXRUb1N0cmluZ1ZhbHVlKHByb3BWYWx1ZSkpO3ZhciBkZWZhdWx0U2VsZWN0ZWQ9bnVsbDtmb3IodmFyIF9pMj0wO19pMjxvcHRpb25zLmxlbmd0aDtfaTIrKyl7aWYob3B0aW9uc1tfaTJdLnZhbHVlPT09X3NlbGVjdGVkVmFsdWUpe29wdGlvbnNbX2kyXS5zZWxlY3RlZD10cnVlO2lmKHNldERlZmF1bHRTZWxlY3RlZCl7b3B0aW9uc1tfaTJdLmRlZmF1bHRTZWxlY3RlZD10cnVlO31yZXR1cm47fWlmKGRlZmF1bHRTZWxlY3RlZD09PW51bGwmJiFvcHRpb25zW19pMl0uZGlzYWJsZWQpe2RlZmF1bHRTZWxlY3RlZD1vcHRpb25zW19pMl07fX1pZihkZWZhdWx0U2VsZWN0ZWQhPT1udWxsKXtkZWZhdWx0U2VsZWN0ZWQuc2VsZWN0ZWQ9dHJ1ZTt9fX0vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL2Z1bmN0aW9uIGdldEhvc3RQcm9wcyQxKGVsZW1lbnQscHJvcHMpe3JldHVybiBhc3NpZ24oe30scHJvcHMse3ZhbHVlOnVuZGVmaW5lZH0pO31mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDEoZWxlbWVudCxwcm9wcyl7dmFyIG5vZGU9ZWxlbWVudDt7Y2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO31ub2RlLl93cmFwcGVyU3RhdGU9e3dhc011bHRpcGxlOiEhcHJvcHMubXVsdGlwbGV9O3tpZihwcm9wcy52YWx1ZSE9PXVuZGVmaW5lZCYmcHJvcHMuZGVmYXVsdFZhbHVlIT09dW5kZWZpbmVkJiYhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpe2Vycm9yKCdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJysnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJysnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcrJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJysnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO2RpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxPXRydWU7fX19ZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQyKGVsZW1lbnQscHJvcHMpe3ZhciBub2RlPWVsZW1lbnQ7bm9kZS5tdWx0aXBsZT0hIXByb3BzLm11bHRpcGxlO3ZhciB2YWx1ZT1wcm9wcy52YWx1ZTtpZih2YWx1ZSE9bnVsbCl7dXBkYXRlT3B0aW9ucyhub2RlLCEhcHJvcHMubXVsdGlwbGUsdmFsdWUsZmFsc2UpO31lbHNlIGlmKHByb3BzLmRlZmF1bHRWYWx1ZSE9bnVsbCl7dXBkYXRlT3B0aW9ucyhub2RlLCEhcHJvcHMubXVsdGlwbGUscHJvcHMuZGVmYXVsdFZhbHVlLHRydWUpO319ZnVuY3Rpb24gcG9zdFVwZGF0ZVdyYXBwZXIoZWxlbWVudCxwcm9wcyl7dmFyIG5vZGU9ZWxlbWVudDt2YXIgd2FzTXVsdGlwbGU9bm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO25vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZT0hIXByb3BzLm11bHRpcGxlO3ZhciB2YWx1ZT1wcm9wcy52YWx1ZTtpZih2YWx1ZSE9bnVsbCl7dXBkYXRlT3B0aW9ucyhub2RlLCEhcHJvcHMubXVsdGlwbGUsdmFsdWUsZmFsc2UpO31lbHNlIGlmKHdhc011bHRpcGxlIT09ISFwcm9wcy5tdWx0aXBsZSl7Ly8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuaWYocHJvcHMuZGVmYXVsdFZhbHVlIT1udWxsKXt1cGRhdGVPcHRpb25zKG5vZGUsISFwcm9wcy5tdWx0aXBsZSxwcm9wcy5kZWZhdWx0VmFsdWUsdHJ1ZSk7fWVsc2V7Ly8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxudXBkYXRlT3B0aW9ucyhub2RlLCEhcHJvcHMubXVsdGlwbGUscHJvcHMubXVsdGlwbGU/W106JycsZmFsc2UpO319fWZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShlbGVtZW50LHByb3BzKXt2YXIgbm9kZT1lbGVtZW50O3ZhciB2YWx1ZT1wcm9wcy52YWx1ZTtpZih2YWx1ZSE9bnVsbCl7dXBkYXRlT3B0aW9ucyhub2RlLCEhcHJvcHMubXVsdGlwbGUsdmFsdWUsZmFsc2UpO319dmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsPWZhbHNlOy8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDIoZWxlbWVudCxwcm9wcyl7dmFyIG5vZGU9ZWxlbWVudDtpZihwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCE9bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKTt9Ly8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbi8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuICBXZSBjb3VsZCBhZGQgYSBjaGVjayBpbiBzZXRUZXh0Q29udGVudFxuLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbi8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitTb3BoaWUgc2VlbWVkIHRvIGxpa2UgdGhpc1xuLy8gc29sdXRpb24uIFRoZSB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3MgZm9yY2VkXG4vLyB0byBiZSBhIHN0cmluZy5cbnZhciBob3N0UHJvcHM9YXNzaWduKHt9LHByb3BzLHt2YWx1ZTp1bmRlZmluZWQsZGVmYXVsdFZhbHVlOnVuZGVmaW5lZCxjaGlsZHJlbjp0b1N0cmluZyhub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKX0pO3JldHVybiBob3N0UHJvcHM7fWZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMihlbGVtZW50LHByb3BzKXt2YXIgbm9kZT1lbGVtZW50O3tjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCd0ZXh0YXJlYScscHJvcHMpO2lmKHByb3BzLnZhbHVlIT09dW5kZWZpbmVkJiZwcm9wcy5kZWZhdWx0VmFsdWUhPT11bmRlZmluZWQmJiFkaWRXYXJuVmFsRGVmYXVsdFZhbCl7ZXJyb3IoJyVzIGNvbnRhaW5zIGEgdGV4dGFyZWEgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcrJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcrJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcrJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcrJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCl8fCdBIGNvbXBvbmVudCcpO2RpZFdhcm5WYWxEZWZhdWx0VmFsPXRydWU7fX12YXIgaW5pdGlhbFZhbHVlPXByb3BzLnZhbHVlOy8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG5pZihpbml0aWFsVmFsdWU9PW51bGwpe3ZhciBjaGlsZHJlbj1wcm9wcy5jaGlsZHJlbixkZWZhdWx0VmFsdWU9cHJvcHMuZGVmYXVsdFZhbHVlO2lmKGNoaWxkcmVuIT1udWxsKXt7ZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJysnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKTt9e2lmKGRlZmF1bHRWYWx1ZSE9bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJyk7fWlmKGlzQXJyYXkoY2hpbGRyZW4pKXtpZihjaGlsZHJlbi5sZW5ndGg+MSl7dGhyb3cgbmV3IEVycm9yKCc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJyk7fWNoaWxkcmVuPWNoaWxkcmVuWzBdO31kZWZhdWx0VmFsdWU9Y2hpbGRyZW47fX1pZihkZWZhdWx0VmFsdWU9PW51bGwpe2RlZmF1bHRWYWx1ZT0nJzt9aW5pdGlhbFZhbHVlPWRlZmF1bHRWYWx1ZTt9bm9kZS5fd3JhcHBlclN0YXRlPXtpbml0aWFsVmFsdWU6Z2V0VG9TdHJpbmdWYWx1ZShpbml0aWFsVmFsdWUpfTt9ZnVuY3Rpb24gdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQscHJvcHMpe3ZhciBub2RlPWVsZW1lbnQ7dmFyIHZhbHVlPWdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpO3ZhciBkZWZhdWx0VmFsdWU9Z2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpO2lmKHZhbHVlIT1udWxsKXsvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxudmFyIG5ld1ZhbHVlPXRvU3RyaW5nKHZhbHVlKTsvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuaWYobmV3VmFsdWUhPT1ub2RlLnZhbHVlKXtub2RlLnZhbHVlPW5ld1ZhbHVlO31pZihwcm9wcy5kZWZhdWx0VmFsdWU9PW51bGwmJm5vZGUuZGVmYXVsdFZhbHVlIT09bmV3VmFsdWUpe25vZGUuZGVmYXVsdFZhbHVlPW5ld1ZhbHVlO319aWYoZGVmYXVsdFZhbHVlIT1udWxsKXtub2RlLmRlZmF1bHRWYWx1ZT10b1N0cmluZyhkZWZhdWx0VmFsdWUpO319ZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQscHJvcHMpe3ZhciBub2RlPWVsZW1lbnQ7Ly8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG52YXIgdGV4dENvbnRlbnQ9bm9kZS50ZXh0Q29udGVudDsvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuLy8gaW5pdGlhbCB2YWx1ZS4gSW4gSUUxMC9JRTExIHRoZXJlIGlzIGEgYnVnIHdoZXJlIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcbi8vIHdpbGwgcG9wdWxhdGUgdGV4dENvbnRlbnQgYXMgd2VsbC5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cbmlmKHRleHRDb250ZW50PT09bm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSl7aWYodGV4dENvbnRlbnQhPT0nJyYmdGV4dENvbnRlbnQhPT1udWxsKXtub2RlLnZhbHVlPXRleHRDb250ZW50O319fWZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihlbGVtZW50LHByb3BzKXsvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxudXBkYXRlV3JhcHBlciQxKGVsZW1lbnQscHJvcHMpO312YXIgSFRNTF9OQU1FU1BBQ0U9J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO3ZhciBNQVRIX05BTUVTUEFDRT0naHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7dmFyIFNWR19OQU1FU1BBQ0U9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJzsvLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5mdW5jdGlvbiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSl7c3dpdGNoKHR5cGUpe2Nhc2Unc3ZnJzpyZXR1cm4gU1ZHX05BTUVTUEFDRTtjYXNlJ21hdGgnOnJldHVybiBNQVRIX05BTUVTUEFDRTtkZWZhdWx0OnJldHVybiBIVE1MX05BTUVTUEFDRTt9fWZ1bmN0aW9uIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSx0eXBlKXtpZihwYXJlbnROYW1lc3BhY2U9PW51bGx8fHBhcmVudE5hbWVzcGFjZT09PUhUTUxfTkFNRVNQQUNFKXsvLyBObyAob3IgZGVmYXVsdCkgcGFyZW50IG5hbWVzcGFjZTogcG90ZW50aWFsIGVudHJ5IHBvaW50LlxucmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTt9aWYocGFyZW50TmFtZXNwYWNlPT09U1ZHX05BTUVTUEFDRSYmdHlwZT09PSdmb3JlaWduT2JqZWN0Jyl7Ly8gV2UncmUgbGVhdmluZyBTVkcuXG5yZXR1cm4gSFRNTF9OQU1FU1BBQ0U7fS8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxucmV0dXJuIHBhcmVudE5hbWVzcGFjZTt9LyogZ2xvYmFscyBNU0FwcCAqLy8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi92YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbj1mdW5jdGlvbihmdW5jKXtpZih0eXBlb2YgTVNBcHAhPT0ndW5kZWZpbmVkJyYmTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pe3JldHVybiBmdW5jdGlvbihhcmcwLGFyZzEsYXJnMixhcmczKXtNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbigpe3JldHVybiBmdW5jKGFyZzAsYXJnMSxhcmcyLGFyZzMpO30pO307fWVsc2V7cmV0dXJuIGZ1bmM7fX07dmFyIHJldXNhYmxlU1ZHQ29udGFpbmVyOy8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi92YXIgc2V0SW5uZXJIVE1MPWNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24obm9kZSxodG1sKXtpZihub2RlLm5hbWVzcGFjZVVSST09PVNWR19OQU1FU1BBQ0Upe2lmKCEoJ2lubmVySFRNTCdpbiBub2RlKSl7Ly8gSUUgZG9lcyBub3QgaGF2ZSBpbm5lckhUTUwgZm9yIFNWRyBub2Rlcywgc28gaW5zdGVhZCB3ZSBpbmplY3QgdGhlXG4vLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4vLyB0aGUgdGFyZ2V0IG5vZGVcbnJldXNhYmxlU1ZHQ29udGFpbmVyPXJldXNhYmxlU1ZHQ29udGFpbmVyfHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtyZXVzYWJsZVNWR0NvbnRhaW5lci5pbm5lckhUTUw9Jzxzdmc+JytodG1sLnZhbHVlT2YoKS50b1N0cmluZygpKyc8L3N2Zz4nO3ZhciBzdmdOb2RlPXJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7d2hpbGUobm9kZS5maXJzdENoaWxkKXtub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7fXdoaWxlKHN2Z05vZGUuZmlyc3RDaGlsZCl7bm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO31yZXR1cm47fX1ub2RlLmlubmVySFRNTD1odG1sO30pOy8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL3ZhciBFTEVNRU5UX05PREU9MTt2YXIgVEVYVF9OT0RFPTM7dmFyIENPTU1FTlRfTk9ERT04O3ZhciBET0NVTUVOVF9OT0RFPTk7dmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU9MTE7LyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZS4gRm9yIHRleHQgdXBkYXRlcywgaXQncyBmYXN0ZXJcbiAqIHRvIHNldCB0aGUgYG5vZGVWYWx1ZWAgb2YgdGhlIFRleHQgbm9kZSBkaXJlY3RseSBpbnN0ZWFkIG9mIHVzaW5nXG4gKiBgLnRleHRDb250ZW50YCB3aGljaCB3aWxsIHJlbW92ZSB0aGUgZXhpc3Rpbmcgbm9kZSBhbmQgY3JlYXRlIGEgbmV3IG9uZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL3ZhciBzZXRUZXh0Q29udGVudD1mdW5jdGlvbihub2RlLHRleHQpe2lmKHRleHQpe3ZhciBmaXJzdENoaWxkPW5vZGUuZmlyc3RDaGlsZDtpZihmaXJzdENoaWxkJiZmaXJzdENoaWxkPT09bm9kZS5sYXN0Q2hpbGQmJmZpcnN0Q2hpbGQubm9kZVR5cGU9PT1URVhUX05PREUpe2ZpcnN0Q2hpbGQubm9kZVZhbHVlPXRleHQ7cmV0dXJuO319bm9kZS50ZXh0Q29udGVudD10ZXh0O307Ly8gTGlzdCBkZXJpdmVkIGZyb20gR2Vja28gc291cmNlIGNvZGU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi80ZTYzOGVmYzcxL2xheW91dC9zdHlsZS90ZXN0L3Byb3BlcnR5X2RhdGFiYXNlLmpzXG52YXIgc2hvcnRoYW5kVG9Mb25naGFuZD17YW5pbWF0aW9uOlsnYW5pbWF0aW9uRGVsYXknLCdhbmltYXRpb25EaXJlY3Rpb24nLCdhbmltYXRpb25EdXJhdGlvbicsJ2FuaW1hdGlvbkZpbGxNb2RlJywnYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQnLCdhbmltYXRpb25OYW1lJywnYW5pbWF0aW9uUGxheVN0YXRlJywnYW5pbWF0aW9uVGltaW5nRnVuY3Rpb24nXSxiYWNrZ3JvdW5kOlsnYmFja2dyb3VuZEF0dGFjaG1lbnQnLCdiYWNrZ3JvdW5kQ2xpcCcsJ2JhY2tncm91bmRDb2xvcicsJ2JhY2tncm91bmRJbWFnZScsJ2JhY2tncm91bmRPcmlnaW4nLCdiYWNrZ3JvdW5kUG9zaXRpb25YJywnYmFja2dyb3VuZFBvc2l0aW9uWScsJ2JhY2tncm91bmRSZXBlYXQnLCdiYWNrZ3JvdW5kU2l6ZSddLGJhY2tncm91bmRQb3NpdGlvbjpbJ2JhY2tncm91bmRQb3NpdGlvblgnLCdiYWNrZ3JvdW5kUG9zaXRpb25ZJ10sYm9yZGVyOlsnYm9yZGVyQm90dG9tQ29sb3InLCdib3JkZXJCb3R0b21TdHlsZScsJ2JvcmRlckJvdHRvbVdpZHRoJywnYm9yZGVySW1hZ2VPdXRzZXQnLCdib3JkZXJJbWFnZVJlcGVhdCcsJ2JvcmRlckltYWdlU2xpY2UnLCdib3JkZXJJbWFnZVNvdXJjZScsJ2JvcmRlckltYWdlV2lkdGgnLCdib3JkZXJMZWZ0Q29sb3InLCdib3JkZXJMZWZ0U3R5bGUnLCdib3JkZXJMZWZ0V2lkdGgnLCdib3JkZXJSaWdodENvbG9yJywnYm9yZGVyUmlnaHRTdHlsZScsJ2JvcmRlclJpZ2h0V2lkdGgnLCdib3JkZXJUb3BDb2xvcicsJ2JvcmRlclRvcFN0eWxlJywnYm9yZGVyVG9wV2lkdGgnXSxib3JkZXJCbG9ja0VuZDpbJ2JvcmRlckJsb2NrRW5kQ29sb3InLCdib3JkZXJCbG9ja0VuZFN0eWxlJywnYm9yZGVyQmxvY2tFbmRXaWR0aCddLGJvcmRlckJsb2NrU3RhcnQ6Wydib3JkZXJCbG9ja1N0YXJ0Q29sb3InLCdib3JkZXJCbG9ja1N0YXJ0U3R5bGUnLCdib3JkZXJCbG9ja1N0YXJ0V2lkdGgnXSxib3JkZXJCb3R0b206Wydib3JkZXJCb3R0b21Db2xvcicsJ2JvcmRlckJvdHRvbVN0eWxlJywnYm9yZGVyQm90dG9tV2lkdGgnXSxib3JkZXJDb2xvcjpbJ2JvcmRlckJvdHRvbUNvbG9yJywnYm9yZGVyTGVmdENvbG9yJywnYm9yZGVyUmlnaHRDb2xvcicsJ2JvcmRlclRvcENvbG9yJ10sYm9yZGVySW1hZ2U6Wydib3JkZXJJbWFnZU91dHNldCcsJ2JvcmRlckltYWdlUmVwZWF0JywnYm9yZGVySW1hZ2VTbGljZScsJ2JvcmRlckltYWdlU291cmNlJywnYm9yZGVySW1hZ2VXaWR0aCddLGJvcmRlcklubGluZUVuZDpbJ2JvcmRlcklubGluZUVuZENvbG9yJywnYm9yZGVySW5saW5lRW5kU3R5bGUnLCdib3JkZXJJbmxpbmVFbmRXaWR0aCddLGJvcmRlcklubGluZVN0YXJ0OlsnYm9yZGVySW5saW5lU3RhcnRDb2xvcicsJ2JvcmRlcklubGluZVN0YXJ0U3R5bGUnLCdib3JkZXJJbmxpbmVTdGFydFdpZHRoJ10sYm9yZGVyTGVmdDpbJ2JvcmRlckxlZnRDb2xvcicsJ2JvcmRlckxlZnRTdHlsZScsJ2JvcmRlckxlZnRXaWR0aCddLGJvcmRlclJhZGl1czpbJ2JvcmRlckJvdHRvbUxlZnRSYWRpdXMnLCdib3JkZXJCb3R0b21SaWdodFJhZGl1cycsJ2JvcmRlclRvcExlZnRSYWRpdXMnLCdib3JkZXJUb3BSaWdodFJhZGl1cyddLGJvcmRlclJpZ2h0OlsnYm9yZGVyUmlnaHRDb2xvcicsJ2JvcmRlclJpZ2h0U3R5bGUnLCdib3JkZXJSaWdodFdpZHRoJ10sYm9yZGVyU3R5bGU6Wydib3JkZXJCb3R0b21TdHlsZScsJ2JvcmRlckxlZnRTdHlsZScsJ2JvcmRlclJpZ2h0U3R5bGUnLCdib3JkZXJUb3BTdHlsZSddLGJvcmRlclRvcDpbJ2JvcmRlclRvcENvbG9yJywnYm9yZGVyVG9wU3R5bGUnLCdib3JkZXJUb3BXaWR0aCddLGJvcmRlcldpZHRoOlsnYm9yZGVyQm90dG9tV2lkdGgnLCdib3JkZXJMZWZ0V2lkdGgnLCdib3JkZXJSaWdodFdpZHRoJywnYm9yZGVyVG9wV2lkdGgnXSxjb2x1bW5SdWxlOlsnY29sdW1uUnVsZUNvbG9yJywnY29sdW1uUnVsZVN0eWxlJywnY29sdW1uUnVsZVdpZHRoJ10sY29sdW1uczpbJ2NvbHVtbkNvdW50JywnY29sdW1uV2lkdGgnXSxmbGV4OlsnZmxleEJhc2lzJywnZmxleEdyb3cnLCdmbGV4U2hyaW5rJ10sZmxleEZsb3c6WydmbGV4RGlyZWN0aW9uJywnZmxleFdyYXAnXSxmb250OlsnZm9udEZhbWlseScsJ2ZvbnRGZWF0dXJlU2V0dGluZ3MnLCdmb250S2VybmluZycsJ2ZvbnRMYW5ndWFnZU92ZXJyaWRlJywnZm9udFNpemUnLCdmb250U2l6ZUFkanVzdCcsJ2ZvbnRTdHJldGNoJywnZm9udFN0eWxlJywnZm9udFZhcmlhbnQnLCdmb250VmFyaWFudEFsdGVybmF0ZXMnLCdmb250VmFyaWFudENhcHMnLCdmb250VmFyaWFudEVhc3RBc2lhbicsJ2ZvbnRWYXJpYW50TGlnYXR1cmVzJywnZm9udFZhcmlhbnROdW1lcmljJywnZm9udFZhcmlhbnRQb3NpdGlvbicsJ2ZvbnRXZWlnaHQnLCdsaW5lSGVpZ2h0J10sZm9udFZhcmlhbnQ6Wydmb250VmFyaWFudEFsdGVybmF0ZXMnLCdmb250VmFyaWFudENhcHMnLCdmb250VmFyaWFudEVhc3RBc2lhbicsJ2ZvbnRWYXJpYW50TGlnYXR1cmVzJywnZm9udFZhcmlhbnROdW1lcmljJywnZm9udFZhcmlhbnRQb3NpdGlvbiddLGdhcDpbJ2NvbHVtbkdhcCcsJ3Jvd0dhcCddLGdyaWQ6WydncmlkQXV0b0NvbHVtbnMnLCdncmlkQXV0b0Zsb3cnLCdncmlkQXV0b1Jvd3MnLCdncmlkVGVtcGxhdGVBcmVhcycsJ2dyaWRUZW1wbGF0ZUNvbHVtbnMnLCdncmlkVGVtcGxhdGVSb3dzJ10sZ3JpZEFyZWE6WydncmlkQ29sdW1uRW5kJywnZ3JpZENvbHVtblN0YXJ0JywnZ3JpZFJvd0VuZCcsJ2dyaWRSb3dTdGFydCddLGdyaWRDb2x1bW46WydncmlkQ29sdW1uRW5kJywnZ3JpZENvbHVtblN0YXJ0J10sZ3JpZENvbHVtbkdhcDpbJ2NvbHVtbkdhcCddLGdyaWRHYXA6Wydjb2x1bW5HYXAnLCdyb3dHYXAnXSxncmlkUm93OlsnZ3JpZFJvd0VuZCcsJ2dyaWRSb3dTdGFydCddLGdyaWRSb3dHYXA6Wydyb3dHYXAnXSxncmlkVGVtcGxhdGU6WydncmlkVGVtcGxhdGVBcmVhcycsJ2dyaWRUZW1wbGF0ZUNvbHVtbnMnLCdncmlkVGVtcGxhdGVSb3dzJ10sbGlzdFN0eWxlOlsnbGlzdFN0eWxlSW1hZ2UnLCdsaXN0U3R5bGVQb3NpdGlvbicsJ2xpc3RTdHlsZVR5cGUnXSxtYXJnaW46WydtYXJnaW5Cb3R0b20nLCdtYXJnaW5MZWZ0JywnbWFyZ2luUmlnaHQnLCdtYXJnaW5Ub3AnXSxtYXJrZXI6WydtYXJrZXJFbmQnLCdtYXJrZXJNaWQnLCdtYXJrZXJTdGFydCddLG1hc2s6WydtYXNrQ2xpcCcsJ21hc2tDb21wb3NpdGUnLCdtYXNrSW1hZ2UnLCdtYXNrTW9kZScsJ21hc2tPcmlnaW4nLCdtYXNrUG9zaXRpb25YJywnbWFza1Bvc2l0aW9uWScsJ21hc2tSZXBlYXQnLCdtYXNrU2l6ZSddLG1hc2tQb3NpdGlvbjpbJ21hc2tQb3NpdGlvblgnLCdtYXNrUG9zaXRpb25ZJ10sb3V0bGluZTpbJ291dGxpbmVDb2xvcicsJ291dGxpbmVTdHlsZScsJ291dGxpbmVXaWR0aCddLG92ZXJmbG93Olsnb3ZlcmZsb3dYJywnb3ZlcmZsb3dZJ10scGFkZGluZzpbJ3BhZGRpbmdCb3R0b20nLCdwYWRkaW5nTGVmdCcsJ3BhZGRpbmdSaWdodCcsJ3BhZGRpbmdUb3AnXSxwbGFjZUNvbnRlbnQ6WydhbGlnbkNvbnRlbnQnLCdqdXN0aWZ5Q29udGVudCddLHBsYWNlSXRlbXM6WydhbGlnbkl0ZW1zJywnanVzdGlmeUl0ZW1zJ10scGxhY2VTZWxmOlsnYWxpZ25TZWxmJywnanVzdGlmeVNlbGYnXSx0ZXh0RGVjb3JhdGlvbjpbJ3RleHREZWNvcmF0aW9uQ29sb3InLCd0ZXh0RGVjb3JhdGlvbkxpbmUnLCd0ZXh0RGVjb3JhdGlvblN0eWxlJ10sdGV4dEVtcGhhc2lzOlsndGV4dEVtcGhhc2lzQ29sb3InLCd0ZXh0RW1waGFzaXNTdHlsZSddLHRyYW5zaXRpb246Wyd0cmFuc2l0aW9uRGVsYXknLCd0cmFuc2l0aW9uRHVyYXRpb24nLCd0cmFuc2l0aW9uUHJvcGVydHknLCd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nXSx3b3JkV3JhcDpbJ292ZXJmbG93V3JhcCddfTsvKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL3ZhciBpc1VuaXRsZXNzTnVtYmVyPXthbmltYXRpb25JdGVyYXRpb25Db3VudDp0cnVlLGFzcGVjdFJhdGlvOnRydWUsYm9yZGVySW1hZ2VPdXRzZXQ6dHJ1ZSxib3JkZXJJbWFnZVNsaWNlOnRydWUsYm9yZGVySW1hZ2VXaWR0aDp0cnVlLGJveEZsZXg6dHJ1ZSxib3hGbGV4R3JvdXA6dHJ1ZSxib3hPcmRpbmFsR3JvdXA6dHJ1ZSxjb2x1bW5Db3VudDp0cnVlLGNvbHVtbnM6dHJ1ZSxmbGV4OnRydWUsZmxleEdyb3c6dHJ1ZSxmbGV4UG9zaXRpdmU6dHJ1ZSxmbGV4U2hyaW5rOnRydWUsZmxleE5lZ2F0aXZlOnRydWUsZmxleE9yZGVyOnRydWUsZ3JpZEFyZWE6dHJ1ZSxncmlkUm93OnRydWUsZ3JpZFJvd0VuZDp0cnVlLGdyaWRSb3dTcGFuOnRydWUsZ3JpZFJvd1N0YXJ0OnRydWUsZ3JpZENvbHVtbjp0cnVlLGdyaWRDb2x1bW5FbmQ6dHJ1ZSxncmlkQ29sdW1uU3Bhbjp0cnVlLGdyaWRDb2x1bW5TdGFydDp0cnVlLGZvbnRXZWlnaHQ6dHJ1ZSxsaW5lQ2xhbXA6dHJ1ZSxsaW5lSGVpZ2h0OnRydWUsb3BhY2l0eTp0cnVlLG9yZGVyOnRydWUsb3JwaGFuczp0cnVlLHRhYlNpemU6dHJ1ZSx3aWRvd3M6dHJ1ZSx6SW5kZXg6dHJ1ZSx6b29tOnRydWUsLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuZmlsbE9wYWNpdHk6dHJ1ZSxmbG9vZE9wYWNpdHk6dHJ1ZSxzdG9wT3BhY2l0eTp0cnVlLHN0cm9rZURhc2hhcnJheTp0cnVlLHN0cm9rZURhc2hvZmZzZXQ6dHJ1ZSxzdHJva2VNaXRlcmxpbWl0OnRydWUsc3Ryb2tlT3BhY2l0eTp0cnVlLHN0cm9rZVdpZHRoOnRydWV9Oy8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCxrZXkpe3JldHVybiBwcmVmaXgra2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2tleS5zdWJzdHJpbmcoMSk7fS8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi92YXIgcHJlZml4ZXM9WydXZWJraXQnLCdtcycsJ01veicsJ08nXTsvLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24ocHJvcCl7cHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbihwcmVmaXgpe2lzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCxwcm9wKV09aXNVbml0bGVzc051bWJlcltwcm9wXTt9KTt9KTsvKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLHZhbHVlLGlzQ3VzdG9tUHJvcGVydHkpey8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbi8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbi8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3Rcbi8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbi8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4vLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcbnZhciBpc0VtcHR5PXZhbHVlPT1udWxsfHx0eXBlb2YgdmFsdWU9PT0nYm9vbGVhbid8fHZhbHVlPT09Jyc7aWYoaXNFbXB0eSl7cmV0dXJuJyc7fWlmKCFpc0N1c3RvbVByb3BlcnR5JiZ0eXBlb2YgdmFsdWU9PT0nbnVtYmVyJyYmdmFsdWUhPT0wJiYhKGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkmJmlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKXtyZXR1cm4gdmFsdWUrJ3B4JzsvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xufXtjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24odmFsdWUsbmFtZSk7fXJldHVybignJyt2YWx1ZSkudHJpbSgpO312YXIgdXBwZXJjYXNlUGF0dGVybj0vKFtBLVpdKS9nO3ZhciBtc1BhdHRlcm49L15tcy0vOy8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICovZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpe3JldHVybiBuYW1lLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwnLSQxJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKG1zUGF0dGVybiwnLW1zLScpO312YXIgd2FyblZhbGlkU3R5bGU9ZnVuY3Rpb24oKXt9O3svLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG52YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuPS9eKD86d2Via2l0fG1venxvKVtBLVpdLzt2YXIgbXNQYXR0ZXJuJDE9L14tbXMtLzt2YXIgaHlwaGVuUGF0dGVybj0vLSguKS9nOy8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxudmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybj0vO1xccyokLzt2YXIgd2FybmVkU3R5bGVOYW1lcz17fTt2YXIgd2FybmVkU3R5bGVWYWx1ZXM9e307dmFyIHdhcm5lZEZvck5hTlZhbHVlPWZhbHNlO3ZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlPWZhbHNlO3ZhciBjYW1lbGl6ZT1mdW5jdGlvbihzdHJpbmcpe3JldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLGZ1bmN0aW9uKF8sY2hhcmFjdGVyKXtyZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7fSk7fTt2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWU9ZnVuY3Rpb24obmFtZSl7aWYod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSYmd2FybmVkU3R5bGVOYW1lc1tuYW1lXSl7cmV0dXJuO313YXJuZWRTdHlsZU5hbWVzW25hbWVdPXRydWU7ZXJyb3IoJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JyxuYW1lLC8vIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbi8vIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbi8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbmNhbWVsaXplKG5hbWUucmVwbGFjZShtc1BhdHRlcm4kMSwnbXMtJykpKTt9O3ZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWU9ZnVuY3Rpb24obmFtZSl7aWYod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSYmd2FybmVkU3R5bGVOYW1lc1tuYW1lXSl7cmV0dXJuO313YXJuZWRTdHlsZU5hbWVzW25hbWVdPXRydWU7ZXJyb3IoJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsbmFtZSxuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK25hbWUuc2xpY2UoMSkpO307dmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbj1mdW5jdGlvbihuYW1lLHZhbHVlKXtpZih3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkmJndhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSl7cmV0dXJuO313YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV09dHJ1ZTtlcnJvcihcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIrJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJyxuYW1lLHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCcnKSk7fTt2YXIgd2FyblN0eWxlVmFsdWVJc05hTj1mdW5jdGlvbihuYW1lLHZhbHVlKXtpZih3YXJuZWRGb3JOYU5WYWx1ZSl7cmV0dXJuO313YXJuZWRGb3JOYU5WYWx1ZT10cnVlO2Vycm9yKCdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJyxuYW1lKTt9O3ZhciB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHk9ZnVuY3Rpb24obmFtZSx2YWx1ZSl7aWYod2FybmVkRm9ySW5maW5pdHlWYWx1ZSl7cmV0dXJuO313YXJuZWRGb3JJbmZpbml0eVZhbHVlPXRydWU7ZXJyb3IoJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LicsbmFtZSk7fTt3YXJuVmFsaWRTdHlsZT1mdW5jdGlvbihuYW1lLHZhbHVlKXtpZihuYW1lLmluZGV4T2YoJy0nKT4tMSl7d2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7fWVsc2UgaWYoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpe3dhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKTt9ZWxzZSBpZihiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpe3dhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLHZhbHVlKTt9aWYodHlwZW9mIHZhbHVlPT09J251bWJlcicpe2lmKGlzTmFOKHZhbHVlKSl7d2FyblN0eWxlVmFsdWVJc05hTihuYW1lLHZhbHVlKTt9ZWxzZSBpZighaXNGaW5pdGUodmFsdWUpKXt3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSx2YWx1ZSk7fX19O312YXIgd2FyblZhbGlkU3R5bGUkMT13YXJuVmFsaWRTdHlsZTsvKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqLy8qKlxuICogVGhpcyBjcmVhdGVzIGEgc3RyaW5nIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZXF1aXZhbGVudCB0byB0aGUgc3R5bGVcbiAqIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgYnkgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBJdCBieS1wYXNzZXMgd2FybmluZ3MgYW5kXG4gKiBzZWN1cml0eSBjaGVja3Mgc28gaXQncyBub3Qgc2FmZSB0byB1c2UgdGhpcyB2YWx1ZSBmb3IgYW55dGhpbmcgb3RoZXIgdGhhblxuICogY29tcGFyaXNvbi4gSXQgaXMgb25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKi9mdW5jdGlvbiBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMoc3R5bGVzKXt7dmFyIHNlcmlhbGl6ZWQ9Jyc7dmFyIGRlbGltaXRlcj0nJztmb3IodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpe2lmKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSl7Y29udGludWU7fXZhciBzdHlsZVZhbHVlPXN0eWxlc1tzdHlsZU5hbWVdO2lmKHN0eWxlVmFsdWUhPW51bGwpe3ZhciBpc0N1c3RvbVByb3BlcnR5PXN0eWxlTmFtZS5pbmRleE9mKCctLScpPT09MDtzZXJpYWxpemVkKz1kZWxpbWl0ZXIrKGlzQ3VzdG9tUHJvcGVydHk/c3R5bGVOYW1lOmh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpKSsnOic7c2VyaWFsaXplZCs9ZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsc3R5bGVWYWx1ZSxpc0N1c3RvbVByb3BlcnR5KTtkZWxpbWl0ZXI9JzsnO319cmV0dXJuIHNlcmlhbGl6ZWR8fG51bGw7fX0vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBtdWx0aXBsZSBzdHlsZXMgb24gYSBub2RlLiAgSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXNcbiAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICovZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMobm9kZSxzdHlsZXMpe3ZhciBzdHlsZT1ub2RlLnN0eWxlO2Zvcih2YXIgc3R5bGVOYW1lIGluIHN0eWxlcyl7aWYoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKXtjb250aW51ZTt9dmFyIGlzQ3VzdG9tUHJvcGVydHk9c3R5bGVOYW1lLmluZGV4T2YoJy0tJyk9PT0wO3tpZighaXNDdXN0b21Qcm9wZXJ0eSl7d2FyblZhbGlkU3R5bGUkMShzdHlsZU5hbWUsc3R5bGVzW3N0eWxlTmFtZV0pO319dmFyIHN0eWxlVmFsdWU9ZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsc3R5bGVzW3N0eWxlTmFtZV0saXNDdXN0b21Qcm9wZXJ0eSk7aWYoc3R5bGVOYW1lPT09J2Zsb2F0Jyl7c3R5bGVOYW1lPSdjc3NGbG9hdCc7fWlmKGlzQ3VzdG9tUHJvcGVydHkpe3N0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSxzdHlsZVZhbHVlKTt9ZWxzZXtzdHlsZVtzdHlsZU5hbWVdPXN0eWxlVmFsdWU7fX19ZnVuY3Rpb24gaXNWYWx1ZUVtcHR5KHZhbHVlKXtyZXR1cm4gdmFsdWU9PW51bGx8fHR5cGVvZiB2YWx1ZT09PSdib29sZWFuJ3x8dmFsdWU9PT0nJzt9LyoqXG4gKiBHaXZlbiB7Y29sb3I6ICdyZWQnLCBvdmVyZmxvdzogJ2hpZGRlbid9IHJldHVybnMge1xuICogICBjb2xvcjogJ2NvbG9yJyxcbiAqICAgb3ZlcmZsb3dYOiAnb3ZlcmZsb3cnLFxuICogICBvdmVyZmxvd1k6ICdvdmVyZmxvdycsXG4gKiB9LiBUaGlzIGNhbiBiZSByZWFkIGFzIFwidGhlIG92ZXJmbG93WSBwcm9wZXJ0eSB3YXMgc2V0IGJ5IHRoZSBvdmVyZmxvd1xuICogc2hvcnRoYW5kXCIuIFRoYXQgaXMsIHRoZSB2YWx1ZXMgYXJlIHRoZSBwcm9wZXJ0eSB0aGF0IGVhY2ggd2FzIGRlcml2ZWQgZnJvbS5cbiAqL2Z1bmN0aW9uIGV4cGFuZFNob3J0aGFuZE1hcChzdHlsZXMpe3ZhciBleHBhbmRlZD17fTtmb3IodmFyIGtleSBpbiBzdHlsZXMpe3ZhciBsb25naGFuZHM9c2hvcnRoYW5kVG9Mb25naGFuZFtrZXldfHxba2V5XTtmb3IodmFyIGk9MDtpPGxvbmdoYW5kcy5sZW5ndGg7aSsrKXtleHBhbmRlZFtsb25naGFuZHNbaV1dPWtleTt9fXJldHVybiBleHBhbmRlZDt9LyoqXG4gKiBXaGVuIG1peGluZyBzaG9ydGhhbmQgYW5kIGxvbmdoYW5kIHByb3BlcnR5IG5hbWVzLCB3ZSB3YXJuIGR1cmluZyB1cGRhdGVzIGlmXG4gKiB3ZSBleHBlY3QgYW4gaW5jb3JyZWN0IHJlc3VsdCB0byBvY2N1ci4gSW4gcGFydGljdWxhciwgd2Ugd2FybiBmb3I6XG4gKlxuICogVXBkYXRpbmcgYSBzaG9ydGhhbmQgcHJvcGVydHkgKGxvbmdoYW5kIGdldHMgb3ZlcndyaXR0ZW4pOlxuICogICB7Zm9udDogJ2ZvbycsIGZvbnRWYXJpYW50OiAnYmFyJ30gLT4ge2ZvbnQ6ICdiYXonLCBmb250VmFyaWFudDogJ2Jhcid9XG4gKiAgIGJlY29tZXMgLnN0eWxlLmZvbnQgPSAnYmF6J1xuICogUmVtb3ZpbmcgYSBzaG9ydGhhbmQgcHJvcGVydHkgKGxvbmdoYW5kIGdldHMgbG9zdCB0b28pOlxuICogICB7Zm9udDogJ2ZvbycsIGZvbnRWYXJpYW50OiAnYmFyJ30gLT4ge2ZvbnRWYXJpYW50OiAnYmFyJ31cbiAqICAgYmVjb21lcyAuc3R5bGUuZm9udCA9ICcnXG4gKiBSZW1vdmluZyBhIGxvbmdoYW5kIHByb3BlcnR5IChzaG91bGQgcmV2ZXJ0IHRvIHNob3J0aGFuZDsgZG9lc24ndCk6XG4gKiAgIHtmb250OiAnZm9vJywgZm9udFZhcmlhbnQ6ICdiYXInfSAtPiB7Zm9udDogJ2Zvbyd9XG4gKiAgIGJlY29tZXMgLnN0eWxlLmZvbnRWYXJpYW50ID0gJydcbiAqL2Z1bmN0aW9uIHZhbGlkYXRlU2hvcnRoYW5kUHJvcGVydHlDb2xsaXNpb25JbkRldihzdHlsZVVwZGF0ZXMsbmV4dFN0eWxlcyl7e2lmKCFuZXh0U3R5bGVzKXtyZXR1cm47fXZhciBleHBhbmRlZFVwZGF0ZXM9ZXhwYW5kU2hvcnRoYW5kTWFwKHN0eWxlVXBkYXRlcyk7dmFyIGV4cGFuZGVkU3R5bGVzPWV4cGFuZFNob3J0aGFuZE1hcChuZXh0U3R5bGVzKTt2YXIgd2FybmVkQWJvdXQ9e307Zm9yKHZhciBrZXkgaW4gZXhwYW5kZWRVcGRhdGVzKXt2YXIgb3JpZ2luYWxLZXk9ZXhwYW5kZWRVcGRhdGVzW2tleV07dmFyIGNvcnJlY3RPcmlnaW5hbEtleT1leHBhbmRlZFN0eWxlc1trZXldO2lmKGNvcnJlY3RPcmlnaW5hbEtleSYmb3JpZ2luYWxLZXkhPT1jb3JyZWN0T3JpZ2luYWxLZXkpe3ZhciB3YXJuaW5nS2V5PW9yaWdpbmFsS2V5KycsJytjb3JyZWN0T3JpZ2luYWxLZXk7aWYod2FybmVkQWJvdXRbd2FybmluZ0tleV0pe2NvbnRpbnVlO313YXJuZWRBYm91dFt3YXJuaW5nS2V5XT10cnVlO2Vycm9yKCclcyBhIHN0eWxlIHByb3BlcnR5IGR1cmluZyByZXJlbmRlciAoJXMpIHdoZW4gYSAnKydjb25mbGljdGluZyBwcm9wZXJ0eSBpcyBzZXQgKCVzKSBjYW4gbGVhZCB0byBzdHlsaW5nIGJ1Z3MuIFRvICcrXCJhdm9pZCB0aGlzLCBkb24ndCBtaXggc2hvcnRoYW5kIGFuZCBub24tc2hvcnRoYW5kIHByb3BlcnRpZXMgXCIrJ2ZvciB0aGUgc2FtZSB2YWx1ZTsgaW5zdGVhZCwgcmVwbGFjZSB0aGUgc2hvcnRoYW5kIHdpdGggJysnc2VwYXJhdGUgdmFsdWVzLicsaXNWYWx1ZUVtcHR5KHN0eWxlVXBkYXRlc1tvcmlnaW5hbEtleV0pPydSZW1vdmluZyc6J1VwZGF0aW5nJyxvcmlnaW5hbEtleSxjb3JyZWN0T3JpZ2luYWxLZXkpO319fX0vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIGxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzPXthcmVhOnRydWUsYmFzZTp0cnVlLGJyOnRydWUsY29sOnRydWUsZW1iZWQ6dHJ1ZSxocjp0cnVlLGltZzp0cnVlLGlucHV0OnRydWUsa2V5Z2VuOnRydWUsbGluazp0cnVlLG1ldGE6dHJ1ZSxwYXJhbTp0cnVlLHNvdXJjZTp0cnVlLHRyYWNrOnRydWUsd2JyOnRydWUvLyBOT1RFOiBtZW51aXRlbSdzIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IHRoYXQgY2F1c2VzIHByb2JsZW1zLlxufTsvLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG52YXIgdm9pZEVsZW1lbnRUYWdzPWFzc2lnbih7bWVudWl0ZW06dHJ1ZX0sb21pdHRlZENsb3NlVGFncyk7dmFyIEhUTUw9J19faHRtbCc7ZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcscHJvcHMpe2lmKCFwcm9wcyl7cmV0dXJuO30vLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuaWYodm9pZEVsZW1lbnRUYWdzW3RhZ10pe2lmKHByb3BzLmNoaWxkcmVuIT1udWxsfHxwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCE9bnVsbCl7dGhyb3cgbmV3IEVycm9yKHRhZytcIiBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIFwiKyd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTt9fWlmKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIT1udWxsKXtpZihwcm9wcy5jaGlsZHJlbiE9bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTt9aWYodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIT09J29iamVjdCd8fCEoSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkpe3Rocm93IG5ldyBFcnJvcignYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gJysnUGxlYXNlIHZpc2l0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCAnKydmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTt9fXtpZighcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJiZwcm9wcy5jb250ZW50RWRpdGFibGUmJnByb3BzLmNoaWxkcmVuIT1udWxsKXtlcnJvcignQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnKydSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnKyd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJysncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpO319aWYocHJvcHMuc3R5bGUhPW51bGwmJnR5cGVvZiBwcm9wcy5zdHlsZSE9PSdvYmplY3QnKXt0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgJytcIm5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiBcIisndXNpbmcgSlNYLicpO319ZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSxwcm9wcyl7aWYodGFnTmFtZS5pbmRleE9mKCctJyk9PT0tMSl7cmV0dXJuIHR5cGVvZiBwcm9wcy5pcz09PSdzdHJpbmcnO31zd2l0Y2godGFnTmFtZSl7Ly8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuLy8gV2UgZG9uJ3QgbWluZCB0aGlzIGxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbi8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG5jYXNlJ2Fubm90YXRpb24teG1sJzpjYXNlJ2NvbG9yLXByb2ZpbGUnOmNhc2UnZm9udC1mYWNlJzpjYXNlJ2ZvbnQtZmFjZS1zcmMnOmNhc2UnZm9udC1mYWNlLXVyaSc6Y2FzZSdmb250LWZhY2UtZm9ybWF0JzpjYXNlJ2ZvbnQtZmFjZS1uYW1lJzpjYXNlJ21pc3NpbmctZ2x5cGgnOnJldHVybiBmYWxzZTtkZWZhdWx0OnJldHVybiB0cnVlO319Ly8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgYWxsb3dlZCBhdHRyaWJ1dGUgbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzPXsvLyBIVE1MXG5hY2NlcHQ6J2FjY2VwdCcsYWNjZXB0Y2hhcnNldDonYWNjZXB0Q2hhcnNldCcsJ2FjY2VwdC1jaGFyc2V0JzonYWNjZXB0Q2hhcnNldCcsYWNjZXNza2V5OidhY2Nlc3NLZXknLGFjdGlvbjonYWN0aW9uJyxhbGxvd2Z1bGxzY3JlZW46J2FsbG93RnVsbFNjcmVlbicsYWx0OidhbHQnLGFzOidhcycsYXN5bmM6J2FzeW5jJyxhdXRvY2FwaXRhbGl6ZTonYXV0b0NhcGl0YWxpemUnLGF1dG9jb21wbGV0ZTonYXV0b0NvbXBsZXRlJyxhdXRvY29ycmVjdDonYXV0b0NvcnJlY3QnLGF1dG9mb2N1czonYXV0b0ZvY3VzJyxhdXRvcGxheTonYXV0b1BsYXknLGF1dG9zYXZlOidhdXRvU2F2ZScsY2FwdHVyZTonY2FwdHVyZScsY2VsbHBhZGRpbmc6J2NlbGxQYWRkaW5nJyxjZWxsc3BhY2luZzonY2VsbFNwYWNpbmcnLGNoYWxsZW5nZTonY2hhbGxlbmdlJyxjaGFyc2V0OidjaGFyU2V0JyxjaGVja2VkOidjaGVja2VkJyxjaGlsZHJlbjonY2hpbGRyZW4nLGNpdGU6J2NpdGUnLGNsYXNzOidjbGFzc05hbWUnLGNsYXNzaWQ6J2NsYXNzSUQnLGNsYXNzbmFtZTonY2xhc3NOYW1lJyxjb2xzOidjb2xzJyxjb2xzcGFuOidjb2xTcGFuJyxjb250ZW50Oidjb250ZW50Jyxjb250ZW50ZWRpdGFibGU6J2NvbnRlbnRFZGl0YWJsZScsY29udGV4dG1lbnU6J2NvbnRleHRNZW51Jyxjb250cm9sczonY29udHJvbHMnLGNvbnRyb2xzbGlzdDonY29udHJvbHNMaXN0Jyxjb29yZHM6J2Nvb3JkcycsY3Jvc3NvcmlnaW46J2Nyb3NzT3JpZ2luJyxkYW5nZXJvdXNseXNldGlubmVyaHRtbDonZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLGRhdGE6J2RhdGEnLGRhdGV0aW1lOidkYXRlVGltZScsZGVmYXVsdDonZGVmYXVsdCcsZGVmYXVsdGNoZWNrZWQ6J2RlZmF1bHRDaGVja2VkJyxkZWZhdWx0dmFsdWU6J2RlZmF1bHRWYWx1ZScsZGVmZXI6J2RlZmVyJyxkaXI6J2RpcicsZGlzYWJsZWQ6J2Rpc2FibGVkJyxkaXNhYmxlcGljdHVyZWlucGljdHVyZTonZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLGRpc2FibGVyZW1vdGVwbGF5YmFjazonZGlzYWJsZVJlbW90ZVBsYXliYWNrJyxkb3dubG9hZDonZG93bmxvYWQnLGRyYWdnYWJsZTonZHJhZ2dhYmxlJyxlbmN0eXBlOidlbmNUeXBlJyxlbnRlcmtleWhpbnQ6J2VudGVyS2V5SGludCcsZm9yOidodG1sRm9yJyxmb3JtOidmb3JtJyxmb3JtbWV0aG9kOidmb3JtTWV0aG9kJyxmb3JtYWN0aW9uOidmb3JtQWN0aW9uJyxmb3JtZW5jdHlwZTonZm9ybUVuY1R5cGUnLGZvcm1ub3ZhbGlkYXRlOidmb3JtTm9WYWxpZGF0ZScsZm9ybXRhcmdldDonZm9ybVRhcmdldCcsZnJhbWVib3JkZXI6J2ZyYW1lQm9yZGVyJyxoZWFkZXJzOidoZWFkZXJzJyxoZWlnaHQ6J2hlaWdodCcsaGlkZGVuOidoaWRkZW4nLGhpZ2g6J2hpZ2gnLGhyZWY6J2hyZWYnLGhyZWZsYW5nOidocmVmTGFuZycsaHRtbGZvcjonaHRtbEZvcicsaHR0cGVxdWl2OidodHRwRXF1aXYnLCdodHRwLWVxdWl2JzonaHR0cEVxdWl2JyxpY29uOidpY29uJyxpZDonaWQnLGltYWdlc2l6ZXM6J2ltYWdlU2l6ZXMnLGltYWdlc3Jjc2V0OidpbWFnZVNyY1NldCcsaW5uZXJodG1sOidpbm5lckhUTUwnLGlucHV0bW9kZTonaW5wdXRNb2RlJyxpbnRlZ3JpdHk6J2ludGVncml0eScsaXM6J2lzJyxpdGVtaWQ6J2l0ZW1JRCcsaXRlbXByb3A6J2l0ZW1Qcm9wJyxpdGVtcmVmOidpdGVtUmVmJyxpdGVtc2NvcGU6J2l0ZW1TY29wZScsaXRlbXR5cGU6J2l0ZW1UeXBlJyxrZXlwYXJhbXM6J2tleVBhcmFtcycsa2V5dHlwZTona2V5VHlwZScsa2luZDona2luZCcsbGFiZWw6J2xhYmVsJyxsYW5nOidsYW5nJyxsaXN0OidsaXN0Jyxsb29wOidsb29wJyxsb3c6J2xvdycsbWFuaWZlc3Q6J21hbmlmZXN0JyxtYXJnaW53aWR0aDonbWFyZ2luV2lkdGgnLG1hcmdpbmhlaWdodDonbWFyZ2luSGVpZ2h0JyxtYXg6J21heCcsbWF4bGVuZ3RoOidtYXhMZW5ndGgnLG1lZGlhOidtZWRpYScsbWVkaWFncm91cDonbWVkaWFHcm91cCcsbWV0aG9kOidtZXRob2QnLG1pbjonbWluJyxtaW5sZW5ndGg6J21pbkxlbmd0aCcsbXVsdGlwbGU6J211bHRpcGxlJyxtdXRlZDonbXV0ZWQnLG5hbWU6J25hbWUnLG5vbW9kdWxlOidub01vZHVsZScsbm9uY2U6J25vbmNlJyxub3ZhbGlkYXRlOidub1ZhbGlkYXRlJyxvcGVuOidvcGVuJyxvcHRpbXVtOidvcHRpbXVtJyxwYXR0ZXJuOidwYXR0ZXJuJyxwbGFjZWhvbGRlcjoncGxhY2Vob2xkZXInLHBsYXlzaW5saW5lOidwbGF5c0lubGluZScscG9zdGVyOidwb3N0ZXInLHByZWxvYWQ6J3ByZWxvYWQnLHByb2ZpbGU6J3Byb2ZpbGUnLHJhZGlvZ3JvdXA6J3JhZGlvR3JvdXAnLHJlYWRvbmx5OidyZWFkT25seScscmVmZXJyZXJwb2xpY3k6J3JlZmVycmVyUG9saWN5JyxyZWw6J3JlbCcscmVxdWlyZWQ6J3JlcXVpcmVkJyxyZXZlcnNlZDoncmV2ZXJzZWQnLHJvbGU6J3JvbGUnLHJvd3M6J3Jvd3MnLHJvd3NwYW46J3Jvd1NwYW4nLHNhbmRib3g6J3NhbmRib3gnLHNjb3BlOidzY29wZScsc2NvcGVkOidzY29wZWQnLHNjcm9sbGluZzonc2Nyb2xsaW5nJyxzZWFtbGVzczonc2VhbWxlc3MnLHNlbGVjdGVkOidzZWxlY3RlZCcsc2hhcGU6J3NoYXBlJyxzaXplOidzaXplJyxzaXplczonc2l6ZXMnLHNwYW46J3NwYW4nLHNwZWxsY2hlY2s6J3NwZWxsQ2hlY2snLHNyYzonc3JjJyxzcmNkb2M6J3NyY0RvYycsc3JjbGFuZzonc3JjTGFuZycsc3Jjc2V0OidzcmNTZXQnLHN0YXJ0OidzdGFydCcsc3RlcDonc3RlcCcsc3R5bGU6J3N0eWxlJyxzdW1tYXJ5OidzdW1tYXJ5Jyx0YWJpbmRleDondGFiSW5kZXgnLHRhcmdldDondGFyZ2V0Jyx0aXRsZTondGl0bGUnLHR5cGU6J3R5cGUnLHVzZW1hcDondXNlTWFwJyx2YWx1ZTondmFsdWUnLHdpZHRoOid3aWR0aCcsd21vZGU6J3dtb2RlJyx3cmFwOid3cmFwJywvLyBTVkdcbmFib3V0OidhYm91dCcsYWNjZW50aGVpZ2h0OidhY2NlbnRIZWlnaHQnLCdhY2NlbnQtaGVpZ2h0JzonYWNjZW50SGVpZ2h0JyxhY2N1bXVsYXRlOidhY2N1bXVsYXRlJyxhZGRpdGl2ZTonYWRkaXRpdmUnLGFsaWdubWVudGJhc2VsaW5lOidhbGlnbm1lbnRCYXNlbGluZScsJ2FsaWdubWVudC1iYXNlbGluZSc6J2FsaWdubWVudEJhc2VsaW5lJyxhbGxvd3Jlb3JkZXI6J2FsbG93UmVvcmRlcicsYWxwaGFiZXRpYzonYWxwaGFiZXRpYycsYW1wbGl0dWRlOidhbXBsaXR1ZGUnLGFyYWJpY2Zvcm06J2FyYWJpY0Zvcm0nLCdhcmFiaWMtZm9ybSc6J2FyYWJpY0Zvcm0nLGFzY2VudDonYXNjZW50JyxhdHRyaWJ1dGVuYW1lOidhdHRyaWJ1dGVOYW1lJyxhdHRyaWJ1dGV0eXBlOidhdHRyaWJ1dGVUeXBlJyxhdXRvcmV2ZXJzZTonYXV0b1JldmVyc2UnLGF6aW11dGg6J2F6aW11dGgnLGJhc2VmcmVxdWVuY3k6J2Jhc2VGcmVxdWVuY3knLGJhc2VsaW5lc2hpZnQ6J2Jhc2VsaW5lU2hpZnQnLCdiYXNlbGluZS1zaGlmdCc6J2Jhc2VsaW5lU2hpZnQnLGJhc2Vwcm9maWxlOidiYXNlUHJvZmlsZScsYmJveDonYmJveCcsYmVnaW46J2JlZ2luJyxiaWFzOidiaWFzJyxieTonYnknLGNhbGNtb2RlOidjYWxjTW9kZScsY2FwaGVpZ2h0OidjYXBIZWlnaHQnLCdjYXAtaGVpZ2h0JzonY2FwSGVpZ2h0JyxjbGlwOidjbGlwJyxjbGlwcGF0aDonY2xpcFBhdGgnLCdjbGlwLXBhdGgnOidjbGlwUGF0aCcsY2xpcHBhdGh1bml0czonY2xpcFBhdGhVbml0cycsY2xpcHJ1bGU6J2NsaXBSdWxlJywnY2xpcC1ydWxlJzonY2xpcFJ1bGUnLGNvbG9yOidjb2xvcicsY29sb3JpbnRlcnBvbGF0aW9uOidjb2xvckludGVycG9sYXRpb24nLCdjb2xvci1pbnRlcnBvbGF0aW9uJzonY29sb3JJbnRlcnBvbGF0aW9uJyxjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOidjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJywnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzonY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsY29sb3Jwcm9maWxlOidjb2xvclByb2ZpbGUnLCdjb2xvci1wcm9maWxlJzonY29sb3JQcm9maWxlJyxjb2xvcnJlbmRlcmluZzonY29sb3JSZW5kZXJpbmcnLCdjb2xvci1yZW5kZXJpbmcnOidjb2xvclJlbmRlcmluZycsY29udGVudHNjcmlwdHR5cGU6J2NvbnRlbnRTY3JpcHRUeXBlJyxjb250ZW50c3R5bGV0eXBlOidjb250ZW50U3R5bGVUeXBlJyxjdXJzb3I6J2N1cnNvcicsY3g6J2N4JyxjeTonY3knLGQ6J2QnLGRhdGF0eXBlOidkYXRhdHlwZScsZGVjZWxlcmF0ZTonZGVjZWxlcmF0ZScsZGVzY2VudDonZGVzY2VudCcsZGlmZnVzZWNvbnN0YW50OidkaWZmdXNlQ29uc3RhbnQnLGRpcmVjdGlvbjonZGlyZWN0aW9uJyxkaXNwbGF5OidkaXNwbGF5JyxkaXZpc29yOidkaXZpc29yJyxkb21pbmFudGJhc2VsaW5lOidkb21pbmFudEJhc2VsaW5lJywnZG9taW5hbnQtYmFzZWxpbmUnOidkb21pbmFudEJhc2VsaW5lJyxkdXI6J2R1cicsZHg6J2R4JyxkeTonZHknLGVkZ2Vtb2RlOidlZGdlTW9kZScsZWxldmF0aW9uOidlbGV2YXRpb24nLGVuYWJsZWJhY2tncm91bmQ6J2VuYWJsZUJhY2tncm91bmQnLCdlbmFibGUtYmFja2dyb3VuZCc6J2VuYWJsZUJhY2tncm91bmQnLGVuZDonZW5kJyxleHBvbmVudDonZXhwb25lbnQnLGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6J2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLGZpbGw6J2ZpbGwnLGZpbGxvcGFjaXR5OidmaWxsT3BhY2l0eScsJ2ZpbGwtb3BhY2l0eSc6J2ZpbGxPcGFjaXR5JyxmaWxscnVsZTonZmlsbFJ1bGUnLCdmaWxsLXJ1bGUnOidmaWxsUnVsZScsZmlsdGVyOidmaWx0ZXInLGZpbHRlcnJlczonZmlsdGVyUmVzJyxmaWx0ZXJ1bml0czonZmlsdGVyVW5pdHMnLGZsb29kb3BhY2l0eTonZmxvb2RPcGFjaXR5JywnZmxvb2Qtb3BhY2l0eSc6J2Zsb29kT3BhY2l0eScsZmxvb2Rjb2xvcjonZmxvb2RDb2xvcicsJ2Zsb29kLWNvbG9yJzonZmxvb2RDb2xvcicsZm9jdXNhYmxlOidmb2N1c2FibGUnLGZvbnRmYW1pbHk6J2ZvbnRGYW1pbHknLCdmb250LWZhbWlseSc6J2ZvbnRGYW1pbHknLGZvbnRzaXplOidmb250U2l6ZScsJ2ZvbnQtc2l6ZSc6J2ZvbnRTaXplJyxmb250c2l6ZWFkanVzdDonZm9udFNpemVBZGp1c3QnLCdmb250LXNpemUtYWRqdXN0JzonZm9udFNpemVBZGp1c3QnLGZvbnRzdHJldGNoOidmb250U3RyZXRjaCcsJ2ZvbnQtc3RyZXRjaCc6J2ZvbnRTdHJldGNoJyxmb250c3R5bGU6J2ZvbnRTdHlsZScsJ2ZvbnQtc3R5bGUnOidmb250U3R5bGUnLGZvbnR2YXJpYW50Oidmb250VmFyaWFudCcsJ2ZvbnQtdmFyaWFudCc6J2ZvbnRWYXJpYW50Jyxmb250d2VpZ2h0Oidmb250V2VpZ2h0JywnZm9udC13ZWlnaHQnOidmb250V2VpZ2h0Jyxmb3JtYXQ6J2Zvcm1hdCcsZnJvbTonZnJvbScsZng6J2Z4JyxmeTonZnknLGcxOidnMScsZzI6J2cyJyxnbHlwaG5hbWU6J2dseXBoTmFtZScsJ2dseXBoLW5hbWUnOidnbHlwaE5hbWUnLGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOidnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOidnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOidnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLCdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6J2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsZ2x5cGhyZWY6J2dseXBoUmVmJyxncmFkaWVudHRyYW5zZm9ybTonZ3JhZGllbnRUcmFuc2Zvcm0nLGdyYWRpZW50dW5pdHM6J2dyYWRpZW50VW5pdHMnLGhhbmdpbmc6J2hhbmdpbmcnLGhvcml6YWR2eDonaG9yaXpBZHZYJywnaG9yaXotYWR2LXgnOidob3JpekFkdlgnLGhvcml6b3JpZ2lueDonaG9yaXpPcmlnaW5YJywnaG9yaXotb3JpZ2luLXgnOidob3Jpek9yaWdpblgnLGlkZW9ncmFwaGljOidpZGVvZ3JhcGhpYycsaW1hZ2VyZW5kZXJpbmc6J2ltYWdlUmVuZGVyaW5nJywnaW1hZ2UtcmVuZGVyaW5nJzonaW1hZ2VSZW5kZXJpbmcnLGluMjonaW4yJyxpbjonaW4nLGlubGlzdDonaW5saXN0JyxpbnRlcmNlcHQ6J2ludGVyY2VwdCcsazE6J2sxJyxrMjonazInLGszOidrMycsazQ6J2s0JyxrOidrJyxrZXJuZWxtYXRyaXg6J2tlcm5lbE1hdHJpeCcsa2VybmVsdW5pdGxlbmd0aDona2VybmVsVW5pdExlbmd0aCcsa2VybmluZzona2VybmluZycsa2V5cG9pbnRzOidrZXlQb2ludHMnLGtleXNwbGluZXM6J2tleVNwbGluZXMnLGtleXRpbWVzOidrZXlUaW1lcycsbGVuZ3RoYWRqdXN0OidsZW5ndGhBZGp1c3QnLGxldHRlcnNwYWNpbmc6J2xldHRlclNwYWNpbmcnLCdsZXR0ZXItc3BhY2luZyc6J2xldHRlclNwYWNpbmcnLGxpZ2h0aW5nY29sb3I6J2xpZ2h0aW5nQ29sb3InLCdsaWdodGluZy1jb2xvcic6J2xpZ2h0aW5nQ29sb3InLGxpbWl0aW5nY29uZWFuZ2xlOidsaW1pdGluZ0NvbmVBbmdsZScsbG9jYWw6J2xvY2FsJyxtYXJrZXJlbmQ6J21hcmtlckVuZCcsJ21hcmtlci1lbmQnOidtYXJrZXJFbmQnLG1hcmtlcmhlaWdodDonbWFya2VySGVpZ2h0JyxtYXJrZXJtaWQ6J21hcmtlck1pZCcsJ21hcmtlci1taWQnOidtYXJrZXJNaWQnLG1hcmtlcnN0YXJ0OidtYXJrZXJTdGFydCcsJ21hcmtlci1zdGFydCc6J21hcmtlclN0YXJ0JyxtYXJrZXJ1bml0czonbWFya2VyVW5pdHMnLG1hcmtlcndpZHRoOidtYXJrZXJXaWR0aCcsbWFzazonbWFzaycsbWFza2NvbnRlbnR1bml0czonbWFza0NvbnRlbnRVbml0cycsbWFza3VuaXRzOidtYXNrVW5pdHMnLG1hdGhlbWF0aWNhbDonbWF0aGVtYXRpY2FsJyxtb2RlOidtb2RlJyxudW1vY3RhdmVzOidudW1PY3RhdmVzJyxvZmZzZXQ6J29mZnNldCcsb3BhY2l0eTonb3BhY2l0eScsb3BlcmF0b3I6J29wZXJhdG9yJyxvcmRlcjonb3JkZXInLG9yaWVudDonb3JpZW50JyxvcmllbnRhdGlvbjonb3JpZW50YXRpb24nLG9yaWdpbjonb3JpZ2luJyxvdmVyZmxvdzonb3ZlcmZsb3cnLG92ZXJsaW5lcG9zaXRpb246J292ZXJsaW5lUG9zaXRpb24nLCdvdmVybGluZS1wb3NpdGlvbic6J292ZXJsaW5lUG9zaXRpb24nLG92ZXJsaW5ldGhpY2tuZXNzOidvdmVybGluZVRoaWNrbmVzcycsJ292ZXJsaW5lLXRoaWNrbmVzcyc6J292ZXJsaW5lVGhpY2tuZXNzJyxwYWludG9yZGVyOidwYWludE9yZGVyJywncGFpbnQtb3JkZXInOidwYWludE9yZGVyJyxwYW5vc2UxOidwYW5vc2UxJywncGFub3NlLTEnOidwYW5vc2UxJyxwYXRobGVuZ3RoOidwYXRoTGVuZ3RoJyxwYXR0ZXJuY29udGVudHVuaXRzOidwYXR0ZXJuQ29udGVudFVuaXRzJyxwYXR0ZXJudHJhbnNmb3JtOidwYXR0ZXJuVHJhbnNmb3JtJyxwYXR0ZXJudW5pdHM6J3BhdHRlcm5Vbml0cycscG9pbnRlcmV2ZW50czoncG9pbnRlckV2ZW50cycsJ3BvaW50ZXItZXZlbnRzJzoncG9pbnRlckV2ZW50cycscG9pbnRzOidwb2ludHMnLHBvaW50c2F0eDoncG9pbnRzQXRYJyxwb2ludHNhdHk6J3BvaW50c0F0WScscG9pbnRzYXR6Oidwb2ludHNBdFonLHByZWZpeDoncHJlZml4JyxwcmVzZXJ2ZWFscGhhOidwcmVzZXJ2ZUFscGhhJyxwcmVzZXJ2ZWFzcGVjdHJhdGlvOidwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxwcmltaXRpdmV1bml0czoncHJpbWl0aXZlVW5pdHMnLHByb3BlcnR5Oidwcm9wZXJ0eScscjoncicscmFkaXVzOidyYWRpdXMnLHJlZng6J3JlZlgnLHJlZnk6J3JlZlknLHJlbmRlcmluZ2ludGVudDoncmVuZGVyaW5nSW50ZW50JywncmVuZGVyaW5nLWludGVudCc6J3JlbmRlcmluZ0ludGVudCcscmVwZWF0Y291bnQ6J3JlcGVhdENvdW50JyxyZXBlYXRkdXI6J3JlcGVhdER1cicscmVxdWlyZWRleHRlbnNpb25zOidyZXF1aXJlZEV4dGVuc2lvbnMnLHJlcXVpcmVkZmVhdHVyZXM6J3JlcXVpcmVkRmVhdHVyZXMnLHJlc291cmNlOidyZXNvdXJjZScscmVzdGFydDoncmVzdGFydCcscmVzdWx0OidyZXN1bHQnLHJlc3VsdHM6J3Jlc3VsdHMnLHJvdGF0ZToncm90YXRlJyxyeDoncngnLHJ5OidyeScsc2NhbGU6J3NjYWxlJyxzZWN1cml0eTonc2VjdXJpdHknLHNlZWQ6J3NlZWQnLHNoYXBlcmVuZGVyaW5nOidzaGFwZVJlbmRlcmluZycsJ3NoYXBlLXJlbmRlcmluZyc6J3NoYXBlUmVuZGVyaW5nJyxzbG9wZTonc2xvcGUnLHNwYWNpbmc6J3NwYWNpbmcnLHNwZWN1bGFyY29uc3RhbnQ6J3NwZWN1bGFyQ29uc3RhbnQnLHNwZWN1bGFyZXhwb25lbnQ6J3NwZWN1bGFyRXhwb25lbnQnLHNwZWVkOidzcGVlZCcsc3ByZWFkbWV0aG9kOidzcHJlYWRNZXRob2QnLHN0YXJ0b2Zmc2V0OidzdGFydE9mZnNldCcsc3RkZGV2aWF0aW9uOidzdGREZXZpYXRpb24nLHN0ZW1oOidzdGVtaCcsc3RlbXY6J3N0ZW12JyxzdGl0Y2h0aWxlczonc3RpdGNoVGlsZXMnLHN0b3Bjb2xvcjonc3RvcENvbG9yJywnc3RvcC1jb2xvcic6J3N0b3BDb2xvcicsc3RvcG9wYWNpdHk6J3N0b3BPcGFjaXR5Jywnc3RvcC1vcGFjaXR5Jzonc3RvcE9wYWNpdHknLHN0cmlrZXRocm91Z2hwb3NpdGlvbjonc3RyaWtldGhyb3VnaFBvc2l0aW9uJywnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6J3N0cmlrZXRocm91Z2hQb3NpdGlvbicsc3RyaWtldGhyb3VnaHRoaWNrbmVzczonc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzonc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsc3RyaW5nOidzdHJpbmcnLHN0cm9rZTonc3Ryb2tlJyxzdHJva2VkYXNoYXJyYXk6J3N0cm9rZURhc2hhcnJheScsJ3N0cm9rZS1kYXNoYXJyYXknOidzdHJva2VEYXNoYXJyYXknLHN0cm9rZWRhc2hvZmZzZXQ6J3N0cm9rZURhc2hvZmZzZXQnLCdzdHJva2UtZGFzaG9mZnNldCc6J3N0cm9rZURhc2hvZmZzZXQnLHN0cm9rZWxpbmVjYXA6J3N0cm9rZUxpbmVjYXAnLCdzdHJva2UtbGluZWNhcCc6J3N0cm9rZUxpbmVjYXAnLHN0cm9rZWxpbmVqb2luOidzdHJva2VMaW5lam9pbicsJ3N0cm9rZS1saW5lam9pbic6J3N0cm9rZUxpbmVqb2luJyxzdHJva2VtaXRlcmxpbWl0OidzdHJva2VNaXRlcmxpbWl0Jywnc3Ryb2tlLW1pdGVybGltaXQnOidzdHJva2VNaXRlcmxpbWl0JyxzdHJva2V3aWR0aDonc3Ryb2tlV2lkdGgnLCdzdHJva2Utd2lkdGgnOidzdHJva2VXaWR0aCcsc3Ryb2tlb3BhY2l0eTonc3Ryb2tlT3BhY2l0eScsJ3N0cm9rZS1vcGFjaXR5Jzonc3Ryb2tlT3BhY2l0eScsc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOidzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzonc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxzdXJmYWNlc2NhbGU6J3N1cmZhY2VTY2FsZScsc3lzdGVtbGFuZ3VhZ2U6J3N5c3RlbUxhbmd1YWdlJyx0YWJsZXZhbHVlczondGFibGVWYWx1ZXMnLHRhcmdldHg6J3RhcmdldFgnLHRhcmdldHk6J3RhcmdldFknLHRleHRhbmNob3I6J3RleHRBbmNob3InLCd0ZXh0LWFuY2hvcic6J3RleHRBbmNob3InLHRleHRkZWNvcmF0aW9uOid0ZXh0RGVjb3JhdGlvbicsJ3RleHQtZGVjb3JhdGlvbic6J3RleHREZWNvcmF0aW9uJyx0ZXh0bGVuZ3RoOid0ZXh0TGVuZ3RoJyx0ZXh0cmVuZGVyaW5nOid0ZXh0UmVuZGVyaW5nJywndGV4dC1yZW5kZXJpbmcnOid0ZXh0UmVuZGVyaW5nJyx0bzondG8nLHRyYW5zZm9ybTondHJhbnNmb3JtJyx0eXBlb2Y6J3R5cGVvZicsdTE6J3UxJyx1MjondTInLHVuZGVybGluZXBvc2l0aW9uOid1bmRlcmxpbmVQb3NpdGlvbicsJ3VuZGVybGluZS1wb3NpdGlvbic6J3VuZGVybGluZVBvc2l0aW9uJyx1bmRlcmxpbmV0aGlja25lc3M6J3VuZGVybGluZVRoaWNrbmVzcycsJ3VuZGVybGluZS10aGlja25lc3MnOid1bmRlcmxpbmVUaGlja25lc3MnLHVuaWNvZGU6J3VuaWNvZGUnLHVuaWNvZGViaWRpOid1bmljb2RlQmlkaScsJ3VuaWNvZGUtYmlkaSc6J3VuaWNvZGVCaWRpJyx1bmljb2RlcmFuZ2U6J3VuaWNvZGVSYW5nZScsJ3VuaWNvZGUtcmFuZ2UnOid1bmljb2RlUmFuZ2UnLHVuaXRzcGVyZW06J3VuaXRzUGVyRW0nLCd1bml0cy1wZXItZW0nOid1bml0c1BlckVtJyx1bnNlbGVjdGFibGU6J3Vuc2VsZWN0YWJsZScsdmFscGhhYmV0aWM6J3ZBbHBoYWJldGljJywndi1hbHBoYWJldGljJzondkFscGhhYmV0aWMnLHZhbHVlczondmFsdWVzJyx2ZWN0b3JlZmZlY3Q6J3ZlY3RvckVmZmVjdCcsJ3ZlY3Rvci1lZmZlY3QnOid2ZWN0b3JFZmZlY3QnLHZlcnNpb246J3ZlcnNpb24nLHZlcnRhZHZ5Oid2ZXJ0QWR2WScsJ3ZlcnQtYWR2LXknOid2ZXJ0QWR2WScsdmVydG9yaWdpbng6J3ZlcnRPcmlnaW5YJywndmVydC1vcmlnaW4teCc6J3ZlcnRPcmlnaW5YJyx2ZXJ0b3JpZ2lueTondmVydE9yaWdpblknLCd2ZXJ0LW9yaWdpbi15JzondmVydE9yaWdpblknLHZoYW5naW5nOid2SGFuZ2luZycsJ3YtaGFuZ2luZyc6J3ZIYW5naW5nJyx2aWRlb2dyYXBoaWM6J3ZJZGVvZ3JhcGhpYycsJ3YtaWRlb2dyYXBoaWMnOid2SWRlb2dyYXBoaWMnLHZpZXdib3g6J3ZpZXdCb3gnLHZpZXd0YXJnZXQ6J3ZpZXdUYXJnZXQnLHZpc2liaWxpdHk6J3Zpc2liaWxpdHknLHZtYXRoZW1hdGljYWw6J3ZNYXRoZW1hdGljYWwnLCd2LW1hdGhlbWF0aWNhbCc6J3ZNYXRoZW1hdGljYWwnLHZvY2FiOid2b2NhYicsd2lkdGhzOid3aWR0aHMnLHdvcmRzcGFjaW5nOid3b3JkU3BhY2luZycsJ3dvcmQtc3BhY2luZyc6J3dvcmRTcGFjaW5nJyx3cml0aW5nbW9kZTond3JpdGluZ01vZGUnLCd3cml0aW5nLW1vZGUnOid3cml0aW5nTW9kZScseDE6J3gxJyx4MjoneDInLHg6J3gnLHhjaGFubmVsc2VsZWN0b3I6J3hDaGFubmVsU2VsZWN0b3InLHhoZWlnaHQ6J3hIZWlnaHQnLCd4LWhlaWdodCc6J3hIZWlnaHQnLHhsaW5rYWN0dWF0ZToneGxpbmtBY3R1YXRlJywneGxpbms6YWN0dWF0ZSc6J3hsaW5rQWN0dWF0ZScseGxpbmthcmNyb2xlOid4bGlua0FyY3JvbGUnLCd4bGluazphcmNyb2xlJzoneGxpbmtBcmNyb2xlJyx4bGlua2hyZWY6J3hsaW5rSHJlZicsJ3hsaW5rOmhyZWYnOid4bGlua0hyZWYnLHhsaW5rcm9sZToneGxpbmtSb2xlJywneGxpbms6cm9sZSc6J3hsaW5rUm9sZScseGxpbmtzaG93Oid4bGlua1Nob3cnLCd4bGluazpzaG93JzoneGxpbmtTaG93Jyx4bGlua3RpdGxlOid4bGlua1RpdGxlJywneGxpbms6dGl0bGUnOid4bGlua1RpdGxlJyx4bGlua3R5cGU6J3hsaW5rVHlwZScsJ3hsaW5rOnR5cGUnOid4bGlua1R5cGUnLHhtbGJhc2U6J3htbEJhc2UnLCd4bWw6YmFzZSc6J3htbEJhc2UnLHhtbGxhbmc6J3htbExhbmcnLCd4bWw6bGFuZyc6J3htbExhbmcnLHhtbG5zOid4bWxucycsJ3htbDpzcGFjZSc6J3htbFNwYWNlJyx4bWxuc3hsaW5rOid4bWxuc1hsaW5rJywneG1sbnM6eGxpbmsnOid4bWxuc1hsaW5rJyx4bWxzcGFjZToneG1sU3BhY2UnLHkxOid5MScseTI6J3kyJyx5Oid5Jyx5Y2hhbm5lbHNlbGVjdG9yOid5Q2hhbm5lbFNlbGVjdG9yJyx6Oid6Jyx6b29tYW5kcGFuOid6b29tQW5kUGFuJ307dmFyIGFyaWFQcm9wZXJ0aWVzPXsnYXJpYS1jdXJyZW50JzowLC8vIHN0YXRlXG4nYXJpYS1kZXNjcmlwdGlvbic6MCwnYXJpYS1kZXRhaWxzJzowLCdhcmlhLWRpc2FibGVkJzowLC8vIHN0YXRlXG4nYXJpYS1oaWRkZW4nOjAsLy8gc3RhdGVcbidhcmlhLWludmFsaWQnOjAsLy8gc3RhdGVcbidhcmlhLWtleXNob3J0Y3V0cyc6MCwnYXJpYS1sYWJlbCc6MCwnYXJpYS1yb2xlZGVzY3JpcHRpb24nOjAsLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbidhcmlhLWF1dG9jb21wbGV0ZSc6MCwnYXJpYS1jaGVja2VkJzowLCdhcmlhLWV4cGFuZGVkJzowLCdhcmlhLWhhc3BvcHVwJzowLCdhcmlhLWxldmVsJzowLCdhcmlhLW1vZGFsJzowLCdhcmlhLW11bHRpbGluZSc6MCwnYXJpYS1tdWx0aXNlbGVjdGFibGUnOjAsJ2FyaWEtb3JpZW50YXRpb24nOjAsJ2FyaWEtcGxhY2Vob2xkZXInOjAsJ2FyaWEtcHJlc3NlZCc6MCwnYXJpYS1yZWFkb25seSc6MCwnYXJpYS1yZXF1aXJlZCc6MCwnYXJpYS1zZWxlY3RlZCc6MCwnYXJpYS1zb3J0JzowLCdhcmlhLXZhbHVlbWF4JzowLCdhcmlhLXZhbHVlbWluJzowLCdhcmlhLXZhbHVlbm93JzowLCdhcmlhLXZhbHVldGV4dCc6MCwvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXG4nYXJpYS1hdG9taWMnOjAsJ2FyaWEtYnVzeSc6MCwnYXJpYS1saXZlJzowLCdhcmlhLXJlbGV2YW50JzowLC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuJ2FyaWEtZHJvcGVmZmVjdCc6MCwnYXJpYS1ncmFiYmVkJzowLC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4nYXJpYS1hY3RpdmVkZXNjZW5kYW50JzowLCdhcmlhLWNvbGNvdW50JzowLCdhcmlhLWNvbGluZGV4JzowLCdhcmlhLWNvbHNwYW4nOjAsJ2FyaWEtY29udHJvbHMnOjAsJ2FyaWEtZGVzY3JpYmVkYnknOjAsJ2FyaWEtZXJyb3JtZXNzYWdlJzowLCdhcmlhLWZsb3d0byc6MCwnYXJpYS1sYWJlbGxlZGJ5JzowLCdhcmlhLW93bnMnOjAsJ2FyaWEtcG9zaW5zZXQnOjAsJ2FyaWEtcm93Y291bnQnOjAsJ2FyaWEtcm93aW5kZXgnOjAsJ2FyaWEtcm93c3Bhbic6MCwnYXJpYS1zZXRzaXplJzowfTt2YXIgd2FybmVkUHJvcGVydGllcz17fTt2YXIgckFSSUE9bmV3IFJlZ0V4cCgnXihhcmlhKS1bJytBVFRSSUJVVEVfTkFNRV9DSEFSKyddKiQnKTt2YXIgckFSSUFDYW1lbD1uZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJytBVFRSSUJVVEVfTkFNRV9DSEFSKyddKiQnKTtmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsbmFtZSl7e2lmKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyxuYW1lKSYmd2FybmVkUHJvcGVydGllc1tuYW1lXSl7cmV0dXJuIHRydWU7fWlmKHJBUklBQ2FtZWwudGVzdChuYW1lKSl7dmFyIGFyaWFOYW1lPSdhcmlhLScrbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO3ZhciBjb3JyZWN0TmFtZT1hcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShhcmlhTmFtZSk/YXJpYU5hbWU6bnVsbDsvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbi8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbmlmKGNvcnJlY3ROYW1lPT1udWxsKXtlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuJyxuYW1lKTt3YXJuZWRQcm9wZXJ0aWVzW25hbWVdPXRydWU7cmV0dXJuIHRydWU7fS8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuaWYobmFtZSE9PWNvcnJlY3ROYW1lKXtlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLG5hbWUsY29ycmVjdE5hbWUpO3dhcm5lZFByb3BlcnRpZXNbbmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9fWlmKHJBUklBLnRlc3QobmFtZSkpe3ZhciBsb3dlckNhc2VkTmFtZT1uYW1lLnRvTG93ZXJDYXNlKCk7dmFyIHN0YW5kYXJkTmFtZT1hcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSk/bG93ZXJDYXNlZE5hbWU6bnVsbDsvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbi8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbmlmKHN0YW5kYXJkTmFtZT09bnVsbCl7d2FybmVkUHJvcGVydGllc1tuYW1lXT10cnVlO3JldHVybiBmYWxzZTt9Ly8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5pZihuYW1lIT09c3RhbmRhcmROYW1lKXtlcnJvcignVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLG5hbWUsc3RhbmRhcmROYW1lKTt3YXJuZWRQcm9wZXJ0aWVzW25hbWVdPXRydWU7cmV0dXJuIHRydWU7fX19cmV0dXJuIHRydWU7fWZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUscHJvcHMpe3t2YXIgaW52YWxpZFByb3BzPVtdO2Zvcih2YXIga2V5IGluIHByb3BzKXt2YXIgaXNWYWxpZD12YWxpZGF0ZVByb3BlcnR5KHR5cGUsa2V5KTtpZighaXNWYWxpZCl7aW52YWxpZFByb3BzLnB1c2goa2V5KTt9fXZhciB1bmtub3duUHJvcFN0cmluZz1pbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uKHByb3Ape3JldHVybidgJytwcm9wKydgJzt9KS5qb2luKCcsICcpO2lmKGludmFsaWRQcm9wcy5sZW5ndGg9PT0xKXtlcnJvcignSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuICcrJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsdW5rbm93blByb3BTdHJpbmcsdHlwZSk7fWVsc2UgaWYoaW52YWxpZFByb3BzLmxlbmd0aD4xKXtlcnJvcignSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnKydGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLHVua25vd25Qcm9wU3RyaW5nLHR5cGUpO319fWZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLHByb3BzKXtpZihpc0N1c3RvbUNvbXBvbmVudCh0eXBlLHByb3BzKSl7cmV0dXJuO313YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLHByb3BzKTt9dmFyIGRpZFdhcm5WYWx1ZU51bGw9ZmFsc2U7ZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSxwcm9wcyl7e2lmKHR5cGUhPT0naW5wdXQnJiZ0eXBlIT09J3RleHRhcmVhJyYmdHlwZSE9PSdzZWxlY3QnKXtyZXR1cm47fWlmKHByb3BzIT1udWxsJiZwcm9wcy52YWx1ZT09PW51bGwmJiFkaWRXYXJuVmFsdWVOdWxsKXtkaWRXYXJuVmFsdWVOdWxsPXRydWU7aWYodHlwZT09PSdzZWxlY3QnJiZwcm9wcy5tdWx0aXBsZSl7ZXJyb3IoJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJysnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJysndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJyx0eXBlKTt9ZWxzZXtlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnKydDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnKydmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJyx0eXBlKTt9fX19dmFyIHZhbGlkYXRlUHJvcGVydHkkMT1mdW5jdGlvbigpe307e3ZhciB3YXJuZWRQcm9wZXJ0aWVzJDE9e307dmFyIEVWRU5UX05BTUVfUkVHRVg9L15vbi4vO3ZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVg9L15vblteQS1aXS87dmFyIHJBUklBJDE9bmV3IFJlZ0V4cCgnXihhcmlhKS1bJytBVFRSSUJVVEVfTkFNRV9DSEFSKyddKiQnKTt2YXIgckFSSUFDYW1lbCQxPW5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnK0FUVFJJQlVURV9OQU1FX0NIQVIrJ10qJCcpO3ZhbGlkYXRlUHJvcGVydHkkMT1mdW5jdGlvbih0YWdOYW1lLG5hbWUsdmFsdWUsZXZlbnRSZWdpc3RyeSl7aWYoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsbmFtZSkmJndhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSl7cmV0dXJuIHRydWU7fXZhciBsb3dlckNhc2VkTmFtZT1uYW1lLnRvTG93ZXJDYXNlKCk7aWYobG93ZXJDYXNlZE5hbWU9PT0nb25mb2N1c2luJ3x8bG93ZXJDYXNlZE5hbWU9PT0nb25mb2N1c291dCcpe2Vycm9yKCdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJysnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnKydhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7d2FybmVkUHJvcGVydGllcyQxW25hbWVdPXRydWU7cmV0dXJuIHRydWU7fS8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuaWYoZXZlbnRSZWdpc3RyeSE9bnVsbCl7dmFyIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM9ZXZlbnRSZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM9ZXZlbnRSZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO2lmKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkobmFtZSkpe3JldHVybiB0cnVlO312YXIgcmVnaXN0cmF0aW9uTmFtZT1wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKT9wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXTpudWxsO2lmKHJlZ2lzdHJhdGlvbk5hbWUhPW51bGwpe2Vycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JyxuYW1lLHJlZ2lzdHJhdGlvbk5hbWUpO3dhcm5lZFByb3BlcnRpZXMkMVtuYW1lXT10cnVlO3JldHVybiB0cnVlO31pZihFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpe2Vycm9yKCdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLicsbmFtZSk7d2FybmVkUHJvcGVydGllcyQxW25hbWVdPXRydWU7cmV0dXJuIHRydWU7fX1lbHNlIGlmKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSl7Ly8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbi8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbi8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbmlmKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKXtlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuICcrJ1JlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLicsbmFtZSk7fXdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXT10cnVlO3JldHVybiB0cnVlO30vLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG5pZihyQVJJQSQxLnRlc3QobmFtZSl8fHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKXtyZXR1cm4gdHJ1ZTt9aWYobG93ZXJDYXNlZE5hbWU9PT0naW5uZXJodG1sJyl7ZXJyb3IoJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJysnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7d2FybmVkUHJvcGVydGllcyQxW25hbWVdPXRydWU7cmV0dXJuIHRydWU7fWlmKGxvd2VyQ2FzZWROYW1lPT09J2FyaWEnKXtlcnJvcignVGhlIGBhcmlhYCBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgaW4gUmVhY3QuICcrJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTt3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9aWYobG93ZXJDYXNlZE5hbWU9PT0naXMnJiZ2YWx1ZSE9PW51bGwmJnZhbHVlIT09dW5kZWZpbmVkJiZ0eXBlb2YgdmFsdWUhPT0nc3RyaW5nJyl7ZXJyb3IoJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJysndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsdHlwZW9mIHZhbHVlKTt3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9aWYodHlwZW9mIHZhbHVlPT09J251bWJlcicmJmlzTmFOKHZhbHVlKSl7ZXJyb3IoJ1JlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcrJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLG5hbWUpO3dhcm5lZFByb3BlcnRpZXMkMVtuYW1lXT10cnVlO3JldHVybiB0cnVlO312YXIgcHJvcGVydHlJbmZvPWdldFByb3BlcnR5SW5mbyhuYW1lKTt2YXIgaXNSZXNlcnZlZD1wcm9wZXJ0eUluZm8hPT1udWxsJiZwcm9wZXJ0eUluZm8udHlwZT09PVJFU0VSVkVEOy8vIEtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIG1hdGNoIHRoZSBjYXNpbmcgc3BlY2lmaWVkIGluIHRoZSBwcm9wZXJ0eSBjb25maWcuXG5pZihwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKXt2YXIgc3RhbmRhcmROYW1lPXBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07aWYoc3RhbmRhcmROYW1lIT09bmFtZSl7ZXJyb3IoJ0ludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsbmFtZSxzdGFuZGFyZE5hbWUpO3dhcm5lZFByb3BlcnRpZXMkMVtuYW1lXT10cnVlO3JldHVybiB0cnVlO319ZWxzZSBpZighaXNSZXNlcnZlZCYmbmFtZSE9PWxvd2VyQ2FzZWROYW1lKXsvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbi8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbmVycm9yKCdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJysnaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tICcrJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJysnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnKydpdCBmcm9tIHRoZSBET00gZWxlbWVudC4nLG5hbWUsbG93ZXJDYXNlZE5hbWUpO3dhcm5lZFByb3BlcnRpZXMkMVtuYW1lXT10cnVlO3JldHVybiB0cnVlO31pZih0eXBlb2YgdmFsdWU9PT0nYm9vbGVhbicmJnNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsdmFsdWUscHJvcGVydHlJbmZvLGZhbHNlKSl7aWYodmFsdWUpe2Vycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicrJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJysnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4nLHZhbHVlLG5hbWUsbmFtZSx2YWx1ZSxuYW1lKTt9ZWxzZXtlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nKydJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcrJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJysnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcrJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicsdmFsdWUsbmFtZSxuYW1lLHZhbHVlLG5hbWUsbmFtZSxuYW1lKTt9d2FybmVkUHJvcGVydGllcyQxW25hbWVdPXRydWU7cmV0dXJuIHRydWU7fS8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcbmlmKGlzUmVzZXJ2ZWQpe3JldHVybiB0cnVlO30vLyBXYXJuIHdoZW4gYSBrbm93biBhdHRyaWJ1dGUgaXMgYSBiYWQgdHlwZVxuaWYoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSx2YWx1ZSxwcm9wZXJ0eUluZm8sZmFsc2UpKXt3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV09dHJ1ZTtyZXR1cm4gZmFsc2U7fS8vIFdhcm4gd2hlbiBwYXNzaW5nIHRoZSBzdHJpbmdzICdmYWxzZScgb3IgJ3RydWUnIGludG8gYSBib29sZWFuIHByb3BcbmlmKCh2YWx1ZT09PSdmYWxzZSd8fHZhbHVlPT09J3RydWUnKSYmcHJvcGVydHlJbmZvIT09bnVsbCYmcHJvcGVydHlJbmZvLnR5cGU9PT1CT09MRUFOKXtlcnJvcignUmVjZWl2ZWQgdGhlIHN0cmluZyBgJXNgIGZvciB0aGUgYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC4gJysnJXMgJysnRGlkIHlvdSBtZWFuICVzPXslc30/Jyx2YWx1ZSxuYW1lLHZhbHVlPT09J2ZhbHNlJz8nVGhlIGJyb3dzZXIgd2lsbCBpbnRlcnByZXQgaXQgYXMgYSB0cnV0aHkgdmFsdWUuJzonQWx0aG91Z2ggdGhpcyB3b3JrcywgaXQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpZiB5b3UgcGFzcyB0aGUgc3RyaW5nIFwiZmFsc2VcIi4nLG5hbWUsdmFsdWUpO3dhcm5lZFByb3BlcnRpZXMkMVtuYW1lXT10cnVlO3JldHVybiB0cnVlO31yZXR1cm4gdHJ1ZTt9O312YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzPWZ1bmN0aW9uKHR5cGUscHJvcHMsZXZlbnRSZWdpc3RyeSl7e3ZhciB1bmtub3duUHJvcHM9W107Zm9yKHZhciBrZXkgaW4gcHJvcHMpe3ZhciBpc1ZhbGlkPXZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLGtleSxwcm9wc1trZXldLGV2ZW50UmVnaXN0cnkpO2lmKCFpc1ZhbGlkKXt1bmtub3duUHJvcHMucHVzaChrZXkpO319dmFyIHVua25vd25Qcm9wU3RyaW5nPXVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24ocHJvcCl7cmV0dXJuJ2AnK3Byb3ArJ2AnO30pLmpvaW4oJywgJyk7aWYodW5rbm93blByb3BzLmxlbmd0aD09PTEpe2Vycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcrJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gJysnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsdW5rbm93blByb3BTdHJpbmcsdHlwZSk7fWVsc2UgaWYodW5rbm93blByb3BzLmxlbmd0aD4xKXtlcnJvcignSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJysnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcrJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLHVua25vd25Qcm9wU3RyaW5nLHR5cGUpO319fTtmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLHByb3BzLGV2ZW50UmVnaXN0cnkpe2lmKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUscHJvcHMpKXtyZXR1cm47fXdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLHByb3BzLGV2ZW50UmVnaXN0cnkpO312YXIgSVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREU9MTt2YXIgSVNfTk9OX0RFTEVHQVRFRD0xPDwxO3ZhciBJU19DQVBUVVJFX1BIQVNFPTE8PDI7Ly8gc2V0IHRvIExFR0FDWV9GQl9TVVBQT1JULiBMRUdBQ1lfRkJfU1VQUE9SVCBvbmx5IGdldHMgc2V0IHdoZW5cbi8vIHdlIGNhbGwgd2lsbERlZmVyTGF0ZXJGb3JMZWdhY3lGQlN1cHBvcnQsIHRodXMgbm90IGJhaWxpbmcgb3V0XG4vLyB3aWxsIHJlc3VsdCBpbiBlbmRsZXNzIGN5Y2xlcyBsaWtlIGFuIGluZmluaXRlIGxvb3AuXG4vLyBXZSBhbHNvIGRvbid0IHdhbnQgdG8gZGVmZXIgZHVyaW5nIGV2ZW50IHJlcGxheWluZy5cbnZhciBTSE9VTERfTk9UX1BST0NFU1NfUE9MWUZJTExfRVZFTlRfUExVR0lOUz1JU19FVkVOVF9IQU5ETEVfTk9OX01BTkFHRURfTk9ERXxJU19OT05fREVMRUdBVEVEfElTX0NBUFRVUkVfUEhBU0U7Ly8gVGhpcyBleGlzdHMgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIFJlYWN0RE9NRXZlbnRSZXBsYXlpbmdcbi8vIGFuZCBET01QbHVnaW5FdmVudFN5c3RlbS5cbnZhciBjdXJyZW50UmVwbGF5aW5nRXZlbnQ9bnVsbDtmdW5jdGlvbiBzZXRSZXBsYXlpbmdFdmVudChldmVudCl7e2lmKGN1cnJlbnRSZXBsYXlpbmdFdmVudCE9PW51bGwpe2Vycm9yKCdFeHBlY3RlZCBjdXJyZW50bHkgcmVwbGF5aW5nIGV2ZW50IHRvIGJlIG51bGwuIFRoaXMgZXJyb3IgJysnaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fX1jdXJyZW50UmVwbGF5aW5nRXZlbnQ9ZXZlbnQ7fWZ1bmN0aW9uIHJlc2V0UmVwbGF5aW5nRXZlbnQoKXt7aWYoY3VycmVudFJlcGxheWluZ0V2ZW50PT09bnVsbCl7ZXJyb3IoJ0V4cGVjdGVkIGN1cnJlbnRseSByZXBsYXlpbmcgZXZlbnQgdG8gbm90IGJlIG51bGwuIFRoaXMgZXJyb3IgJysnaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fX1jdXJyZW50UmVwbGF5aW5nRXZlbnQ9bnVsbDt9ZnVuY3Rpb24gaXNSZXBsYXlpbmdFdmVudChldmVudCl7cmV0dXJuIGV2ZW50PT09Y3VycmVudFJlcGxheWluZ0V2ZW50O30vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpey8vIEZhbGxiYWNrIHRvIG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgZm9yIElFOVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwNlxudmFyIHRhcmdldD1uYXRpdmVFdmVudC50YXJnZXR8fG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnR8fHdpbmRvdzsvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG5pZih0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpe3RhcmdldD10YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7fS8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4vLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxucmV0dXJuIHRhcmdldC5ub2RlVHlwZT09PVRFWFRfTk9ERT90YXJnZXQucGFyZW50Tm9kZTp0YXJnZXQ7fXZhciByZXN0b3JlSW1wbD1udWxsO3ZhciByZXN0b3JlVGFyZ2V0PW51bGw7dmFyIHJlc3RvcmVRdWV1ZT1udWxsO2Z1bmN0aW9uIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCl7Ly8gV2UgcGVyZm9ybSB0aGlzIHRyYW5zbGF0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50IGxvb3Agc28gdGhhdCB3ZVxuLy8gYWx3YXlzIHJlY2VpdmUgdGhlIGNvcnJlY3QgZmliZXIgaGVyZVxudmFyIGludGVybmFsSW5zdGFuY2U9Z2V0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXQpO2lmKCFpbnRlcm5hbEluc3RhbmNlKXsvLyBVbm1vdW50ZWRcbnJldHVybjt9aWYodHlwZW9mIHJlc3RvcmVJbXBsIT09J2Z1bmN0aW9uJyl7dGhyb3cgbmV3IEVycm9yKCdzZXRSZXN0b3JlSW1wbGVtZW50YXRpb24oKSBuZWVkcyB0byBiZSBjYWxsZWQgdG8gaGFuZGxlIGEgdGFyZ2V0IGZvciBjb250cm9sbGVkICcrJ2V2ZW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9dmFyIHN0YXRlTm9kZT1pbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZTsvLyBHdWFyZCBhZ2FpbnN0IEZpYmVyIGJlaW5nIHVubW91bnRlZC5cbmlmKHN0YXRlTm9kZSl7dmFyIF9wcm9wcz1nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKHN0YXRlTm9kZSk7cmVzdG9yZUltcGwoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUsaW50ZXJuYWxJbnN0YW5jZS50eXBlLF9wcm9wcyk7fX1mdW5jdGlvbiBzZXRSZXN0b3JlSW1wbGVtZW50YXRpb24oaW1wbCl7cmVzdG9yZUltcGw9aW1wbDt9ZnVuY3Rpb24gZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpe2lmKHJlc3RvcmVUYXJnZXQpe2lmKHJlc3RvcmVRdWV1ZSl7cmVzdG9yZVF1ZXVlLnB1c2godGFyZ2V0KTt9ZWxzZXtyZXN0b3JlUXVldWU9W3RhcmdldF07fX1lbHNle3Jlc3RvcmVUYXJnZXQ9dGFyZ2V0O319ZnVuY3Rpb24gbmVlZHNTdGF0ZVJlc3RvcmUoKXtyZXR1cm4gcmVzdG9yZVRhcmdldCE9PW51bGx8fHJlc3RvcmVRdWV1ZSE9PW51bGw7fWZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCl7aWYoIXJlc3RvcmVUYXJnZXQpe3JldHVybjt9dmFyIHRhcmdldD1yZXN0b3JlVGFyZ2V0O3ZhciBxdWV1ZWRUYXJnZXRzPXJlc3RvcmVRdWV1ZTtyZXN0b3JlVGFyZ2V0PW51bGw7cmVzdG9yZVF1ZXVlPW51bGw7cmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KTtpZihxdWV1ZWRUYXJnZXRzKXtmb3IodmFyIGk9MDtpPHF1ZXVlZFRhcmdldHMubGVuZ3RoO2krKyl7cmVzdG9yZVN0YXRlT2ZUYXJnZXQocXVldWVkVGFyZ2V0c1tpXSk7fX19Ly8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG4vLyBEZWZhdWx0c1xudmFyIGJhdGNoZWRVcGRhdGVzSW1wbD1mdW5jdGlvbihmbixib29ra2VlcGluZyl7cmV0dXJuIGZuKGJvb2trZWVwaW5nKTt9O3ZhciBmbHVzaFN5bmNJbXBsPWZ1bmN0aW9uKCl7fTt2YXIgaXNJbnNpZGVFdmVudEhhbmRsZXI9ZmFsc2U7ZnVuY3Rpb24gZmluaXNoRXZlbnRIYW5kbGVyKCl7Ly8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4vLyB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjk4XG4vLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxudmFyIGNvbnRyb2xsZWRDb21wb25lbnRzSGF2ZVBlbmRpbmdVcGRhdGVzPW5lZWRzU3RhdGVSZXN0b3JlKCk7aWYoY29udHJvbGxlZENvbXBvbmVudHNIYXZlUGVuZGluZ1VwZGF0ZXMpey8vIElmIGEgY29udHJvbGxlZCBldmVudCB3YXMgZmlyZWQsIHdlIG1heSBuZWVkIHRvIHJlc3RvcmUgdGhlIHN0YXRlIG9mXG4vLyB0aGUgRE9NIG5vZGUgYmFjayB0byB0aGUgY29udHJvbGxlZCB2YWx1ZS4gVGhpcyBpcyBuZWNlc3Nhcnkgd2hlbiBSZWFjdFxuLy8gYmFpbHMgb3V0IG9mIHRoZSB1cGRhdGUgd2l0aG91dCB0b3VjaGluZyB0aGUgRE9NLlxuLy8gVE9ETzogUmVzdG9yZSBzdGF0ZSBpbiB0aGUgbWljcm90YXNrLCBhZnRlciB0aGUgZGlzY3JldGUgdXBkYXRlcyBmbHVzaCxcbi8vIGluc3RlYWQgb2YgZWFybHkgZmx1c2hpbmcgdGhlbSBoZXJlLlxuZmx1c2hTeW5jSW1wbCgpO3Jlc3RvcmVTdGF0ZUlmTmVlZGVkKCk7fX1mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbixhLGIpe2lmKGlzSW5zaWRlRXZlbnRIYW5kbGVyKXsvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbi8vIGZ1bGx5IGNvbXBsZXRlcyBiZWZvcmUgcmVzdG9yaW5nIHN0YXRlLlxucmV0dXJuIGZuKGEsYik7fWlzSW5zaWRlRXZlbnRIYW5kbGVyPXRydWU7dHJ5e3JldHVybiBiYXRjaGVkVXBkYXRlc0ltcGwoZm4sYSxiKTt9ZmluYWxseXtpc0luc2lkZUV2ZW50SGFuZGxlcj1mYWxzZTtmaW5pc2hFdmVudEhhbmRsZXIoKTt9fS8vIFRPRE86IFJlcGxhY2Ugd2l0aCBmbHVzaFN5bmNcbmZ1bmN0aW9uIHNldEJhdGNoaW5nSW1wbGVtZW50YXRpb24oX2JhdGNoZWRVcGRhdGVzSW1wbCxfZGlzY3JldGVVcGRhdGVzSW1wbCxfZmx1c2hTeW5jSW1wbCl7YmF0Y2hlZFVwZGF0ZXNJbXBsPV9iYXRjaGVkVXBkYXRlc0ltcGw7Zmx1c2hTeW5jSW1wbD1fZmx1c2hTeW5jSW1wbDt9ZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpe3JldHVybiB0YWc9PT0nYnV0dG9uJ3x8dGFnPT09J2lucHV0J3x8dGFnPT09J3NlbGVjdCd8fHRhZz09PSd0ZXh0YXJlYSc7fWZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsdHlwZSxwcm9wcyl7c3dpdGNoKG5hbWUpe2Nhc2Unb25DbGljayc6Y2FzZSdvbkNsaWNrQ2FwdHVyZSc6Y2FzZSdvbkRvdWJsZUNsaWNrJzpjYXNlJ29uRG91YmxlQ2xpY2tDYXB0dXJlJzpjYXNlJ29uTW91c2VEb3duJzpjYXNlJ29uTW91c2VEb3duQ2FwdHVyZSc6Y2FzZSdvbk1vdXNlTW92ZSc6Y2FzZSdvbk1vdXNlTW92ZUNhcHR1cmUnOmNhc2Unb25Nb3VzZVVwJzpjYXNlJ29uTW91c2VVcENhcHR1cmUnOmNhc2Unb25Nb3VzZUVudGVyJzpyZXR1cm4hIShwcm9wcy5kaXNhYmxlZCYmaXNJbnRlcmFjdGl2ZSh0eXBlKSk7ZGVmYXVsdDpyZXR1cm4gZmFsc2U7fX0vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gKi9mdW5jdGlvbiBnZXRMaXN0ZW5lcihpbnN0LHJlZ2lzdHJhdGlvbk5hbWUpe3ZhciBzdGF0ZU5vZGU9aW5zdC5zdGF0ZU5vZGU7aWYoc3RhdGVOb2RlPT09bnVsbCl7Ly8gV29yayBpbiBwcm9ncmVzcyAoZXg6IG9ubG9hZCBldmVudHMgaW4gaW5jcmVtZW50YWwgbW9kZSkuXG5yZXR1cm4gbnVsbDt9dmFyIHByb3BzPWdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtpZihwcm9wcz09PW51bGwpey8vIFdvcmsgaW4gcHJvZ3Jlc3MuXG5yZXR1cm4gbnVsbDt9dmFyIGxpc3RlbmVyPXByb3BzW3JlZ2lzdHJhdGlvbk5hbWVdO2lmKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsaW5zdC50eXBlLHByb3BzKSl7cmV0dXJuIG51bGw7fWlmKGxpc3RlbmVyJiZ0eXBlb2YgbGlzdGVuZXIhPT0nZnVuY3Rpb24nKXt0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBgXCIrcmVnaXN0cmF0aW9uTmFtZStcImAgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgXCIrdHlwZW9mIGxpc3RlbmVyK1wiYCB0eXBlLlwiKTt9cmV0dXJuIGxpc3RlbmVyO312YXIgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQ9ZmFsc2U7Ly8gQ2hlY2sgaWYgYnJvd3NlciBzdXBwb3J0IGV2ZW50cyB3aXRoIHBhc3NpdmUgbGlzdGVuZXJzXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG5pZihjYW5Vc2VET00pe3RyeXt2YXIgb3B0aW9ucz17fTsvLyAkRmxvd0ZpeE1lOiBJZ25vcmUgRmxvdyBjb21wbGFpbmluZyBhYm91dCBuZWVkaW5nIGEgdmFsdWVcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRpb25zLCdwYXNzaXZlJyx7Z2V0OmZ1bmN0aW9uKCl7cGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQ9dHJ1ZTt9fSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLG9wdGlvbnMsb3B0aW9ucyk7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLG9wdGlvbnMsb3B0aW9ucyk7fWNhdGNoKGUpe3Bhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkPWZhbHNlO319ZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZChuYW1lLGZ1bmMsY29udGV4dCxhLGIsYyxkLGUsZil7dmFyIGZ1bmNBcmdzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywzKTt0cnl7ZnVuYy5hcHBseShjb250ZXh0LGZ1bmNBcmdzKTt9Y2F0Y2goZXJyb3Ipe3RoaXMub25FcnJvcihlcnJvcik7fX12YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbD1pbnZva2VHdWFyZGVkQ2FsbGJhY2tQcm9kO3svLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuLy8gdGhhdCBwbGF5cyBtb3JlIG5pY2VseSB3aXRoIHRoZSBicm93c2VyJ3MgRGV2VG9vbHMuIFRoZSBpZGVhIGlzIHRvIHByZXNlcnZlXG4vLyBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvci4gQmVjYXVzZSBSZWFjdCB3cmFwcyBhbGwgdXNlci1wcm92aWRlZFxuLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2Zcbi8vIGludm9rZUd1YXJkZWRDYWxsYmFjayB1c2VzIGEgdHJ5LWNhdGNoLCBhbGwgdXNlciBleGNlcHRpb25zIGFyZSB0cmVhdGVkXG4vLyBsaWtlIGNhdWdodCBleGNlcHRpb25zLCBhbmQgdGhlIERldlRvb2xzIHdvbid0IHBhdXNlIHVubGVzcyB0aGUgZGV2ZWxvcGVyXG4vLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuLy8gdW5pbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuLy8gdGhlIGRldmVsb3BlcidzIHBlcnNwZWN0aXZlLCB0aGUgZXJyb3IgaXMgdW5jYXVnaHQuXG4vL1xuLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuLy8gdHJ5LWNhdGNoIGluIERFVi4gSW5zdGVhZCwgd2Ugc3luY2hyb25vdXNseSBkaXNwYXRjaCBhIGZha2UgZXZlbnQgdG8gYSBmYWtlXG4vLyBET00gbm9kZSwgYW5kIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlclxuLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuLy8gYSBnbG9iYWwgZXZlbnQgaGFuZGxlci4gQnV0IGJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbnMgaW4gYSBkaWZmZXJlbnRcbi8vIGV2ZW50IGxvb3AgY29udGV4dCwgaXQgZG9lcyBub3QgaW50ZXJydXB0IHRoZSBub3JtYWwgcHJvZ3JhbSBmbG93LlxuLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbi8vIHRyeS1jYXRjaC4gTmVhdCFcbi8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbi8vIERFViB2ZXJzaW9uIG9mIGludm9rZUd1YXJkZWRDYWxsYmFja1xuaWYodHlwZW9mIHdpbmRvdyE9PSd1bmRlZmluZWQnJiZ0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQ9PT0nZnVuY3Rpb24nJiZ0eXBlb2YgZG9jdW1lbnQhPT0ndW5kZWZpbmVkJyYmdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50PT09J2Z1bmN0aW9uJyl7dmFyIGZha2VOb2RlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7aW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbD1mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYobmFtZSxmdW5jLGNvbnRleHQsYSxiLGMsZCxlLGYpey8vIElmIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3Qgd2Uga25vdyBmb3Igc3VyZSB3ZSB3aWxsIGNyYXNoIGluIHRoaXMgbWV0aG9kXG4vLyB3aGVuIHdlIGNhbGwgZG9jdW1lbnQuY3JlYXRlRXZlbnQoKS4gSG93ZXZlciB0aGlzIGNhbiBjYXVzZSBjb25mdXNpbmdcbi8vIGVycm9yczogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NyZWF0ZS1yZWFjdC1hcHAvaXNzdWVzLzM0ODJcbi8vIFNvIHdlIHByZWVtcHRpdmVseSB0aHJvdyB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UgaW5zdGVhZC5cbmlmKHR5cGVvZiBkb2N1bWVudD09PSd1bmRlZmluZWQnfHxkb2N1bWVudD09PW51bGwpe3Rocm93IG5ldyBFcnJvcignVGhlIGBkb2N1bWVudGAgZ2xvYmFsIHdhcyBkZWZpbmVkIHdoZW4gUmVhY3Qgd2FzIGluaXRpYWxpemVkLCBidXQgaXMgbm90ICcrJ2RlZmluZWQgYW55bW9yZS4gVGhpcyBjYW4gaGFwcGVuIGluIGEgdGVzdCBlbnZpcm9ubWVudCBpZiBhIGNvbXBvbmVudCAnKydzY2hlZHVsZXMgYW4gdXBkYXRlIGZyb20gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLCBidXQgdGhlIHRlc3QgaGFzIGFscmVhZHkgJysnZmluaXNoZWQgcnVubmluZy4gVG8gc29sdmUgdGhpcywgeW91IGNhbiBlaXRoZXIgdW5tb3VudCB0aGUgY29tcG9uZW50IGF0ICcrJ3RoZSBlbmQgb2YgeW91ciB0ZXN0IChhbmQgZW5zdXJlIHRoYXQgYW55IGFzeW5jaHJvbm91cyBvcGVyYXRpb25zIGdldCAnKydjYW5jZWxlZCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgKSwgb3IgeW91IGNhbiBjaGFuZ2UgdGhlIHRlc3QgaXRzZWxmICcrJ3RvIGJlIGFzeW5jaHJvbm91cy4nKTt9dmFyIGV2dD1kb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTt2YXIgZGlkQ2FsbD1mYWxzZTsvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4vLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbi8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG52YXIgZGlkRXJyb3I9dHJ1ZTsvLyBLZWVwcyB0cmFjayBvZiB0aGUgdmFsdWUgb2Ygd2luZG93LmV2ZW50IHNvIHRoYXQgd2UgY2FuIHJlc2V0IGl0XG4vLyBkdXJpbmcgdGhlIGNhbGxiYWNrIHRvIGxldCB1c2VyIGNvZGUgYWNjZXNzIHdpbmRvdy5ldmVudCBpbiB0aGVcbi8vIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdC5cbnZhciB3aW5kb3dFdmVudD13aW5kb3cuZXZlbnQ7Ly8gS2VlcHMgdHJhY2sgb2YgdGhlIGRlc2NyaXB0b3Igb2Ygd2luZG93LmV2ZW50IHRvIHJlc3RvcmUgaXQgYWZ0ZXIgZXZlbnRcbi8vIGRpc3BhdGNoaW5nOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjg4XG52YXIgd2luZG93RXZlbnREZXNjcmlwdG9yPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93LCdldmVudCcpO2Z1bmN0aW9uIHJlc3RvcmVBZnRlckRpc3BhdGNoKCl7Ly8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4vLyBuZXN0ZWQgYGludm9rZUd1YXJkZWRDYWxsYmFja2AgY2FsbHMgZG8gbm90IGNsYXNoLiBPdGhlcndpc2UsIGFcbi8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4vLyBpbiB0aGUgc3RhY2suXG5mYWtlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsY2FsbENhbGxiYWNrLGZhbHNlKTsvLyBXZSBjaGVjayBmb3Igd2luZG93Lmhhc093blByb3BlcnR5KCdldmVudCcpIHRvIHByZXZlbnQgdGhlXG4vLyB3aW5kb3cuZXZlbnQgYXNzaWdubWVudCBpbiBib3RoIElFIDw9IDEwIGFzIHRoZXkgdGhyb3cgYW4gZXJyb3Jcbi8vIFwiTWVtYmVyIG5vdCBmb3VuZFwiIGluIHN0cmljdCBtb2RlLCBhbmQgaW4gRmlyZWZveCB3aGljaCBkb2VzIG5vdFxuLy8gc3VwcG9ydCB3aW5kb3cuZXZlbnQuXG5pZih0eXBlb2Ygd2luZG93LmV2ZW50IT09J3VuZGVmaW5lZCcmJndpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSl7d2luZG93LmV2ZW50PXdpbmRvd0V2ZW50O319Ly8gQ3JlYXRlIGFuIGV2ZW50IGhhbmRsZXIgZm9yIG91ciBmYWtlIGV2ZW50LiBXZSB3aWxsIHN5bmNocm9ub3VzbHlcbi8vIGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50IHVzaW5nIGBkaXNwYXRjaEV2ZW50YC4gSW5zaWRlIHRoZSBoYW5kbGVyLCB3ZVxuLy8gY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjay5cbnZhciBmdW5jQXJncz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMyk7ZnVuY3Rpb24gY2FsbENhbGxiYWNrKCl7ZGlkQ2FsbD10cnVlO3Jlc3RvcmVBZnRlckRpc3BhdGNoKCk7ZnVuYy5hcHBseShjb250ZXh0LGZ1bmNBcmdzKTtkaWRFcnJvcj1mYWxzZTt9Ly8gQ3JlYXRlIGEgZ2xvYmFsIGVycm9yIGV2ZW50IGhhbmRsZXIuIFdlIHVzZSB0aGlzIHRvIGNhcHR1cmUgdGhlIHZhbHVlXG4vLyB0aGF0IHdhcyB0aHJvd24uIEl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGVycm9yIGhhbmRsZXIgd2lsbCBmaXJlIG1vcmVcbi8vIHRoYW4gb25jZTsgZm9yIGV4YW1wbGUsIGlmIG5vbi1SZWFjdCBjb2RlIGFsc28gY2FsbHMgYGRpc3BhdGNoRXZlbnRgXG4vLyBhbmQgYSBoYW5kbGVyIGZvciB0aGF0IGV2ZW50IHRocm93cy4gV2Ugc2hvdWxkIGJlIHJlc2lsaWVudCB0byBtb3N0IG9mXG4vLyB0aG9zZSBjYXNlcy4gRXZlbiBpZiBvdXIgZXJyb3IgZXZlbnQgaGFuZGxlciBmaXJlcyBtb3JlIHRoYW4gb25jZSwgdGhlXG4vLyBsYXN0IGVycm9yIGV2ZW50IGlzIGFsd2F5cyB1c2VkLiBJZiB0aGUgY2FsbGJhY2sgYWN0dWFsbHkgZG9lcyBlcnJvcixcbi8vIHdlIGtub3cgdGhhdCB0aGUgbGFzdCBlcnJvciBldmVudCBpcyB0aGUgY29ycmVjdCBvbmUsIGJlY2F1c2UgaXQncyBub3Rcbi8vIHBvc3NpYmxlIGZvciBhbnl0aGluZyBlbHNlIHRvIGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiBvdXIgY2FsbGJhY2tcbi8vIGVycm9yaW5nIGFuZCB0aGUgY29kZSB0aGF0IGZvbGxvd3MgdGhlIGBkaXNwYXRjaEV2ZW50YCBjYWxsIGJlbG93LiBJZlxuLy8gdGhlIGNhbGxiYWNrIGRvZXNuJ3QgZXJyb3IsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgd2FzIGZpcmVkLCB3ZSBrbm93IHRvXG4vLyBpZ25vcmUgaXQgYmVjYXVzZSBgZGlkRXJyb3JgIHdpbGwgYmUgZmFsc2UsIGFzIGRlc2NyaWJlZCBhYm92ZS5cbnZhciBlcnJvcjsvLyBVc2UgdGhpcyB0byB0cmFjayB3aGV0aGVyIHRoZSBlcnJvciBldmVudCBpcyBldmVyIGNhbGxlZC5cbnZhciBkaWRTZXRFcnJvcj1mYWxzZTt2YXIgaXNDcm9zc09yaWdpbkVycm9yPWZhbHNlO2Z1bmN0aW9uIGhhbmRsZVdpbmRvd0Vycm9yKGV2ZW50KXtlcnJvcj1ldmVudC5lcnJvcjtkaWRTZXRFcnJvcj10cnVlO2lmKGVycm9yPT09bnVsbCYmZXZlbnQuY29sbm89PT0wJiZldmVudC5saW5lbm89PT0wKXtpc0Nyb3NzT3JpZ2luRXJyb3I9dHJ1ZTt9aWYoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCl7Ly8gU29tZSBvdGhlciBlcnJvciBoYW5kbGVyIGhhcyBwcmV2ZW50ZWQgZGVmYXVsdC5cbi8vIEJyb3dzZXJzIHNpbGVuY2UgdGhlIGVycm9yIHJlcG9ydCBpZiB0aGlzIGhhcHBlbnMuXG4vLyBXZSdsbCByZW1lbWJlciB0aGlzIHRvIGxhdGVyIGRlY2lkZSB3aGV0aGVyIHRvIGxvZyBpdCBvciBub3QuXG5pZihlcnJvciE9bnVsbCYmdHlwZW9mIGVycm9yPT09J29iamVjdCcpe3RyeXtlcnJvci5fc3VwcHJlc3NMb2dnaW5nPXRydWU7fWNhdGNoKGlubmVyKXsvLyBJZ25vcmUuXG59fX19Ly8gQ3JlYXRlIGEgZmFrZSBldmVudCB0eXBlLlxudmFyIGV2dFR5cGU9XCJyZWFjdC1cIisobmFtZT9uYW1lOidpbnZva2VndWFyZGVkY2FsbGJhY2snKTsvLyBBdHRhY2ggb3VyIGV2ZW50IGhhbmRsZXJzXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLGhhbmRsZVdpbmRvd0Vycm9yKTtmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsY2FsbENhbGxiYWNrLGZhbHNlKTsvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuZXZ0LmluaXRFdmVudChldnRUeXBlLGZhbHNlLGZhbHNlKTtmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7aWYod2luZG93RXZlbnREZXNjcmlwdG9yKXtPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCdldmVudCcsd2luZG93RXZlbnREZXNjcmlwdG9yKTt9aWYoZGlkQ2FsbCYmZGlkRXJyb3Ipe2lmKCFkaWRTZXRFcnJvcil7Ly8gVGhlIGNhbGxiYWNrIGVycm9yZWQsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgbmV2ZXIgZmlyZWQuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuZXJyb3I9bmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJytcImRvZXNuJ3Qga25vdyB3aGF0IGl0IHdhcy4gVGhpcyBpcyBsaWtlbHkgZHVlIHRvIGJyb3dzZXIgXCIrJ2ZsYWtpbmVzcy4gUmVhY3QgZG9lcyBpdHMgYmVzdCB0byBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiAnKydleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcrXCJERVYtbW9kZSBvbmx5IHRyaWNrcy4gSXQncyBwb3NzaWJsZSB0aGF0IHRoZXNlIGRvbid0IHdvcmsgaW4gXCIrJ3lvdXIgYnJvd3Nlci4gVHJ5IHRyaWdnZXJpbmcgdGhlIGVycm9yIGluIHByb2R1Y3Rpb24gbW9kZSwgJysnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnKydhY3R1YWxseSBhbiBpc3N1ZSB3aXRoIFJlYWN0LCBwbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9ZWxzZSBpZihpc0Nyb3NzT3JpZ2luRXJyb3Ipey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG5lcnJvcj1uZXcgRXJyb3IoXCJBIGNyb3NzLW9yaWdpbiBlcnJvciB3YXMgdGhyb3duLiBSZWFjdCBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvIFwiKyd0aGUgYWN0dWFsIGVycm9yIG9iamVjdCBpbiBkZXZlbG9wbWVudC4gJysnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jcm9zc29yaWdpbi1lcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTt9dGhpcy5vbkVycm9yKGVycm9yKTt9Ly8gUmVtb3ZlIG91ciBldmVudCBsaXN0ZW5lcnNcbndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsaGFuZGxlV2luZG93RXJyb3IpO2lmKCFkaWRDYWxsKXsvLyBTb21ldGhpbmcgd2VudCByZWFsbHkgd3JvbmcsIGFuZCBvdXIgZXZlbnQgd2FzIG5vdCBkaXNwYXRjaGVkLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjczNFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjU4NVxuLy8gRmFsbCBiYWNrIHRvIHRoZSBwcm9kdWN0aW9uIGltcGxlbWVudGF0aW9uLlxucmVzdG9yZUFmdGVyRGlzcGF0Y2goKTtyZXR1cm4gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7fX07fX12YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxPWludm9rZUd1YXJkZWRDYWxsYmFja0ltcGw7dmFyIGhhc0Vycm9yPWZhbHNlO3ZhciBjYXVnaHRFcnJvcj1udWxsOy8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG52YXIgaGFzUmV0aHJvd0Vycm9yPWZhbHNlO3ZhciByZXRocm93RXJyb3I9bnVsbDt2YXIgcmVwb3J0ZXI9e29uRXJyb3I6ZnVuY3Rpb24oZXJyb3Ipe2hhc0Vycm9yPXRydWU7Y2F1Z2h0RXJyb3I9ZXJyb3I7fX07LyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgdGhyb3dzLCBvdGhlcndpc2UgbnVsbC5cbiAqXG4gKiBJbiBwcm9kdWN0aW9uLCB0aGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgdHJ5LWNhdGNoLiBUaGUgcmVhc29uIHdlIGRvbid0XG4gKiB1c2UgYSB0cnktY2F0Y2ggZGlyZWN0bHkgaXMgc28gdGhhdCB3ZSBjYW4gc3dhcCBvdXQgYSBkaWZmZXJlbnRcbiAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAqL2Z1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLGZ1bmMsY29udGV4dCxhLGIsYyxkLGUsZil7aGFzRXJyb3I9ZmFsc2U7Y2F1Z2h0RXJyb3I9bnVsbDtpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEuYXBwbHkocmVwb3J0ZXIsYXJndW1lbnRzKTt9LyoqXG4gKiBTYW1lIGFzIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYnV0IGluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIGVycm9yLCBpdCBzdG9yZXNcbiAqIGl0IGluIGEgZ2xvYmFsIHNvIGl0IGNhbiBiZSByZXRocm93biBieSBgcmV0aHJvd0NhdWdodEVycm9yYCBsYXRlci5cbiAqIFRPRE86IFNlZSBpZiBjYXVnaHRFcnJvciBhbmQgcmV0aHJvd0Vycm9yIGNhbiBiZSB1bmlmaWVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAqL2Z1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcihuYW1lLGZ1bmMsY29udGV4dCxhLGIsYyxkLGUsZil7aW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihoYXNFcnJvcil7dmFyIGVycm9yPWNsZWFyQ2F1Z2h0RXJyb3IoKTtpZighaGFzUmV0aHJvd0Vycm9yKXtoYXNSZXRocm93RXJyb3I9dHJ1ZTtyZXRocm93RXJyb3I9ZXJyb3I7fX19LyoqXG4gKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAqL2Z1bmN0aW9uIHJldGhyb3dDYXVnaHRFcnJvcigpe2lmKGhhc1JldGhyb3dFcnJvcil7dmFyIGVycm9yPXJldGhyb3dFcnJvcjtoYXNSZXRocm93RXJyb3I9ZmFsc2U7cmV0aHJvd0Vycm9yPW51bGw7dGhyb3cgZXJyb3I7fX1mdW5jdGlvbiBoYXNDYXVnaHRFcnJvcigpe3JldHVybiBoYXNFcnJvcjt9ZnVuY3Rpb24gY2xlYXJDYXVnaHRFcnJvcigpe2lmKGhhc0Vycm9yKXt2YXIgZXJyb3I9Y2F1Z2h0RXJyb3I7aGFzRXJyb3I9ZmFsc2U7Y2F1Z2h0RXJyb3I9bnVsbDtyZXR1cm4gZXJyb3I7fWVsc2V7dGhyb3cgbmV3IEVycm9yKCdjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciAnKydpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9fS8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL2Z1bmN0aW9uIGdldChrZXkpe3JldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxzO31mdW5jdGlvbiBoYXMoa2V5KXtyZXR1cm4ga2V5Ll9yZWFjdEludGVybmFscyE9PXVuZGVmaW5lZDt9ZnVuY3Rpb24gc2V0KGtleSx2YWx1ZSl7a2V5Ll9yZWFjdEludGVybmFscz12YWx1ZTt9Ly8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXMuIFRoZXkncmUgdXNlZCBieSBSZWFjdCBEZXYgVG9vbHMuXG52YXIgTm9GbGFncz0vKiAgICAgICAgICAgICAgICAgICAgICAqLzA7dmFyIFBlcmZvcm1lZFdvcms9LyogICAgICAgICAgICAgICAgKi8xOy8vIFlvdSBjYW4gY2hhbmdlIHRoZSByZXN0IChhbmQgYWRkIG1vcmUpLlxudmFyIFBsYWNlbWVudD0vKiAgICAgICAgICAgICAgICAgICAgKi8yO3ZhciBVcGRhdGU9LyogICAgICAgICAgICAgICAgICAgICAgICovNDt2YXIgQ2hpbGREZWxldGlvbj0vKiAgICAgICAgICAgICAgICAqLzE2O3ZhciBDb250ZW50UmVzZXQ9LyogICAgICAgICAgICAgICAgICovMzI7dmFyIENhbGxiYWNrPS8qICAgICAgICAgICAgICAgICAgICAgKi82NDt2YXIgRGlkQ2FwdHVyZT0vKiAgICAgICAgICAgICAgICAgICAqLzEyODt2YXIgRm9yY2VDbGllbnRSZW5kZXI9LyogICAgICAgICAgICAqLzI1Njt2YXIgUmVmPS8qICAgICAgICAgICAgICAgICAgICAgICAgICAqLzUxMjt2YXIgU25hcHNob3Q9LyogICAgICAgICAgICAgICAgICAgICAqLzEwMjQ7dmFyIFBhc3NpdmU9LyogICAgICAgICAgICAgICAgICAgICAgKi8yMDQ4O3ZhciBIeWRyYXRpbmc9LyogICAgICAgICAgICAgICAgICAgICovNDA5Njt2YXIgVmlzaWJpbGl0eT0vKiAgICAgICAgICAgICAgICAgICAqLzgxOTI7dmFyIFN0b3JlQ29uc2lzdGVuY3k9LyogICAgICAgICAgICAgKi8xNjM4NDt2YXIgTGlmZWN5Y2xlRWZmZWN0TWFzaz1QYXNzaXZlfFVwZGF0ZXxDYWxsYmFja3xSZWZ8U25hcHNob3R8U3RvcmVDb25zaXN0ZW5jeTsvLyBVbmlvbiBvZiBhbGwgY29tbWl0IGZsYWdzIChmbGFncyB3aXRoIHRoZSBsaWZldGltZSBvZiBhIHBhcnRpY3VsYXIgY29tbWl0KVxudmFyIEhvc3RFZmZlY3RNYXNrPS8qICAgICAgICAgICAgICAgKi8zMjc2NzsvLyBUaGVzZSBhcmUgbm90IHJlYWxseSBzaWRlIGVmZmVjdHMsIGJ1dCB3ZSBzdGlsbCByZXVzZSB0aGlzIGZpZWxkLlxudmFyIEluY29tcGxldGU9LyogICAgICAgICAgICAgICAgICAgKi8zMjc2ODt2YXIgU2hvdWxkQ2FwdHVyZT0vKiAgICAgICAgICAgICAgICAqLzY1NTM2O3ZhciBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlPS8qICovMTMxMDcyO3ZhciBGb3JrZWQ9LyogICAgICAgICAgICAgICAgICAgICAgICovMTA0ODU3NjsvLyBTdGF0aWMgdGFncyBkZXNjcmliZSBhc3BlY3RzIG9mIGEgZmliZXIgdGhhdCBhcmUgbm90IHNwZWNpZmljIHRvIGEgcmVuZGVyLFxuLy8gZS5nLiBhIGZpYmVyIHVzZXMgYSBwYXNzaXZlIGVmZmVjdCAoZXZlbiBpZiB0aGVyZSBhcmUgbm8gdXBkYXRlcyBvbiB0aGlzIHBhcnRpY3VsYXIgcmVuZGVyKS5cbi8vIFRoaXMgZW5hYmxlcyB1cyB0byBkZWZlciBtb3JlIHdvcmsgaW4gdGhlIHVubW91bnQgY2FzZSxcbi8vIHNpbmNlIHdlIGNhbiBkZWZlciB0cmF2ZXJzaW5nIHRoZSB0cmVlIGR1cmluZyBsYXlvdXQgdG8gbG9vayBmb3IgUGFzc2l2ZSBlZmZlY3RzLFxuLy8gYW5kIGluc3RlYWQgcmVseSBvbiB0aGUgc3RhdGljIGZsYWcgYXMgYSBzaWduYWwgdGhhdCB0aGVyZSBtYXkgYmUgY2xlYW51cCB3b3JrLlxudmFyIFJlZlN0YXRpYz0vKiAgICAgICAgICAgICAgICAgICAgKi8yMDk3MTUyO3ZhciBMYXlvdXRTdGF0aWM9LyogICAgICAgICAgICAgICAgICovNDE5NDMwNDt2YXIgUGFzc2l2ZVN0YXRpYz0vKiAgICAgICAgICAgICAgICAqLzgzODg2MDg7Ly8gVGhlc2UgZmxhZ3MgYWxsb3cgdXMgdG8gdHJhdmVyc2UgdG8gZmliZXJzIHRoYXQgaGF2ZSBlZmZlY3RzIG9uIG1vdW50XG4vLyB3aXRob3V0IHRyYXZlcnNpbmcgdGhlIGVudGlyZSB0cmVlIGFmdGVyIGV2ZXJ5IGNvbW1pdCBmb3Jcbi8vIGRvdWJsZSBpbnZva2luZ1xudmFyIE1vdW50TGF5b3V0RGV2PS8qICAgICAgICAgICAgICAgKi8xNjc3NzIxNjt2YXIgTW91bnRQYXNzaXZlRGV2PS8qICAgICAgICAgICAgICAqLzMzNTU0NDMyOy8vIEdyb3VwcyBvZiBmbGFncyB0aGF0IGFyZSB1c2VkIGluIHRoZSBjb21taXQgcGhhc2UgdG8gc2tpcCBvdmVyIHRyZWVzIHRoYXRcbi8vIGRvbid0IGNvbnRhaW4gZWZmZWN0cywgYnkgY2hlY2tpbmcgc3VidHJlZUZsYWdzLlxudmFyIEJlZm9yZU11dGF0aW9uTWFzaz0vLyBUT0RPOiBSZW1vdmUgVXBkYXRlIGZsYWcgZnJvbSBiZWZvcmUgbXV0YXRpb24gcGhhc2UgYnkgcmUtbGFuZGluZyBWaXNpYmlsaXR5XG4vLyBmbGFnIGxvZ2ljIChzZWUgIzIwMDQzKVxuVXBkYXRlfFNuYXBzaG90fDA7dmFyIE11dGF0aW9uTWFzaz1QbGFjZW1lbnR8VXBkYXRlfENoaWxkRGVsZXRpb258Q29udGVudFJlc2V0fFJlZnxIeWRyYXRpbmd8VmlzaWJpbGl0eTt2YXIgTGF5b3V0TWFzaz1VcGRhdGV8Q2FsbGJhY2t8UmVmfFZpc2liaWxpdHk7Ly8gVE9ETzogU3BsaXQgaW50byBQYXNzaXZlTW91bnRNYXNrIGFuZCBQYXNzaXZlVW5tb3VudE1hc2tcbnZhciBQYXNzaXZlTWFzaz1QYXNzaXZlfENoaWxkRGVsZXRpb247Ly8gVW5pb24gb2YgdGFncyB0aGF0IGRvbid0IGdldCByZXNldCBvbiBjbG9uZXMuXG4vLyBUaGlzIGFsbG93cyBjZXJ0YWluIGNvbmNlcHRzIHRvIHBlcnNpc3Qgd2l0aG91dCByZWNhbGN1bGF0aW5nIHRoZW0sXG4vLyBlLmcuIHdoZXRoZXIgYSBzdWJ0cmVlIGNvbnRhaW5zIHBhc3NpdmUgZWZmZWN0cyBvciBwb3J0YWxzLlxudmFyIFN0YXRpY01hc2s9TGF5b3V0U3RhdGljfFBhc3NpdmVTdGF0aWN8UmVmU3RhdGljO3ZhciBSZWFjdEN1cnJlbnRPd25lcj1SZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtmdW5jdGlvbiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKXt2YXIgbm9kZT1maWJlcjt2YXIgbmVhcmVzdE1vdW50ZWQ9ZmliZXI7aWYoIWZpYmVyLmFsdGVybmF0ZSl7Ly8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG52YXIgbmV4dE5vZGU9bm9kZTtkb3tub2RlPW5leHROb2RlO2lmKChub2RlLmZsYWdzJihQbGFjZW1lbnR8SHlkcmF0aW5nKSkhPT1Ob0ZsYWdzKXsvLyBUaGlzIGlzIGFuIGluc2VydGlvbiBvciBpbi1wcm9ncmVzcyBoeWRyYXRpb24uIFRoZSBuZWFyZXN0IHBvc3NpYmxlXG4vLyBtb3VudGVkIGZpYmVyIGlzIHRoZSBwYXJlbnQgYnV0IHdlIG5lZWQgdG8gY29udGludWUgdG8gZmlndXJlIG91dFxuLy8gaWYgdGhhdCBvbmUgaXMgc3RpbGwgbW91bnRlZC5cbm5lYXJlc3RNb3VudGVkPW5vZGUucmV0dXJuO31uZXh0Tm9kZT1ub2RlLnJldHVybjt9d2hpbGUobmV4dE5vZGUpO31lbHNle3doaWxlKG5vZGUucmV0dXJuKXtub2RlPW5vZGUucmV0dXJuO319aWYobm9kZS50YWc9PT1Ib3N0Um9vdCl7Ly8gVE9ETzogQ2hlY2sgaWYgdGhpcyB3YXMgYSBuZXN0ZWQgSG9zdFJvb3Qgd2hlbiB1c2VkIHdpdGhcbi8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxucmV0dXJuIG5lYXJlc3RNb3VudGVkO30vLyBJZiB3ZSBkaWRuJ3QgaGl0IHRoZSByb290LCB0aGF0IG1lYW5zIHRoYXQgd2UncmUgaW4gYW4gZGlzY29ubmVjdGVkIHRyZWVcbi8vIHRoYXQgaGFzIGJlZW4gdW5tb3VudGVkLlxucmV0dXJuIG51bGw7fWZ1bmN0aW9uIGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIoZmliZXIpe2lmKGZpYmVyLnRhZz09PVN1c3BlbnNlQ29tcG9uZW50KXt2YXIgc3VzcGVuc2VTdGF0ZT1maWJlci5tZW1vaXplZFN0YXRlO2lmKHN1c3BlbnNlU3RhdGU9PT1udWxsKXt2YXIgY3VycmVudD1maWJlci5hbHRlcm5hdGU7aWYoY3VycmVudCE9PW51bGwpe3N1c3BlbnNlU3RhdGU9Y3VycmVudC5tZW1vaXplZFN0YXRlO319aWYoc3VzcGVuc2VTdGF0ZSE9PW51bGwpe3JldHVybiBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7fX1yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gZ2V0Q29udGFpbmVyRnJvbUZpYmVyKGZpYmVyKXtyZXR1cm4gZmliZXIudGFnPT09SG9zdFJvb3Q/ZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm86bnVsbDt9ZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpe3JldHVybiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKT09PWZpYmVyO31mdW5jdGlvbiBpc01vdW50ZWQoY29tcG9uZW50KXt7dmFyIG93bmVyPVJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7aWYob3duZXIhPT1udWxsJiZvd25lci50YWc9PT1DbGFzc0NvbXBvbmVudCl7dmFyIG93bmVyRmliZXI9b3duZXI7dmFyIGluc3RhbmNlPW93bmVyRmliZXIuc3RhdGVOb2RlO2lmKCFpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIpe2Vycm9yKCclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcrJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJysnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJysncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJysnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyRmliZXIpfHwnQSBjb21wb25lbnQnKTt9aW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyPXRydWU7fX12YXIgZmliZXI9Z2V0KGNvbXBvbmVudCk7aWYoIWZpYmVyKXtyZXR1cm4gZmFsc2U7fXJldHVybiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKT09PWZpYmVyO31mdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpe2lmKGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpIT09ZmliZXIpe3Rocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO319ZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpe3ZhciBhbHRlcm5hdGU9ZmliZXIuYWx0ZXJuYXRlO2lmKCFhbHRlcm5hdGUpey8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbnZhciBuZWFyZXN0TW91bnRlZD1nZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKTtpZihuZWFyZXN0TW91bnRlZD09PW51bGwpe3Rocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO31pZihuZWFyZXN0TW91bnRlZCE9PWZpYmVyKXtyZXR1cm4gbnVsbDt9cmV0dXJuIGZpYmVyO30vLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3Rcbi8vIHRvIHNlZSB3aGF0IHBhdGggdGhlIHJvb3QgcG9pbnRzIHRvLiBPbiB0aGUgd2F5IHdlIG1heSBoaXQgb25lIG9mIHRoZVxuLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG52YXIgYT1maWJlcjt2YXIgYj1hbHRlcm5hdGU7d2hpbGUodHJ1ZSl7dmFyIHBhcmVudEE9YS5yZXR1cm47aWYocGFyZW50QT09PW51bGwpey8vIFdlJ3JlIGF0IHRoZSByb290LlxuYnJlYWs7fXZhciBwYXJlbnRCPXBhcmVudEEuYWx0ZXJuYXRlO2lmKHBhcmVudEI9PT1udWxsKXsvLyBUaGVyZSBpcyBubyBhbHRlcm5hdGUuIFRoaXMgaXMgYW4gdW51c3VhbCBjYXNlLiBDdXJyZW50bHksIGl0IG9ubHlcbi8vIGhhcHBlbnMgd2hlbiBhIFN1c3BlbnNlIGNvbXBvbmVudCBpcyBoaWRkZW4uIEFuIGV4dHJhIGZyYWdtZW50IGZpYmVyXG4vLyBpcyBpbnNlcnRlZCBpbiBiZXR3ZWVuIHRoZSBTdXNwZW5zZSBmaWJlciBhbmQgaXRzIGNoaWxkcmVuLiBTa2lwXG4vLyBvdmVyIHRoaXMgZXh0cmEgZnJhZ21lbnQgZmliZXIgYW5kIHByb2NlZWQgdG8gdGhlIG5leHQgcGFyZW50LlxudmFyIG5leHRQYXJlbnQ9cGFyZW50QS5yZXR1cm47aWYobmV4dFBhcmVudCE9PW51bGwpe2E9Yj1uZXh0UGFyZW50O2NvbnRpbnVlO30vLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UncmUgYXQgdGhlIHJvb3QuXG5icmVhazt9Ly8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4vLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbi8vIHByaW9yaXR5OiB0aGUgYmFpbGVkIG91dCBmaWJlcidzIGNoaWxkIHJldXNlcyB0aGUgY3VycmVudCBjaGlsZC5cbmlmKHBhcmVudEEuY2hpbGQ9PT1wYXJlbnRCLmNoaWxkKXt2YXIgY2hpbGQ9cGFyZW50QS5jaGlsZDt3aGlsZShjaGlsZCl7aWYoY2hpbGQ9PT1hKXsvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG5hc3NlcnRJc01vdW50ZWQocGFyZW50QSk7cmV0dXJuIGZpYmVyO31pZihjaGlsZD09PWIpey8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbmFzc2VydElzTW91bnRlZChwYXJlbnRBKTtyZXR1cm4gYWx0ZXJuYXRlO31jaGlsZD1jaGlsZC5zaWJsaW5nO30vLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxudGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7fWlmKGEucmV0dXJuIT09Yi5yZXR1cm4pey8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbi8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3Rcbi8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbi8vIHNldCBvZiBCLnJldHVybi5cbmE9cGFyZW50QTtiPXBhcmVudEI7fWVsc2V7Ly8gVGhlIHJldHVybiBwb2ludGVycyBwb2ludCB0byB0aGUgc2FtZSBmaWJlci4gV2UnbGwgaGF2ZSB0byB1c2UgdGhlXG4vLyBkZWZhdWx0LCBzbG93IHBhdGg6IHNjYW4gdGhlIGNoaWxkIHNldHMgb2YgZWFjaCBwYXJlbnQgYWx0ZXJuYXRlIHRvIHNlZVxuLy8gd2hpY2ggY2hpbGQgYmVsb25ncyB0byB3aGljaCBzZXQuXG4vL1xuLy8gU2VhcmNoIHBhcmVudCBBJ3MgY2hpbGQgc2V0XG52YXIgZGlkRmluZENoaWxkPWZhbHNlO3ZhciBfY2hpbGQ9cGFyZW50QS5jaGlsZDt3aGlsZShfY2hpbGQpe2lmKF9jaGlsZD09PWEpe2RpZEZpbmRDaGlsZD10cnVlO2E9cGFyZW50QTtiPXBhcmVudEI7YnJlYWs7fWlmKF9jaGlsZD09PWIpe2RpZEZpbmRDaGlsZD10cnVlO2I9cGFyZW50QTthPXBhcmVudEI7YnJlYWs7fV9jaGlsZD1fY2hpbGQuc2libGluZzt9aWYoIWRpZEZpbmRDaGlsZCl7Ly8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG5fY2hpbGQ9cGFyZW50Qi5jaGlsZDt3aGlsZShfY2hpbGQpe2lmKF9jaGlsZD09PWEpe2RpZEZpbmRDaGlsZD10cnVlO2E9cGFyZW50QjtiPXBhcmVudEE7YnJlYWs7fWlmKF9jaGlsZD09PWIpe2RpZEZpbmRDaGlsZD10cnVlO2I9cGFyZW50QjthPXBhcmVudEE7YnJlYWs7fV9jaGlsZD1fY2hpbGQuc2libGluZzt9aWYoIWRpZEZpbmRDaGlsZCl7dGhyb3cgbmV3IEVycm9yKCdDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyAnKydpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fX19aWYoYS5hbHRlcm5hdGUhPT1iKXt0aHJvdyBuZXcgRXJyb3IoXCJSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnMnIGFsdGVybmF0ZXMuIFwiKydUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO319Ly8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cbi8vIHVubW91bnRlZC5cbmlmKGEudGFnIT09SG9zdFJvb3Qpe3Rocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO31pZihhLnN0YXRlTm9kZS5jdXJyZW50PT09YSl7Ly8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxucmV0dXJuIGZpYmVyO30vLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG5yZXR1cm4gYWx0ZXJuYXRlO31mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpe3ZhciBjdXJyZW50UGFyZW50PWZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7cmV0dXJuIGN1cnJlbnRQYXJlbnQhPT1udWxsP2ZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChjdXJyZW50UGFyZW50KTpudWxsO31mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwobm9kZSl7Ly8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbmlmKG5vZGUudGFnPT09SG9zdENvbXBvbmVudHx8bm9kZS50YWc9PT1Ib3N0VGV4dCl7cmV0dXJuIG5vZGU7fXZhciBjaGlsZD1ub2RlLmNoaWxkO3doaWxlKGNoaWxkIT09bnVsbCl7dmFyIG1hdGNoPWZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChjaGlsZCk7aWYobWF0Y2ghPT1udWxsKXtyZXR1cm4gbWF0Y2g7fWNoaWxkPWNoaWxkLnNpYmxpbmc7fXJldHVybiBudWxsO31mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMocGFyZW50KXt2YXIgY3VycmVudFBhcmVudD1maW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO3JldHVybiBjdXJyZW50UGFyZW50IT09bnVsbD9maW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKGN1cnJlbnRQYXJlbnQpOm51bGw7fWZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwobm9kZSl7Ly8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbmlmKG5vZGUudGFnPT09SG9zdENvbXBvbmVudHx8bm9kZS50YWc9PT1Ib3N0VGV4dCl7cmV0dXJuIG5vZGU7fXZhciBjaGlsZD1ub2RlLmNoaWxkO3doaWxlKGNoaWxkIT09bnVsbCl7aWYoY2hpbGQudGFnIT09SG9zdFBvcnRhbCl7dmFyIG1hdGNoPWZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwoY2hpbGQpO2lmKG1hdGNoIT09bnVsbCl7cmV0dXJuIG1hdGNoO319Y2hpbGQ9Y2hpbGQuc2libGluZzt9cmV0dXJuIG51bGw7fS8vIFRoaXMgbW9kdWxlIG9ubHkgZXhpc3RzIGFzIGFuIEVTTSB3cmFwcGVyIGFyb3VuZCB0aGUgZXh0ZXJuYWwgQ29tbW9uSlNcbnZhciBzY2hlZHVsZUNhbGxiYWNrPVNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrO3ZhciBjYW5jZWxDYWxsYmFjaz1TY2hlZHVsZXIudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s7dmFyIHNob3VsZFlpZWxkPVNjaGVkdWxlci51bnN0YWJsZV9zaG91bGRZaWVsZDt2YXIgcmVxdWVzdFBhaW50PVNjaGVkdWxlci51bnN0YWJsZV9yZXF1ZXN0UGFpbnQ7dmFyIG5vdz1TY2hlZHVsZXIudW5zdGFibGVfbm93O3ZhciBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbD1TY2hlZHVsZXIudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWw7dmFyIEltbWVkaWF0ZVByaW9yaXR5PVNjaGVkdWxlci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eTt2YXIgVXNlckJsb2NraW5nUHJpb3JpdHk9U2NoZWR1bGVyLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5O3ZhciBOb3JtYWxQcmlvcml0eT1TY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHk7dmFyIExvd1ByaW9yaXR5PVNjaGVkdWxlci51bnN0YWJsZV9Mb3dQcmlvcml0eTt2YXIgSWRsZVByaW9yaXR5PVNjaGVkdWxlci51bnN0YWJsZV9JZGxlUHJpb3JpdHk7Ly8gdGhpcyBkb2Vzbid0IGFjdHVhbGx5IGV4aXN0IG9uIHRoZSBzY2hlZHVsZXIsIGJ1dCBpdCAqZG9lcypcbi8vIG9uIHNjaGVkdWxlci91bnN0YWJsZV9tb2NrLCB3aGljaCB3ZSdsbCBuZWVkIGZvciBpbnRlcm5hbCB0ZXN0aW5nXG52YXIgdW5zdGFibGVfeWllbGRWYWx1ZT1TY2hlZHVsZXIudW5zdGFibGVfeWllbGRWYWx1ZTt2YXIgdW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWU9U2NoZWR1bGVyLnVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlO3ZhciByZW5kZXJlcklEPW51bGw7dmFyIGluamVjdGVkSG9vaz1udWxsO3ZhciBpbmplY3RlZFByb2ZpbGluZ0hvb2tzPW51bGw7dmFyIGhhc0xvZ2dlZEVycm9yPWZhbHNlO3ZhciBpc0RldlRvb2xzUHJlc2VudD10eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIT09J3VuZGVmaW5lZCc7ZnVuY3Rpb24gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscyl7aWYodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXz09PSd1bmRlZmluZWQnKXsvLyBObyBEZXZUb29sc1xucmV0dXJuIGZhbHNlO312YXIgaG9vaz1fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187aWYoaG9vay5pc0Rpc2FibGVkKXsvLyBUaGlzIGlzbid0IGEgcmVhbCBwcm9wZXJ0eSBvbiB0aGUgaG9vaywgYnV0IGl0IGNhbiBiZSBzZXQgdG8gb3B0IG91dFxuLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzM4NzdcbnJldHVybiB0cnVlO31pZighaG9vay5zdXBwb3J0c0ZpYmVyKXt7ZXJyb3IoJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcrJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJysnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlYWN0LWRldnRvb2xzJyk7fS8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxucmV0dXJuIHRydWU7fXRyeXtpZihlbmFibGVTY2hlZHVsaW5nUHJvZmlsZXIpey8vIENvbmRpdGlvbmFsbHkgaW5qZWN0IHRoZXNlIGhvb2tzIG9ubHkgaWYgVGltZWxpbmUgcHJvZmlsZXIgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgYnVpbGQuXG4vLyBUaGlzIGdpdmVzIERldlRvb2xzIGEgd2F5IHRvIGZlYXR1cmUgZGV0ZWN0IHRoYXQgaXNuJ3QgdGllZCB0byB2ZXJzaW9uIG51bWJlclxuLy8gKHNpbmNlIHByb2ZpbGluZyBhbmQgdGltZWxpbmUgYXJlIGNvbnRyb2xsZWQgYnkgZGlmZmVyZW50IGZlYXR1cmUgZmxhZ3MpLlxuaW50ZXJuYWxzPWFzc2lnbih7fSxpbnRlcm5hbHMse2dldExhbmVMYWJlbE1hcDpnZXRMYW5lTGFiZWxNYXAsaW5qZWN0UHJvZmlsaW5nSG9va3M6aW5qZWN0UHJvZmlsaW5nSG9va3N9KTt9cmVuZGVyZXJJRD1ob29rLmluamVjdChpbnRlcm5hbHMpOy8vIFdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGluamVjdGVkLCBzbyBub3cgaXQgaXMgc2FmZSB0byBzZXQgdXAgaG9va3MuXG5pbmplY3RlZEhvb2s9aG9vazt9Y2F0Y2goZXJyKXsvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbntlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcy4nLGVycik7fX1pZihob29rLmNoZWNrRENFKXsvLyBUaGlzIGlzIHRoZSByZWFsIERldlRvb2xzLlxucmV0dXJuIHRydWU7fWVsc2V7Ly8gVGhpcyBpcyBsaWtlbHkgYSBob29rIGluc3RhbGxlZCBieSBGYXN0IFJlZnJlc2ggcnVudGltZS5cbnJldHVybiBmYWxzZTt9fWZ1bmN0aW9uIG9uU2NoZWR1bGVSb290KHJvb3QsY2hpbGRyZW4pe3tpZihpbmplY3RlZEhvb2smJnR5cGVvZiBpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdD09PSdmdW5jdGlvbicpe3RyeXtpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdChyZW5kZXJlcklELHJvb3QsY2hpbGRyZW4pO31jYXRjaChlcnIpe2lmKCFoYXNMb2dnZWRFcnJvcil7aGFzTG9nZ2VkRXJyb3I9dHJ1ZTtlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsZXJyKTt9fX19fWZ1bmN0aW9uIG9uQ29tbWl0Um9vdChyb290LGV2ZW50UHJpb3JpdHkpe2lmKGluamVjdGVkSG9vayYmdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdD09PSdmdW5jdGlvbicpe3RyeXt2YXIgZGlkRXJyb3I9KHJvb3QuY3VycmVudC5mbGFncyZEaWRDYXB0dXJlKT09PURpZENhcHR1cmU7aWYoZW5hYmxlUHJvZmlsZXJUaW1lcil7dmFyIHNjaGVkdWxlclByaW9yaXR5O3N3aXRjaChldmVudFByaW9yaXR5KXtjYXNlIERpc2NyZXRlRXZlbnRQcmlvcml0eTpzY2hlZHVsZXJQcmlvcml0eT1JbW1lZGlhdGVQcmlvcml0eTticmVhaztjYXNlIENvbnRpbnVvdXNFdmVudFByaW9yaXR5OnNjaGVkdWxlclByaW9yaXR5PVVzZXJCbG9ja2luZ1ByaW9yaXR5O2JyZWFrO2Nhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6c2NoZWR1bGVyUHJpb3JpdHk9Tm9ybWFsUHJpb3JpdHk7YnJlYWs7Y2FzZSBJZGxlRXZlbnRQcmlvcml0eTpzY2hlZHVsZXJQcmlvcml0eT1JZGxlUHJpb3JpdHk7YnJlYWs7ZGVmYXVsdDpzY2hlZHVsZXJQcmlvcml0eT1Ob3JtYWxQcmlvcml0eTticmVhazt9aW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290KHJlbmRlcmVySUQscm9vdCxzY2hlZHVsZXJQcmlvcml0eSxkaWRFcnJvcik7fWVsc2V7aW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290KHJlbmRlcmVySUQscm9vdCx1bmRlZmluZWQsZGlkRXJyb3IpO319Y2F0Y2goZXJyKXt7aWYoIWhhc0xvZ2dlZEVycm9yKXtoYXNMb2dnZWRFcnJvcj10cnVlO2Vycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJyxlcnIpO319fX19ZnVuY3Rpb24gb25Qb3N0Q29tbWl0Um9vdChyb290KXtpZihpbmplY3RlZEhvb2smJnR5cGVvZiBpbmplY3RlZEhvb2sub25Qb3N0Q29tbWl0RmliZXJSb290PT09J2Z1bmN0aW9uJyl7dHJ5e2luamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3QocmVuZGVyZXJJRCxyb290KTt9Y2F0Y2goZXJyKXt7aWYoIWhhc0xvZ2dlZEVycm9yKXtoYXNMb2dnZWRFcnJvcj10cnVlO2Vycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJyxlcnIpO319fX19ZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKXtpZihpbmplY3RlZEhvb2smJnR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQ9PT0nZnVuY3Rpb24nKXt0cnl7aW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50KHJlbmRlcmVySUQsZmliZXIpO31jYXRjaChlcnIpe3tpZighaGFzTG9nZ2VkRXJyb3Ipe2hhc0xvZ2dlZEVycm9yPXRydWU7ZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLGVycik7fX19fX1mdW5jdGlvbiBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhuZXdJc1N0cmljdE1vZGUpe3tpZih0eXBlb2YgdW5zdGFibGVfeWllbGRWYWx1ZT09PSdmdW5jdGlvbicpey8vIFdlJ3JlIGluIGEgdGVzdCBiZWNhdXNlIFNjaGVkdWxlci51bnN0YWJsZV95aWVsZFZhbHVlIG9ubHkgZXhpc3RzXG4vLyBpbiBTY2hlZHVsZXJNb2NrLiBUbyByZWR1Y2UgdGhlIG5vaXNlIGluIHN0cmljdCBtb2RlIHRlc3RzLFxuLy8gc3VwcHJlc3Mgd2FybmluZ3MgYW5kIGRpc2FibGUgc2NoZWR1bGVyIHlpZWxkaW5nIGR1cmluZyB0aGUgZG91YmxlIHJlbmRlclxudW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUobmV3SXNTdHJpY3RNb2RlKTtzZXRTdXBwcmVzc1dhcm5pbmcobmV3SXNTdHJpY3RNb2RlKTt9aWYoaW5qZWN0ZWRIb29rJiZ0eXBlb2YgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGU9PT0nZnVuY3Rpb24nKXt0cnl7aW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUocmVuZGVyZXJJRCxuZXdJc1N0cmljdE1vZGUpO31jYXRjaChlcnIpe3tpZighaGFzTG9nZ2VkRXJyb3Ipe2hhc0xvZ2dlZEVycm9yPXRydWU7ZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLGVycik7fX19fX19Ly8gUHJvZmlsZXIgQVBJIGhvb2tzXG5mdW5jdGlvbiBpbmplY3RQcm9maWxpbmdIb29rcyhwcm9maWxpbmdIb29rcyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcz1wcm9maWxpbmdIb29rczt9ZnVuY3Rpb24gZ2V0TGFuZUxhYmVsTWFwKCl7e3ZhciBtYXA9bmV3IE1hcCgpO3ZhciBsYW5lPTE7Zm9yKHZhciBpbmRleD0wO2luZGV4PFRvdGFsTGFuZXM7aW5kZXgrKyl7dmFyIGxhYmVsPWdldExhYmVsRm9yTGFuZShsYW5lKTttYXAuc2V0KGxhbmUsbGFiZWwpO2xhbmUqPTI7fXJldHVybiBtYXA7fX1mdW5jdGlvbiBtYXJrQ29tbWl0U3RhcnRlZChsYW5lcyl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0YXJ0ZWQobGFuZXMpO319fWZ1bmN0aW9uIG1hcmtDb21taXRTdG9wcGVkKCl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RvcHBlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0b3BwZWQoKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcil7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpO319fWZ1bmN0aW9uIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZChmaWJlcil7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpO319fWZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXIpO319fWZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQoKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQoKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpO319fWZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQoKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQoKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXIpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXIpO319fWZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50RXJyb3JlZChmaWJlcix0aHJvd25WYWx1ZSxsYW5lcyl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50RXJyb3JlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudEVycm9yZWQoZmliZXIsdGhyb3duVmFsdWUsbGFuZXMpO319fWZ1bmN0aW9uIG1hcmtDb21wb25lbnRTdXNwZW5kZWQoZmliZXIsd2FrZWFibGUsbGFuZXMpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFN1c3BlbmRlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFN1c3BlbmRlZChmaWJlcix3YWtlYWJsZSxsYW5lcyk7fX19ZnVuY3Rpb24gbWFya0xheW91dEVmZmVjdHNTdGFydGVkKGxhbmVzKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdGFydGVkKGxhbmVzKTt9fX1mdW5jdGlvbiBtYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQoKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCk7fX19ZnVuY3Rpb24gbWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcyl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTt9fX1mdW5jdGlvbiBtYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkKCl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkKCk7fX19ZnVuY3Rpb24gbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0YXJ0ZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTt9fX1mdW5jdGlvbiBtYXJrUmVuZGVyWWllbGRlZCgpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlcllpZWxkZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkKCk7fX19ZnVuY3Rpb24gbWFya1JlbmRlclN0b3BwZWQoKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RvcHBlZCgpO319fWZ1bmN0aW9uIG1hcmtSZW5kZXJTY2hlZHVsZWQobGFuZSl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU2NoZWR1bGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpO319fWZ1bmN0aW9uIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlcixsYW5lKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLGxhbmUpO319fWZ1bmN0aW9uIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlcixsYW5lKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLGxhbmUpO319fXZhciBOb01vZGU9LyogICAgICAgICAgICAgICAgICAgICAgICAgKi8wOy8vIFRPRE86IFJlbW92ZSBDb25jdXJyZW50TW9kZSBieSByZWFkaW5nIGZyb20gdGhlIHJvb3QgdGFnIGluc3RlYWRcbnZhciBDb25jdXJyZW50TW9kZT0vKiAgICAgICAgICAgICAgICAgKi8xO3ZhciBQcm9maWxlTW9kZT0vKiAgICAgICAgICAgICAgICAgICAgKi8yO3ZhciBTdHJpY3RMZWdhY3lNb2RlPS8qICAgICAgICAgICAgICAgKi84O3ZhciBTdHJpY3RFZmZlY3RzTW9kZT0vKiAgICAgICAgICAgICAgKi8xNjsvLyBUT0RPOiBUaGlzIGlzIHByZXR0eSB3ZWxsIHN1cHBvcnRlZCBieSBicm93c2Vycy4gTWF5YmUgd2UgY2FuIGRyb3AgaXQuXG52YXIgY2x6MzI9TWF0aC5jbHozMj9NYXRoLmNsejMyOmNsejMyRmFsbGJhY2s7Ly8gQ291bnQgbGVhZGluZyB6ZXJvcy5cbi8vIEJhc2VkIG9uOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jbHozMlxudmFyIGxvZz1NYXRoLmxvZzt2YXIgTE4yPU1hdGguTE4yO2Z1bmN0aW9uIGNsejMyRmFsbGJhY2soeCl7dmFyIGFzVWludD14Pj4+MDtpZihhc1VpbnQ9PT0wKXtyZXR1cm4gMzI7fXJldHVybiAzMS0obG9nKGFzVWludCkvTE4yfDApfDA7fS8vIElmIHRob3NlIHZhbHVlcyBhcmUgY2hhbmdlZCB0aGF0IHBhY2thZ2Ugc2hvdWxkIGJlIHJlYnVpbHQgYW5kIHJlZGVwbG95ZWQuXG52YXIgVG90YWxMYW5lcz0zMTt2YXIgTm9MYW5lcz0vKiAgICAgICAgICAgICAgICAgICAgICAgICovMDt2YXIgTm9MYW5lPS8qICAgICAgICAgICAgICAgICAgICAgICAgICAqLzA7dmFyIFN5bmNMYW5lPS8qICAgICAgICAgICAgICAgICAgICAgICAgKi8xO3ZhciBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lPS8qICAgICovMjt2YXIgSW5wdXRDb250aW51b3VzTGFuZT0vKiAgICAgICAgICAgICAqLzQ7dmFyIERlZmF1bHRIeWRyYXRpb25MYW5lPS8qICAgICAgICAgICAgKi84O3ZhciBEZWZhdWx0TGFuZT0vKiAgICAgICAgICAgICAgICAgICAgICovMTY7dmFyIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lPS8qICAgICAgICAgICAgICAgICovMzI7dmFyIFRyYW5zaXRpb25MYW5lcz0vKiAgICAgICAgICAgICAgICAgICAgICAgKi80MTk0MjQwO3ZhciBUcmFuc2l0aW9uTGFuZTE9LyogICAgICAgICAgICAgICAgICAgICAgICAqLzY0O3ZhciBUcmFuc2l0aW9uTGFuZTI9LyogICAgICAgICAgICAgICAgICAgICAgICAqLzEyODt2YXIgVHJhbnNpdGlvbkxhbmUzPS8qICAgICAgICAgICAgICAgICAgICAgICAgKi8yNTY7dmFyIFRyYW5zaXRpb25MYW5lND0vKiAgICAgICAgICAgICAgICAgICAgICAgICovNTEyO3ZhciBUcmFuc2l0aW9uTGFuZTU9LyogICAgICAgICAgICAgICAgICAgICAgICAqLzEwMjQ7dmFyIFRyYW5zaXRpb25MYW5lNj0vKiAgICAgICAgICAgICAgICAgICAgICAgICovMjA0ODt2YXIgVHJhbnNpdGlvbkxhbmU3PS8qICAgICAgICAgICAgICAgICAgICAgICAgKi80MDk2O3ZhciBUcmFuc2l0aW9uTGFuZTg9LyogICAgICAgICAgICAgICAgICAgICAgICAqLzgxOTI7dmFyIFRyYW5zaXRpb25MYW5lOT0vKiAgICAgICAgICAgICAgICAgICAgICAgICovMTYzODQ7dmFyIFRyYW5zaXRpb25MYW5lMTA9LyogICAgICAgICAgICAgICAgICAgICAgICovMzI3Njg7dmFyIFRyYW5zaXRpb25MYW5lMTE9LyogICAgICAgICAgICAgICAgICAgICAgICovNjU1MzY7dmFyIFRyYW5zaXRpb25MYW5lMTI9LyogICAgICAgICAgICAgICAgICAgICAgICovMTMxMDcyO3ZhciBUcmFuc2l0aW9uTGFuZTEzPS8qICAgICAgICAgICAgICAgICAgICAgICAqLzI2MjE0NDt2YXIgVHJhbnNpdGlvbkxhbmUxND0vKiAgICAgICAgICAgICAgICAgICAgICAgKi81MjQyODg7dmFyIFRyYW5zaXRpb25MYW5lMTU9LyogICAgICAgICAgICAgICAgICAgICAgICovMTA0ODU3Njt2YXIgVHJhbnNpdGlvbkxhbmUxNj0vKiAgICAgICAgICAgICAgICAgICAgICAgKi8yMDk3MTUyO3ZhciBSZXRyeUxhbmVzPS8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICovMTMwMDIzNDI0O3ZhciBSZXRyeUxhbmUxPS8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqLzQxOTQzMDQ7dmFyIFJldHJ5TGFuZTI9LyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovODM4ODYwODt2YXIgUmV0cnlMYW5lMz0vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi8xNjc3NzIxNjt2YXIgUmV0cnlMYW5lND0vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi8zMzU1NDQzMjt2YXIgUmV0cnlMYW5lNT0vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi82NzEwODg2NDt2YXIgU29tZVJldHJ5TGFuZT1SZXRyeUxhbmUxO3ZhciBTZWxlY3RpdmVIeWRyYXRpb25MYW5lPS8qICAgICAgICAgICovMTM0MjE3NzI4O3ZhciBOb25JZGxlTGFuZXM9LyogICAgICAgICAgICAgICAgICAgICAgICAgICovMjY4NDM1NDU1O3ZhciBJZGxlSHlkcmF0aW9uTGFuZT0vKiAgICAgICAgICAgICAgICovMjY4NDM1NDU2O3ZhciBJZGxlTGFuZT0vKiAgICAgICAgICAgICAgICAgICAgICAgICovNTM2ODcwOTEyO3ZhciBPZmZzY3JlZW5MYW5lPS8qICAgICAgICAgICAgICAgICAgICovMTA3Mzc0MTgyNDsvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgZm9yIHRoZSBleHBlcmltZW50YWwgdGltZWxpbmUgKHJlYWN0LWRldnRvb2xzLXRpbWVsaW5lKVxuLy8gSXQgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBMYW5lcyB2YWx1ZXMgYWJvdmUuXG5mdW5jdGlvbiBnZXRMYWJlbEZvckxhbmUobGFuZSl7e2lmKGxhbmUmU3luY0xhbmUpe3JldHVybidTeW5jJzt9aWYobGFuZSZJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lKXtyZXR1cm4nSW5wdXRDb250aW51b3VzSHlkcmF0aW9uJzt9aWYobGFuZSZJbnB1dENvbnRpbnVvdXNMYW5lKXtyZXR1cm4nSW5wdXRDb250aW51b3VzJzt9aWYobGFuZSZEZWZhdWx0SHlkcmF0aW9uTGFuZSl7cmV0dXJuJ0RlZmF1bHRIeWRyYXRpb24nO31pZihsYW5lJkRlZmF1bHRMYW5lKXtyZXR1cm4nRGVmYXVsdCc7fWlmKGxhbmUmVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmUpe3JldHVybidUcmFuc2l0aW9uSHlkcmF0aW9uJzt9aWYobGFuZSZUcmFuc2l0aW9uTGFuZXMpe3JldHVybidUcmFuc2l0aW9uJzt9aWYobGFuZSZSZXRyeUxhbmVzKXtyZXR1cm4nUmV0cnknO31pZihsYW5lJlNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUpe3JldHVybidTZWxlY3RpdmVIeWRyYXRpb24nO31pZihsYW5lJklkbGVIeWRyYXRpb25MYW5lKXtyZXR1cm4nSWRsZUh5ZHJhdGlvbic7fWlmKGxhbmUmSWRsZUxhbmUpe3JldHVybidJZGxlJzt9aWYobGFuZSZPZmZzY3JlZW5MYW5lKXtyZXR1cm4nT2Zmc2NyZWVuJzt9fX12YXIgTm9UaW1lc3RhbXA9LTE7dmFyIG5leHRUcmFuc2l0aW9uTGFuZT1UcmFuc2l0aW9uTGFuZTE7dmFyIG5leHRSZXRyeUxhbmU9UmV0cnlMYW5lMTtmdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhsYW5lcyl7c3dpdGNoKGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpKXtjYXNlIFN5bmNMYW5lOnJldHVybiBTeW5jTGFuZTtjYXNlIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU6cmV0dXJuIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU7Y2FzZSBJbnB1dENvbnRpbnVvdXNMYW5lOnJldHVybiBJbnB1dENvbnRpbnVvdXNMYW5lO2Nhc2UgRGVmYXVsdEh5ZHJhdGlvbkxhbmU6cmV0dXJuIERlZmF1bHRIeWRyYXRpb25MYW5lO2Nhc2UgRGVmYXVsdExhbmU6cmV0dXJuIERlZmF1bHRMYW5lO2Nhc2UgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmU6cmV0dXJuIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lO2Nhc2UgVHJhbnNpdGlvbkxhbmUxOmNhc2UgVHJhbnNpdGlvbkxhbmUyOmNhc2UgVHJhbnNpdGlvbkxhbmUzOmNhc2UgVHJhbnNpdGlvbkxhbmU0OmNhc2UgVHJhbnNpdGlvbkxhbmU1OmNhc2UgVHJhbnNpdGlvbkxhbmU2OmNhc2UgVHJhbnNpdGlvbkxhbmU3OmNhc2UgVHJhbnNpdGlvbkxhbmU4OmNhc2UgVHJhbnNpdGlvbkxhbmU5OmNhc2UgVHJhbnNpdGlvbkxhbmUxMDpjYXNlIFRyYW5zaXRpb25MYW5lMTE6Y2FzZSBUcmFuc2l0aW9uTGFuZTEyOmNhc2UgVHJhbnNpdGlvbkxhbmUxMzpjYXNlIFRyYW5zaXRpb25MYW5lMTQ6Y2FzZSBUcmFuc2l0aW9uTGFuZTE1OmNhc2UgVHJhbnNpdGlvbkxhbmUxNjpyZXR1cm4gbGFuZXMmVHJhbnNpdGlvbkxhbmVzO2Nhc2UgUmV0cnlMYW5lMTpjYXNlIFJldHJ5TGFuZTI6Y2FzZSBSZXRyeUxhbmUzOmNhc2UgUmV0cnlMYW5lNDpjYXNlIFJldHJ5TGFuZTU6cmV0dXJuIGxhbmVzJlJldHJ5TGFuZXM7Y2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOnJldHVybiBTZWxlY3RpdmVIeWRyYXRpb25MYW5lO2Nhc2UgSWRsZUh5ZHJhdGlvbkxhbmU6cmV0dXJuIElkbGVIeWRyYXRpb25MYW5lO2Nhc2UgSWRsZUxhbmU6cmV0dXJuIElkbGVMYW5lO2Nhc2UgT2Zmc2NyZWVuTGFuZTpyZXR1cm4gT2Zmc2NyZWVuTGFuZTtkZWZhdWx0OntlcnJvcignU2hvdWxkIGhhdmUgZm91bmQgbWF0Y2hpbmcgbGFuZXMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7fS8vIFRoaXMgc2hvdWxkbid0IGJlIHJlYWNoYWJsZSwgYnV0IGFzIGEgZmFsbGJhY2ssIHJldHVybiB0aGUgZW50aXJlIGJpdG1hc2suXG5yZXR1cm4gbGFuZXM7fX1mdW5jdGlvbiBnZXROZXh0TGFuZXMocm9vdCx3aXBMYW5lcyl7Ly8gRWFybHkgYmFpbG91dCBpZiB0aGVyZSdzIG5vIHBlbmRpbmcgd29yayBsZWZ0LlxudmFyIHBlbmRpbmdMYW5lcz1yb290LnBlbmRpbmdMYW5lcztpZihwZW5kaW5nTGFuZXM9PT1Ob0xhbmVzKXtyZXR1cm4gTm9MYW5lczt9dmFyIG5leHRMYW5lcz1Ob0xhbmVzO3ZhciBzdXNwZW5kZWRMYW5lcz1yb290LnN1c3BlbmRlZExhbmVzO3ZhciBwaW5nZWRMYW5lcz1yb290LnBpbmdlZExhbmVzOy8vIERvIG5vdCB3b3JrIG9uIGFueSBpZGxlIHdvcmsgdW50aWwgYWxsIHRoZSBub24taWRsZSB3b3JrIGhhcyBmaW5pc2hlZCxcbi8vIGV2ZW4gaWYgdGhlIHdvcmsgaXMgc3VzcGVuZGVkLlxudmFyIG5vbklkbGVQZW5kaW5nTGFuZXM9cGVuZGluZ0xhbmVzJk5vbklkbGVMYW5lcztpZihub25JZGxlUGVuZGluZ0xhbmVzIT09Tm9MYW5lcyl7dmFyIG5vbklkbGVVbmJsb2NrZWRMYW5lcz1ub25JZGxlUGVuZGluZ0xhbmVzJn5zdXNwZW5kZWRMYW5lcztpZihub25JZGxlVW5ibG9ja2VkTGFuZXMhPT1Ob0xhbmVzKXtuZXh0TGFuZXM9Z2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobm9uSWRsZVVuYmxvY2tlZExhbmVzKTt9ZWxzZXt2YXIgbm9uSWRsZVBpbmdlZExhbmVzPW5vbklkbGVQZW5kaW5nTGFuZXMmcGluZ2VkTGFuZXM7aWYobm9uSWRsZVBpbmdlZExhbmVzIT09Tm9MYW5lcyl7bmV4dExhbmVzPWdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVQaW5nZWRMYW5lcyk7fX19ZWxzZXsvLyBUaGUgb25seSByZW1haW5pbmcgd29yayBpcyBJZGxlLlxudmFyIHVuYmxvY2tlZExhbmVzPXBlbmRpbmdMYW5lcyZ+c3VzcGVuZGVkTGFuZXM7aWYodW5ibG9ja2VkTGFuZXMhPT1Ob0xhbmVzKXtuZXh0TGFuZXM9Z2V0SGlnaGVzdFByaW9yaXR5TGFuZXModW5ibG9ja2VkTGFuZXMpO31lbHNle2lmKHBpbmdlZExhbmVzIT09Tm9MYW5lcyl7bmV4dExhbmVzPWdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKTt9fX1pZihuZXh0TGFuZXM9PT1Ob0xhbmVzKXsvLyBUaGlzIHNob3VsZCBvbmx5IGJlIHJlYWNoYWJsZSBpZiB3ZSdyZSBzdXNwZW5kZWRcbi8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgaW4gdGhpcyBwYXRoIGlmIGEgZmFsbGJhY2sgdGltZXIgaXMgbm90IHNjaGVkdWxlZC5cbnJldHVybiBOb0xhbmVzO30vLyBJZiB3ZSdyZSBhbHJlYWR5IGluIHRoZSBtaWRkbGUgb2YgYSByZW5kZXIsIHN3aXRjaGluZyBsYW5lcyB3aWxsIGludGVycnVwdFxuLy8gaXQgYW5kIHdlJ2xsIGxvc2Ugb3VyIHByb2dyZXNzLiBXZSBzaG91bGQgb25seSBkbyB0aGlzIGlmIHRoZSBuZXcgbGFuZXMgYXJlXG4vLyBoaWdoZXIgcHJpb3JpdHkuXG5pZih3aXBMYW5lcyE9PU5vTGFuZXMmJndpcExhbmVzIT09bmV4dExhbmVzJiYvLyBJZiB3ZSBhbHJlYWR5IHN1c3BlbmRlZCB3aXRoIGEgZGVsYXksIHRoZW4gaW50ZXJydXB0aW5nIGlzIGZpbmUuIERvbid0XG4vLyBib3RoZXIgd2FpdGluZyB1bnRpbCB0aGUgcm9vdCBpcyBjb21wbGV0ZS5cbih3aXBMYW5lcyZzdXNwZW5kZWRMYW5lcyk9PT1Ob0xhbmVzKXt2YXIgbmV4dExhbmU9Z2V0SGlnaGVzdFByaW9yaXR5TGFuZShuZXh0TGFuZXMpO3ZhciB3aXBMYW5lPWdldEhpZ2hlc3RQcmlvcml0eUxhbmUod2lwTGFuZXMpO2lmKC8vIFRlc3RzIHdoZXRoZXIgdGhlIG5leHQgbGFuZSBpcyBlcXVhbCBvciBsb3dlciBwcmlvcml0eSB0aGFuIHRoZSB3aXBcbi8vIG9uZS4gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXRzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxubmV4dExhbmU+PXdpcExhbmV8fC8vIERlZmF1bHQgcHJpb3JpdHkgdXBkYXRlcyBzaG91bGQgbm90IGludGVycnVwdCB0cmFuc2l0aW9uIHVwZGF0ZXMuIFRoZVxuLy8gb25seSBkaWZmZXJlbmNlIGJldHdlZW4gZGVmYXVsdCB1cGRhdGVzIGFuZCB0cmFuc2l0aW9uIHVwZGF0ZXMgaXMgdGhhdFxuLy8gZGVmYXVsdCB1cGRhdGVzIGRvIG5vdCBzdXBwb3J0IHJlZnJlc2ggdHJhbnNpdGlvbnMuXG5uZXh0TGFuZT09PURlZmF1bHRMYW5lJiYod2lwTGFuZSZUcmFuc2l0aW9uTGFuZXMpIT09Tm9MYW5lcyl7Ly8gS2VlcCB3b3JraW5nIG9uIHRoZSBleGlzdGluZyBpbi1wcm9ncmVzcyB0cmVlLiBEbyBub3QgaW50ZXJydXB0LlxucmV0dXJuIHdpcExhbmVzO319aWYoKG5leHRMYW5lcyZJbnB1dENvbnRpbnVvdXNMYW5lKSE9PU5vTGFuZXMpey8vIFdoZW4gdXBkYXRlcyBhcmUgc3luYyBieSBkZWZhdWx0LCB3ZSBlbnRhbmdsZSBjb250aW51b3VzIHByaW9yaXR5IHVwZGF0ZXNcbi8vIGFuZCBkZWZhdWx0IHVwZGF0ZXMsIHNvIHRoZXkgcmVuZGVyIGluIHRoZSBzYW1lIGJhdGNoLiBUaGUgb25seSByZWFzb25cbi8vIHRoZXkgdXNlIHNlcGFyYXRlIGxhbmVzIGlzIGJlY2F1c2UgY29udGludW91cyB1cGRhdGVzIHNob3VsZCBpbnRlcnJ1cHRcbi8vIHRyYW5zaXRpb25zLCBidXQgZGVmYXVsdCB1cGRhdGVzIHNob3VsZCBub3QuXG5uZXh0TGFuZXN8PXBlbmRpbmdMYW5lcyZEZWZhdWx0TGFuZTt9Ly8gQ2hlY2sgZm9yIGVudGFuZ2xlZCBsYW5lcyBhbmQgYWRkIHRoZW0gdG8gdGhlIGJhdGNoLlxuLy9cbi8vIEEgbGFuZSBpcyBzYWlkIHRvIGJlIGVudGFuZ2xlZCB3aXRoIGFub3RoZXIgd2hlbiBpdCdzIG5vdCBhbGxvd2VkIHRvIHJlbmRlclxuLy8gaW4gYSBiYXRjaCB0aGF0IGRvZXMgbm90IGFsc28gaW5jbHVkZSB0aGUgb3RoZXIgbGFuZS4gVHlwaWNhbGx5IHdlIGRvIHRoaXNcbi8vIHdoZW4gbXVsdGlwbGUgdXBkYXRlcyBoYXZlIHRoZSBzYW1lIHNvdXJjZSwgYW5kIHdlIG9ubHkgd2FudCB0byByZXNwb25kIHRvXG4vLyB0aGUgbW9zdCByZWNlbnQgZXZlbnQgZnJvbSB0aGF0IHNvdXJjZS5cbi8vXG4vLyBOb3RlIHRoYXQgd2UgYXBwbHkgZW50YW5nbGVtZW50cyAqYWZ0ZXIqIGNoZWNraW5nIGZvciBwYXJ0aWFsIHdvcmsgYWJvdmUuXG4vLyBUaGlzIG1lYW5zIHRoYXQgaWYgYSBsYW5lIGlzIGVudGFuZ2xlZCBkdXJpbmcgYW4gaW50ZXJsZWF2ZWQgZXZlbnQgd2hpbGVcbi8vIGl0J3MgYWxyZWFkeSByZW5kZXJpbmcsIHdlIHdvbid0IGludGVycnVwdCBpdC4gVGhpcyBpcyBpbnRlbnRpb25hbCwgc2luY2Vcbi8vIGVudGFuZ2xlbWVudCBpcyB1c3VhbGx5IFwiYmVzdCBlZmZvcnRcIjogd2UnbGwgdHJ5IG91ciBiZXN0IHRvIHJlbmRlciB0aGVcbi8vIGxhbmVzIGluIHRoZSBzYW1lIGJhdGNoLCBidXQgaXQncyBub3Qgd29ydGggdGhyb3dpbmcgb3V0IHBhcnRpYWxseVxuLy8gY29tcGxldGVkIHdvcmsgaW4gb3JkZXIgdG8gZG8gaXQuXG4vLyBUT0RPOiBSZWNvbnNpZGVyIHRoaXMuIFRoZSBjb3VudGVyLWFyZ3VtZW50IGlzIHRoYXQgdGhlIHBhcnRpYWwgd29ya1xuLy8gcmVwcmVzZW50cyBhbiBpbnRlcm1lZGlhdGUgc3RhdGUsIHdoaWNoIHdlIGRvbid0IHdhbnQgdG8gc2hvdyB0byB0aGUgdXNlci5cbi8vIEFuZCBieSBzcGVuZGluZyBleHRyYSB0aW1lIGZpbmlzaGluZyBpdCwgd2UncmUgaW5jcmVhc2luZyB0aGUgYW1vdW50IG9mXG4vLyB0aW1lIGl0IHRha2VzIHRvIHNob3cgdGhlIGZpbmFsIHN0YXRlLCB3aGljaCBpcyB3aGF0IHRoZXkgYXJlIGFjdHVhbGx5XG4vLyB3YWl0aW5nIGZvci5cbi8vXG4vLyBGb3IgdGhvc2UgZXhjZXB0aW9ucyB3aGVyZSBlbnRhbmdsZW1lbnQgaXMgc2VtYW50aWNhbGx5IGltcG9ydGFudCwgbGlrZVxuLy8gdXNlTXV0YWJsZVNvdXJjZSwgd2Ugc2hvdWxkIGVuc3VyZSB0aGF0IHRoZXJlIGlzIG5vIHBhcnRpYWwgd29yayBhdCB0aGVcbi8vIHRpbWUgd2UgYXBwbHkgdGhlIGVudGFuZ2xlbWVudC5cbnZhciBlbnRhbmdsZWRMYW5lcz1yb290LmVudGFuZ2xlZExhbmVzO2lmKGVudGFuZ2xlZExhbmVzIT09Tm9MYW5lcyl7dmFyIGVudGFuZ2xlbWVudHM9cm9vdC5lbnRhbmdsZW1lbnRzO3ZhciBsYW5lcz1uZXh0TGFuZXMmZW50YW5nbGVkTGFuZXM7d2hpbGUobGFuZXM+MCl7dmFyIGluZGV4PXBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO3ZhciBsYW5lPTE8PGluZGV4O25leHRMYW5lc3w9ZW50YW5nbGVtZW50c1tpbmRleF07bGFuZXMmPX5sYW5lO319cmV0dXJuIG5leHRMYW5lczt9ZnVuY3Rpb24gZ2V0TW9zdFJlY2VudEV2ZW50VGltZShyb290LGxhbmVzKXt2YXIgZXZlbnRUaW1lcz1yb290LmV2ZW50VGltZXM7dmFyIG1vc3RSZWNlbnRFdmVudFRpbWU9Tm9UaW1lc3RhbXA7d2hpbGUobGFuZXM+MCl7dmFyIGluZGV4PXBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO3ZhciBsYW5lPTE8PGluZGV4O3ZhciBldmVudFRpbWU9ZXZlbnRUaW1lc1tpbmRleF07aWYoZXZlbnRUaW1lPm1vc3RSZWNlbnRFdmVudFRpbWUpe21vc3RSZWNlbnRFdmVudFRpbWU9ZXZlbnRUaW1lO31sYW5lcyY9fmxhbmU7fXJldHVybiBtb3N0UmVjZW50RXZlbnRUaW1lO31mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSxjdXJyZW50VGltZSl7c3dpdGNoKGxhbmUpe2Nhc2UgU3luY0xhbmU6Y2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOmNhc2UgSW5wdXRDb250aW51b3VzTGFuZTovLyBVc2VyIGludGVyYWN0aW9ucyBzaG91bGQgZXhwaXJlIHNsaWdodGx5IG1vcmUgcXVpY2tseS5cbi8vXG4vLyBOT1RFOiBUaGlzIGlzIHNldCB0byB0aGUgY29ycmVzcG9uZGluZyBjb25zdGFudCBhcyBpbiBTY2hlZHVsZXIuanMuXG4vLyBXaGVuIHdlIG1hZGUgaXQgbGFyZ2VyLCBhIHByb2R1Y3QgbWV0cmljIGluIHd3dyByZWdyZXNzZWQsIHN1Z2dlc3Rpbmdcbi8vIHRoZXJlJ3MgYSB1c2VyIGludGVyYWN0aW9uIHRoYXQncyBiZWluZyBzdGFydmVkIGJ5IGEgc2VyaWVzIG9mXG4vLyBzeW5jaHJvbm91cyB1cGRhdGVzLiBJZiB0aGF0IHRoZW9yeSBpcyBjb3JyZWN0LCB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzXG4vLyB0byBmaXggdGhlIHN0YXJ2YXRpb24uIEhvd2V2ZXIsIHRoaXMgc2NlbmFyaW8gc3VwcG9ydHMgdGhlIGlkZWEgdGhhdFxuLy8gZXhwaXJhdGlvbiB0aW1lcyBhcmUgYW4gaW1wb3J0YW50IHNhZmVndWFyZCB3aGVuIHN0YXJ2YXRpb25cbi8vIGRvZXMgaGFwcGVuLlxucmV0dXJuIGN1cnJlbnRUaW1lKzI1MDtjYXNlIERlZmF1bHRIeWRyYXRpb25MYW5lOmNhc2UgRGVmYXVsdExhbmU6Y2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpjYXNlIFRyYW5zaXRpb25MYW5lMTpjYXNlIFRyYW5zaXRpb25MYW5lMjpjYXNlIFRyYW5zaXRpb25MYW5lMzpjYXNlIFRyYW5zaXRpb25MYW5lNDpjYXNlIFRyYW5zaXRpb25MYW5lNTpjYXNlIFRyYW5zaXRpb25MYW5lNjpjYXNlIFRyYW5zaXRpb25MYW5lNzpjYXNlIFRyYW5zaXRpb25MYW5lODpjYXNlIFRyYW5zaXRpb25MYW5lOTpjYXNlIFRyYW5zaXRpb25MYW5lMTA6Y2FzZSBUcmFuc2l0aW9uTGFuZTExOmNhc2UgVHJhbnNpdGlvbkxhbmUxMjpjYXNlIFRyYW5zaXRpb25MYW5lMTM6Y2FzZSBUcmFuc2l0aW9uTGFuZTE0OmNhc2UgVHJhbnNpdGlvbkxhbmUxNTpjYXNlIFRyYW5zaXRpb25MYW5lMTY6cmV0dXJuIGN1cnJlbnRUaW1lKzUwMDA7Y2FzZSBSZXRyeUxhbmUxOmNhc2UgUmV0cnlMYW5lMjpjYXNlIFJldHJ5TGFuZTM6Y2FzZSBSZXRyeUxhbmU0OmNhc2UgUmV0cnlMYW5lNTovLyBUT0RPOiBSZXRyaWVzIHNob3VsZCBiZSBhbGxvd2VkIHRvIGV4cGlyZSBpZiB0aGV5IGFyZSBDUFUgYm91bmQgZm9yXG4vLyB0b28gbG9uZywgYnV0IHdoZW4gSSBtYWRlIHRoaXMgY2hhbmdlIGl0IGNhdXNlZCBhIHNwaWtlIGluIGJyb3dzZXJcbi8vIGNyYXNoZXMuIFRoZXJlIG11c3QgYmUgc29tZSBvdGhlciB1bmRlcmx5aW5nIGJ1Zzsgbm90IHN1cGVyIHVyZ2VudCBidXRcbi8vIGlkZWFsbHkgc2hvdWxkIGZpZ3VyZSBvdXQgd2h5IGFuZCBmaXggaXQuIFVuZm9ydHVuYXRlbHkgd2UgZG9uJ3QgaGF2ZVxuLy8gYSByZXBybyBmb3IgdGhlIGNyYXNoZXMsIG9ubHkgZGV0ZWN0ZWQgdmlhIHByb2R1Y3Rpb24gbWV0cmljcy5cbnJldHVybiBOb1RpbWVzdGFtcDtjYXNlIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU6Y2FzZSBJZGxlSHlkcmF0aW9uTGFuZTpjYXNlIElkbGVMYW5lOmNhc2UgT2Zmc2NyZWVuTGFuZTovLyBBbnl0aGluZyBpZGxlIHByaW9yaXR5IG9yIGxvd2VyIHNob3VsZCBuZXZlciBleHBpcmUuXG5yZXR1cm4gTm9UaW1lc3RhbXA7ZGVmYXVsdDp7ZXJyb3IoJ1Nob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO31yZXR1cm4gTm9UaW1lc3RhbXA7fX1mdW5jdGlvbiBtYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkKHJvb3QsY3VycmVudFRpbWUpey8vIFRPRE86IFRoaXMgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSB3ZSB5aWVsZC4gV2UgY2FuIG9wdGltaXplIGJ5IHN0b3Jpbmdcbi8vIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUgb24gdGhlIHJvb3QuIFRoZW4gdXNlIHRoYXQgdG8gcXVpY2tseSBiYWlsIG91dFxuLy8gb2YgdGhpcyBmdW5jdGlvbi5cbnZhciBwZW5kaW5nTGFuZXM9cm9vdC5wZW5kaW5nTGFuZXM7dmFyIHN1c3BlbmRlZExhbmVzPXJvb3Quc3VzcGVuZGVkTGFuZXM7dmFyIHBpbmdlZExhbmVzPXJvb3QucGluZ2VkTGFuZXM7dmFyIGV4cGlyYXRpb25UaW1lcz1yb290LmV4cGlyYXRpb25UaW1lczsvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHBlbmRpbmcgbGFuZXMgYW5kIGNoZWNrIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlaXJcbi8vIGV4cGlyYXRpb24gdGltZS4gSWYgc28sIHdlJ2xsIGFzc3VtZSB0aGUgdXBkYXRlIGlzIGJlaW5nIHN0YXJ2ZWQgYW5kIG1hcmtcbi8vIGl0IGFzIGV4cGlyZWQgdG8gZm9yY2UgaXQgdG8gZmluaXNoLlxudmFyIGxhbmVzPXBlbmRpbmdMYW5lczt3aGlsZShsYW5lcz4wKXt2YXIgaW5kZXg9cGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7dmFyIGxhbmU9MTw8aW5kZXg7dmFyIGV4cGlyYXRpb25UaW1lPWV4cGlyYXRpb25UaW1lc1tpbmRleF07aWYoZXhwaXJhdGlvblRpbWU9PT1Ob1RpbWVzdGFtcCl7Ly8gRm91bmQgYSBwZW5kaW5nIGxhbmUgd2l0aCBubyBleHBpcmF0aW9uIHRpbWUuIElmIGl0J3Mgbm90IHN1c3BlbmRlZCwgb3Jcbi8vIGlmIGl0J3MgcGluZ2VkLCBhc3N1bWUgaXQncyBDUFUtYm91bmQuIENvbXB1dGUgYSBuZXcgZXhwaXJhdGlvbiB0aW1lXG4vLyB1c2luZyB0aGUgY3VycmVudCB0aW1lLlxuaWYoKGxhbmUmc3VzcGVuZGVkTGFuZXMpPT09Tm9MYW5lc3x8KGxhbmUmcGluZ2VkTGFuZXMpIT09Tm9MYW5lcyl7Ly8gQXNzdW1lcyB0aW1lc3RhbXBzIGFyZSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcuXG5leHBpcmF0aW9uVGltZXNbaW5kZXhdPWNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLGN1cnJlbnRUaW1lKTt9fWVsc2UgaWYoZXhwaXJhdGlvblRpbWU8PWN1cnJlbnRUaW1lKXsvLyBUaGlzIGxhbmUgZXhwaXJlZFxucm9vdC5leHBpcmVkTGFuZXN8PWxhbmU7fWxhbmVzJj1+bGFuZTt9fS8vIFRoaXMgcmV0dXJucyB0aGUgaGlnaGVzdCBwcmlvcml0eSBwZW5kaW5nIGxhbmVzIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGV5XG4vLyBhcmUgc3VzcGVuZGVkLlxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5UGVuZGluZ0xhbmVzKHJvb3Qpe3JldHVybiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhyb290LnBlbmRpbmdMYW5lcyk7fWZ1bmN0aW9uIGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3Qpe3ZhciBldmVyeXRoaW5nQnV0T2Zmc2NyZWVuPXJvb3QucGVuZGluZ0xhbmVzJn5PZmZzY3JlZW5MYW5lO2lmKGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4hPT1Ob0xhbmVzKXtyZXR1cm4gZXZlcnl0aGluZ0J1dE9mZnNjcmVlbjt9aWYoZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiZPZmZzY3JlZW5MYW5lKXtyZXR1cm4gT2Zmc2NyZWVuTGFuZTt9cmV0dXJuIE5vTGFuZXM7fWZ1bmN0aW9uIGluY2x1ZGVzU3luY0xhbmUobGFuZXMpe3JldHVybihsYW5lcyZTeW5jTGFuZSkhPT1Ob0xhbmVzO31mdW5jdGlvbiBpbmNsdWRlc05vbklkbGVXb3JrKGxhbmVzKXtyZXR1cm4obGFuZXMmTm9uSWRsZUxhbmVzKSE9PU5vTGFuZXM7fWZ1bmN0aW9uIGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpe3JldHVybihsYW5lcyZSZXRyeUxhbmVzKT09PWxhbmVzO31mdW5jdGlvbiBpbmNsdWRlc09ubHlOb25VcmdlbnRMYW5lcyhsYW5lcyl7dmFyIFVyZ2VudExhbmVzPVN5bmNMYW5lfElucHV0Q29udGludW91c0xhbmV8RGVmYXVsdExhbmU7cmV0dXJuKGxhbmVzJlVyZ2VudExhbmVzKT09PU5vTGFuZXM7fWZ1bmN0aW9uIGluY2x1ZGVzT25seVRyYW5zaXRpb25zKGxhbmVzKXtyZXR1cm4obGFuZXMmVHJhbnNpdGlvbkxhbmVzKT09PWxhbmVzO31mdW5jdGlvbiBpbmNsdWRlc0Jsb2NraW5nTGFuZShyb290LGxhbmVzKXt2YXIgU3luY0RlZmF1bHRMYW5lcz1JbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lfElucHV0Q29udGludW91c0xhbmV8RGVmYXVsdEh5ZHJhdGlvbkxhbmV8RGVmYXVsdExhbmU7cmV0dXJuKGxhbmVzJlN5bmNEZWZhdWx0TGFuZXMpIT09Tm9MYW5lczt9ZnVuY3Rpb24gaW5jbHVkZXNFeHBpcmVkTGFuZShyb290LGxhbmVzKXsvLyBUaGlzIGlzIGEgc2VwYXJhdGUgY2hlY2sgZnJvbSBpbmNsdWRlc0Jsb2NraW5nTGFuZSBiZWNhdXNlIGEgbGFuZSBjYW5cbi8vIGV4cGlyZSBhZnRlciBhIHJlbmRlciBoYXMgYWxyZWFkeSBzdGFydGVkLlxucmV0dXJuKGxhbmVzJnJvb3QuZXhwaXJlZExhbmVzKSE9PU5vTGFuZXM7fWZ1bmN0aW9uIGlzVHJhbnNpdGlvbkxhbmUobGFuZSl7cmV0dXJuKGxhbmUmVHJhbnNpdGlvbkxhbmVzKSE9PU5vTGFuZXM7fWZ1bmN0aW9uIGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCl7Ly8gQ3ljbGUgdGhyb3VnaCB0aGUgbGFuZXMsIGFzc2lnbmluZyBlYWNoIG5ldyB0cmFuc2l0aW9uIHRvIHRoZSBuZXh0IGxhbmUuXG4vLyBJbiBtb3N0IGNhc2VzLCB0aGlzIG1lYW5zIGV2ZXJ5IHRyYW5zaXRpb24gZ2V0cyBpdHMgb3duIGxhbmUsIHVudGlsIHdlXG4vLyBydW4gb3V0IG9mIGxhbmVzIGFuZCBjeWNsZSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcuXG52YXIgbGFuZT1uZXh0VHJhbnNpdGlvbkxhbmU7bmV4dFRyYW5zaXRpb25MYW5lPDw9MTtpZigobmV4dFRyYW5zaXRpb25MYW5lJlRyYW5zaXRpb25MYW5lcyk9PT1Ob0xhbmVzKXtuZXh0VHJhbnNpdGlvbkxhbmU9VHJhbnNpdGlvbkxhbmUxO31yZXR1cm4gbGFuZTt9ZnVuY3Rpb24gY2xhaW1OZXh0UmV0cnlMYW5lKCl7dmFyIGxhbmU9bmV4dFJldHJ5TGFuZTtuZXh0UmV0cnlMYW5lPDw9MTtpZigobmV4dFJldHJ5TGFuZSZSZXRyeUxhbmVzKT09PU5vTGFuZXMpe25leHRSZXRyeUxhbmU9UmV0cnlMYW5lMTt9cmV0dXJuIGxhbmU7fWZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpe3JldHVybiBsYW5lcyYtbGFuZXM7fWZ1bmN0aW9uIHBpY2tBcmJpdHJhcnlMYW5lKGxhbmVzKXsvLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZ2V0cyBpbmxpbmVkLiBPbmx5IGV4aXN0cyBzbyB0byBjb21tdW5pY2F0ZSB0aGF0IGl0XG4vLyBkb2Vzbid0IG1hdHRlciB3aGljaCBiaXQgaXMgc2VsZWN0ZWQ7IHlvdSBjYW4gcGljayBhbnkgYml0IHdpdGhvdXRcbi8vIGFmZmVjdGluZyB0aGUgYWxnb3JpdGhtcyB3aGVyZSBpdHMgdXNlZC4gSGVyZSBJJ20gdXNpbmdcbi8vIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUgYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgZmV3ZXN0IG9wZXJhdGlvbnMuXG5yZXR1cm4gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcyk7fWZ1bmN0aW9uIHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpe3JldHVybiAzMS1jbHozMihsYW5lcyk7fWZ1bmN0aW9uIGxhbmVUb0luZGV4KGxhbmUpe3JldHVybiBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmUpO31mdW5jdGlvbiBpbmNsdWRlc1NvbWVMYW5lKGEsYil7cmV0dXJuKGEmYikhPT1Ob0xhbmVzO31mdW5jdGlvbiBpc1N1YnNldE9mTGFuZXMoc2V0LHN1YnNldCl7cmV0dXJuKHNldCZzdWJzZXQpPT09c3Vic2V0O31mdW5jdGlvbiBtZXJnZUxhbmVzKGEsYil7cmV0dXJuIGF8Yjt9ZnVuY3Rpb24gcmVtb3ZlTGFuZXMoc2V0LHN1YnNldCl7cmV0dXJuIHNldCZ+c3Vic2V0O31mdW5jdGlvbiBpbnRlcnNlY3RMYW5lcyhhLGIpe3JldHVybiBhJmI7fS8vIFNlZW1zIHJlZHVuZGFudCwgYnV0IGl0IGNoYW5nZXMgdGhlIHR5cGUgZnJvbSBhIHNpbmdsZSBsYW5lICh1c2VkIGZvclxuLy8gdXBkYXRlcykgdG8gYSBncm91cCBvZiBsYW5lcyAodXNlZCBmb3IgZmx1c2hpbmcgd29yaykuXG5mdW5jdGlvbiBsYW5lVG9MYW5lcyhsYW5lKXtyZXR1cm4gbGFuZTt9ZnVuY3Rpb24gaGlnaGVyUHJpb3JpdHlMYW5lKGEsYil7Ly8gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXQgcmFuZ2VzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxucmV0dXJuIGEhPT1Ob0xhbmUmJmE8Yj9hOmI7fWZ1bmN0aW9uIGNyZWF0ZUxhbmVNYXAoaW5pdGlhbCl7Ly8gSW50ZW50aW9uYWxseSBwdXNoaW5nIG9uZSBieSBvbmUuXG4vLyBodHRwczovL3Y4LmRldi9ibG9nL2VsZW1lbnRzLWtpbmRzI2F2b2lkLWNyZWF0aW5nLWhvbGVzXG52YXIgbGFuZU1hcD1bXTtmb3IodmFyIGk9MDtpPFRvdGFsTGFuZXM7aSsrKXtsYW5lTWFwLnB1c2goaW5pdGlhbCk7fXJldHVybiBsYW5lTWFwO31mdW5jdGlvbiBtYXJrUm9vdFVwZGF0ZWQocm9vdCx1cGRhdGVMYW5lLGV2ZW50VGltZSl7cm9vdC5wZW5kaW5nTGFuZXN8PXVwZGF0ZUxhbmU7Ly8gSWYgdGhlcmUgYXJlIGFueSBzdXNwZW5kZWQgdHJhbnNpdGlvbnMsIGl0J3MgcG9zc2libGUgdGhpcyBuZXcgdXBkYXRlXG4vLyBjb3VsZCB1bmJsb2NrIHRoZW0uIENsZWFyIHRoZSBzdXNwZW5kZWQgbGFuZXMgc28gdGhhdCB3ZSBjYW4gdHJ5IHJlbmRlcmluZ1xuLy8gdGhlbSBhZ2Fpbi5cbi8vXG4vLyBUT0RPOiBXZSByZWFsbHkgb25seSBuZWVkIHRvIHVuc3VzcGVuZCBvbmx5IGxhbmVzIHRoYXQgYXJlIGluIHRoZVxuLy8gYHN1YnRyZWVMYW5lc2Agb2YgdGhlIHVwZGF0ZWQgZmliZXIsIG9yIHRoZSB1cGRhdGUgbGFuZXMgb2YgdGhlIHJldHVyblxuLy8gcGF0aC4gVGhpcyB3b3VsZCBleGNsdWRlIHN1c3BlbmRlZCB1cGRhdGVzIGluIGFuIHVucmVsYXRlZCBzaWJsaW5nIHRyZWUsXG4vLyBzaW5jZSB0aGVyZSdzIG5vIHdheSBmb3IgdGhpcyB1cGRhdGUgdG8gdW5ibG9jayBpdC5cbi8vXG4vLyBXZSBkb24ndCBkbyB0aGlzIGlmIHRoZSBpbmNvbWluZyB1cGRhdGUgaXMgaWRsZSwgYmVjYXVzZSB3ZSBuZXZlciBwcm9jZXNzXG4vLyBpZGxlIHVwZGF0ZXMgdW50aWwgYWZ0ZXIgYWxsIHRoZSByZWd1bGFyIHVwZGF0ZXMgaGF2ZSBmaW5pc2hlZDsgdGhlcmUncyBub1xuLy8gd2F5IGl0IGNvdWxkIHVuYmxvY2sgYSB0cmFuc2l0aW9uLlxuaWYodXBkYXRlTGFuZSE9PUlkbGVMYW5lKXtyb290LnN1c3BlbmRlZExhbmVzPU5vTGFuZXM7cm9vdC5waW5nZWRMYW5lcz1Ob0xhbmVzO312YXIgZXZlbnRUaW1lcz1yb290LmV2ZW50VGltZXM7dmFyIGluZGV4PWxhbmVUb0luZGV4KHVwZGF0ZUxhbmUpOy8vIFdlIGNhbiBhbHdheXMgb3ZlcndyaXRlIGFuIGV4aXN0aW5nIHRpbWVzdGFtcCBiZWNhdXNlIHdlIHByZWZlciB0aGUgbW9zdFxuLy8gcmVjZW50IGV2ZW50LCBhbmQgd2UgYXNzdW1lIHRpbWUgaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuZXZlbnRUaW1lc1tpbmRleF09ZXZlbnRUaW1lO31mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZChyb290LHN1c3BlbmRlZExhbmVzKXtyb290LnN1c3BlbmRlZExhbmVzfD1zdXNwZW5kZWRMYW5lcztyb290LnBpbmdlZExhbmVzJj1+c3VzcGVuZGVkTGFuZXM7Ly8gVGhlIHN1c3BlbmRlZCBsYW5lcyBhcmUgbm8gbG9uZ2VyIENQVS1ib3VuZC4gQ2xlYXIgdGhlaXIgZXhwaXJhdGlvbiB0aW1lcy5cbnZhciBleHBpcmF0aW9uVGltZXM9cm9vdC5leHBpcmF0aW9uVGltZXM7dmFyIGxhbmVzPXN1c3BlbmRlZExhbmVzO3doaWxlKGxhbmVzPjApe3ZhciBpbmRleD1waWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTt2YXIgbGFuZT0xPDxpbmRleDtleHBpcmF0aW9uVGltZXNbaW5kZXhdPU5vVGltZXN0YW1wO2xhbmVzJj1+bGFuZTt9fWZ1bmN0aW9uIG1hcmtSb290UGluZ2VkKHJvb3QscGluZ2VkTGFuZXMsZXZlbnRUaW1lKXtyb290LnBpbmdlZExhbmVzfD1yb290LnN1c3BlbmRlZExhbmVzJnBpbmdlZExhbmVzO31mdW5jdGlvbiBtYXJrUm9vdEZpbmlzaGVkKHJvb3QscmVtYWluaW5nTGFuZXMpe3ZhciBub0xvbmdlclBlbmRpbmdMYW5lcz1yb290LnBlbmRpbmdMYW5lcyZ+cmVtYWluaW5nTGFuZXM7cm9vdC5wZW5kaW5nTGFuZXM9cmVtYWluaW5nTGFuZXM7Ly8gTGV0J3MgdHJ5IGV2ZXJ5dGhpbmcgYWdhaW5cbnJvb3Quc3VzcGVuZGVkTGFuZXM9Tm9MYW5lcztyb290LnBpbmdlZExhbmVzPU5vTGFuZXM7cm9vdC5leHBpcmVkTGFuZXMmPXJlbWFpbmluZ0xhbmVzO3Jvb3QubXV0YWJsZVJlYWRMYW5lcyY9cmVtYWluaW5nTGFuZXM7cm9vdC5lbnRhbmdsZWRMYW5lcyY9cmVtYWluaW5nTGFuZXM7dmFyIGVudGFuZ2xlbWVudHM9cm9vdC5lbnRhbmdsZW1lbnRzO3ZhciBldmVudFRpbWVzPXJvb3QuZXZlbnRUaW1lczt2YXIgZXhwaXJhdGlvblRpbWVzPXJvb3QuZXhwaXJhdGlvblRpbWVzOy8vIENsZWFyIHRoZSBsYW5lcyB0aGF0IG5vIGxvbmdlciBoYXZlIHBlbmRpbmcgd29ya1xudmFyIGxhbmVzPW5vTG9uZ2VyUGVuZGluZ0xhbmVzO3doaWxlKGxhbmVzPjApe3ZhciBpbmRleD1waWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTt2YXIgbGFuZT0xPDxpbmRleDtlbnRhbmdsZW1lbnRzW2luZGV4XT1Ob0xhbmVzO2V2ZW50VGltZXNbaW5kZXhdPU5vVGltZXN0YW1wO2V4cGlyYXRpb25UaW1lc1tpbmRleF09Tm9UaW1lc3RhbXA7bGFuZXMmPX5sYW5lO319ZnVuY3Rpb24gbWFya1Jvb3RFbnRhbmdsZWQocm9vdCxlbnRhbmdsZWRMYW5lcyl7Ly8gSW4gYWRkaXRpb24gdG8gZW50YW5nbGluZyBlYWNoIG9mIHRoZSBnaXZlbiBsYW5lcyB3aXRoIGVhY2ggb3RoZXIsIHdlIGFsc29cbi8vIGhhdmUgdG8gY29uc2lkZXIgX3RyYW5zaXRpdmVfIGVudGFuZ2xlbWVudHMuIEZvciBlYWNoIGxhbmUgdGhhdCBpcyBhbHJlYWR5XG4vLyBlbnRhbmdsZWQgd2l0aCAqYW55KiBvZiB0aGUgZ2l2ZW4gbGFuZXMsIHRoYXQgbGFuZSBpcyBub3cgdHJhbnNpdGl2ZWx5XG4vLyBlbnRhbmdsZWQgd2l0aCAqYWxsKiB0aGUgZ2l2ZW4gbGFuZXMuXG4vL1xuLy8gVHJhbnNsYXRlZDogSWYgQyBpcyBlbnRhbmdsZWQgd2l0aCBBLCB0aGVuIGVudGFuZ2xpbmcgQSB3aXRoIEIgYWxzb1xuLy8gZW50YW5nbGVzIEMgd2l0aCBCLlxuLy9cbi8vIElmIHRoaXMgaXMgaGFyZCB0byBncmFzcCwgaXQgbWlnaHQgaGVscCB0byBpbnRlbnRpb25hbGx5IGJyZWFrIHRoaXNcbi8vIGZ1bmN0aW9uIGFuZCBsb29rIGF0IHRoZSB0ZXN0cyB0aGF0IGZhaWwgaW4gUmVhY3RUcmFuc2l0aW9uLXRlc3QuanMuIFRyeVxuLy8gY29tbWVudGluZyBvdXQgb25lIG9mIHRoZSBjb25kaXRpb25zIGJlbG93LlxudmFyIHJvb3RFbnRhbmdsZWRMYW5lcz1yb290LmVudGFuZ2xlZExhbmVzfD1lbnRhbmdsZWRMYW5lczt2YXIgZW50YW5nbGVtZW50cz1yb290LmVudGFuZ2xlbWVudHM7dmFyIGxhbmVzPXJvb3RFbnRhbmdsZWRMYW5lczt3aGlsZShsYW5lcyl7dmFyIGluZGV4PXBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO3ZhciBsYW5lPTE8PGluZGV4O2lmKC8vIElzIHRoaXMgb25lIG9mIHRoZSBuZXdseSBlbnRhbmdsZWQgbGFuZXM/XG5sYW5lJmVudGFuZ2xlZExhbmVzfC8vIElzIHRoaXMgbGFuZSB0cmFuc2l0aXZlbHkgZW50YW5nbGVkIHdpdGggdGhlIG5ld2x5IGVudGFuZ2xlZCBsYW5lcz9cbmVudGFuZ2xlbWVudHNbaW5kZXhdJmVudGFuZ2xlZExhbmVzKXtlbnRhbmdsZW1lbnRzW2luZGV4XXw9ZW50YW5nbGVkTGFuZXM7fWxhbmVzJj1+bGFuZTt9fWZ1bmN0aW9uIGdldEJ1bXBlZExhbmVGb3JIeWRyYXRpb24ocm9vdCxyZW5kZXJMYW5lcyl7dmFyIHJlbmRlckxhbmU9Z2V0SGlnaGVzdFByaW9yaXR5TGFuZShyZW5kZXJMYW5lcyk7dmFyIGxhbmU7c3dpdGNoKHJlbmRlckxhbmUpe2Nhc2UgSW5wdXRDb250aW51b3VzTGFuZTpsYW5lPUlucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU7YnJlYWs7Y2FzZSBEZWZhdWx0TGFuZTpsYW5lPURlZmF1bHRIeWRyYXRpb25MYW5lO2JyZWFrO2Nhc2UgVHJhbnNpdGlvbkxhbmUxOmNhc2UgVHJhbnNpdGlvbkxhbmUyOmNhc2UgVHJhbnNpdGlvbkxhbmUzOmNhc2UgVHJhbnNpdGlvbkxhbmU0OmNhc2UgVHJhbnNpdGlvbkxhbmU1OmNhc2UgVHJhbnNpdGlvbkxhbmU2OmNhc2UgVHJhbnNpdGlvbkxhbmU3OmNhc2UgVHJhbnNpdGlvbkxhbmU4OmNhc2UgVHJhbnNpdGlvbkxhbmU5OmNhc2UgVHJhbnNpdGlvbkxhbmUxMDpjYXNlIFRyYW5zaXRpb25MYW5lMTE6Y2FzZSBUcmFuc2l0aW9uTGFuZTEyOmNhc2UgVHJhbnNpdGlvbkxhbmUxMzpjYXNlIFRyYW5zaXRpb25MYW5lMTQ6Y2FzZSBUcmFuc2l0aW9uTGFuZTE1OmNhc2UgVHJhbnNpdGlvbkxhbmUxNjpjYXNlIFJldHJ5TGFuZTE6Y2FzZSBSZXRyeUxhbmUyOmNhc2UgUmV0cnlMYW5lMzpjYXNlIFJldHJ5TGFuZTQ6Y2FzZSBSZXRyeUxhbmU1OmxhbmU9VHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmU7YnJlYWs7Y2FzZSBJZGxlTGFuZTpsYW5lPUlkbGVIeWRyYXRpb25MYW5lO2JyZWFrO2RlZmF1bHQ6Ly8gRXZlcnl0aGluZyBlbHNlIGlzIGFscmVhZHkgZWl0aGVyIGEgaHlkcmF0aW9uIGxhbmUsIG9yIHNob3VsZG4ndFxuLy8gYmUgcmV0cmllZCBhdCBhIGh5ZHJhdGlvbiBsYW5lLlxubGFuZT1Ob0xhbmU7YnJlYWs7fS8vIENoZWNrIGlmIHRoZSBsYW5lIHdlIGNob3NlIGlzIHN1c3BlbmRlZC4gSWYgc28sIHRoYXQgaW5kaWNhdGVzIHRoYXQgd2Vcbi8vIGFscmVhZHkgYXR0ZW1wdGVkIGFuZCBmYWlsZWQgdG8gaHlkcmF0ZSBhdCB0aGF0IGxldmVsLiBBbHNvIGNoZWNrIGlmIHdlJ3JlXG4vLyBhbHJlYWR5IHJlbmRlcmluZyB0aGF0IGxhbmUsIHdoaWNoIGlzIHJhcmUgYnV0IGNvdWxkIGhhcHBlbi5cbmlmKChsYW5lJihyb290LnN1c3BlbmRlZExhbmVzfHJlbmRlckxhbmVzKSkhPT1Ob0xhbmUpey8vIEdpdmUgdXAgdHJ5aW5nIHRvIGh5ZHJhdGUgYW5kIGZhbGwgYmFjayB0byBjbGllbnQgcmVuZGVyLlxucmV0dXJuIE5vTGFuZTt9cmV0dXJuIGxhbmU7fWZ1bmN0aW9uIGFkZEZpYmVyVG9MYW5lc01hcChyb290LGZpYmVyLGxhbmVzKXtpZighaXNEZXZUb29sc1ByZXNlbnQpe3JldHVybjt9dmFyIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXA9cm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwO3doaWxlKGxhbmVzPjApe3ZhciBpbmRleD1sYW5lVG9JbmRleChsYW5lcyk7dmFyIGxhbmU9MTw8aW5kZXg7dmFyIHVwZGF0ZXJzPXBlbmRpbmdVcGRhdGVyc0xhbmVNYXBbaW5kZXhdO3VwZGF0ZXJzLmFkZChmaWJlcik7bGFuZXMmPX5sYW5lO319ZnVuY3Rpb24gbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsbGFuZXMpe2lmKCFpc0RldlRvb2xzUHJlc2VudCl7cmV0dXJuO312YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcD1yb290LnBlbmRpbmdVcGRhdGVyc0xhbmVNYXA7dmFyIG1lbW9pemVkVXBkYXRlcnM9cm9vdC5tZW1vaXplZFVwZGF0ZXJzO3doaWxlKGxhbmVzPjApe3ZhciBpbmRleD1sYW5lVG9JbmRleChsYW5lcyk7dmFyIGxhbmU9MTw8aW5kZXg7dmFyIHVwZGF0ZXJzPXBlbmRpbmdVcGRhdGVyc0xhbmVNYXBbaW5kZXhdO2lmKHVwZGF0ZXJzLnNpemU+MCl7dXBkYXRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWJlcil7dmFyIGFsdGVybmF0ZT1maWJlci5hbHRlcm5hdGU7aWYoYWx0ZXJuYXRlPT09bnVsbHx8IW1lbW9pemVkVXBkYXRlcnMuaGFzKGFsdGVybmF0ZSkpe21lbW9pemVkVXBkYXRlcnMuYWRkKGZpYmVyKTt9fSk7dXBkYXRlcnMuY2xlYXIoKTt9bGFuZXMmPX5sYW5lO319ZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbnNGb3JMYW5lcyhyb290LGxhbmVzKXt7cmV0dXJuIG51bGw7fX12YXIgRGlzY3JldGVFdmVudFByaW9yaXR5PVN5bmNMYW5lO3ZhciBDb250aW51b3VzRXZlbnRQcmlvcml0eT1JbnB1dENvbnRpbnVvdXNMYW5lO3ZhciBEZWZhdWx0RXZlbnRQcmlvcml0eT1EZWZhdWx0TGFuZTt2YXIgSWRsZUV2ZW50UHJpb3JpdHk9SWRsZUxhbmU7dmFyIGN1cnJlbnRVcGRhdGVQcmlvcml0eT1Ob0xhbmU7ZnVuY3Rpb24gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCl7cmV0dXJuIGN1cnJlbnRVcGRhdGVQcmlvcml0eTt9ZnVuY3Rpb24gc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5KXtjdXJyZW50VXBkYXRlUHJpb3JpdHk9bmV3UHJpb3JpdHk7fWZ1bmN0aW9uIHJ1bldpdGhQcmlvcml0eShwcmlvcml0eSxmbil7dmFyIHByZXZpb3VzUHJpb3JpdHk9Y3VycmVudFVwZGF0ZVByaW9yaXR5O3RyeXtjdXJyZW50VXBkYXRlUHJpb3JpdHk9cHJpb3JpdHk7cmV0dXJuIGZuKCk7fWZpbmFsbHl7Y3VycmVudFVwZGF0ZVByaW9yaXR5PXByZXZpb3VzUHJpb3JpdHk7fX1mdW5jdGlvbiBoaWdoZXJFdmVudFByaW9yaXR5KGEsYil7cmV0dXJuIGEhPT0wJiZhPGI/YTpiO31mdW5jdGlvbiBsb3dlckV2ZW50UHJpb3JpdHkoYSxiKXtyZXR1cm4gYT09PTB8fGE+Yj9hOmI7fWZ1bmN0aW9uIGlzSGlnaGVyRXZlbnRQcmlvcml0eShhLGIpe3JldHVybiBhIT09MCYmYTxiO31mdW5jdGlvbiBsYW5lc1RvRXZlbnRQcmlvcml0eShsYW5lcyl7dmFyIGxhbmU9Z2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcyk7aWYoIWlzSGlnaGVyRXZlbnRQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHksbGFuZSkpe3JldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7fWlmKCFpc0hpZ2hlckV2ZW50UHJpb3JpdHkoQ29udGludW91c0V2ZW50UHJpb3JpdHksbGFuZSkpe3JldHVybiBDb250aW51b3VzRXZlbnRQcmlvcml0eTt9aWYoaW5jbHVkZXNOb25JZGxlV29yayhsYW5lKSl7cmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O31yZXR1cm4gSWRsZUV2ZW50UHJpb3JpdHk7fS8vIFRoaXMgaXMgaW1wb3J0ZWQgYnkgdGhlIGV2ZW50IHJlcGxheWluZyBpbXBsZW1lbnRhdGlvbiBpbiBSZWFjdCBET00uIEl0J3Ncbi8vIGluIGEgc2VwYXJhdGUgZmlsZSB0byBicmVhayBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGUgcmVuZGVyZXIgYW5kXG4vLyB0aGUgcmVjb25jaWxlci5cbmZ1bmN0aW9uIGlzUm9vdERlaHlkcmF0ZWQocm9vdCl7dmFyIGN1cnJlbnRTdGF0ZT1yb290LmN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtyZXR1cm4gY3VycmVudFN0YXRlLmlzRGVoeWRyYXRlZDt9dmFyIF9hdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb247ZnVuY3Rpb24gc2V0QXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uKGZuKXtfYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uPWZuO31mdW5jdGlvbiBhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oZmliZXIpe19hdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oZmliZXIpO312YXIgYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb247ZnVuY3Rpb24gc2V0QXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oZm4pe2F0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uPWZuO312YXIgYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5O2Z1bmN0aW9uIHNldEF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eShmbil7YXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5PWZuO312YXIgZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5JDE7ZnVuY3Rpb24gc2V0R2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KGZuKXtnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkkMT1mbjt9dmFyIGF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5O2Z1bmN0aW9uIHNldEF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5KGZuKXthdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eT1mbjt9Ly8gVE9ETzogVXBncmFkZSB0aGlzIGRlZmluaXRpb24gb25jZSB3ZSdyZSBvbiBhIG5ld2VyIHZlcnNpb24gb2YgRmxvdyB0aGF0XG4vLyBoYXMgdGhpcyBkZWZpbml0aW9uIGJ1aWx0LWluLlxudmFyIGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQ9ZmFsc2U7Ly8gVGhlIHF1ZXVlIG9mIGRpc2NyZXRlIGV2ZW50cyB0byBiZSByZXBsYXllZC5cbnZhciBxdWV1ZWREaXNjcmV0ZUV2ZW50cz1bXTsvLyBJbmRpY2F0ZXMgaWYgYW55IGNvbnRpbnVvdXMgZXZlbnQgdGFyZ2V0cyBhcmUgbm9uLW51bGwgZm9yIGVhcmx5IGJhaWxvdXQuXG4vLyBpZiB0aGUgbGFzdCB0YXJnZXQgd2FzIGRlaHlkcmF0ZWQuXG52YXIgcXVldWVkRm9jdXM9bnVsbDt2YXIgcXVldWVkRHJhZz1udWxsO3ZhciBxdWV1ZWRNb3VzZT1udWxsOy8vIEZvciBwb2ludGVyIGV2ZW50cyB0aGVyZSBjYW4gYmUgb25lIGxhdGVzdCBldmVudCBwZXIgcG9pbnRlcklkLlxudmFyIHF1ZXVlZFBvaW50ZXJzPW5ldyBNYXAoKTt2YXIgcXVldWVkUG9pbnRlckNhcHR1cmVzPW5ldyBNYXAoKTsvLyBXZSBjb3VsZCBjb25zaWRlciByZXBsYXlpbmcgc2VsZWN0aW9uY2hhbmdlIGFuZCB0b3VjaG1vdmVzIHRvby5cbnZhciBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHM9W107dmFyIGRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cz1bJ21vdXNlZG93bicsJ21vdXNldXAnLCd0b3VjaGNhbmNlbCcsJ3RvdWNoZW5kJywndG91Y2hzdGFydCcsJ2F1eGNsaWNrJywnZGJsY2xpY2snLCdwb2ludGVyY2FuY2VsJywncG9pbnRlcmRvd24nLCdwb2ludGVydXAnLCdkcmFnZW5kJywnZHJhZ3N0YXJ0JywnZHJvcCcsJ2NvbXBvc2l0aW9uZW5kJywnY29tcG9zaXRpb25zdGFydCcsJ2tleWRvd24nLCdrZXlwcmVzcycsJ2tleXVwJywnaW5wdXQnLCd0ZXh0SW5wdXQnLC8vIEludGVudGlvbmFsbHkgY2FtZWxDYXNlXG4nY29weScsJ2N1dCcsJ3Bhc3RlJywnY2xpY2snLCdjaGFuZ2UnLCdjb250ZXh0bWVudScsJ3Jlc2V0Jywnc3VibWl0J107ZnVuY3Rpb24gaXNEaXNjcmV0ZUV2ZW50VGhhdFJlcXVpcmVzSHlkcmF0aW9uKGV2ZW50VHlwZSl7cmV0dXJuIGRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cy5pbmRleE9mKGV2ZW50VHlwZSk+LTE7fWZ1bmN0aW9uIGNyZWF0ZVF1ZXVlZFJlcGxheWFibGVFdmVudChibG9ja2VkT24sZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLG5hdGl2ZUV2ZW50KXtyZXR1cm57YmxvY2tlZE9uOmJsb2NrZWRPbixkb21FdmVudE5hbWU6ZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3M6ZXZlbnRTeXN0ZW1GbGFncyxuYXRpdmVFdmVudDpuYXRpdmVFdmVudCx0YXJnZXRDb250YWluZXJzOlt0YXJnZXRDb250YWluZXJdfTt9ZnVuY3Rpb24gY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpe3N3aXRjaChkb21FdmVudE5hbWUpe2Nhc2UnZm9jdXNpbic6Y2FzZSdmb2N1c291dCc6cXVldWVkRm9jdXM9bnVsbDticmVhaztjYXNlJ2RyYWdlbnRlcic6Y2FzZSdkcmFnbGVhdmUnOnF1ZXVlZERyYWc9bnVsbDticmVhaztjYXNlJ21vdXNlb3Zlcic6Y2FzZSdtb3VzZW91dCc6cXVldWVkTW91c2U9bnVsbDticmVhaztjYXNlJ3BvaW50ZXJvdmVyJzpjYXNlJ3BvaW50ZXJvdXQnOnt2YXIgcG9pbnRlcklkPW5hdGl2ZUV2ZW50LnBvaW50ZXJJZDtxdWV1ZWRQb2ludGVycy5kZWxldGUocG9pbnRlcklkKTticmVhazt9Y2FzZSdnb3Rwb2ludGVyY2FwdHVyZSc6Y2FzZSdsb3N0cG9pbnRlcmNhcHR1cmUnOnt2YXIgX3BvaW50ZXJJZD1uYXRpdmVFdmVudC5wb2ludGVySWQ7cXVldWVkUG9pbnRlckNhcHR1cmVzLmRlbGV0ZShfcG9pbnRlcklkKTticmVhazt9fX1mdW5jdGlvbiBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KGV4aXN0aW5nUXVldWVkRXZlbnQsYmxvY2tlZE9uLGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCl7aWYoZXhpc3RpbmdRdWV1ZWRFdmVudD09PW51bGx8fGV4aXN0aW5nUXVldWVkRXZlbnQubmF0aXZlRXZlbnQhPT1uYXRpdmVFdmVudCl7dmFyIHF1ZXVlZEV2ZW50PWNyZWF0ZVF1ZXVlZFJlcGxheWFibGVFdmVudChibG9ja2VkT24sZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLG5hdGl2ZUV2ZW50KTtpZihibG9ja2VkT24hPT1udWxsKXt2YXIgX2ZpYmVyMj1nZXRJbnN0YW5jZUZyb21Ob2RlKGJsb2NrZWRPbik7aWYoX2ZpYmVyMiE9PW51bGwpey8vIEF0dGVtcHQgdG8gaW5jcmVhc2UgdGhlIHByaW9yaXR5IG9mIHRoaXMgdGFyZ2V0LlxuYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oX2ZpYmVyMik7fX1yZXR1cm4gcXVldWVkRXZlbnQ7fS8vIElmIHdlIGhhdmUgYWxyZWFkeSBxdWV1ZWQgdGhpcyBleGFjdCBldmVudCwgdGhlbiBpdCdzIGJlY2F1c2Vcbi8vIHRoZSBkaWZmZXJlbnQgZXZlbnQgc3lzdGVtcyBoYXZlIGRpZmZlcmVudCBET00gZXZlbnQgbGlzdGVuZXJzLlxuLy8gV2UgY2FuIGFjY3VtdWxhdGUgdGhlIGZsYWdzLCBhbmQgdGhlIHRhcmdldENvbnRhaW5lcnMsIGFuZFxuLy8gc3RvcmUgYSBzaW5nbGUgZXZlbnQgdG8gYmUgcmVwbGF5ZWQuXG5leGlzdGluZ1F1ZXVlZEV2ZW50LmV2ZW50U3lzdGVtRmxhZ3N8PWV2ZW50U3lzdGVtRmxhZ3M7dmFyIHRhcmdldENvbnRhaW5lcnM9ZXhpc3RpbmdRdWV1ZWRFdmVudC50YXJnZXRDb250YWluZXJzO2lmKHRhcmdldENvbnRhaW5lciE9PW51bGwmJnRhcmdldENvbnRhaW5lcnMuaW5kZXhPZih0YXJnZXRDb250YWluZXIpPT09LTEpe3RhcmdldENvbnRhaW5lcnMucHVzaCh0YXJnZXRDb250YWluZXIpO31yZXR1cm4gZXhpc3RpbmdRdWV1ZWRFdmVudDt9ZnVuY3Rpb24gcXVldWVJZkNvbnRpbnVvdXNFdmVudChibG9ja2VkT24sZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLG5hdGl2ZUV2ZW50KXsvLyBUaGVzZSBzZXQgcmVsYXRlZFRhcmdldCB0byBudWxsIGJlY2F1c2UgdGhlIHJlcGxheWVkIGV2ZW50IHdpbGwgYmUgdHJlYXRlZCBhcyBpZiB3ZVxuLy8gbW92ZWQgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cgKG5vIHRhcmdldCkgb250byB0aGUgdGFyZ2V0IG9uY2UgaXQgaHlkcmF0ZXMuXG4vLyBJbnN0ZWFkIG9mIG11dGF0aW5nIHdlIGNvdWxkIGNsb25lIHRoZSBldmVudC5cbnN3aXRjaChkb21FdmVudE5hbWUpe2Nhc2UnZm9jdXNpbic6e3ZhciBmb2N1c0V2ZW50PW5hdGl2ZUV2ZW50O3F1ZXVlZEZvY3VzPWFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkRm9jdXMsYmxvY2tlZE9uLGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixmb2N1c0V2ZW50KTtyZXR1cm4gdHJ1ZTt9Y2FzZSdkcmFnZW50ZXInOnt2YXIgZHJhZ0V2ZW50PW5hdGl2ZUV2ZW50O3F1ZXVlZERyYWc9YWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChxdWV1ZWREcmFnLGJsb2NrZWRPbixkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIsZHJhZ0V2ZW50KTtyZXR1cm4gdHJ1ZTt9Y2FzZSdtb3VzZW92ZXInOnt2YXIgbW91c2VFdmVudD1uYXRpdmVFdmVudDtxdWV1ZWRNb3VzZT1hY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZE1vdXNlLGJsb2NrZWRPbixkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIsbW91c2VFdmVudCk7cmV0dXJuIHRydWU7fWNhc2UncG9pbnRlcm92ZXInOnt2YXIgcG9pbnRlckV2ZW50PW5hdGl2ZUV2ZW50O3ZhciBwb2ludGVySWQ9cG9pbnRlckV2ZW50LnBvaW50ZXJJZDtxdWV1ZWRQb2ludGVycy5zZXQocG9pbnRlcklkLGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkUG9pbnRlcnMuZ2V0KHBvaW50ZXJJZCl8fG51bGwsYmxvY2tlZE9uLGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixwb2ludGVyRXZlbnQpKTtyZXR1cm4gdHJ1ZTt9Y2FzZSdnb3Rwb2ludGVyY2FwdHVyZSc6e3ZhciBfcG9pbnRlckV2ZW50PW5hdGl2ZUV2ZW50O3ZhciBfcG9pbnRlcklkMj1fcG9pbnRlckV2ZW50LnBvaW50ZXJJZDtxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuc2V0KF9wb2ludGVySWQyLGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkUG9pbnRlckNhcHR1cmVzLmdldChfcG9pbnRlcklkMil8fG51bGwsYmxvY2tlZE9uLGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixfcG9pbnRlckV2ZW50KSk7cmV0dXJuIHRydWU7fX1yZXR1cm4gZmFsc2U7fS8vIENoZWNrIGlmIHRoaXMgdGFyZ2V0IGlzIHVuYmxvY2tlZC4gUmV0dXJucyB0cnVlIGlmIGl0J3MgdW5ibG9ja2VkLlxuZnVuY3Rpb24gYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KHF1ZXVlZFRhcmdldCl7Ly8gVE9ETzogVGhpcyBmdW5jdGlvbiBzaGFyZXMgYSBsb3Qgb2YgbG9naWMgd2l0aCBmaW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50LlxuLy8gVHJ5IHRvIHVuaWZ5IHRoZW0uIEl0J3MgYSBiaXQgdHJpY2t5IHNpbmNlIGl0IHdvdWxkIHJlcXVpcmUgdHdvIHJldHVyblxuLy8gdmFsdWVzLlxudmFyIHRhcmdldEluc3Q9Z2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocXVldWVkVGFyZ2V0LnRhcmdldCk7aWYodGFyZ2V0SW5zdCE9PW51bGwpe3ZhciBuZWFyZXN0TW91bnRlZD1nZXROZWFyZXN0TW91bnRlZEZpYmVyKHRhcmdldEluc3QpO2lmKG5lYXJlc3RNb3VudGVkIT09bnVsbCl7dmFyIHRhZz1uZWFyZXN0TW91bnRlZC50YWc7aWYodGFnPT09U3VzcGVuc2VDb21wb25lbnQpe3ZhciBpbnN0YW5jZT1nZXRTdXNwZW5zZUluc3RhbmNlRnJvbUZpYmVyKG5lYXJlc3RNb3VudGVkKTtpZihpbnN0YW5jZSE9PW51bGwpey8vIFdlJ3JlIGJsb2NrZWQgb24gaHlkcmF0aW5nIHRoaXMgYm91bmRhcnkuXG4vLyBJbmNyZWFzZSBpdHMgcHJpb3JpdHkuXG5xdWV1ZWRUYXJnZXQuYmxvY2tlZE9uPWluc3RhbmNlO2F0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5KHF1ZXVlZFRhcmdldC5wcmlvcml0eSxmdW5jdGlvbigpe2F0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eShuZWFyZXN0TW91bnRlZCk7fSk7cmV0dXJuO319ZWxzZSBpZih0YWc9PT1Ib3N0Um9vdCl7dmFyIHJvb3Q9bmVhcmVzdE1vdW50ZWQuc3RhdGVOb2RlO2lmKGlzUm9vdERlaHlkcmF0ZWQocm9vdCkpe3F1ZXVlZFRhcmdldC5ibG9ja2VkT249Z2V0Q29udGFpbmVyRnJvbUZpYmVyKG5lYXJlc3RNb3VudGVkKTsvLyBXZSBkb24ndCBjdXJyZW50bHkgaGF2ZSBhIHdheSB0byBpbmNyZWFzZSB0aGUgcHJpb3JpdHkgb2Zcbi8vIGEgcm9vdCBvdGhlciB0aGFuIHN5bmMuXG5yZXR1cm47fX19fXF1ZXVlZFRhcmdldC5ibG9ja2VkT249bnVsbDt9ZnVuY3Rpb24gcXVldWVFeHBsaWNpdEh5ZHJhdGlvblRhcmdldCh0YXJnZXQpey8vIFRPRE86IFRoaXMgd2lsbCByZWFkIHRoZSBwcmlvcml0eSBpZiBpdCdzIGRpc3BhdGNoZWQgYnkgdGhlIFJlYWN0XG4vLyBldmVudCBzeXN0ZW0gYnV0IG5vdCBuYXRpdmUgZXZlbnRzLiBTaG91bGQgcmVhZCB3aW5kb3cuZXZlbnQudHlwZSwgbGlrZVxuLy8gd2UgZG8gZm9yIHVwZGF0ZXMgKGdldEN1cnJlbnRFdmVudFByaW9yaXR5KS5cbnZhciB1cGRhdGVQcmlvcml0eT1nZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkkMSgpO3ZhciBxdWV1ZWRUYXJnZXQ9e2Jsb2NrZWRPbjpudWxsLHRhcmdldDp0YXJnZXQscHJpb3JpdHk6dXBkYXRlUHJpb3JpdHl9O3ZhciBpPTA7Zm9yKDtpPHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5sZW5ndGg7aSsrKXsvLyBTdG9wIG9uY2Ugd2UgaGl0IHRoZSBmaXJzdCB0YXJnZXQgd2l0aCBsb3dlciBwcmlvcml0eSB0aGFuXG5pZighaXNIaWdoZXJFdmVudFByaW9yaXR5KHVwZGF0ZVByaW9yaXR5LHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1tpXS5wcmlvcml0eSkpe2JyZWFrO319cXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLnNwbGljZShpLDAscXVldWVkVGFyZ2V0KTtpZihpPT09MCl7YXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KHF1ZXVlZFRhcmdldCk7fX1mdW5jdGlvbiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZEV2ZW50KXtpZihxdWV1ZWRFdmVudC5ibG9ja2VkT24hPT1udWxsKXtyZXR1cm4gZmFsc2U7fXZhciB0YXJnZXRDb250YWluZXJzPXF1ZXVlZEV2ZW50LnRhcmdldENvbnRhaW5lcnM7d2hpbGUodGFyZ2V0Q29udGFpbmVycy5sZW5ndGg+MCl7dmFyIHRhcmdldENvbnRhaW5lcj10YXJnZXRDb250YWluZXJzWzBdO3ZhciBuZXh0QmxvY2tlZE9uPWZpbmRJbnN0YW5jZUJsb2NraW5nRXZlbnQocXVldWVkRXZlbnQuZG9tRXZlbnROYW1lLHF1ZXVlZEV2ZW50LmV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLHF1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50KTtpZihuZXh0QmxvY2tlZE9uPT09bnVsbCl7e3ZhciBuYXRpdmVFdmVudD1xdWV1ZWRFdmVudC5uYXRpdmVFdmVudDt2YXIgbmF0aXZlRXZlbnRDbG9uZT1uZXcgbmF0aXZlRXZlbnQuY29uc3RydWN0b3IobmF0aXZlRXZlbnQudHlwZSxuYXRpdmVFdmVudCk7c2V0UmVwbGF5aW5nRXZlbnQobmF0aXZlRXZlbnRDbG9uZSk7bmF0aXZlRXZlbnQudGFyZ2V0LmRpc3BhdGNoRXZlbnQobmF0aXZlRXZlbnRDbG9uZSk7cmVzZXRSZXBsYXlpbmdFdmVudCgpO319ZWxzZXsvLyBXZSdyZSBzdGlsbCBibG9ja2VkLiBUcnkgYWdhaW4gbGF0ZXIuXG52YXIgX2ZpYmVyMz1nZXRJbnN0YW5jZUZyb21Ob2RlKG5leHRCbG9ja2VkT24pO2lmKF9maWJlcjMhPT1udWxsKXthdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbihfZmliZXIzKTt9cXVldWVkRXZlbnQuYmxvY2tlZE9uPW5leHRCbG9ja2VkT247cmV0dXJuIGZhbHNlO30vLyBUaGlzIHRhcmdldCBjb250YWluZXIgd2FzIHN1Y2Nlc3NmdWxseSBkaXNwYXRjaGVkLiBUcnkgdGhlIG5leHQuXG50YXJnZXRDb250YWluZXJzLnNoaWZ0KCk7fXJldHVybiB0cnVlO31mdW5jdGlvbiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXAocXVldWVkRXZlbnQsa2V5LG1hcCl7aWYoYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRFdmVudCkpe21hcC5kZWxldGUoa2V5KTt9fWZ1bmN0aW9uIHJlcGxheVVuYmxvY2tlZEV2ZW50cygpe2hhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQ9ZmFsc2U7aWYocXVldWVkRm9jdXMhPT1udWxsJiZhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZEZvY3VzKSl7cXVldWVkRm9jdXM9bnVsbDt9aWYocXVldWVkRHJhZyE9PW51bGwmJmF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRHJhZykpe3F1ZXVlZERyYWc9bnVsbDt9aWYocXVldWVkTW91c2UhPT1udWxsJiZhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZE1vdXNlKSl7cXVldWVkTW91c2U9bnVsbDt9cXVldWVkUG9pbnRlcnMuZm9yRWFjaChhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXApO3F1ZXVlZFBvaW50ZXJDYXB0dXJlcy5mb3JFYWNoKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcCk7fWZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRFdmVudCx1bmJsb2NrZWQpe2lmKHF1ZXVlZEV2ZW50LmJsb2NrZWRPbj09PXVuYmxvY2tlZCl7cXVldWVkRXZlbnQuYmxvY2tlZE9uPW51bGw7aWYoIWhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQpe2hhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQ9dHJ1ZTsvLyBTY2hlZHVsZSBhIGNhbGxiYWNrIHRvIGF0dGVtcHQgcmVwbGF5aW5nIGFzIG1hbnkgZXZlbnRzIGFzIGFyZVxuLy8gbm93IHVuYmxvY2tlZC4gVGhpcyBmaXJzdCBtaWdodCBub3QgYWN0dWFsbHkgYmUgdW5ibG9ja2VkIHlldC5cbi8vIFdlIGNvdWxkIGNoZWNrIGl0IGVhcmx5IHRvIGF2b2lkIHNjaGVkdWxpbmcgYW4gdW5uZWNlc3NhcnkgY2FsbGJhY2suXG5TY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkscmVwbGF5VW5ibG9ja2VkRXZlbnRzKTt9fX1mdW5jdGlvbiByZXRyeUlmQmxvY2tlZE9uKHVuYmxvY2tlZCl7Ly8gTWFyayBhbnl0aGluZyB0aGF0IHdhcyBibG9ja2VkIG9uIHRoaXMgYXMgbm8gbG9uZ2VyIGJsb2NrZWRcbi8vIGFuZCBlbGlnaWJsZSBmb3IgYSByZXBsYXkuXG5pZihxdWV1ZWREaXNjcmV0ZUV2ZW50cy5sZW5ndGg+MCl7c2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZERpc2NyZXRlRXZlbnRzWzBdLHVuYmxvY2tlZCk7Ly8gVGhpcyBpcyBhIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgZWFjaCBib3VuZGFyeSB0aGF0IGNvbW1pdHMuIEkgdGhpbmsgaXQnc1xuLy8gd29ydGggaXQgYmVjYXVzZSB3ZSBleHBlY3QgdmVyeSBmZXcgZGlzY3JldGUgZXZlbnRzIHRvIHF1ZXVlIHVwIGFuZCBvbmNlXG4vLyB3ZSBhcmUgYWN0dWFsbHkgZnVsbHkgdW5ibG9ja2VkIGl0IHdpbGwgYmUgZmFzdCB0byByZXBsYXkgdGhlbS5cbmZvcih2YXIgaT0xO2k8cXVldWVkRGlzY3JldGVFdmVudHMubGVuZ3RoO2krKyl7dmFyIHF1ZXVlZEV2ZW50PXF1ZXVlZERpc2NyZXRlRXZlbnRzW2ldO2lmKHF1ZXVlZEV2ZW50LmJsb2NrZWRPbj09PXVuYmxvY2tlZCl7cXVldWVkRXZlbnQuYmxvY2tlZE9uPW51bGw7fX19aWYocXVldWVkRm9jdXMhPT1udWxsKXtzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRm9jdXMsdW5ibG9ja2VkKTt9aWYocXVldWVkRHJhZyE9PW51bGwpe3NjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWREcmFnLHVuYmxvY2tlZCk7fWlmKHF1ZXVlZE1vdXNlIT09bnVsbCl7c2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZE1vdXNlLHVuYmxvY2tlZCk7fXZhciB1bmJsb2NrPWZ1bmN0aW9uKHF1ZXVlZEV2ZW50KXtyZXR1cm4gc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZEV2ZW50LHVuYmxvY2tlZCk7fTtxdWV1ZWRQb2ludGVycy5mb3JFYWNoKHVuYmxvY2spO3F1ZXVlZFBvaW50ZXJDYXB0dXJlcy5mb3JFYWNoKHVuYmxvY2spO2Zvcih2YXIgX2k9MDtfaTxxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMubGVuZ3RoO19pKyspe3ZhciBxdWV1ZWRUYXJnZXQ9cXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzW19pXTtpZihxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uPT09dW5ibG9ja2VkKXtxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uPW51bGw7fX13aGlsZShxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMubGVuZ3RoPjApe3ZhciBuZXh0RXhwbGljaXRUYXJnZXQ9cXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzWzBdO2lmKG5leHRFeHBsaWNpdFRhcmdldC5ibG9ja2VkT24hPT1udWxsKXsvLyBXZSdyZSBzdGlsbCBibG9ja2VkLlxuYnJlYWs7fWVsc2V7YXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KG5leHRFeHBsaWNpdFRhcmdldCk7aWYobmV4dEV4cGxpY2l0VGFyZ2V0LmJsb2NrZWRPbj09PW51bGwpey8vIFdlJ3JlIHVuYmxvY2tlZC5cbnF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5zaGlmdCgpO319fX12YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWc9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QmF0Y2hDb25maWc7Ly8gVE9ETzogY2FuIHdlIHN0b3AgZXhwb3J0aW5nIHRoZXNlP1xudmFyIF9lbmFibGVkPXRydWU7Ly8gVGhpcyBpcyBleHBvcnRlZCBpbiBGQiBidWlsZHMgZm9yIHVzZSBieSBsZWdhY3kgRkIgbGF5ZXIgaW5mcmEuXG4vLyBXZSdkIGxpa2UgdG8gcmVtb3ZlIHRoaXMgYnV0IGl0J3Mgbm90IGNsZWFyIGlmIHRoaXMgaXMgc2FmZS5cbmZ1bmN0aW9uIHNldEVuYWJsZWQoZW5hYmxlZCl7X2VuYWJsZWQ9ISFlbmFibGVkO31mdW5jdGlvbiBpc0VuYWJsZWQoKXtyZXR1cm4gX2VuYWJsZWQ7fWZ1bmN0aW9uIGNyZWF0ZUV2ZW50TGlzdGVuZXJXcmFwcGVyV2l0aFByaW9yaXR5KHRhcmdldENvbnRhaW5lcixkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyl7dmFyIGV2ZW50UHJpb3JpdHk9Z2V0RXZlbnRQcmlvcml0eShkb21FdmVudE5hbWUpO3ZhciBsaXN0ZW5lcldyYXBwZXI7c3dpdGNoKGV2ZW50UHJpb3JpdHkpe2Nhc2UgRGlzY3JldGVFdmVudFByaW9yaXR5Omxpc3RlbmVyV3JhcHBlcj1kaXNwYXRjaERpc2NyZXRlRXZlbnQ7YnJlYWs7Y2FzZSBDb250aW51b3VzRXZlbnRQcmlvcml0eTpsaXN0ZW5lcldyYXBwZXI9ZGlzcGF0Y2hDb250aW51b3VzRXZlbnQ7YnJlYWs7Y2FzZSBEZWZhdWx0RXZlbnRQcmlvcml0eTpkZWZhdWx0Omxpc3RlbmVyV3JhcHBlcj1kaXNwYXRjaEV2ZW50O2JyZWFrO31yZXR1cm4gbGlzdGVuZXJXcmFwcGVyLmJpbmQobnVsbCxkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIpO31mdW5jdGlvbiBkaXNwYXRjaERpc2NyZXRlRXZlbnQoZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsY29udGFpbmVyLG5hdGl2ZUV2ZW50KXt2YXIgcHJldmlvdXNQcmlvcml0eT1nZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTt2YXIgcHJldlRyYW5zaXRpb249UmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbjtSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uPW51bGw7dHJ5e3NldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO2Rpc3BhdGNoRXZlbnQoZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsY29udGFpbmVyLG5hdGl2ZUV2ZW50KTt9ZmluYWxseXtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7UmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbj1wcmV2VHJhbnNpdGlvbjt9fWZ1bmN0aW9uIGRpc3BhdGNoQ29udGludW91c0V2ZW50KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLGNvbnRhaW5lcixuYXRpdmVFdmVudCl7dmFyIHByZXZpb3VzUHJpb3JpdHk9Z2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7dmFyIHByZXZUcmFuc2l0aW9uPVJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb247UmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbj1udWxsO3RyeXtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoQ29udGludW91c0V2ZW50UHJpb3JpdHkpO2Rpc3BhdGNoRXZlbnQoZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsY29udGFpbmVyLG5hdGl2ZUV2ZW50KTt9ZmluYWxseXtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7UmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbj1wcmV2VHJhbnNpdGlvbjt9fWZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLG5hdGl2ZUV2ZW50KXtpZighX2VuYWJsZWQpe3JldHVybjt9e2Rpc3BhdGNoRXZlbnRXaXRoRW5hYmxlQ2FwdHVyZVBoYXNlU2VsZWN0aXZlSHlkcmF0aW9uV2l0aG91dERpc2NyZXRlRXZlbnRSZXBsYXkoZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLG5hdGl2ZUV2ZW50KTt9fWZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRXaXRoRW5hYmxlQ2FwdHVyZVBoYXNlU2VsZWN0aXZlSHlkcmF0aW9uV2l0aG91dERpc2NyZXRlRXZlbnRSZXBsYXkoZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLG5hdGl2ZUV2ZW50KXt2YXIgYmxvY2tlZE9uPWZpbmRJbnN0YW5jZUJsb2NraW5nRXZlbnQoZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLG5hdGl2ZUV2ZW50KTtpZihibG9ja2VkT249PT1udWxsKXtkaXNwYXRjaEV2ZW50Rm9yUGx1Z2luRXZlbnRTeXN0ZW0oZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsbmF0aXZlRXZlbnQscmV0dXJuX3RhcmdldEluc3QsdGFyZ2V0Q29udGFpbmVyKTtjbGVhcklmQ29udGludW91c0V2ZW50KGRvbUV2ZW50TmFtZSxuYXRpdmVFdmVudCk7cmV0dXJuO31pZihxdWV1ZUlmQ29udGludW91c0V2ZW50KGJsb2NrZWRPbixkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIsbmF0aXZlRXZlbnQpKXtuYXRpdmVFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtyZXR1cm47fS8vIFdlIG5lZWQgdG8gY2xlYXIgb25seSBpZiB3ZSBkaWRuJ3QgcXVldWUgYmVjYXVzZVxuLy8gcXVldWVpbmcgaXMgYWNjdW11bGF0aXZlLlxuY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpO2lmKGV2ZW50U3lzdGVtRmxhZ3MmSVNfQ0FQVFVSRV9QSEFTRSYmaXNEaXNjcmV0ZUV2ZW50VGhhdFJlcXVpcmVzSHlkcmF0aW9uKGRvbUV2ZW50TmFtZSkpe3doaWxlKGJsb2NrZWRPbiE9PW51bGwpe3ZhciBmaWJlcj1nZXRJbnN0YW5jZUZyb21Ob2RlKGJsb2NrZWRPbik7aWYoZmliZXIhPT1udWxsKXthdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oZmliZXIpO312YXIgbmV4dEJsb2NrZWRPbj1maW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCk7aWYobmV4dEJsb2NrZWRPbj09PW51bGwpe2Rpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyxuYXRpdmVFdmVudCxyZXR1cm5fdGFyZ2V0SW5zdCx0YXJnZXRDb250YWluZXIpO31pZihuZXh0QmxvY2tlZE9uPT09YmxvY2tlZE9uKXticmVhazt9YmxvY2tlZE9uPW5leHRCbG9ja2VkT247fWlmKGJsb2NrZWRPbiE9PW51bGwpe25hdGl2ZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO31yZXR1cm47fS8vIFRoaXMgaXMgbm90IHJlcGxheWFibGUgc28gd2UnbGwgaW52b2tlIGl0IGJ1dCB3aXRob3V0IGEgdGFyZ2V0LFxuLy8gaW4gY2FzZSB0aGUgZXZlbnQgc3lzdGVtIG5lZWRzIHRvIHRyYWNlIGl0LlxuZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLG5hdGl2ZUV2ZW50LG51bGwsdGFyZ2V0Q29udGFpbmVyKTt9dmFyIHJldHVybl90YXJnZXRJbnN0PW51bGw7Ly8gUmV0dXJucyBhIFN1c3BlbnNlSW5zdGFuY2Ugb3IgQ29udGFpbmVyIGlmIGl0J3MgYmxvY2tlZC5cbi8vIFRoZSByZXR1cm5fdGFyZ2V0SW5zdCBmaWVsZCBhYm92ZSBpcyBjb25jZXB0dWFsbHkgcGFydCBvZiB0aGUgcmV0dXJuIHZhbHVlLlxuZnVuY3Rpb24gZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudChkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIsbmF0aXZlRXZlbnQpey8vIFRPRE86IFdhcm4gaWYgX2VuYWJsZWQgaXMgZmFsc2UuXG5yZXR1cm5fdGFyZ2V0SW5zdD1udWxsO3ZhciBuYXRpdmVFdmVudFRhcmdldD1nZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7dmFyIHRhcmdldEluc3Q9Z2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO2lmKHRhcmdldEluc3QhPT1udWxsKXt2YXIgbmVhcmVzdE1vdW50ZWQ9Z2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtpZihuZWFyZXN0TW91bnRlZD09PW51bGwpey8vIFRoaXMgdHJlZSBoYXMgYmVlbiB1bm1vdW50ZWQgYWxyZWFkeS4gRGlzcGF0Y2ggd2l0aG91dCBhIHRhcmdldC5cbnRhcmdldEluc3Q9bnVsbDt9ZWxzZXt2YXIgdGFnPW5lYXJlc3RNb3VudGVkLnRhZztpZih0YWc9PT1TdXNwZW5zZUNvbXBvbmVudCl7dmFyIGluc3RhbmNlPWdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpO2lmKGluc3RhbmNlIT09bnVsbCl7Ly8gUXVldWUgdGhlIGV2ZW50IHRvIGJlIHJlcGxheWVkIGxhdGVyLiBBYm9ydCBkaXNwYXRjaGluZyBzaW5jZSB3ZVxuLy8gZG9uJ3Qgd2FudCB0aGlzIGV2ZW50IGRpc3BhdGNoZWQgdHdpY2UgdGhyb3VnaCB0aGUgZXZlbnQgc3lzdGVtLlxuLy8gVE9ETzogSWYgdGhpcyBpcyB0aGUgZmlyc3QgZGlzY3JldGUgZXZlbnQgaW4gdGhlIHF1ZXVlLiBTY2hlZHVsZSBhbiBpbmNyZWFzZWRcbi8vIHByaW9yaXR5IGZvciB0aGlzIGJvdW5kYXJ5LlxucmV0dXJuIGluc3RhbmNlO30vLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4sIHNvbWV0aGluZyB3ZW50IHdyb25nIGJ1dCB0byBhdm9pZCBibG9ja2luZ1xuLy8gdGhlIHdob2xlIHN5c3RlbSwgZGlzcGF0Y2ggdGhlIGV2ZW50IHdpdGhvdXQgYSB0YXJnZXQuXG4vLyBUT0RPOiBXYXJuLlxudGFyZ2V0SW5zdD1udWxsO31lbHNlIGlmKHRhZz09PUhvc3RSb290KXt2YXIgcm9vdD1uZWFyZXN0TW91bnRlZC5zdGF0ZU5vZGU7aWYoaXNSb290RGVoeWRyYXRlZChyb290KSl7Ly8gSWYgdGhpcyBoYXBwZW5zIGR1cmluZyBhIHJlcGxheSBzb21ldGhpbmcgd2VudCB3cm9uZyBhbmQgaXQgbWlnaHQgYmxvY2tcbi8vIHRoZSB3aG9sZSBzeXN0ZW0uXG5yZXR1cm4gZ2V0Q29udGFpbmVyRnJvbUZpYmVyKG5lYXJlc3RNb3VudGVkKTt9dGFyZ2V0SW5zdD1udWxsO31lbHNlIGlmKG5lYXJlc3RNb3VudGVkIT09dGFyZ2V0SW5zdCl7Ly8gSWYgd2UgZ2V0IGFuIGV2ZW50IChleDogaW1nIG9ubG9hZCkgYmVmb3JlIGNvbW1pdHRpbmcgdGhhdFxuLy8gY29tcG9uZW50J3MgbW91bnQsIGlnbm9yZSBpdCBmb3Igbm93ICh0aGF0IGlzLCB0cmVhdCBpdCBhcyBpZiBpdCB3YXMgYW5cbi8vIGV2ZW50IG9uIGEgbm9uLVJlYWN0IHRyZWUpLiBXZSBtaWdodCBhbHNvIGNvbnNpZGVyIHF1ZXVlaW5nIGV2ZW50cyBhbmRcbi8vIGRpc3BhdGNoaW5nIHRoZW0gYWZ0ZXIgdGhlIG1vdW50LlxudGFyZ2V0SW5zdD1udWxsO319fXJldHVybl90YXJnZXRJbnN0PXRhcmdldEluc3Q7Ly8gV2UncmUgbm90IGJsb2NrZWQgb24gYW55dGhpbmcuXG5yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gZ2V0RXZlbnRQcmlvcml0eShkb21FdmVudE5hbWUpe3N3aXRjaChkb21FdmVudE5hbWUpey8vIFVzZWQgYnkgU2ltcGxlRXZlbnRQbHVnaW46XG5jYXNlJ2NhbmNlbCc6Y2FzZSdjbGljayc6Y2FzZSdjbG9zZSc6Y2FzZSdjb250ZXh0bWVudSc6Y2FzZSdjb3B5JzpjYXNlJ2N1dCc6Y2FzZSdhdXhjbGljayc6Y2FzZSdkYmxjbGljayc6Y2FzZSdkcmFnZW5kJzpjYXNlJ2RyYWdzdGFydCc6Y2FzZSdkcm9wJzpjYXNlJ2ZvY3VzaW4nOmNhc2UnZm9jdXNvdXQnOmNhc2UnaW5wdXQnOmNhc2UnaW52YWxpZCc6Y2FzZSdrZXlkb3duJzpjYXNlJ2tleXByZXNzJzpjYXNlJ2tleXVwJzpjYXNlJ21vdXNlZG93bic6Y2FzZSdtb3VzZXVwJzpjYXNlJ3Bhc3RlJzpjYXNlJ3BhdXNlJzpjYXNlJ3BsYXknOmNhc2UncG9pbnRlcmNhbmNlbCc6Y2FzZSdwb2ludGVyZG93bic6Y2FzZSdwb2ludGVydXAnOmNhc2UncmF0ZWNoYW5nZSc6Y2FzZSdyZXNldCc6Y2FzZSdyZXNpemUnOmNhc2Unc2Vla2VkJzpjYXNlJ3N1Ym1pdCc6Y2FzZSd0b3VjaGNhbmNlbCc6Y2FzZSd0b3VjaGVuZCc6Y2FzZSd0b3VjaHN0YXJ0JzpjYXNlJ3ZvbHVtZWNoYW5nZSc6Ly8gVXNlZCBieSBwb2x5ZmlsbHM6XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbmNhc2UnY2hhbmdlJzpjYXNlJ3NlbGVjdGlvbmNoYW5nZSc6Y2FzZSd0ZXh0SW5wdXQnOmNhc2UnY29tcG9zaXRpb25zdGFydCc6Y2FzZSdjb21wb3NpdGlvbmVuZCc6Y2FzZSdjb21wb3NpdGlvbnVwZGF0ZSc6Ly8gT25seSBlbmFibGVDcmVhdGVFdmVudEhhbmRsZUFQSTpcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuY2FzZSdiZWZvcmVibHVyJzpjYXNlJ2FmdGVyYmx1cic6Ly8gTm90IHVzZWQgYnkgUmVhY3QgYnV0IGNvdWxkIGJlIGJ5IHVzZXIgY29kZTpcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuY2FzZSdiZWZvcmVpbnB1dCc6Y2FzZSdibHVyJzpjYXNlJ2Z1bGxzY3JlZW5jaGFuZ2UnOmNhc2UnZm9jdXMnOmNhc2UnaGFzaGNoYW5nZSc6Y2FzZSdwb3BzdGF0ZSc6Y2FzZSdzZWxlY3QnOmNhc2Unc2VsZWN0c3RhcnQnOnJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7Y2FzZSdkcmFnJzpjYXNlJ2RyYWdlbnRlcic6Y2FzZSdkcmFnZXhpdCc6Y2FzZSdkcmFnbGVhdmUnOmNhc2UnZHJhZ292ZXInOmNhc2UnbW91c2Vtb3ZlJzpjYXNlJ21vdXNlb3V0JzpjYXNlJ21vdXNlb3Zlcic6Y2FzZSdwb2ludGVybW92ZSc6Y2FzZSdwb2ludGVyb3V0JzpjYXNlJ3BvaW50ZXJvdmVyJzpjYXNlJ3Njcm9sbCc6Y2FzZSd0b2dnbGUnOmNhc2UndG91Y2htb3ZlJzpjYXNlJ3doZWVsJzovLyBOb3QgdXNlZCBieSBSZWFjdCBidXQgY291bGQgYmUgYnkgdXNlciBjb2RlOlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5jYXNlJ21vdXNlZW50ZXInOmNhc2UnbW91c2VsZWF2ZSc6Y2FzZSdwb2ludGVyZW50ZXInOmNhc2UncG9pbnRlcmxlYXZlJzpyZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7Y2FzZSdtZXNzYWdlJzp7Ly8gV2UgbWlnaHQgYmUgaW4gdGhlIFNjaGVkdWxlciBjYWxsYmFjay5cbi8vIEV2ZW50dWFsbHkgdGhpcyBtZWNoYW5pc20gd2lsbCBiZSByZXBsYWNlZCBieSBhIGNoZWNrXG4vLyBvZiB0aGUgY3VycmVudCBwcmlvcml0eSBvbiB0aGUgbmF0aXZlIHNjaGVkdWxlci5cbnZhciBzY2hlZHVsZXJQcmlvcml0eT1nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpO3N3aXRjaChzY2hlZHVsZXJQcmlvcml0eSl7Y2FzZSBJbW1lZGlhdGVQcmlvcml0eTpyZXR1cm4gRGlzY3JldGVFdmVudFByaW9yaXR5O2Nhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6cmV0dXJuIENvbnRpbnVvdXNFdmVudFByaW9yaXR5O2Nhc2UgTm9ybWFsUHJpb3JpdHk6Y2FzZSBMb3dQcmlvcml0eTovLyBUT0RPOiBIYW5kbGUgTG93U2NoZWR1bGVyUHJpb3JpdHksIHNvbWVob3cuIE1heWJlIHRoZSBzYW1lIGxhbmUgYXMgaHlkcmF0aW9uLlxucmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O2Nhc2UgSWRsZVByaW9yaXR5OnJldHVybiBJZGxlRXZlbnRQcmlvcml0eTtkZWZhdWx0OnJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTt9fWRlZmF1bHQ6cmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O319ZnVuY3Rpb24gYWRkRXZlbnRCdWJibGVMaXN0ZW5lcih0YXJnZXQsZXZlbnRUeXBlLGxpc3RlbmVyKXt0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsbGlzdGVuZXIsZmFsc2UpO3JldHVybiBsaXN0ZW5lcjt9ZnVuY3Rpb24gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXIodGFyZ2V0LGV2ZW50VHlwZSxsaXN0ZW5lcil7dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLGxpc3RlbmVyLHRydWUpO3JldHVybiBsaXN0ZW5lcjt9ZnVuY3Rpb24gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0LGV2ZW50VHlwZSxsaXN0ZW5lcixwYXNzaXZlKXt0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsbGlzdGVuZXIse2NhcHR1cmU6dHJ1ZSxwYXNzaXZlOnBhc3NpdmV9KTtyZXR1cm4gbGlzdGVuZXI7fWZ1bmN0aW9uIGFkZEV2ZW50QnViYmxlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0LGV2ZW50VHlwZSxsaXN0ZW5lcixwYXNzaXZlKXt0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsbGlzdGVuZXIse3Bhc3NpdmU6cGFzc2l2ZX0pO3JldHVybiBsaXN0ZW5lcjt9LyoqXG4gKiBUaGVzZSB2YXJpYWJsZXMgc3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKlxuICovdmFyIHJvb3Q9bnVsbDt2YXIgc3RhcnRUZXh0PW51bGw7dmFyIGZhbGxiYWNrVGV4dD1udWxsO2Z1bmN0aW9uIGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpe3Jvb3Q9bmF0aXZlRXZlbnRUYXJnZXQ7c3RhcnRUZXh0PWdldFRleHQoKTtyZXR1cm4gdHJ1ZTt9ZnVuY3Rpb24gcmVzZXQoKXtyb290PW51bGw7c3RhcnRUZXh0PW51bGw7ZmFsbGJhY2tUZXh0PW51bGw7fWZ1bmN0aW9uIGdldERhdGEoKXtpZihmYWxsYmFja1RleHQpe3JldHVybiBmYWxsYmFja1RleHQ7fXZhciBzdGFydDt2YXIgc3RhcnRWYWx1ZT1zdGFydFRleHQ7dmFyIHN0YXJ0TGVuZ3RoPXN0YXJ0VmFsdWUubGVuZ3RoO3ZhciBlbmQ7dmFyIGVuZFZhbHVlPWdldFRleHQoKTt2YXIgZW5kTGVuZ3RoPWVuZFZhbHVlLmxlbmd0aDtmb3Ioc3RhcnQ9MDtzdGFydDxzdGFydExlbmd0aDtzdGFydCsrKXtpZihzdGFydFZhbHVlW3N0YXJ0XSE9PWVuZFZhbHVlW3N0YXJ0XSl7YnJlYWs7fX12YXIgbWluRW5kPXN0YXJ0TGVuZ3RoLXN0YXJ0O2ZvcihlbmQ9MTtlbmQ8PW1pbkVuZDtlbmQrKyl7aWYoc3RhcnRWYWx1ZVtzdGFydExlbmd0aC1lbmRdIT09ZW5kVmFsdWVbZW5kTGVuZ3RoLWVuZF0pe2JyZWFrO319dmFyIHNsaWNlVGFpbD1lbmQ+MT8xLWVuZDp1bmRlZmluZWQ7ZmFsbGJhY2tUZXh0PWVuZFZhbHVlLnNsaWNlKHN0YXJ0LHNsaWNlVGFpbCk7cmV0dXJuIGZhbGxiYWNrVGV4dDt9ZnVuY3Rpb24gZ2V0VGV4dCgpe2lmKCd2YWx1ZSdpbiByb290KXtyZXR1cm4gcm9vdC52YWx1ZTt9cmV0dXJuIHJvb3QudGV4dENvbnRlbnQ7fS8qKlxuICogYGNoYXJDb2RlYCByZXByZXNlbnRzIHRoZSBhY3R1YWwgXCJjaGFyYWN0ZXIgY29kZVwiIGFuZCBpcyBzYWZlIHRvIHVzZSB3aXRoXG4gKiBgU3RyaW5nLmZyb21DaGFyQ29kZWAuIEFzIHN1Y2gsIG9ubHkga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gcHJpbnRhYmxlXG4gKiBjaGFyYWN0ZXJzIHByb2R1Y2UgYSB2YWxpZCBgY2hhckNvZGVgLCB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyBFbnRlci5cbiAqIFRoZSBUYWIta2V5IGlzIGNvbnNpZGVyZWQgbm9uLXByaW50YWJsZSBhbmQgZG9lcyBub3QgaGF2ZSBhIGBjaGFyQ29kZWAsXG4gKiBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgZG9lcyBub3QgcHJvZHVjZSBhIHRhYi1jaGFyYWN0ZXIgaW4gYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBOb3JtYWxpemVkIGBjaGFyQ29kZWAgcHJvcGVydHkuXG4gKi9mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KXt2YXIgY2hhckNvZGU7dmFyIGtleUNvZGU9bmF0aXZlRXZlbnQua2V5Q29kZTtpZignY2hhckNvZGUnaW4gbmF0aXZlRXZlbnQpe2NoYXJDb2RlPW5hdGl2ZUV2ZW50LmNoYXJDb2RlOy8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbmlmKGNoYXJDb2RlPT09MCYma2V5Q29kZT09PTEzKXtjaGFyQ29kZT0xMzt9fWVsc2V7Ly8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbmNoYXJDb2RlPWtleUNvZGU7fS8vIElFIGFuZCBFZGdlIChvbiBXaW5kb3dzKSBhbmQgQ2hyb21lIC8gU2FmYXJpIChvbiBXaW5kb3dzIGFuZCBMaW51eClcbi8vIHJlcG9ydCBFbnRlciBhcyBjaGFyQ29kZSAxMCB3aGVuIGN0cmwgaXMgcHJlc3NlZC5cbmlmKGNoYXJDb2RlPT09MTApe2NoYXJDb2RlPTEzO30vLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbi8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG5pZihjaGFyQ29kZT49MzJ8fGNoYXJDb2RlPT09MTMpe3JldHVybiBjaGFyQ29kZTt9cmV0dXJuIDA7fWZ1bmN0aW9uIGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlKCl7cmV0dXJuIHRydWU7fWZ1bmN0aW9uIGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZSgpe3JldHVybiBmYWxzZTt9Ly8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGEgZmFjdG9yeSBzbyB0aGF0IHdlIGhhdmUgZGlmZmVyZW50IHJldHVybmVkIGNvbnN0cnVjdG9ycy5cbi8vIElmIHdlIGhhZCBhIHNpbmdsZSBjb25zdHJ1Y3RvciwgaXQgd291bGQgYmUgbWVnYW1vcnBoaWMgYW5kIGVuZ2luZXMgd291bGQgZGVvcHQuXG5mdW5jdGlvbiBjcmVhdGVTeW50aGV0aWNFdmVudChJbnRlcmZhY2Upey8qKlxuICAgKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gICAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gICAqXG4gICAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gICAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICAgKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gICAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gICAqXG4gICAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAgICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAgICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICAgKi9mdW5jdGlvbiBTeW50aGV0aWNCYXNlRXZlbnQocmVhY3ROYW1lLHJlYWN0RXZlbnRUeXBlLHRhcmdldEluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpe3RoaXMuX3JlYWN0TmFtZT1yZWFjdE5hbWU7dGhpcy5fdGFyZ2V0SW5zdD10YXJnZXRJbnN0O3RoaXMudHlwZT1yZWFjdEV2ZW50VHlwZTt0aGlzLm5hdGl2ZUV2ZW50PW5hdGl2ZUV2ZW50O3RoaXMudGFyZ2V0PW5hdGl2ZUV2ZW50VGFyZ2V0O3RoaXMuY3VycmVudFRhcmdldD1udWxsO2Zvcih2YXIgX3Byb3BOYW1lIGluIEludGVyZmFjZSl7aWYoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShfcHJvcE5hbWUpKXtjb250aW51ZTt9dmFyIG5vcm1hbGl6ZT1JbnRlcmZhY2VbX3Byb3BOYW1lXTtpZihub3JtYWxpemUpe3RoaXNbX3Byb3BOYW1lXT1ub3JtYWxpemUobmF0aXZlRXZlbnQpO31lbHNle3RoaXNbX3Byb3BOYW1lXT1uYXRpdmVFdmVudFtfcHJvcE5hbWVdO319dmFyIGRlZmF1bHRQcmV2ZW50ZWQ9bmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCE9bnVsbD9uYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkOm5hdGl2ZUV2ZW50LnJldHVyblZhbHVlPT09ZmFsc2U7aWYoZGVmYXVsdFByZXZlbnRlZCl7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9ZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7fWVsc2V7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9ZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO310aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPWZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTtyZXR1cm4gdGhpczt9YXNzaWduKFN5bnRoZXRpY0Jhc2VFdmVudC5wcm90b3R5cGUse3ByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPXRydWU7dmFyIGV2ZW50PXRoaXMubmF0aXZlRXZlbnQ7aWYoIWV2ZW50KXtyZXR1cm47fWlmKGV2ZW50LnByZXZlbnREZWZhdWx0KXtldmVudC5wcmV2ZW50RGVmYXVsdCgpOy8vICRGbG93Rml4TWUgLSBmbG93IGlzIG5vdCBhd2FyZSBvZiBgdW5rbm93bmAgaW4gSUVcbn1lbHNlIGlmKHR5cGVvZiBldmVudC5yZXR1cm5WYWx1ZSE9PSd1bmtub3duJyl7ZXZlbnQucmV0dXJuVmFsdWU9ZmFsc2U7fXRoaXMuaXNEZWZhdWx0UHJldmVudGVkPWZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO30sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGV2ZW50PXRoaXMubmF0aXZlRXZlbnQ7aWYoIWV2ZW50KXtyZXR1cm47fWlmKGV2ZW50LnN0b3BQcm9wYWdhdGlvbil7ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7Ly8gJEZsb3dGaXhNZSAtIGZsb3cgaXMgbm90IGF3YXJlIG9mIGB1bmtub3duYCBpbiBJRVxufWVsc2UgaWYodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSE9PSd1bmtub3duJyl7Ly8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3Jcbi8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4vLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4vLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbi8vIElFIHNwZWNpZmljKS5cbmV2ZW50LmNhbmNlbEJ1YmJsZT10cnVlO310aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPWZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO30sLyoqXG4gICAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICAgKi9wZXJzaXN0OmZ1bmN0aW9uKCl7Ly8gTW9kZXJuIGV2ZW50IHN5c3RlbSBkb2Vzbid0IHVzZSBwb29saW5nLlxufSwvKipcbiAgICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9pc1BlcnNpc3RlbnQ6ZnVuY3Rpb25UaGF0UmV0dXJuc1RydWV9KTtyZXR1cm4gU3ludGhldGljQmFzZUV2ZW50O30vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovdmFyIEV2ZW50SW50ZXJmYWNlPXtldmVudFBoYXNlOjAsYnViYmxlczowLGNhbmNlbGFibGU6MCx0aW1lU3RhbXA6ZnVuY3Rpb24oZXZlbnQpe3JldHVybiBldmVudC50aW1lU3RhbXB8fERhdGUubm93KCk7fSxkZWZhdWx0UHJldmVudGVkOjAsaXNUcnVzdGVkOjB9O3ZhciBTeW50aGV0aWNFdmVudD1jcmVhdGVTeW50aGV0aWNFdmVudChFdmVudEludGVyZmFjZSk7dmFyIFVJRXZlbnRJbnRlcmZhY2U9YXNzaWduKHt9LEV2ZW50SW50ZXJmYWNlLHt2aWV3OjAsZGV0YWlsOjB9KTt2YXIgU3ludGhldGljVUlFdmVudD1jcmVhdGVTeW50aGV0aWNFdmVudChVSUV2ZW50SW50ZXJmYWNlKTt2YXIgbGFzdE1vdmVtZW50WDt2YXIgbGFzdE1vdmVtZW50WTt2YXIgbGFzdE1vdXNlRXZlbnQ7ZnVuY3Rpb24gdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoZXZlbnQpe2lmKGV2ZW50IT09bGFzdE1vdXNlRXZlbnQpe2lmKGxhc3RNb3VzZUV2ZW50JiZldmVudC50eXBlPT09J21vdXNlbW92ZScpe2xhc3RNb3ZlbWVudFg9ZXZlbnQuc2NyZWVuWC1sYXN0TW91c2VFdmVudC5zY3JlZW5YO2xhc3RNb3ZlbWVudFk9ZXZlbnQuc2NyZWVuWS1sYXN0TW91c2VFdmVudC5zY3JlZW5ZO31lbHNle2xhc3RNb3ZlbWVudFg9MDtsYXN0TW92ZW1lbnRZPTA7fWxhc3RNb3VzZUV2ZW50PWV2ZW50O319LyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovdmFyIE1vdXNlRXZlbnRJbnRlcmZhY2U9YXNzaWduKHt9LFVJRXZlbnRJbnRlcmZhY2Use3NjcmVlblg6MCxzY3JlZW5ZOjAsY2xpZW50WDowLGNsaWVudFk6MCxwYWdlWDowLHBhZ2VZOjAsY3RybEtleTowLHNoaWZ0S2V5OjAsYWx0S2V5OjAsbWV0YUtleTowLGdldE1vZGlmaWVyU3RhdGU6Z2V0RXZlbnRNb2RpZmllclN0YXRlLGJ1dHRvbjowLGJ1dHRvbnM6MCxyZWxhdGVkVGFyZ2V0OmZ1bmN0aW9uKGV2ZW50KXtpZihldmVudC5yZWxhdGVkVGFyZ2V0PT09dW5kZWZpbmVkKXJldHVybiBldmVudC5mcm9tRWxlbWVudD09PWV2ZW50LnNyY0VsZW1lbnQ/ZXZlbnQudG9FbGVtZW50OmV2ZW50LmZyb21FbGVtZW50O3JldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0O30sbW92ZW1lbnRYOmZ1bmN0aW9uKGV2ZW50KXtpZignbW92ZW1lbnRYJ2luIGV2ZW50KXtyZXR1cm4gZXZlbnQubW92ZW1lbnRYO311cGRhdGVNb3VzZU1vdmVtZW50UG9seWZpbGxTdGF0ZShldmVudCk7cmV0dXJuIGxhc3RNb3ZlbWVudFg7fSxtb3ZlbWVudFk6ZnVuY3Rpb24oZXZlbnQpe2lmKCdtb3ZlbWVudFknaW4gZXZlbnQpe3JldHVybiBldmVudC5tb3ZlbWVudFk7fS8vIERvbid0IG5lZWQgdG8gY2FsbCB1cGRhdGVNb3VzZU1vdmVtZW50UG9seWZpbGxTdGF0ZSgpIGhlcmVcbi8vIGJlY2F1c2UgaXQncyBndWFyYW50ZWVkIHRvIGhhdmUgYWxyZWFkeSBydW4gd2hlbiBtb3ZlbWVudFhcbi8vIHdhcyBjb3BpZWQuXG5yZXR1cm4gbGFzdE1vdmVtZW50WTt9fSk7dmFyIFN5bnRoZXRpY01vdXNlRXZlbnQ9Y3JlYXRlU3ludGhldGljRXZlbnQoTW91c2VFdmVudEludGVyZmFjZSk7LyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi92YXIgRHJhZ0V2ZW50SW50ZXJmYWNlPWFzc2lnbih7fSxNb3VzZUV2ZW50SW50ZXJmYWNlLHtkYXRhVHJhbnNmZXI6MH0pO3ZhciBTeW50aGV0aWNEcmFnRXZlbnQ9Y3JlYXRlU3ludGhldGljRXZlbnQoRHJhZ0V2ZW50SW50ZXJmYWNlKTsvKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi92YXIgRm9jdXNFdmVudEludGVyZmFjZT1hc3NpZ24oe30sVUlFdmVudEludGVyZmFjZSx7cmVsYXRlZFRhcmdldDowfSk7dmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQ9Y3JlYXRlU3ludGhldGljRXZlbnQoRm9jdXNFdmVudEludGVyZmFjZSk7LyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovdmFyIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlPWFzc2lnbih7fSxFdmVudEludGVyZmFjZSx7YW5pbWF0aW9uTmFtZTowLGVsYXBzZWRUaW1lOjAscHNldWRvRWxlbWVudDowfSk7dmFyIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50PWNyZWF0ZVN5bnRoZXRpY0V2ZW50KEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTsvKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi92YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2U9YXNzaWduKHt9LEV2ZW50SW50ZXJmYWNlLHtjbGlwYm9hcmREYXRhOmZ1bmN0aW9uKGV2ZW50KXtyZXR1cm4nY2xpcGJvYXJkRGF0YSdpbiBldmVudD9ldmVudC5jbGlwYm9hcmREYXRhOndpbmRvdy5jbGlwYm9hcmREYXRhO319KTt2YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ9Y3JlYXRlU3ludGhldGljRXZlbnQoQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpOy8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovdmFyIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2U9YXNzaWduKHt9LEV2ZW50SW50ZXJmYWNlLHtkYXRhOjB9KTt2YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudD1jcmVhdGVTeW50aGV0aWNFdmVudChDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlKTsvKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqLy8vIEhhcHBlbnMgdG8gc2hhcmUgdGhlIHNhbWUgbGlzdCBmb3Igbm93LlxudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQ9U3ludGhldGljQ29tcG9zaXRpb25FdmVudDsvKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi92YXIgbm9ybWFsaXplS2V5PXtFc2M6J0VzY2FwZScsU3BhY2ViYXI6JyAnLExlZnQ6J0Fycm93TGVmdCcsVXA6J0Fycm93VXAnLFJpZ2h0OidBcnJvd1JpZ2h0JyxEb3duOidBcnJvd0Rvd24nLERlbDonRGVsZXRlJyxXaW46J09TJyxNZW51OidDb250ZXh0TWVudScsQXBwczonQ29udGV4dE1lbnUnLFNjcm9sbDonU2Nyb2xsTG9jaycsTW96UHJpbnRhYmxlS2V5OidVbmlkZW50aWZpZWQnfTsvKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL3ZhciB0cmFuc2xhdGVUb0tleT17JzgnOidCYWNrc3BhY2UnLCc5JzonVGFiJywnMTInOidDbGVhcicsJzEzJzonRW50ZXInLCcxNic6J1NoaWZ0JywnMTcnOidDb250cm9sJywnMTgnOidBbHQnLCcxOSc6J1BhdXNlJywnMjAnOidDYXBzTG9jaycsJzI3JzonRXNjYXBlJywnMzInOicgJywnMzMnOidQYWdlVXAnLCczNCc6J1BhZ2VEb3duJywnMzUnOidFbmQnLCczNic6J0hvbWUnLCczNyc6J0Fycm93TGVmdCcsJzM4JzonQXJyb3dVcCcsJzM5JzonQXJyb3dSaWdodCcsJzQwJzonQXJyb3dEb3duJywnNDUnOidJbnNlcnQnLCc0Nic6J0RlbGV0ZScsJzExMic6J0YxJywnMTEzJzonRjInLCcxMTQnOidGMycsJzExNSc6J0Y0JywnMTE2JzonRjUnLCcxMTcnOidGNicsJzExOCc6J0Y3JywnMTE5JzonRjgnLCcxMjAnOidGOScsJzEyMSc6J0YxMCcsJzEyMic6J0YxMScsJzEyMyc6J0YxMicsJzE0NCc6J051bUxvY2snLCcxNDUnOidTY3JvbGxMb2NrJywnMjI0JzonTWV0YSd9Oy8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpe2lmKG5hdGl2ZUV2ZW50LmtleSl7Ly8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4vLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG4vLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG52YXIga2V5PW5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldfHxuYXRpdmVFdmVudC5rZXk7aWYoa2V5IT09J1VuaWRlbnRpZmllZCcpe3JldHVybiBrZXk7fX0vLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG5pZihuYXRpdmVFdmVudC50eXBlPT09J2tleXByZXNzJyl7dmFyIGNoYXJDb2RlPWdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpOy8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG5yZXR1cm4gY2hhckNvZGU9PT0xMz8nRW50ZXInOlN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO31pZihuYXRpdmVFdmVudC50eXBlPT09J2tleWRvd24nfHxuYXRpdmVFdmVudC50eXBlPT09J2tleXVwJyl7Ly8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cbnJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXXx8J1VuaWRlbnRpZmllZCc7fXJldHVybicnO30vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovdmFyIG1vZGlmaWVyS2V5VG9Qcm9wPXtBbHQ6J2FsdEtleScsQ29udHJvbDonY3RybEtleScsTWV0YTonbWV0YUtleScsU2hpZnQ6J3NoaWZ0S2V5J307Ly8gT2xkZXIgYnJvd3NlcnMgKFNhZmFyaSA8PSAxMCwgaU9TIFNhZmFyaSA8PSAxMC4yKSBkbyBub3Qgc3VwcG9ydFxuLy8gZ2V0TW9kaWZpZXJTdGF0ZS4gSWYgZ2V0TW9kaWZpZXJTdGF0ZSBpcyBub3Qgc3VwcG9ydGVkLCB3ZSBtYXAgaXQgdG8gYSBzZXQgb2Zcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQuIEluIHRoaXMgY2FzZSwgTG9jay1rZXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpe3ZhciBzeW50aGV0aWNFdmVudD10aGlzO3ZhciBuYXRpdmVFdmVudD1zeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtpZihuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKXtyZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO312YXIga2V5UHJvcD1tb2RpZmllcktleVRvUHJvcFtrZXlBcmddO3JldHVybiBrZXlQcm9wPyEhbmF0aXZlRXZlbnRba2V5UHJvcF06ZmFsc2U7fWZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCl7cmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7fS8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL3ZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlPWFzc2lnbih7fSxVSUV2ZW50SW50ZXJmYWNlLHtrZXk6Z2V0RXZlbnRLZXksY29kZTowLGxvY2F0aW9uOjAsY3RybEtleTowLHNoaWZ0S2V5OjAsYWx0S2V5OjAsbWV0YUtleTowLHJlcGVhdDowLGxvY2FsZTowLGdldE1vZGlmaWVyU3RhdGU6Z2V0RXZlbnRNb2RpZmllclN0YXRlLC8vIExlZ2FjeSBJbnRlcmZhY2VcbmNoYXJDb2RlOmZ1bmN0aW9uKGV2ZW50KXsvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2Zcbi8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cbi8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4vLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci4gT25seSBLZXlQcmVzcyBoYXMgY2hhckNvZGUuXG5pZihldmVudC50eXBlPT09J2tleXByZXNzJyl7cmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO31yZXR1cm4gMDt9LGtleUNvZGU6ZnVuY3Rpb24oZXZlbnQpey8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2Zcbi8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cbi8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4vLyBwcm92aWRlcyBhIHN1cnByaXNpbmdseSBhY2N1cmF0ZSBtYXBwaW5nIGZvciBVUyBhbmQgRXVyb3BlYW4gdXNlcnMuXG4vLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuaWYoZXZlbnQudHlwZT09PSdrZXlkb3duJ3x8ZXZlbnQudHlwZT09PSdrZXl1cCcpe3JldHVybiBldmVudC5rZXlDb2RlO31yZXR1cm4gMDt9LHdoaWNoOmZ1bmN0aW9uKGV2ZW50KXsvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG5pZihldmVudC50eXBlPT09J2tleXByZXNzJyl7cmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO31pZihldmVudC50eXBlPT09J2tleWRvd24nfHxldmVudC50eXBlPT09J2tleXVwJyl7cmV0dXJuIGV2ZW50LmtleUNvZGU7fXJldHVybiAwO319KTt2YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudD1jcmVhdGVTeW50aGV0aWNFdmVudChLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTsvKipcbiAqIEBpbnRlcmZhY2UgUG9pbnRlckV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvXG4gKi92YXIgUG9pbnRlckV2ZW50SW50ZXJmYWNlPWFzc2lnbih7fSxNb3VzZUV2ZW50SW50ZXJmYWNlLHtwb2ludGVySWQ6MCx3aWR0aDowLGhlaWdodDowLHByZXNzdXJlOjAsdGFuZ2VudGlhbFByZXNzdXJlOjAsdGlsdFg6MCx0aWx0WTowLHR3aXN0OjAscG9pbnRlclR5cGU6MCxpc1ByaW1hcnk6MH0pO3ZhciBTeW50aGV0aWNQb2ludGVyRXZlbnQ9Y3JlYXRlU3ludGhldGljRXZlbnQoUG9pbnRlckV2ZW50SW50ZXJmYWNlKTsvKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi92YXIgVG91Y2hFdmVudEludGVyZmFjZT1hc3NpZ24oe30sVUlFdmVudEludGVyZmFjZSx7dG91Y2hlczowLHRhcmdldFRvdWNoZXM6MCxjaGFuZ2VkVG91Y2hlczowLGFsdEtleTowLG1ldGFLZXk6MCxjdHJsS2V5OjAsc2hpZnRLZXk6MCxnZXRNb2RpZmllclN0YXRlOmdldEV2ZW50TW9kaWZpZXJTdGF0ZX0pO3ZhciBTeW50aGV0aWNUb3VjaEV2ZW50PWNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRvdWNoRXZlbnRJbnRlcmZhY2UpOy8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELWNzczMtdHJhbnNpdGlvbnMtMjAwOTAzMjAvI3RyYW5zaXRpb24tZXZlbnRzLVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XG4gKi92YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlPWFzc2lnbih7fSxFdmVudEludGVyZmFjZSx7cHJvcGVydHlOYW1lOjAsZWxhcHNlZFRpbWU6MCxwc2V1ZG9FbGVtZW50OjB9KTt2YXIgU3ludGhldGljVHJhbnNpdGlvbkV2ZW50PWNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7LyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovdmFyIFdoZWVsRXZlbnRJbnRlcmZhY2U9YXNzaWduKHt9LE1vdXNlRXZlbnRJbnRlcmZhY2Use2RlbHRhWDpmdW5jdGlvbihldmVudCl7cmV0dXJuJ2RlbHRhWCdpbiBldmVudD9ldmVudC5kZWx0YVg6Ly8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbid3aGVlbERlbHRhWCdpbiBldmVudD8tZXZlbnQud2hlZWxEZWx0YVg6MDt9LGRlbHRhWTpmdW5jdGlvbihldmVudCl7cmV0dXJuJ2RlbHRhWSdpbiBldmVudD9ldmVudC5kZWx0YVk6Ly8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuJ3doZWVsRGVsdGFZJ2luIGV2ZW50Py1ldmVudC53aGVlbERlbHRhWTovLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4nd2hlZWxEZWx0YSdpbiBldmVudD8tZXZlbnQud2hlZWxEZWx0YTowO30sZGVsdGFaOjAsLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4vLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3Jcbi8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuZGVsdGFNb2RlOjB9KTt2YXIgU3ludGhldGljV2hlZWxFdmVudD1jcmVhdGVTeW50aGV0aWNFdmVudChXaGVlbEV2ZW50SW50ZXJmYWNlKTt2YXIgRU5EX0tFWUNPREVTPVs5LDEzLDI3LDMyXTsvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREU9MjI5O3ZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50PWNhblVzZURPTSYmJ0NvbXBvc2l0aW9uRXZlbnQnaW4gd2luZG93O3ZhciBkb2N1bWVudE1vZGU9bnVsbDtpZihjYW5Vc2VET00mJidkb2N1bWVudE1vZGUnaW4gZG9jdW1lbnQpe2RvY3VtZW50TW9kZT1kb2N1bWVudC5kb2N1bWVudE1vZGU7fS8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQ9Y2FuVXNlRE9NJiYnVGV4dEV2ZW50J2luIHdpbmRvdyYmIWRvY3VtZW50TW9kZTsvLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhPWNhblVzZURPTSYmKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50fHxkb2N1bWVudE1vZGUmJmRvY3VtZW50TW9kZT44JiZkb2N1bWVudE1vZGU8PTExKTt2YXIgU1BBQ0VCQVJfQ09ERT0zMjt2YXIgU1BBQ0VCQVJfQ0hBUj1TdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO2Z1bmN0aW9uIHJlZ2lzdGVyRXZlbnRzKCl7cmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvbkJlZm9yZUlucHV0JyxbJ2NvbXBvc2l0aW9uZW5kJywna2V5cHJlc3MnLCd0ZXh0SW5wdXQnLCdwYXN0ZSddKTtyZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ29tcG9zaXRpb25FbmQnLFsnY29tcG9zaXRpb25lbmQnLCdmb2N1c291dCcsJ2tleWRvd24nLCdrZXlwcmVzcycsJ2tleXVwJywnbW91c2Vkb3duJ10pO3JlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25Db21wb3NpdGlvblN0YXJ0JyxbJ2NvbXBvc2l0aW9uc3RhcnQnLCdmb2N1c291dCcsJ2tleWRvd24nLCdrZXlwcmVzcycsJ2tleXVwJywnbW91c2Vkb3duJ10pO3JlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25Db21wb3NpdGlvblVwZGF0ZScsWydjb21wb3NpdGlvbnVwZGF0ZScsJ2ZvY3Vzb3V0Jywna2V5ZG93bicsJ2tleXByZXNzJywna2V5dXAnLCdtb3VzZWRvd24nXSk7fS8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzPWZhbHNlOy8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCl7cmV0dXJuKG5hdGl2ZUV2ZW50LmN0cmxLZXl8fG5hdGl2ZUV2ZW50LmFsdEtleXx8bmF0aXZlRXZlbnQubWV0YUtleSkmJi8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuIShuYXRpdmVFdmVudC5jdHJsS2V5JiZuYXRpdmVFdmVudC5hbHRLZXkpO30vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICovZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUoZG9tRXZlbnROYW1lKXtzd2l0Y2goZG9tRXZlbnROYW1lKXtjYXNlJ2NvbXBvc2l0aW9uc3RhcnQnOnJldHVybidvbkNvbXBvc2l0aW9uU3RhcnQnO2Nhc2UnY29tcG9zaXRpb25lbmQnOnJldHVybidvbkNvbXBvc2l0aW9uRW5kJztjYXNlJ2NvbXBvc2l0aW9udXBkYXRlJzpyZXR1cm4nb25Db21wb3NpdGlvblVwZGF0ZSc7fX0vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICovZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQoZG9tRXZlbnROYW1lLG5hdGl2ZUV2ZW50KXtyZXR1cm4gZG9tRXZlbnROYW1lPT09J2tleWRvd24nJiZuYXRpdmVFdmVudC5rZXlDb2RlPT09U1RBUlRfS0VZQ09ERTt9LyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICovZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKGRvbUV2ZW50TmFtZSxuYXRpdmVFdmVudCl7c3dpdGNoKGRvbUV2ZW50TmFtZSl7Y2FzZSdrZXl1cCc6Ly8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG5yZXR1cm4gRU5EX0tFWUNPREVTLmluZGV4T2YobmF0aXZlRXZlbnQua2V5Q29kZSkhPT0tMTtjYXNlJ2tleWRvd24nOi8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbi8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxucmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUhPT1TVEFSVF9LRVlDT0RFO2Nhc2Una2V5cHJlc3MnOmNhc2UnbW91c2Vkb3duJzpjYXNlJ2ZvY3Vzb3V0JzovLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxucmV0dXJuIHRydWU7ZGVmYXVsdDpyZXR1cm4gZmFsc2U7fX0vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCl7dmFyIGRldGFpbD1uYXRpdmVFdmVudC5kZXRhaWw7aWYodHlwZW9mIGRldGFpbD09PSdvYmplY3QnJiYnZGF0YSdpbiBkZXRhaWwpe3JldHVybiBkZXRhaWwuZGF0YTt9cmV0dXJuIG51bGw7fS8qKlxuICogQ2hlY2sgaWYgYSBjb21wb3NpdGlvbiBldmVudCB3YXMgdHJpZ2dlcmVkIGJ5IEtvcmVhbiBJTUUuXG4gKiBPdXIgZmFsbGJhY2sgbW9kZSBkb2VzIG5vdCB3b3JrIHdlbGwgd2l0aCBJRSdzIEtvcmVhbiBJTUUsXG4gKiBzbyBqdXN0IHVzZSBuYXRpdmUgY29tcG9zaXRpb24gZXZlbnRzIHdoZW4gS29yZWFuIElNRSBpcyB1c2VkLlxuICogQWx0aG91Z2ggQ29tcG9zaXRpb25FdmVudC5sb2NhbGUgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCxcbiAqIGl0IGlzIGF2YWlsYWJsZSBpbiBJRSwgd2hlcmUgb3VyIGZhbGxiYWNrIG1vZGUgaXMgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9mdW5jdGlvbiBpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KXtyZXR1cm4gbmF0aXZlRXZlbnQubG9jYWxlPT09J2tvJzt9Ly8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIHN0YXR1cywgaWYgYW55LlxudmFyIGlzQ29tcG9zaW5nPWZhbHNlOy8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hRdWV1ZSxkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCl7dmFyIGV2ZW50VHlwZTt2YXIgZmFsbGJhY2tEYXRhO2lmKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpe2V2ZW50VHlwZT1nZXRDb21wb3NpdGlvbkV2ZW50VHlwZShkb21FdmVudE5hbWUpO31lbHNlIGlmKCFpc0NvbXBvc2luZyl7aWYoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQoZG9tRXZlbnROYW1lLG5hdGl2ZUV2ZW50KSl7ZXZlbnRUeXBlPSdvbkNvbXBvc2l0aW9uU3RhcnQnO319ZWxzZSBpZihpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLG5hdGl2ZUV2ZW50KSl7ZXZlbnRUeXBlPSdvbkNvbXBvc2l0aW9uRW5kJzt9aWYoIWV2ZW50VHlwZSl7cmV0dXJuIG51bGw7fWlmKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhJiYhaXNVc2luZ0tvcmVhbklNRShuYXRpdmVFdmVudCkpey8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuaWYoIWlzQ29tcG9zaW5nJiZldmVudFR5cGU9PT0nb25Db21wb3NpdGlvblN0YXJ0Jyl7aXNDb21wb3Npbmc9aW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCk7fWVsc2UgaWYoZXZlbnRUeXBlPT09J29uQ29tcG9zaXRpb25FbmQnKXtpZihpc0NvbXBvc2luZyl7ZmFsbGJhY2tEYXRhPWdldERhdGEoKTt9fX12YXIgbGlzdGVuZXJzPWFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyh0YXJnZXRJbnN0LGV2ZW50VHlwZSk7aWYobGlzdGVuZXJzLmxlbmd0aD4wKXt2YXIgZXZlbnQ9bmV3IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZXZlbnRUeXBlLGRvbUV2ZW50TmFtZSxudWxsLG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTtkaXNwYXRjaFF1ZXVlLnB1c2goe2V2ZW50OmV2ZW50LGxpc3RlbmVyczpsaXN0ZW5lcnN9KTtpZihmYWxsYmFja0RhdGEpey8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbmV2ZW50LmRhdGE9ZmFsbGJhY2tEYXRhO31lbHNle3ZhciBjdXN0b21EYXRhPWdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO2lmKGN1c3RvbURhdGEhPT1udWxsKXtldmVudC5kYXRhPWN1c3RvbURhdGE7fX19fWZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLG5hdGl2ZUV2ZW50KXtzd2l0Y2goZG9tRXZlbnROYW1lKXtjYXNlJ2NvbXBvc2l0aW9uZW5kJzpyZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7Y2FzZSdrZXlwcmVzcyc6LyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL3ZhciB3aGljaD1uYXRpdmVFdmVudC53aGljaDtpZih3aGljaCE9PVNQQUNFQkFSX0NPREUpe3JldHVybiBudWxsO31oYXNTcGFjZUtleXByZXNzPXRydWU7cmV0dXJuIFNQQUNFQkFSX0NIQVI7Y2FzZSd0ZXh0SW5wdXQnOi8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxudmFyIGNoYXJzPW5hdGl2ZUV2ZW50LmRhdGE7Ly8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbi8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbi8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBpZ25vcmUgaXQuXG5pZihjaGFycz09PVNQQUNFQkFSX0NIQVImJmhhc1NwYWNlS2V5cHJlc3Mpe3JldHVybiBudWxsO31yZXR1cm4gY2hhcnM7ZGVmYXVsdDovLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxucmV0dXJuIG51bGw7fX0vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLG5hdGl2ZUV2ZW50KXsvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbi8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbi8vIElmIGNvbXBvc2l0aW9uIGV2ZW50IGlzIGF2YWlsYWJsZSwgd2UgZXh0cmFjdCBhIHN0cmluZyBvbmx5IGF0XG4vLyBjb21wb3NpdGlvbmV2ZW50LCBvdGhlcndpc2UgZXh0cmFjdCBpdCBhdCBmYWxsYmFjayBldmVudHMuXG5pZihpc0NvbXBvc2luZyl7aWYoZG9tRXZlbnROYW1lPT09J2NvbXBvc2l0aW9uZW5kJ3x8IWNhblVzZUNvbXBvc2l0aW9uRXZlbnQmJmlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpKXt2YXIgY2hhcnM9Z2V0RGF0YSgpO3Jlc2V0KCk7aXNDb21wb3Npbmc9ZmFsc2U7cmV0dXJuIGNoYXJzO31yZXR1cm4gbnVsbDt9c3dpdGNoKGRvbUV2ZW50TmFtZSl7Y2FzZSdwYXN0ZSc6Ly8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxucmV0dXJuIG51bGw7Y2FzZSdrZXlwcmVzcyc6LyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL2lmKCFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpey8vIElFIGZpcmVzIHRoZSBga2V5cHJlc3NgIGV2ZW50IHdoZW4gYSB1c2VyIHR5cGVzIGFuIGVtb2ppIHZpYVxuLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4vLyBob2xkcyBhbiBlbW9qaSBjaGFyYWN0ZXIgbGlrZSBgXFx1RDgzRFxcdURFMEFgLiAgQmVjYXVzZSBpdHMgbGVuZ3RoXG4vLyBpcyAyLCB0aGUgcHJvcGVydHkgYHdoaWNoYCBkb2VzIG5vdCByZXByZXNlbnQgYW4gZW1vamkgY29ycmVjdGx5LlxuLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2Zcbi8vIHVzaW5nIGB3aGljaGAuXG5pZihuYXRpdmVFdmVudC5jaGFyJiZuYXRpdmVFdmVudC5jaGFyLmxlbmd0aD4xKXtyZXR1cm4gbmF0aXZlRXZlbnQuY2hhcjt9ZWxzZSBpZihuYXRpdmVFdmVudC53aGljaCl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO319cmV0dXJuIG51bGw7Y2FzZSdjb21wb3NpdGlvbmVuZCc6cmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhJiYhaXNVc2luZ0tvcmVhbklNRShuYXRpdmVFdmVudCk/bnVsbDpuYXRpdmVFdmVudC5kYXRhO2RlZmF1bHQ6cmV0dXJuIG51bGw7fX0vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudChkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KXt2YXIgY2hhcnM7aWYoY2FuVXNlVGV4dElucHV0RXZlbnQpe2NoYXJzPWdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLG5hdGl2ZUV2ZW50KTt9ZWxzZXtjaGFycz1nZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLG5hdGl2ZUV2ZW50KTt9Ly8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuLy8gYmUgZmlyZWQuXG5pZighY2hhcnMpe3JldHVybiBudWxsO312YXIgbGlzdGVuZXJzPWFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyh0YXJnZXRJbnN0LCdvbkJlZm9yZUlucHV0Jyk7aWYobGlzdGVuZXJzLmxlbmd0aD4wKXt2YXIgZXZlbnQ9bmV3IFN5bnRoZXRpY0lucHV0RXZlbnQoJ29uQmVmb3JlSW5wdXQnLCdiZWZvcmVpbnB1dCcsbnVsbCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCk7ZGlzcGF0Y2hRdWV1ZS5wdXNoKHtldmVudDpldmVudCxsaXN0ZW5lcnM6bGlzdGVuZXJzfSk7ZXZlbnQuZGF0YT1jaGFyczt9fS8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL2Z1bmN0aW9uIGV4dHJhY3RFdmVudHMoZGlzcGF0Y2hRdWV1ZSxkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcil7ZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hRdWV1ZSxkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCk7ZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQoZGlzcGF0Y2hRdWV1ZSxkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCk7fS8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi92YXIgc3VwcG9ydGVkSW5wdXRUeXBlcz17Y29sb3I6dHJ1ZSxkYXRlOnRydWUsZGF0ZXRpbWU6dHJ1ZSwnZGF0ZXRpbWUtbG9jYWwnOnRydWUsZW1haWw6dHJ1ZSxtb250aDp0cnVlLG51bWJlcjp0cnVlLHBhc3N3b3JkOnRydWUscmFuZ2U6dHJ1ZSxzZWFyY2g6dHJ1ZSx0ZWw6dHJ1ZSx0ZXh0OnRydWUsdGltZTp0cnVlLHVybDp0cnVlLHdlZWs6dHJ1ZX07ZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pe3ZhciBub2RlTmFtZT1lbGVtJiZlbGVtLm5vZGVOYW1lJiZlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYobm9kZU5hbWU9PT0naW5wdXQnKXtyZXR1cm4hIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTt9aWYobm9kZU5hbWU9PT0ndGV4dGFyZWEnKXtyZXR1cm4gdHJ1ZTt9cmV0dXJuIGZhbHNlO30vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL2Z1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4KXtpZighY2FuVXNlRE9NKXtyZXR1cm4gZmFsc2U7fXZhciBldmVudE5hbWU9J29uJytldmVudE5hbWVTdWZmaXg7dmFyIGlzU3VwcG9ydGVkPWV2ZW50TmFtZSBpbiBkb2N1bWVudDtpZighaXNTdXBwb3J0ZWQpe3ZhciBlbGVtZW50PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO2VsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwncmV0dXJuOycpO2lzU3VwcG9ydGVkPXR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV09PT0nZnVuY3Rpb24nO31yZXR1cm4gaXNTdXBwb3J0ZWQ7fWZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRzJDEoKXtyZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ2hhbmdlJyxbJ2NoYW5nZScsJ2NsaWNrJywnZm9jdXNpbicsJ2ZvY3Vzb3V0JywnaW5wdXQnLCdrZXlkb3duJywna2V5dXAnLCdzZWxlY3Rpb25jaGFuZ2UnXSk7fWZ1bmN0aW9uIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChkaXNwYXRjaFF1ZXVlLGluc3QsbmF0aXZlRXZlbnQsdGFyZ2V0KXsvLyBGbGFnIHRoaXMgZXZlbnQgbG9vcCBhcyBuZWVkaW5nIHN0YXRlIHJlc3RvcmUuXG5lbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCk7dmFyIGxpc3RlbmVycz1hY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnMoaW5zdCwnb25DaGFuZ2UnKTtpZihsaXN0ZW5lcnMubGVuZ3RoPjApe3ZhciBldmVudD1uZXcgU3ludGhldGljRXZlbnQoJ29uQ2hhbmdlJywnY2hhbmdlJyxudWxsLG5hdGl2ZUV2ZW50LHRhcmdldCk7ZGlzcGF0Y2hRdWV1ZS5wdXNoKHtldmVudDpldmVudCxsaXN0ZW5lcnM6bGlzdGVuZXJzfSk7fX0vKipcbiAqIEZvciBJRSBzaGltc1xuICovdmFyIGFjdGl2ZUVsZW1lbnQ9bnVsbDt2YXIgYWN0aXZlRWxlbWVudEluc3Q9bnVsbDsvKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSl7dmFyIG5vZGVOYW1lPWVsZW0ubm9kZU5hbWUmJmVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gbm9kZU5hbWU9PT0nc2VsZWN0J3x8bm9kZU5hbWU9PT0naW5wdXQnJiZlbGVtLnR5cGU9PT0nZmlsZSc7fWZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpe3ZhciBkaXNwYXRjaFF1ZXVlPVtdO2NyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChkaXNwYXRjaFF1ZXVlLGFjdGl2ZUVsZW1lbnRJbnN0LG5hdGl2ZUV2ZW50LGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7Ly8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbi8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbi8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4vL1xuLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3Jcbi8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4vLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4vLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLGRpc3BhdGNoUXVldWUpO31mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZGlzcGF0Y2hRdWV1ZSl7cHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwwKTt9ZnVuY3Rpb24gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3Qpe3ZhciB0YXJnZXROb2RlPWdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCk7aWYodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpe3JldHVybiB0YXJnZXRJbnN0O319ZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50KGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0KXtpZihkb21FdmVudE5hbWU9PT0nY2hhbmdlJyl7cmV0dXJuIHRhcmdldEluc3Q7fX0vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi92YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkPWZhbHNlO2lmKGNhblVzZURPTSl7Ly8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4vLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbmlzSW5wdXRFdmVudFN1cHBvcnRlZD1pc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpJiYoIWRvY3VtZW50LmRvY3VtZW50TW9kZXx8ZG9jdW1lbnQuZG9jdW1lbnRNb2RlPjkpO30vKipcbiAqIChGb3IgSUUgPD05KSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCx0YXJnZXRJbnN0KXthY3RpdmVFbGVtZW50PXRhcmdldDthY3RpdmVFbGVtZW50SW5zdD10YXJnZXRJbnN0O2FjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLGhhbmRsZVByb3BlcnR5Q2hhbmdlKTt9LyoqXG4gKiAoRm9yIElFIDw9OSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKXtpZighYWN0aXZlRWxlbWVudCl7cmV0dXJuO31hY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJyxoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7YWN0aXZlRWxlbWVudD1udWxsO2FjdGl2ZUVsZW1lbnRJbnN0PW51bGw7fS8qKlxuICogKEZvciBJRSA8PTkpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpe2lmKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSE9PSd2YWx1ZScpe3JldHVybjt9aWYoZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KSl7bWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7fX1mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwoZG9tRXZlbnROYW1lLHRhcmdldCx0YXJnZXRJbnN0KXtpZihkb21FdmVudE5hbWU9PT0nZm9jdXNpbicpey8vIEluIElFOSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbi8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4vLyBhcHBlYXJzIHRvIGZpcmUgaW4gYWxsIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgc28gd2UgY2F0Y2ggdGhvc2UgYW5kXG4vLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbi8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4vLyBpcyBjaGFuZ2VkIGZyb20gSlMgc28gd2UgcmVkZWZpbmUgYSBzZXR0ZXIgZm9yIGAudmFsdWVgIHRoYXQgdXBkYXRlc1xuLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbi8vXG4vLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4vLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG5zdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO3N0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsdGFyZ2V0SW5zdCk7fWVsc2UgaWYoZG9tRXZlbnROYW1lPT09J2ZvY3Vzb3V0Jyl7c3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTt9fS8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwoZG9tRXZlbnROYW1lLHRhcmdldEluc3Qpe2lmKGRvbUV2ZW50TmFtZT09PSdzZWxlY3Rpb25jaGFuZ2UnfHxkb21FdmVudE5hbWU9PT0na2V5dXAnfHxkb21FdmVudE5hbWU9PT0na2V5ZG93bicpey8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4vL1xuLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbi8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbi8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3Rcbi8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbi8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxucmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCk7fX0vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pey8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbi8vIHVudGlsIGBibHVyYCBpbiBJRTguXG52YXIgbm9kZU5hbWU9ZWxlbS5ub2RlTmFtZTtyZXR1cm4gbm9kZU5hbWUmJm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT0naW5wdXQnJiYoZWxlbS50eXBlPT09J2NoZWNrYm94J3x8ZWxlbS50eXBlPT09J3JhZGlvJyk7fWZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0KXtpZihkb21FdmVudE5hbWU9PT0nY2xpY2snKXtyZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO319ZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudChkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCl7aWYoZG9tRXZlbnROYW1lPT09J2lucHV0J3x8ZG9tRXZlbnROYW1lPT09J2NoYW5nZScpe3JldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7fX1mdW5jdGlvbiBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKG5vZGUpe3ZhciBzdGF0ZT1ub2RlLl93cmFwcGVyU3RhdGU7aWYoIXN0YXRlfHwhc3RhdGUuY29udHJvbGxlZHx8bm9kZS50eXBlIT09J251bWJlcicpe3JldHVybjt9ey8vIElmIGNvbnRyb2xsZWQsIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9uIGJsdXJcbnNldERlZmF1bHRWYWx1ZShub2RlLCdudW1iZXInLG5vZGUudmFsdWUpO319LyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLiBUaGlzIGV2ZW50IGZpcmVzIGF0IGEgdGltZSB3aGVuIGl0J3MgcG9zc2libGUgdG9cbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBzZWxlY3RcbiAqL2Z1bmN0aW9uIGV4dHJhY3RFdmVudHMkMShkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0LGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyKXt2YXIgdGFyZ2V0Tm9kZT10YXJnZXRJbnN0P2dldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCk6d2luZG93O3ZhciBnZXRUYXJnZXRJbnN0RnVuYyxoYW5kbGVFdmVudEZ1bmM7aWYoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodGFyZ2V0Tm9kZSkpe2dldFRhcmdldEluc3RGdW5jPWdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDt9ZWxzZSBpZihpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpe2lmKGlzSW5wdXRFdmVudFN1cHBvcnRlZCl7Z2V0VGFyZ2V0SW5zdEZ1bmM9Z2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudDt9ZWxzZXtnZXRUYXJnZXRJbnN0RnVuYz1nZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsO2hhbmRsZUV2ZW50RnVuYz1oYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7fX1lbHNlIGlmKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpe2dldFRhcmdldEluc3RGdW5jPWdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O31pZihnZXRUYXJnZXRJbnN0RnVuYyl7dmFyIGluc3Q9Z2V0VGFyZ2V0SW5zdEZ1bmMoZG9tRXZlbnROYW1lLHRhcmdldEluc3QpO2lmKGluc3Qpe2NyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChkaXNwYXRjaFF1ZXVlLGluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpO3JldHVybjt9fWlmKGhhbmRsZUV2ZW50RnVuYyl7aGFuZGxlRXZlbnRGdW5jKGRvbUV2ZW50TmFtZSx0YXJnZXROb2RlLHRhcmdldEluc3QpO30vLyBXaGVuIGJsdXJyaW5nLCBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBmb3IgbnVtYmVyIGlucHV0c1xuaWYoZG9tRXZlbnROYW1lPT09J2ZvY3Vzb3V0Jyl7aGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXROb2RlKTt9fWZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRzJDIoKXtyZWdpc3RlckRpcmVjdEV2ZW50KCdvbk1vdXNlRW50ZXInLFsnbW91c2VvdXQnLCdtb3VzZW92ZXInXSk7cmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Nb3VzZUxlYXZlJyxbJ21vdXNlb3V0JywnbW91c2VvdmVyJ10pO3JlZ2lzdGVyRGlyZWN0RXZlbnQoJ29uUG9pbnRlckVudGVyJyxbJ3BvaW50ZXJvdXQnLCdwb2ludGVyb3ZlciddKTtyZWdpc3RlckRpcmVjdEV2ZW50KCdvblBvaW50ZXJMZWF2ZScsWydwb2ludGVyb3V0JywncG9pbnRlcm92ZXInXSk7fS8qKlxuICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcbiAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cbiAqL2Z1bmN0aW9uIGV4dHJhY3RFdmVudHMkMihkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0LGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyKXt2YXIgaXNPdmVyRXZlbnQ9ZG9tRXZlbnROYW1lPT09J21vdXNlb3Zlcid8fGRvbUV2ZW50TmFtZT09PSdwb2ludGVyb3Zlcic7dmFyIGlzT3V0RXZlbnQ9ZG9tRXZlbnROYW1lPT09J21vdXNlb3V0J3x8ZG9tRXZlbnROYW1lPT09J3BvaW50ZXJvdXQnO2lmKGlzT3ZlckV2ZW50JiYhaXNSZXBsYXlpbmdFdmVudChuYXRpdmVFdmVudCkpey8vIElmIHRoaXMgaXMgYW4gb3ZlciBldmVudCB3aXRoIGEgdGFyZ2V0LCB3ZSBtaWdodCBoYXZlIGFscmVhZHkgZGlzcGF0Y2hlZFxuLy8gdGhlIGV2ZW50IGluIHRoZSBvdXQgZXZlbnQgb2YgdGhlIG90aGVyIHRhcmdldC4gSWYgdGhpcyBpcyByZXBsYXllZCxcbi8vIHRoZW4gaXQncyBiZWNhdXNlIHdlIGNvdWxkbid0IGRpc3BhdGNoIGFnYWluc3QgdGhpcyB0YXJnZXQgcHJldmlvdXNseVxuLy8gc28gd2UgaGF2ZSB0byBkbyBpdCBub3cgaW5zdGVhZC5cbnZhciByZWxhdGVkPW5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXR8fG5hdGl2ZUV2ZW50LmZyb21FbGVtZW50O2lmKHJlbGF0ZWQpey8vIElmIHRoZSByZWxhdGVkIG5vZGUgaXMgbWFuYWdlZCBieSBSZWFjdCwgd2UgY2FuIGFzc3VtZSB0aGF0IHdlIGhhdmVcbi8vIGFscmVhZHkgZGlzcGF0Y2hlZCB0aGUgY29ycmVzcG9uZGluZyBldmVudHMgZHVyaW5nIGl0cyBtb3VzZW91dC5cbmlmKGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpfHxpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChyZWxhdGVkKSl7cmV0dXJuO319fWlmKCFpc091dEV2ZW50JiYhaXNPdmVyRXZlbnQpey8vIE11c3Qgbm90IGJlIGEgbW91c2Ugb3IgcG9pbnRlciBpbiBvciBvdXQgLSBpZ25vcmluZy5cbnJldHVybjt9dmFyIHdpbjsvLyBUT0RPOiB3aHkgaXMgdGhpcyBudWxsYWJsZSBpbiB0aGUgdHlwZXMgYnV0IHdlIHJlYWQgZnJvbSBpdD9cbmlmKG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdz09PW5hdGl2ZUV2ZW50VGFyZ2V0KXsvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbndpbj1uYXRpdmVFdmVudFRhcmdldDt9ZWxzZXsvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG52YXIgZG9jPW5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7aWYoZG9jKXt3aW49ZG9jLmRlZmF1bHRWaWV3fHxkb2MucGFyZW50V2luZG93O31lbHNle3dpbj13aW5kb3c7fX12YXIgZnJvbTt2YXIgdG87aWYoaXNPdXRFdmVudCl7dmFyIF9yZWxhdGVkPW5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXR8fG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtmcm9tPXRhcmdldEluc3Q7dG89X3JlbGF0ZWQ/Z2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUoX3JlbGF0ZWQpOm51bGw7aWYodG8hPT1udWxsKXt2YXIgbmVhcmVzdE1vdW50ZWQ9Z2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0byk7aWYodG8hPT1uZWFyZXN0TW91bnRlZHx8dG8udGFnIT09SG9zdENvbXBvbmVudCYmdG8udGFnIT09SG9zdFRleHQpe3RvPW51bGw7fX19ZWxzZXsvLyBNb3ZpbmcgdG8gYSBub2RlIGZyb20gb3V0c2lkZSB0aGUgd2luZG93LlxuZnJvbT1udWxsO3RvPXRhcmdldEluc3Q7fWlmKGZyb209PT10byl7Ly8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxucmV0dXJuO312YXIgU3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY01vdXNlRXZlbnQ7dmFyIGxlYXZlRXZlbnRUeXBlPSdvbk1vdXNlTGVhdmUnO3ZhciBlbnRlckV2ZW50VHlwZT0nb25Nb3VzZUVudGVyJzt2YXIgZXZlbnRUeXBlUHJlZml4PSdtb3VzZSc7aWYoZG9tRXZlbnROYW1lPT09J3BvaW50ZXJvdXQnfHxkb21FdmVudE5hbWU9PT0ncG9pbnRlcm92ZXInKXtTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljUG9pbnRlckV2ZW50O2xlYXZlRXZlbnRUeXBlPSdvblBvaW50ZXJMZWF2ZSc7ZW50ZXJFdmVudFR5cGU9J29uUG9pbnRlckVudGVyJztldmVudFR5cGVQcmVmaXg9J3BvaW50ZXInO312YXIgZnJvbU5vZGU9ZnJvbT09bnVsbD93aW46Z2V0Tm9kZUZyb21JbnN0YW5jZShmcm9tKTt2YXIgdG9Ob2RlPXRvPT1udWxsP3dpbjpnZXROb2RlRnJvbUluc3RhbmNlKHRvKTt2YXIgbGVhdmU9bmV3IFN5bnRoZXRpY0V2ZW50Q3RvcihsZWF2ZUV2ZW50VHlwZSxldmVudFR5cGVQcmVmaXgrJ2xlYXZlJyxmcm9tLG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTtsZWF2ZS50YXJnZXQ9ZnJvbU5vZGU7bGVhdmUucmVsYXRlZFRhcmdldD10b05vZGU7dmFyIGVudGVyPW51bGw7Ly8gV2Ugc2hvdWxkIG9ubHkgcHJvY2VzcyB0aGlzIG5hdGl2ZUV2ZW50IGlmIHdlIGFyZSBwcm9jZXNzaW5nXG4vLyB0aGUgZmlyc3QgYW5jZXN0b3IuIE5leHQgdGltZSwgd2Ugd2lsbCBpZ25vcmUgdGhlIGV2ZW50LlxudmFyIG5hdGl2ZVRhcmdldEluc3Q9Z2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO2lmKG5hdGl2ZVRhcmdldEluc3Q9PT10YXJnZXRJbnN0KXt2YXIgZW50ZXJFdmVudD1uZXcgU3ludGhldGljRXZlbnRDdG9yKGVudGVyRXZlbnRUeXBlLGV2ZW50VHlwZVByZWZpeCsnZW50ZXInLHRvLG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTtlbnRlckV2ZW50LnRhcmdldD10b05vZGU7ZW50ZXJFdmVudC5yZWxhdGVkVGFyZ2V0PWZyb21Ob2RlO2VudGVyPWVudGVyRXZlbnQ7fWFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMoZGlzcGF0Y2hRdWV1ZSxsZWF2ZSxlbnRlcixmcm9tLHRvKTt9LyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL2Z1bmN0aW9uIGlzKHgseSl7cmV0dXJuIHg9PT15JiYoeCE9PTB8fDEveD09PTEveSl8fHghPT14JiZ5IT09eS8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG47fXZhciBvYmplY3RJcz10eXBlb2YgT2JqZWN0LmlzPT09J2Z1bmN0aW9uJz9PYmplY3QuaXM6aXM7LyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsb2JqQil7aWYob2JqZWN0SXMob2JqQSxvYmpCKSl7cmV0dXJuIHRydWU7fWlmKHR5cGVvZiBvYmpBIT09J29iamVjdCd8fG9iakE9PT1udWxsfHx0eXBlb2Ygb2JqQiE9PSdvYmplY3QnfHxvYmpCPT09bnVsbCl7cmV0dXJuIGZhbHNlO312YXIga2V5c0E9T2JqZWN0LmtleXMob2JqQSk7dmFyIGtleXNCPU9iamVjdC5rZXlzKG9iakIpO2lmKGtleXNBLmxlbmd0aCE9PWtleXNCLmxlbmd0aCl7cmV0dXJuIGZhbHNlO30vLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuZm9yKHZhciBpPTA7aTxrZXlzQS5sZW5ndGg7aSsrKXt2YXIgY3VycmVudEtleT1rZXlzQVtpXTtpZighaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLGN1cnJlbnRLZXkpfHwhb2JqZWN0SXMob2JqQVtjdXJyZW50S2V5XSxvYmpCW2N1cnJlbnRLZXldKSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fS8qKlxuICogR2l2ZW4gYW55IG5vZGUgcmV0dXJuIHRoZSBmaXJzdCBsZWFmIG5vZGUgd2l0aG91dCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKXt3aGlsZShub2RlJiZub2RlLmZpcnN0Q2hpbGQpe25vZGU9bm9kZS5maXJzdENoaWxkO31yZXR1cm4gbm9kZTt9LyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL2Z1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpe3doaWxlKG5vZGUpe2lmKG5vZGUubmV4dFNpYmxpbmcpe3JldHVybiBub2RlLm5leHRTaWJsaW5nO31ub2RlPW5vZGUucGFyZW50Tm9kZTt9fS8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL2Z1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCxvZmZzZXQpe3ZhciBub2RlPWdldExlYWZOb2RlKHJvb3QpO3ZhciBub2RlU3RhcnQ9MDt2YXIgbm9kZUVuZD0wO3doaWxlKG5vZGUpe2lmKG5vZGUubm9kZVR5cGU9PT1URVhUX05PREUpe25vZGVFbmQ9bm9kZVN0YXJ0K25vZGUudGV4dENvbnRlbnQubGVuZ3RoO2lmKG5vZGVTdGFydDw9b2Zmc2V0JiZub2RlRW5kPj1vZmZzZXQpe3JldHVybntub2RlOm5vZGUsb2Zmc2V0Om9mZnNldC1ub2RlU3RhcnR9O31ub2RlU3RhcnQ9bm9kZUVuZDt9bm9kZT1nZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7fX0vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb3V0ZXJOb2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovZnVuY3Rpb24gZ2V0T2Zmc2V0cyhvdXRlck5vZGUpe3ZhciBvd25lckRvY3VtZW50PW91dGVyTm9kZS5vd25lckRvY3VtZW50O3ZhciB3aW49b3duZXJEb2N1bWVudCYmb3duZXJEb2N1bWVudC5kZWZhdWx0Vmlld3x8d2luZG93O3ZhciBzZWxlY3Rpb249d2luLmdldFNlbGVjdGlvbiYmd2luLmdldFNlbGVjdGlvbigpO2lmKCFzZWxlY3Rpb258fHNlbGVjdGlvbi5yYW5nZUNvdW50PT09MCl7cmV0dXJuIG51bGw7fXZhciBhbmNob3JOb2RlPXNlbGVjdGlvbi5hbmNob3JOb2RlLGFuY2hvck9mZnNldD1zZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LGZvY3VzTm9kZT1zZWxlY3Rpb24uZm9jdXNOb2RlLGZvY3VzT2Zmc2V0PXNlbGVjdGlvbi5mb2N1c09mZnNldDsvLyBJbiBGaXJlZm94LCBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgY2FuIGJlIFwiYW5vbnltb3VzIGRpdnNcIiwgZS5nLiB0aGVcbi8vIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzIGRpdnMgZG8gbm90IHNlZW0gdG9cbi8vIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZCBlcnJvclwiIGlmIGFueSBvZiBpdHNcbi8vIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGUgd2F5IHRvIGF2b2lkIGVycm9yaW5nXG4vLyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3Igbm9uLWFub255bW91cyBkaXZzIGFuZFxuLy8gY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4vLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcbnRyeXsvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9hbmNob3JOb2RlLm5vZGVUeXBlO2ZvY3VzTm9kZS5ub2RlVHlwZTsvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL31jYXRjaChlKXtyZXR1cm4gbnVsbDt9cmV0dXJuIGdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzKG91dGVyTm9kZSxhbmNob3JOb2RlLGFuY2hvck9mZnNldCxmb2N1c05vZGUsZm9jdXNPZmZzZXQpO30vKipcbiAqIFJldHVybnMge3N0YXJ0LCBlbmR9IHdoZXJlIGBzdGFydGAgaXMgdGhlIGNoYXJhY3Rlci9jb2RlcG9pbnQgaW5kZXggb2ZcbiAqIChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpIHdpdGhpbiB0aGUgdGV4dENvbnRlbnQgb2YgYG91dGVyTm9kZWAsIGFuZFxuICogYGVuZGAgaXMgdGhlIGluZGV4IG9mIChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgeW91IHBhc3MgaW4gZ2FyYmFnZSBpbnB1dCBidXQgd2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgY3Jhc2guXG4gKlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZy5cbiAqL2Z1bmN0aW9uIGdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzKG91dGVyTm9kZSxhbmNob3JOb2RlLGFuY2hvck9mZnNldCxmb2N1c05vZGUsZm9jdXNPZmZzZXQpe3ZhciBsZW5ndGg9MDt2YXIgc3RhcnQ9LTE7dmFyIGVuZD0tMTt2YXIgaW5kZXhXaXRoaW5BbmNob3I9MDt2YXIgaW5kZXhXaXRoaW5Gb2N1cz0wO3ZhciBub2RlPW91dGVyTm9kZTt2YXIgcGFyZW50Tm9kZT1udWxsO291dGVyOndoaWxlKHRydWUpe3ZhciBuZXh0PW51bGw7d2hpbGUodHJ1ZSl7aWYobm9kZT09PWFuY2hvck5vZGUmJihhbmNob3JPZmZzZXQ9PT0wfHxub2RlLm5vZGVUeXBlPT09VEVYVF9OT0RFKSl7c3RhcnQ9bGVuZ3RoK2FuY2hvck9mZnNldDt9aWYobm9kZT09PWZvY3VzTm9kZSYmKGZvY3VzT2Zmc2V0PT09MHx8bm9kZS5ub2RlVHlwZT09PVRFWFRfTk9ERSkpe2VuZD1sZW5ndGgrZm9jdXNPZmZzZXQ7fWlmKG5vZGUubm9kZVR5cGU9PT1URVhUX05PREUpe2xlbmd0aCs9bm9kZS5ub2RlVmFsdWUubGVuZ3RoO31pZigobmV4dD1ub2RlLmZpcnN0Q2hpbGQpPT09bnVsbCl7YnJlYWs7fS8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgZmlyc3QgY2hpbGQgYG5leHRgLlxucGFyZW50Tm9kZT1ub2RlO25vZGU9bmV4dDt9d2hpbGUodHJ1ZSl7aWYobm9kZT09PW91dGVyTm9kZSl7Ly8gSWYgYG91dGVyTm9kZWAgaGFzIGNoaWxkcmVuLCB0aGlzIGlzIGFsd2F5cyB0aGUgc2Vjb25kIHRpbWUgdmlzaXRpbmdcbi8vIGl0LiBJZiBpdCBoYXMgbm8gY2hpbGRyZW4sIHRoaXMgaXMgc3RpbGwgdGhlIGZpcnN0IGxvb3AsIGFuZCB0aGUgb25seVxuLy8gdmFsaWQgc2VsZWN0aW9uIGlzIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBib3RoIGVxdWFsIHRvIHRoaXMgbm9kZVxuLy8gYW5kIGJvdGggb2Zmc2V0cyAwLCBpbiB3aGljaCBjYXNlIHdlIHdpbGwgaGF2ZSBoYW5kbGVkIGFib3ZlLlxuYnJlYWsgb3V0ZXI7fWlmKHBhcmVudE5vZGU9PT1hbmNob3JOb2RlJiYrK2luZGV4V2l0aGluQW5jaG9yPT09YW5jaG9yT2Zmc2V0KXtzdGFydD1sZW5ndGg7fWlmKHBhcmVudE5vZGU9PT1mb2N1c05vZGUmJisraW5kZXhXaXRoaW5Gb2N1cz09PWZvY3VzT2Zmc2V0KXtlbmQ9bGVuZ3RoO31pZigobmV4dD1ub2RlLm5leHRTaWJsaW5nKSE9PW51bGwpe2JyZWFrO31ub2RlPXBhcmVudE5vZGU7cGFyZW50Tm9kZT1ub2RlLnBhcmVudE5vZGU7fS8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgbmV4dCBzaWJsaW5nIGBuZXh0YC5cbm5vZGU9bmV4dDt9aWYoc3RhcnQ9PT0tMXx8ZW5kPT09LTEpey8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gKFdvdWxkIGhhcHBlbiBpZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFyZW4ndFxuLy8gYWN0dWFsbHkgaW5zaWRlIHRoZSBwYXNzZWQtaW4gbm9kZS4pXG5yZXR1cm4gbnVsbDt9cmV0dXJue3N0YXJ0OnN0YXJ0LGVuZDplbmR9O30vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL2Z1bmN0aW9uIHNldE9mZnNldHMobm9kZSxvZmZzZXRzKXt2YXIgZG9jPW5vZGUub3duZXJEb2N1bWVudHx8ZG9jdW1lbnQ7dmFyIHdpbj1kb2MmJmRvYy5kZWZhdWx0Vmlld3x8d2luZG93Oy8vIEVkZ2UgZmFpbHMgd2l0aCBcIk9iamVjdCBleHBlY3RlZFwiIGluIHNvbWUgc2NlbmFyaW9zLlxuLy8gKEZvciBpbnN0YW5jZTogVGlueU1DRSBlZGl0b3IgdXNlZCBpbiBhIGxpc3QgY29tcG9uZW50IHRoYXQgc3VwcG9ydHMgcGFzdGluZyB0byBhZGQgbW9yZSxcbi8vIGZhaWxzIHdoZW4gcGFzdGluZyAxMDArIGl0ZW1zKVxuaWYoIXdpbi5nZXRTZWxlY3Rpb24pe3JldHVybjt9dmFyIHNlbGVjdGlvbj13aW4uZ2V0U2VsZWN0aW9uKCk7dmFyIGxlbmd0aD1ub2RlLnRleHRDb250ZW50Lmxlbmd0aDt2YXIgc3RhcnQ9TWF0aC5taW4ob2Zmc2V0cy5zdGFydCxsZW5ndGgpO3ZhciBlbmQ9b2Zmc2V0cy5lbmQ9PT11bmRlZmluZWQ/c3RhcnQ6TWF0aC5taW4ob2Zmc2V0cy5lbmQsbGVuZ3RoKTsvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4vLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbmlmKCFzZWxlY3Rpb24uZXh0ZW5kJiZzdGFydD5lbmQpe3ZhciB0ZW1wPWVuZDtlbmQ9c3RhcnQ7c3RhcnQ9dGVtcDt9dmFyIHN0YXJ0TWFya2VyPWdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSxzdGFydCk7dmFyIGVuZE1hcmtlcj1nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsZW5kKTtpZihzdGFydE1hcmtlciYmZW5kTWFya2VyKXtpZihzZWxlY3Rpb24ucmFuZ2VDb3VudD09PTEmJnNlbGVjdGlvbi5hbmNob3JOb2RlPT09c3RhcnRNYXJrZXIubm9kZSYmc2VsZWN0aW9uLmFuY2hvck9mZnNldD09PXN0YXJ0TWFya2VyLm9mZnNldCYmc2VsZWN0aW9uLmZvY3VzTm9kZT09PWVuZE1hcmtlci5ub2RlJiZzZWxlY3Rpb24uZm9jdXNPZmZzZXQ9PT1lbmRNYXJrZXIub2Zmc2V0KXtyZXR1cm47fXZhciByYW5nZT1kb2MuY3JlYXRlUmFuZ2UoKTtyYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLHN0YXJ0TWFya2VyLm9mZnNldCk7c2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO2lmKHN0YXJ0PmVuZCl7c2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLGVuZE1hcmtlci5vZmZzZXQpO31lbHNle3JhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSxlbmRNYXJrZXIub2Zmc2V0KTtzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO319fWZ1bmN0aW9uIGlzVGV4dE5vZGUobm9kZSl7cmV0dXJuIG5vZGUmJm5vZGUubm9kZVR5cGU9PT1URVhUX05PREU7fWZ1bmN0aW9uIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsaW5uZXJOb2RlKXtpZighb3V0ZXJOb2RlfHwhaW5uZXJOb2RlKXtyZXR1cm4gZmFsc2U7fWVsc2UgaWYob3V0ZXJOb2RlPT09aW5uZXJOb2RlKXtyZXR1cm4gdHJ1ZTt9ZWxzZSBpZihpc1RleHROb2RlKG91dGVyTm9kZSkpe3JldHVybiBmYWxzZTt9ZWxzZSBpZihpc1RleHROb2RlKGlubmVyTm9kZSkpe3JldHVybiBjb250YWluc05vZGUob3V0ZXJOb2RlLGlubmVyTm9kZS5wYXJlbnROb2RlKTt9ZWxzZSBpZignY29udGFpbnMnaW4gb3V0ZXJOb2RlKXtyZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7fWVsc2UgaWYob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKXtyZXR1cm4hIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSYxNik7fWVsc2V7cmV0dXJuIGZhbHNlO319ZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpe3JldHVybiBub2RlJiZub2RlLm93bmVyRG9jdW1lbnQmJmNvbnRhaW5zTm9kZShub2RlLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LG5vZGUpO31mdW5jdGlvbiBpc1NhbWVPcmlnaW5GcmFtZShpZnJhbWUpe3RyeXsvLyBBY2Nlc3NpbmcgdGhlIGNvbnRlbnREb2N1bWVudCBvZiBhIEhUTUxJZnJhbWVFbGVtZW50IGNhbiBjYXVzZSB0aGUgYnJvd3NlclxuLy8gdG8gdGhyb3csIGUuZy4gaWYgaXQgaGFzIGEgY3Jvc3Mtb3JpZ2luIHNyYyBhdHRyaWJ1dGUuXG4vLyBTYWZhcmkgd2lsbCBzaG93IGFuIGVycm9yIGluIHRoZSBjb25zb2xlIHdoZW4gdGhlIGFjY2VzcyByZXN1bHRzIGluIFwiQmxvY2tlZCBhIGZyYW1lIHdpdGggb3JpZ2luXCIuIGUuZzpcbi8vIGlmcmFtZS5jb250ZW50RG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4vLyBBIHNhZmV0eSB3YXkgaXMgdG8gYWNjZXNzIG9uZSBvZiB0aGUgY3Jvc3Mgb3JpZ2luIHByb3BlcnRpZXM6IFdpbmRvdyBvciBMb2NhdGlvblxuLy8gV2hpY2ggbWlnaHQgcmVzdWx0IGluIFwiU2VjdXJpdHlFcnJvclwiIERPTSBFeGNlcHRpb24gYW5kIGl0IGlzIGNvbXBhdGlibGUgdG8gU2FmYXJpLlxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvYnJvd3NlcnMuaHRtbCNpbnRlZ3JhdGlvbi13aXRoLWlkbFxucmV0dXJuIHR5cGVvZiBpZnJhbWUuY29udGVudFdpbmRvdy5sb2NhdGlvbi5ocmVmPT09J3N0cmluZyc7fWNhdGNoKGVycil7cmV0dXJuIGZhbHNlO319ZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudERlZXAoKXt2YXIgd2luPXdpbmRvdzt2YXIgZWxlbWVudD1nZXRBY3RpdmVFbGVtZW50KCk7d2hpbGUoZWxlbWVudCBpbnN0YW5jZW9mIHdpbi5IVE1MSUZyYW1lRWxlbWVudCl7aWYoaXNTYW1lT3JpZ2luRnJhbWUoZWxlbWVudCkpe3dpbj1lbGVtZW50LmNvbnRlbnRXaW5kb3c7fWVsc2V7cmV0dXJuIGVsZW1lbnQ7fWVsZW1lbnQ9Z2V0QWN0aXZlRWxlbWVudCh3aW4uZG9jdW1lbnQpO31yZXR1cm4gZWxlbWVudDt9LyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi8vKipcbiAqIEBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IHdlIGdldCB0aGUgZWxlbWVudCB0eXBlcyB0aGF0IHN1cHBvcnQgc2VsZWN0aW9uXG4gKiBmcm9tIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2RvLW5vdC1hcHBseSwgbG9va2luZyBhdCBgc2VsZWN0aW9uU3RhcnRgXG4gKiBhbmQgYHNlbGVjdGlvbkVuZGAgcm93cy5cbiAqL2Z1bmN0aW9uIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhlbGVtKXt2YXIgbm9kZU5hbWU9ZWxlbSYmZWxlbS5ub2RlTmFtZSYmZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiBub2RlTmFtZSYmKG5vZGVOYW1lPT09J2lucHV0JyYmKGVsZW0udHlwZT09PSd0ZXh0J3x8ZWxlbS50eXBlPT09J3NlYXJjaCd8fGVsZW0udHlwZT09PSd0ZWwnfHxlbGVtLnR5cGU9PT0ndXJsJ3x8ZWxlbS50eXBlPT09J3Bhc3N3b3JkJyl8fG5vZGVOYW1lPT09J3RleHRhcmVhJ3x8ZWxlbS5jb250ZW50RWRpdGFibGU9PT0ndHJ1ZScpO31mdW5jdGlvbiBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpe3ZhciBmb2N1c2VkRWxlbT1nZXRBY3RpdmVFbGVtZW50RGVlcCgpO3JldHVybntmb2N1c2VkRWxlbTpmb2N1c2VkRWxlbSxzZWxlY3Rpb25SYW5nZTpoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pP2dldFNlbGVjdGlvbihmb2N1c2VkRWxlbSk6bnVsbH07fS8qKlxuICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICovZnVuY3Rpb24gcmVzdG9yZVNlbGVjdGlvbihwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKXt2YXIgY3VyRm9jdXNlZEVsZW09Z2V0QWN0aXZlRWxlbWVudERlZXAoKTt2YXIgcHJpb3JGb2N1c2VkRWxlbT1wcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO3ZhciBwcmlvclNlbGVjdGlvblJhbmdlPXByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2VsZWN0aW9uUmFuZ2U7aWYoY3VyRm9jdXNlZEVsZW0hPT1wcmlvckZvY3VzZWRFbGVtJiZpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpe2lmKHByaW9yU2VsZWN0aW9uUmFuZ2UhPT1udWxsJiZoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpe3NldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLHByaW9yU2VsZWN0aW9uUmFuZ2UpO30vLyBGb2N1c2luZyBhIG5vZGUgY2FuIGNoYW5nZSB0aGUgc2Nyb2xsIHBvc2l0aW9uLCB3aGljaCBpcyB1bmRlc2lyYWJsZVxudmFyIGFuY2VzdG9ycz1bXTt2YXIgYW5jZXN0b3I9cHJpb3JGb2N1c2VkRWxlbTt3aGlsZShhbmNlc3Rvcj1hbmNlc3Rvci5wYXJlbnROb2RlKXtpZihhbmNlc3Rvci5ub2RlVHlwZT09PUVMRU1FTlRfTk9ERSl7YW5jZXN0b3JzLnB1c2goe2VsZW1lbnQ6YW5jZXN0b3IsbGVmdDphbmNlc3Rvci5zY3JvbGxMZWZ0LHRvcDphbmNlc3Rvci5zY3JvbGxUb3B9KTt9fWlmKHR5cGVvZiBwcmlvckZvY3VzZWRFbGVtLmZvY3VzPT09J2Z1bmN0aW9uJyl7cHJpb3JGb2N1c2VkRWxlbS5mb2N1cygpO31mb3IodmFyIGk9MDtpPGFuY2VzdG9ycy5sZW5ndGg7aSsrKXt2YXIgaW5mbz1hbmNlc3RvcnNbaV07aW5mby5lbGVtZW50LnNjcm9sbExlZnQ9aW5mby5sZWZ0O2luZm8uZWxlbWVudC5zY3JvbGxUb3A9aW5mby50b3A7fX19LyoqXG4gKiBAZ2V0U2VsZWN0aW9uOiBHZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgZm9jdXNlZCB0ZXh0YXJlYSwgaW5wdXQgb3JcbiAqIGNvbnRlbnRFZGl0YWJsZSBub2RlLlxuICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAqIC1AcmV0dXJuIHtzdGFydDogc2VsZWN0aW9uU3RhcnQsIGVuZDogc2VsZWN0aW9uRW5kfVxuICovZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKGlucHV0KXt2YXIgc2VsZWN0aW9uO2lmKCdzZWxlY3Rpb25TdGFydCdpbiBpbnB1dCl7Ly8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbnNlbGVjdGlvbj17c3RhcnQ6aW5wdXQuc2VsZWN0aW9uU3RhcnQsZW5kOmlucHV0LnNlbGVjdGlvbkVuZH07fWVsc2V7Ly8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG5zZWxlY3Rpb249Z2V0T2Zmc2V0cyhpbnB1dCk7fXJldHVybiBzZWxlY3Rpb258fHtzdGFydDowLGVuZDowfTt9LyoqXG4gKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAqIHRoZSBpbnB1dC5cbiAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAqL2Z1bmN0aW9uIHNldFNlbGVjdGlvbihpbnB1dCxvZmZzZXRzKXt2YXIgc3RhcnQ9b2Zmc2V0cy5zdGFydDt2YXIgZW5kPW9mZnNldHMuZW5kO2lmKGVuZD09PXVuZGVmaW5lZCl7ZW5kPXN0YXJ0O31pZignc2VsZWN0aW9uU3RhcnQnaW4gaW5wdXQpe2lucHV0LnNlbGVjdGlvblN0YXJ0PXN0YXJ0O2lucHV0LnNlbGVjdGlvbkVuZD1NYXRoLm1pbihlbmQsaW5wdXQudmFsdWUubGVuZ3RoKTt9ZWxzZXtzZXRPZmZzZXRzKGlucHV0LG9mZnNldHMpO319dmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudD1jYW5Vc2VET00mJidkb2N1bWVudE1vZGUnaW4gZG9jdW1lbnQmJmRvY3VtZW50LmRvY3VtZW50TW9kZTw9MTE7ZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMkMygpe3JlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25TZWxlY3QnLFsnZm9jdXNvdXQnLCdjb250ZXh0bWVudScsJ2RyYWdlbmQnLCdmb2N1c2luJywna2V5ZG93bicsJ2tleXVwJywnbW91c2Vkb3duJywnbW91c2V1cCcsJ3NlbGVjdGlvbmNoYW5nZSddKTt9dmFyIGFjdGl2ZUVsZW1lbnQkMT1udWxsO3ZhciBhY3RpdmVFbGVtZW50SW5zdCQxPW51bGw7dmFyIGxhc3RTZWxlY3Rpb249bnVsbDt2YXIgbW91c2VEb3duPWZhbHNlOy8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqL2Z1bmN0aW9uIGdldFNlbGVjdGlvbiQxKG5vZGUpe2lmKCdzZWxlY3Rpb25TdGFydCdpbiBub2RlJiZoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMobm9kZSkpe3JldHVybntzdGFydDpub2RlLnNlbGVjdGlvblN0YXJ0LGVuZDpub2RlLnNlbGVjdGlvbkVuZH07fWVsc2V7dmFyIHdpbj1ub2RlLm93bmVyRG9jdW1lbnQmJm5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlld3x8d2luZG93O3ZhciBzZWxlY3Rpb249d2luLmdldFNlbGVjdGlvbigpO3JldHVybnthbmNob3JOb2RlOnNlbGVjdGlvbi5hbmNob3JOb2RlLGFuY2hvck9mZnNldDpzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LGZvY3VzTm9kZTpzZWxlY3Rpb24uZm9jdXNOb2RlLGZvY3VzT2Zmc2V0OnNlbGVjdGlvbi5mb2N1c09mZnNldH07fX0vKipcbiAqIEdldCBkb2N1bWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50IHRhcmdldC5cbiAqL2Z1bmN0aW9uIGdldEV2ZW50VGFyZ2V0RG9jdW1lbnQoZXZlbnRUYXJnZXQpe3JldHVybiBldmVudFRhcmdldC53aW5kb3c9PT1ldmVudFRhcmdldD9ldmVudFRhcmdldC5kb2N1bWVudDpldmVudFRhcmdldC5ub2RlVHlwZT09PURPQ1VNRU5UX05PREU/ZXZlbnRUYXJnZXQ6ZXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDt9LyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRUYXJnZXRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL2Z1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpey8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuLy8gd29uJ3QgZGlzcGF0Y2guXG52YXIgZG9jPWdldEV2ZW50VGFyZ2V0RG9jdW1lbnQobmF0aXZlRXZlbnRUYXJnZXQpO2lmKG1vdXNlRG93bnx8YWN0aXZlRWxlbWVudCQxPT1udWxsfHxhY3RpdmVFbGVtZW50JDEhPT1nZXRBY3RpdmVFbGVtZW50KGRvYykpe3JldHVybjt9Ly8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxudmFyIGN1cnJlbnRTZWxlY3Rpb249Z2V0U2VsZWN0aW9uJDEoYWN0aXZlRWxlbWVudCQxKTtpZighbGFzdFNlbGVjdGlvbnx8IXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLGN1cnJlbnRTZWxlY3Rpb24pKXtsYXN0U2VsZWN0aW9uPWN1cnJlbnRTZWxlY3Rpb247dmFyIGxpc3RlbmVycz1hY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnMoYWN0aXZlRWxlbWVudEluc3QkMSwnb25TZWxlY3QnKTtpZihsaXN0ZW5lcnMubGVuZ3RoPjApe3ZhciBldmVudD1uZXcgU3ludGhldGljRXZlbnQoJ29uU2VsZWN0Jywnc2VsZWN0JyxudWxsLG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTtkaXNwYXRjaFF1ZXVlLnB1c2goe2V2ZW50OmV2ZW50LGxpc3RlbmVyczpsaXN0ZW5lcnN9KTtldmVudC50YXJnZXQ9YWN0aXZlRWxlbWVudCQxO319fS8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL2Z1bmN0aW9uIGV4dHJhY3RFdmVudHMkMyhkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0LGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyKXt2YXIgdGFyZ2V0Tm9kZT10YXJnZXRJbnN0P2dldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCk6d2luZG93O3N3aXRjaChkb21FdmVudE5hbWUpey8vIFRyYWNrIHRoZSBpbnB1dCBub2RlIHRoYXQgaGFzIGZvY3VzLlxuY2FzZSdmb2N1c2luJzppZihpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSl8fHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlPT09J3RydWUnKXthY3RpdmVFbGVtZW50JDE9dGFyZ2V0Tm9kZTthY3RpdmVFbGVtZW50SW5zdCQxPXRhcmdldEluc3Q7bGFzdFNlbGVjdGlvbj1udWxsO31icmVhaztjYXNlJ2ZvY3Vzb3V0JzphY3RpdmVFbGVtZW50JDE9bnVsbDthY3RpdmVFbGVtZW50SW5zdCQxPW51bGw7bGFzdFNlbGVjdGlvbj1udWxsO2JyZWFrOy8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4vLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG5jYXNlJ21vdXNlZG93bic6bW91c2VEb3duPXRydWU7YnJlYWs7Y2FzZSdjb250ZXh0bWVudSc6Y2FzZSdtb3VzZXVwJzpjYXNlJ2RyYWdlbmQnOm1vdXNlRG93bj1mYWxzZTtjb25zdHJ1Y3RTZWxlY3RFdmVudChkaXNwYXRjaFF1ZXVlLG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTticmVhazsvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4vLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbi8vXG4vLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbi8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4vLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4vLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG5jYXNlJ3NlbGVjdGlvbmNoYW5nZSc6aWYoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KXticmVhazt9Ly8gZmFsbHMgdGhyb3VnaFxuY2FzZSdrZXlkb3duJzpjYXNlJ2tleXVwJzpjb25zdHJ1Y3RTZWxlY3RFdmVudChkaXNwYXRjaFF1ZXVlLG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTt9fS8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsZXZlbnROYW1lKXt2YXIgcHJlZml4ZXM9e307cHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldPWV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO3ByZWZpeGVzWydXZWJraXQnK3N0eWxlUHJvcF09J3dlYmtpdCcrZXZlbnROYW1lO3ByZWZpeGVzWydNb3onK3N0eWxlUHJvcF09J21veicrZXZlbnROYW1lO3JldHVybiBwcmVmaXhlczt9LyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi92YXIgdmVuZG9yUHJlZml4ZXM9e2FuaW1hdGlvbmVuZDptYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCdBbmltYXRpb25FbmQnKSxhbmltYXRpb25pdGVyYXRpb246bWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywnQW5pbWF0aW9uSXRlcmF0aW9uJyksYW5pbWF0aW9uc3RhcnQ6bWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywnQW5pbWF0aW9uU3RhcnQnKSx0cmFuc2l0aW9uZW5kOm1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCdUcmFuc2l0aW9uRW5kJyl9Oy8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovdmFyIHByZWZpeGVkRXZlbnROYW1lcz17fTsvKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovdmFyIHN0eWxlPXt9Oy8qKlxuICogQm9vdHN0cmFwIGlmIGEgRE9NIGV4aXN0cy5cbiAqL2lmKGNhblVzZURPTSl7c3R5bGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7Ly8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbi8vIHRoZSB1bi1wcmVmaXhlZCBcImFuaW1hdGlvblwiIGFuZCBcInRyYW5zaXRpb25cIiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHRoZVxuLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4vLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuaWYoISgnQW5pbWF0aW9uRXZlbnQnaW4gd2luZG93KSl7ZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbmVuZC5hbmltYXRpb247ZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb247ZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbjt9Ly8gU2FtZSBhcyBhYm92ZVxuaWYoISgnVHJhbnNpdGlvbkV2ZW50J2luIHdpbmRvdykpe2RlbGV0ZSB2ZW5kb3JQcmVmaXhlcy50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247fX0vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovZnVuY3Rpb24gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoZXZlbnROYW1lKXtpZihwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSl7cmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO31lbHNlIGlmKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKXtyZXR1cm4gZXZlbnROYW1lO312YXIgcHJlZml4TWFwPXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07Zm9yKHZhciBzdHlsZVByb3AgaW4gcHJlZml4TWFwKXtpZihwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSYmc3R5bGVQcm9wIGluIHN0eWxlKXtyZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV09cHJlZml4TWFwW3N0eWxlUHJvcF07fX1yZXR1cm4gZXZlbnROYW1lO312YXIgQU5JTUFUSU9OX0VORD1nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJyk7dmFyIEFOSU1BVElPTl9JVEVSQVRJT049Z2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbml0ZXJhdGlvbicpO3ZhciBBTklNQVRJT05fU1RBUlQ9Z2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0Jyk7dmFyIFRSQU5TSVRJT05fRU5EPWdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJyk7dmFyIHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzPW5ldyBNYXAoKTsvLyBOT1RFOiBDYXBpdGFsaXphdGlvbiBpcyBpbXBvcnRhbnQgaW4gdGhpcyBsaXN0IVxuLy9cbi8vIEUuZy4gaXQgbmVlZHMgXCJwb2ludGVyRG93blwiLCBub3QgXCJwb2ludGVyZG93blwiLlxuLy8gVGhpcyBpcyBiZWNhdXNlIHdlIGRlcml2ZSBib3RoIFJlYWN0IG5hbWUgKFwib25Qb2ludGVyRG93blwiKVxuLy8gYW5kIERPTSBuYW1lIChcInBvaW50ZXJkb3duXCIpIGZyb20gdGhlIHNhbWUgbGlzdC5cbi8vXG4vLyBFeGNlcHRpb25zIHRoYXQgZG9uJ3QgbWF0Y2ggdGhpcyBjb252ZW50aW9uIGFyZSBsaXN0ZWQgc2VwYXJhdGVseS5cbi8vXG4vLyBwcmV0dGllci1pZ25vcmVcbnZhciBzaW1wbGVFdmVudFBsdWdpbkV2ZW50cz1bJ2Fib3J0JywnYXV4Q2xpY2snLCdjYW5jZWwnLCdjYW5QbGF5JywnY2FuUGxheVRocm91Z2gnLCdjbGljaycsJ2Nsb3NlJywnY29udGV4dE1lbnUnLCdjb3B5JywnY3V0JywnZHJhZycsJ2RyYWdFbmQnLCdkcmFnRW50ZXInLCdkcmFnRXhpdCcsJ2RyYWdMZWF2ZScsJ2RyYWdPdmVyJywnZHJhZ1N0YXJ0JywnZHJvcCcsJ2R1cmF0aW9uQ2hhbmdlJywnZW1wdGllZCcsJ2VuY3J5cHRlZCcsJ2VuZGVkJywnZXJyb3InLCdnb3RQb2ludGVyQ2FwdHVyZScsJ2lucHV0JywnaW52YWxpZCcsJ2tleURvd24nLCdrZXlQcmVzcycsJ2tleVVwJywnbG9hZCcsJ2xvYWRlZERhdGEnLCdsb2FkZWRNZXRhZGF0YScsJ2xvYWRTdGFydCcsJ2xvc3RQb2ludGVyQ2FwdHVyZScsJ21vdXNlRG93bicsJ21vdXNlTW92ZScsJ21vdXNlT3V0JywnbW91c2VPdmVyJywnbW91c2VVcCcsJ3Bhc3RlJywncGF1c2UnLCdwbGF5JywncGxheWluZycsJ3BvaW50ZXJDYW5jZWwnLCdwb2ludGVyRG93bicsJ3BvaW50ZXJNb3ZlJywncG9pbnRlck91dCcsJ3BvaW50ZXJPdmVyJywncG9pbnRlclVwJywncHJvZ3Jlc3MnLCdyYXRlQ2hhbmdlJywncmVzZXQnLCdyZXNpemUnLCdzZWVrZWQnLCdzZWVraW5nJywnc3RhbGxlZCcsJ3N1Ym1pdCcsJ3N1c3BlbmQnLCd0aW1lVXBkYXRlJywndG91Y2hDYW5jZWwnLCd0b3VjaEVuZCcsJ3RvdWNoU3RhcnQnLCd2b2x1bWVDaGFuZ2UnLCdzY3JvbGwnLCd0b2dnbGUnLCd0b3VjaE1vdmUnLCd3YWl0aW5nJywnd2hlZWwnXTtmdW5jdGlvbiByZWdpc3RlclNpbXBsZUV2ZW50KGRvbUV2ZW50TmFtZSxyZWFjdE5hbWUpe3RvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzLnNldChkb21FdmVudE5hbWUscmVhY3ROYW1lKTtyZWdpc3RlclR3b1BoYXNlRXZlbnQocmVhY3ROYW1lLFtkb21FdmVudE5hbWVdKTt9ZnVuY3Rpb24gcmVnaXN0ZXJTaW1wbGVFdmVudHMoKXtmb3IodmFyIGk9MDtpPHNpbXBsZUV2ZW50UGx1Z2luRXZlbnRzLmxlbmd0aDtpKyspe3ZhciBldmVudE5hbWU9c2ltcGxlRXZlbnRQbHVnaW5FdmVudHNbaV07dmFyIGRvbUV2ZW50TmFtZT1ldmVudE5hbWUudG9Mb3dlckNhc2UoKTt2YXIgY2FwaXRhbGl6ZWRFdmVudD1ldmVudE5hbWVbMF0udG9VcHBlckNhc2UoKStldmVudE5hbWUuc2xpY2UoMSk7cmVnaXN0ZXJTaW1wbGVFdmVudChkb21FdmVudE5hbWUsJ29uJytjYXBpdGFsaXplZEV2ZW50KTt9Ly8gU3BlY2lhbCBjYXNlcyB3aGVyZSBldmVudCBuYW1lcyBkb24ndCBtYXRjaC5cbnJlZ2lzdGVyU2ltcGxlRXZlbnQoQU5JTUFUSU9OX0VORCwnb25BbmltYXRpb25FbmQnKTtyZWdpc3RlclNpbXBsZUV2ZW50KEFOSU1BVElPTl9JVEVSQVRJT04sJ29uQW5pbWF0aW9uSXRlcmF0aW9uJyk7cmVnaXN0ZXJTaW1wbGVFdmVudChBTklNQVRJT05fU1RBUlQsJ29uQW5pbWF0aW9uU3RhcnQnKTtyZWdpc3RlclNpbXBsZUV2ZW50KCdkYmxjbGljaycsJ29uRG91YmxlQ2xpY2snKTtyZWdpc3RlclNpbXBsZUV2ZW50KCdmb2N1c2luJywnb25Gb2N1cycpO3JlZ2lzdGVyU2ltcGxlRXZlbnQoJ2ZvY3Vzb3V0Jywnb25CbHVyJyk7cmVnaXN0ZXJTaW1wbGVFdmVudChUUkFOU0lUSU9OX0VORCwnb25UcmFuc2l0aW9uRW5kJyk7fWZ1bmN0aW9uIGV4dHJhY3RFdmVudHMkNChkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0LGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyKXt2YXIgcmVhY3ROYW1lPXRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzLmdldChkb21FdmVudE5hbWUpO2lmKHJlYWN0TmFtZT09PXVuZGVmaW5lZCl7cmV0dXJuO312YXIgU3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY0V2ZW50O3ZhciByZWFjdEV2ZW50VHlwZT1kb21FdmVudE5hbWU7c3dpdGNoKGRvbUV2ZW50TmFtZSl7Y2FzZSdrZXlwcmVzcyc6Ly8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbi8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4vLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuaWYoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk9PT0wKXtyZXR1cm47fS8qIGZhbGxzIHRocm91Z2ggKi9jYXNlJ2tleWRvd24nOmNhc2Una2V5dXAnOlN5bnRoZXRpY0V2ZW50Q3Rvcj1TeW50aGV0aWNLZXlib2FyZEV2ZW50O2JyZWFrO2Nhc2UnZm9jdXNpbic6cmVhY3RFdmVudFR5cGU9J2ZvY3VzJztTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljRm9jdXNFdmVudDticmVhaztjYXNlJ2ZvY3Vzb3V0JzpyZWFjdEV2ZW50VHlwZT0nYmx1cic7U3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY0ZvY3VzRXZlbnQ7YnJlYWs7Y2FzZSdiZWZvcmVibHVyJzpjYXNlJ2FmdGVyYmx1cic6U3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY0ZvY3VzRXZlbnQ7YnJlYWs7Y2FzZSdjbGljayc6Ly8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4vLyB1bndhbnRlZCBjbGljayBldmVudHMuXG5pZihuYXRpdmVFdmVudC5idXR0b249PT0yKXtyZXR1cm47fS8qIGZhbGxzIHRocm91Z2ggKi9jYXNlJ2F1eGNsaWNrJzpjYXNlJ2RibGNsaWNrJzpjYXNlJ21vdXNlZG93bic6Y2FzZSdtb3VzZW1vdmUnOmNhc2UnbW91c2V1cCc6Ly8gVE9ETzogRGlzYWJsZWQgZWxlbWVudHMgc2hvdWxkIG5vdCByZXNwb25kIHRvIG1vdXNlIGV2ZW50c1xuLyogZmFsbHMgdGhyb3VnaCAqL2Nhc2UnbW91c2VvdXQnOmNhc2UnbW91c2VvdmVyJzpjYXNlJ2NvbnRleHRtZW51JzpTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljTW91c2VFdmVudDticmVhaztjYXNlJ2RyYWcnOmNhc2UnZHJhZ2VuZCc6Y2FzZSdkcmFnZW50ZXInOmNhc2UnZHJhZ2V4aXQnOmNhc2UnZHJhZ2xlYXZlJzpjYXNlJ2RyYWdvdmVyJzpjYXNlJ2RyYWdzdGFydCc6Y2FzZSdkcm9wJzpTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljRHJhZ0V2ZW50O2JyZWFrO2Nhc2UndG91Y2hjYW5jZWwnOmNhc2UndG91Y2hlbmQnOmNhc2UndG91Y2htb3ZlJzpjYXNlJ3RvdWNoc3RhcnQnOlN5bnRoZXRpY0V2ZW50Q3Rvcj1TeW50aGV0aWNUb3VjaEV2ZW50O2JyZWFrO2Nhc2UgQU5JTUFUSU9OX0VORDpjYXNlIEFOSU1BVElPTl9JVEVSQVRJT046Y2FzZSBBTklNQVRJT05fU1RBUlQ6U3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O2JyZWFrO2Nhc2UgVFJBTlNJVElPTl9FTkQ6U3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDticmVhaztjYXNlJ3Njcm9sbCc6U3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY1VJRXZlbnQ7YnJlYWs7Y2FzZSd3aGVlbCc6U3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY1doZWVsRXZlbnQ7YnJlYWs7Y2FzZSdjb3B5JzpjYXNlJ2N1dCc6Y2FzZSdwYXN0ZSc6U3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O2JyZWFrO2Nhc2UnZ290cG9pbnRlcmNhcHR1cmUnOmNhc2UnbG9zdHBvaW50ZXJjYXB0dXJlJzpjYXNlJ3BvaW50ZXJjYW5jZWwnOmNhc2UncG9pbnRlcmRvd24nOmNhc2UncG9pbnRlcm1vdmUnOmNhc2UncG9pbnRlcm91dCc6Y2FzZSdwb2ludGVyb3Zlcic6Y2FzZSdwb2ludGVydXAnOlN5bnRoZXRpY0V2ZW50Q3Rvcj1TeW50aGV0aWNQb2ludGVyRXZlbnQ7YnJlYWs7fXZhciBpbkNhcHR1cmVQaGFzZT0oZXZlbnRTeXN0ZW1GbGFncyZJU19DQVBUVVJFX1BIQVNFKSE9PTA7ey8vIFNvbWUgZXZlbnRzIGRvbid0IGJ1YmJsZSBpbiB0aGUgYnJvd3Nlci5cbi8vIEluIHRoZSBwYXN0LCBSZWFjdCBoYXMgYWx3YXlzIGJ1YmJsZWQgdGhlbSwgYnV0IHRoaXMgY2FuIGJlIHN1cnByaXNpbmcuXG4vLyBXZSdyZSBnb2luZyB0byB0cnkgYWxpZ25pbmcgY2xvc2VyIHRvIHRoZSBicm93c2VyIGJlaGF2aW9yIGJ5IG5vdCBidWJibGluZ1xuLy8gdGhlbSBpbiBSZWFjdCBlaXRoZXIuIFdlJ2xsIHN0YXJ0IGJ5IG5vdCBidWJibGluZyBvblNjcm9sbCwgYW5kIHRoZW4gZXhwYW5kLlxudmFyIGFjY3VtdWxhdGVUYXJnZXRPbmx5PSFpbkNhcHR1cmVQaGFzZSYmLy8gVE9ETzogaWRlYWxseSwgd2UnZCBldmVudHVhbGx5IGFkZCBhbGwgZXZlbnRzIGZyb21cbi8vIG5vbkRlbGVnYXRlZEV2ZW50cyBsaXN0IGluIERPTVBsdWdpbkV2ZW50U3lzdGVtLlxuLy8gVGhlbiB3ZSBjYW4gcmVtb3ZlIHRoaXMgc3BlY2lhbCBsaXN0LlxuLy8gVGhpcyBpcyBhIGJyZWFraW5nIGNoYW5nZSB0aGF0IGNhbiB3YWl0IHVudGlsIFJlYWN0IDE4LlxuZG9tRXZlbnROYW1lPT09J3Njcm9sbCc7dmFyIF9saXN0ZW5lcnM9YWNjdW11bGF0ZVNpbmdsZVBoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QscmVhY3ROYW1lLG5hdGl2ZUV2ZW50LnR5cGUsaW5DYXB0dXJlUGhhc2UsYWNjdW11bGF0ZVRhcmdldE9ubHkpO2lmKF9saXN0ZW5lcnMubGVuZ3RoPjApey8vIEludGVudGlvbmFsbHkgY3JlYXRlIGV2ZW50IGxhemlseS5cbnZhciBfZXZlbnQ9bmV3IFN5bnRoZXRpY0V2ZW50Q3RvcihyZWFjdE5hbWUscmVhY3RFdmVudFR5cGUsbnVsbCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCk7ZGlzcGF0Y2hRdWV1ZS5wdXNoKHtldmVudDpfZXZlbnQsbGlzdGVuZXJzOl9saXN0ZW5lcnN9KTt9fX0vLyBUT0RPOiByZW1vdmUgdG9wLWxldmVsIHNpZGUgZWZmZWN0LlxucmVnaXN0ZXJTaW1wbGVFdmVudHMoKTtyZWdpc3RlckV2ZW50cyQyKCk7cmVnaXN0ZXJFdmVudHMkMSgpO3JlZ2lzdGVyRXZlbnRzJDMoKTtyZWdpc3RlckV2ZW50cygpO2Z1bmN0aW9uIGV4dHJhY3RFdmVudHMkNShkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0LGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyKXsvLyBUT0RPOiB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBjb25jZXB0IG9mIGEgXCJTaW1wbGVFdmVudFBsdWdpblwiLlxuLy8gVGhpcyBpcyB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0eSBvZiB0aGUgZXZlbnQgc3lzdGVtLiBBbGxcbi8vIHRoZSBvdGhlciBwbHVnaW5zIGFyZSBlc3NlbnRpYWxseSBwb2x5ZmlsbHMuIFNvIHRoZSBwbHVnaW5cbi8vIHNob3VsZCBwcm9iYWJseSBiZSBpbmxpbmVkIHNvbWV3aGVyZSBhbmQgaGF2ZSBpdHMgbG9naWNcbi8vIGJlIGNvcmUgdGhlIHRvIGV2ZW50IHN5c3RlbS4gVGhpcyB3b3VsZCBwb3RlbnRpYWxseSBhbGxvd1xuLy8gdXMgdG8gc2hpcCBidWlsZHMgb2YgUmVhY3Qgd2l0aG91dCB0aGUgcG9seWZpbGxlZCBwbHVnaW5zIGJlbG93LlxuZXh0cmFjdEV2ZW50cyQ0KGRpc3BhdGNoUXVldWUsZG9tRXZlbnROYW1lLHRhcmdldEluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQsZXZlbnRTeXN0ZW1GbGFncyk7dmFyIHNob3VsZFByb2Nlc3NQb2x5ZmlsbFBsdWdpbnM9KGV2ZW50U3lzdGVtRmxhZ3MmU0hPVUxEX05PVF9QUk9DRVNTX1BPTFlGSUxMX0VWRU5UX1BMVUdJTlMpPT09MDsvLyBXZSBkb24ndCBwcm9jZXNzIHRoZXNlIGV2ZW50cyB1bmxlc3Mgd2UgYXJlIGluIHRoZVxuLy8gZXZlbnQncyBuYXRpdmUgXCJidWJibGVcIiBwaGFzZSwgd2hpY2ggbWVhbnMgdGhhdCB3ZSdyZVxuLy8gbm90IGluIHRoZSBjYXB0dXJlIHBoYXNlLiBUaGF0J3MgYmVjYXVzZSB3ZSBlbXVsYXRlXG4vLyB0aGUgY2FwdHVyZSBwaGFzZSBoZXJlIHN0aWxsLiBUaGlzIGlzIGEgdHJhZGUtb2ZmLFxuLy8gYmVjYXVzZSBpbiBhbiBpZGVhbCB3b3JsZCB3ZSB3b3VsZCBub3QgZW11bGF0ZSBhbmQgdXNlXG4vLyB0aGUgcGhhc2VzIHByb3Blcmx5LCBsaWtlIHdlIGRvIHdpdGggdGhlIFNpbXBsZUV2ZW50XG4vLyBwbHVnaW4uIEhvd2V2ZXIsIHRoZSBwbHVnaW5zIGJlbG93IGVpdGhlciBleHBlY3Rcbi8vIGVtdWxhdGlvbiAoRW50ZXJMZWF2ZSkgb3IgdXNlIHN0YXRlIGxvY2FsaXplZCB0byB0aGF0XG4vLyBwbHVnaW4gKEJlZm9yZUlucHV0LCBDaGFuZ2UsIFNlbGVjdCkuIFRoZSBzdGF0ZSBpblxuLy8gdGhlc2UgbW9kdWxlcyBjb21wbGljYXRlcyB0aGluZ3MsIGFzIHlvdSdsbCBlc3NlbnRpYWxseVxuLy8gZ2V0IHRoZSBjYXNlIHdoZXJlIHRoZSBjYXB0dXJlIHBoYXNlIGV2ZW50IG1pZ2h0IGNoYW5nZVxuLy8gc3RhdGUsIG9ubHkgZm9yIHRoZSBmb2xsb3dpbmcgYnViYmxlIGV2ZW50IHRvIGNvbWUgaW5cbi8vIGxhdGVyIGFuZCBub3QgdHJpZ2dlciBhbnl0aGluZyBhcyB0aGUgc3RhdGUgbm93XG4vLyBpbnZhbGlkYXRlcyB0aGUgaGV1cmlzdGljcyBvZiB0aGUgZXZlbnQgcGx1Z2luLiBXZVxuLy8gY291bGQgYWx0ZXIgYWxsIHRoZXNlIHBsdWdpbnMgdG8gd29yayBpbiBzdWNoIHdheXMsIGJ1dFxuLy8gdGhhdCBtaWdodCBjYXVzZSBvdGhlciB1bmtub3duIHNpZGUtZWZmZWN0cyB0aGF0IHdlXG4vLyBjYW4ndCBmb3Jlc2VlIHJpZ2h0IG5vdy5cbmlmKHNob3VsZFByb2Nlc3NQb2x5ZmlsbFBsdWdpbnMpe2V4dHJhY3RFdmVudHMkMihkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTtleHRyYWN0RXZlbnRzJDEoZGlzcGF0Y2hRdWV1ZSxkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCk7ZXh0cmFjdEV2ZW50cyQzKGRpc3BhdGNoUXVldWUsZG9tRXZlbnROYW1lLHRhcmdldEluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpO2V4dHJhY3RFdmVudHMoZGlzcGF0Y2hRdWV1ZSxkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCk7fX0vLyBMaXN0IG9mIGV2ZW50cyB0aGF0IG5lZWQgdG8gYmUgaW5kaXZpZHVhbGx5IGF0dGFjaGVkIHRvIG1lZGlhIGVsZW1lbnRzLlxudmFyIG1lZGlhRXZlbnRUeXBlcz1bJ2Fib3J0JywnY2FucGxheScsJ2NhbnBsYXl0aHJvdWdoJywnZHVyYXRpb25jaGFuZ2UnLCdlbXB0aWVkJywnZW5jcnlwdGVkJywnZW5kZWQnLCdlcnJvcicsJ2xvYWRlZGRhdGEnLCdsb2FkZWRtZXRhZGF0YScsJ2xvYWRzdGFydCcsJ3BhdXNlJywncGxheScsJ3BsYXlpbmcnLCdwcm9ncmVzcycsJ3JhdGVjaGFuZ2UnLCdyZXNpemUnLCdzZWVrZWQnLCdzZWVraW5nJywnc3RhbGxlZCcsJ3N1c3BlbmQnLCd0aW1ldXBkYXRlJywndm9sdW1lY2hhbmdlJywnd2FpdGluZyddOy8vIFdlIHNob3VsZCBub3QgZGVsZWdhdGUgdGhlc2UgZXZlbnRzIHRvIHRoZSBjb250YWluZXIsIGJ1dCByYXRoZXJcbi8vIHNldCB0aGVtIG9uIHRoZSBhY3R1YWwgdGFyZ2V0IGVsZW1lbnQgaXRzZWxmLiBUaGlzIGlzIHByaW1hcmlseVxuLy8gYmVjYXVzZSB0aGVzZSBldmVudHMgZG8gbm90IGNvbnNpc3RlbnRseSBidWJibGUgaW4gdGhlIERPTS5cbnZhciBub25EZWxlZ2F0ZWRFdmVudHM9bmV3IFNldChbJ2NhbmNlbCcsJ2Nsb3NlJywnaW52YWxpZCcsJ2xvYWQnLCdzY3JvbGwnLCd0b2dnbGUnXS5jb25jYXQobWVkaWFFdmVudFR5cGVzKSk7ZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LGxpc3RlbmVyLGN1cnJlbnRUYXJnZXQpe3ZhciB0eXBlPWV2ZW50LnR5cGV8fCd1bmtub3duLWV2ZW50JztldmVudC5jdXJyZW50VGFyZ2V0PWN1cnJlbnRUYXJnZXQ7aW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKHR5cGUsbGlzdGVuZXIsdW5kZWZpbmVkLGV2ZW50KTtldmVudC5jdXJyZW50VGFyZ2V0PW51bGw7fWZ1bmN0aW9uIHByb2Nlc3NEaXNwYXRjaFF1ZXVlSXRlbXNJbk9yZGVyKGV2ZW50LGRpc3BhdGNoTGlzdGVuZXJzLGluQ2FwdHVyZVBoYXNlKXt2YXIgcHJldmlvdXNJbnN0YW5jZTtpZihpbkNhcHR1cmVQaGFzZSl7Zm9yKHZhciBpPWRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aC0xO2k+PTA7aS0tKXt2YXIgX2Rpc3BhdGNoTGlzdGVuZXJzJGk9ZGlzcGF0Y2hMaXN0ZW5lcnNbaV0saW5zdGFuY2U9X2Rpc3BhdGNoTGlzdGVuZXJzJGkuaW5zdGFuY2UsY3VycmVudFRhcmdldD1fZGlzcGF0Y2hMaXN0ZW5lcnMkaS5jdXJyZW50VGFyZ2V0LGxpc3RlbmVyPV9kaXNwYXRjaExpc3RlbmVycyRpLmxpc3RlbmVyO2lmKGluc3RhbmNlIT09cHJldmlvdXNJbnN0YW5jZSYmZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSl7cmV0dXJuO31leGVjdXRlRGlzcGF0Y2goZXZlbnQsbGlzdGVuZXIsY3VycmVudFRhcmdldCk7cHJldmlvdXNJbnN0YW5jZT1pbnN0YW5jZTt9fWVsc2V7Zm9yKHZhciBfaT0wO19pPGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDtfaSsrKXt2YXIgX2Rpc3BhdGNoTGlzdGVuZXJzJF9pPWRpc3BhdGNoTGlzdGVuZXJzW19pXSxfaW5zdGFuY2U9X2Rpc3BhdGNoTGlzdGVuZXJzJF9pLmluc3RhbmNlLF9jdXJyZW50VGFyZ2V0PV9kaXNwYXRjaExpc3RlbmVycyRfaS5jdXJyZW50VGFyZ2V0LF9saXN0ZW5lcj1fZGlzcGF0Y2hMaXN0ZW5lcnMkX2kubGlzdGVuZXI7aWYoX2luc3RhbmNlIT09cHJldmlvdXNJbnN0YW5jZSYmZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSl7cmV0dXJuO31leGVjdXRlRGlzcGF0Y2goZXZlbnQsX2xpc3RlbmVyLF9jdXJyZW50VGFyZ2V0KTtwcmV2aW91c0luc3RhbmNlPV9pbnN0YW5jZTt9fX1mdW5jdGlvbiBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLGV2ZW50U3lzdGVtRmxhZ3Mpe3ZhciBpbkNhcHR1cmVQaGFzZT0oZXZlbnRTeXN0ZW1GbGFncyZJU19DQVBUVVJFX1BIQVNFKSE9PTA7Zm9yKHZhciBpPTA7aTxkaXNwYXRjaFF1ZXVlLmxlbmd0aDtpKyspe3ZhciBfZGlzcGF0Y2hRdWV1ZSRpPWRpc3BhdGNoUXVldWVbaV0sZXZlbnQ9X2Rpc3BhdGNoUXVldWUkaS5ldmVudCxsaXN0ZW5lcnM9X2Rpc3BhdGNoUXVldWUkaS5saXN0ZW5lcnM7cHJvY2Vzc0Rpc3BhdGNoUXVldWVJdGVtc0luT3JkZXIoZXZlbnQsbGlzdGVuZXJzLGluQ2FwdHVyZVBoYXNlKTsvLyAgZXZlbnQgc3lzdGVtIGRvZXNuJ3QgdXNlIHBvb2xpbmcuXG59Ly8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG5yZXRocm93Q2F1Z2h0RXJyb3IoKTt9ZnVuY3Rpb24gZGlzcGF0Y2hFdmVudHNGb3JQbHVnaW5zKGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLG5hdGl2ZUV2ZW50LHRhcmdldEluc3QsdGFyZ2V0Q29udGFpbmVyKXt2YXIgbmF0aXZlRXZlbnRUYXJnZXQ9Z2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO3ZhciBkaXNwYXRjaFF1ZXVlPVtdO2V4dHJhY3RFdmVudHMkNShkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0LGV2ZW50U3lzdGVtRmxhZ3MpO3Byb2Nlc3NEaXNwYXRjaFF1ZXVlKGRpc3BhdGNoUXVldWUsZXZlbnRTeXN0ZW1GbGFncyk7fWZ1bmN0aW9uIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoZG9tRXZlbnROYW1lLHRhcmdldEVsZW1lbnQpe3tpZighbm9uRGVsZWdhdGVkRXZlbnRzLmhhcyhkb21FdmVudE5hbWUpKXtlcnJvcignRGlkIG5vdCBleHBlY3QgYSBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCkgY2FsbCBmb3IgXCIlc1wiLiAnKydUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLGRvbUV2ZW50TmFtZSk7fX12YXIgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcj1mYWxzZTt2YXIgbGlzdGVuZXJTZXQ9Z2V0RXZlbnRMaXN0ZW5lclNldCh0YXJnZXRFbGVtZW50KTt2YXIgbGlzdGVuZXJTZXRLZXk9Z2V0TGlzdGVuZXJTZXRLZXkoZG9tRXZlbnROYW1lLGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpO2lmKCFsaXN0ZW5lclNldC5oYXMobGlzdGVuZXJTZXRLZXkpKXthZGRUcmFwcGVkRXZlbnRMaXN0ZW5lcih0YXJnZXRFbGVtZW50LGRvbUV2ZW50TmFtZSxJU19OT05fREVMRUdBVEVELGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpO2xpc3RlbmVyU2V0LmFkZChsaXN0ZW5lclNldEtleSk7fX1mdW5jdGlvbiBsaXN0ZW5Ub05hdGl2ZUV2ZW50KGRvbUV2ZW50TmFtZSxpc0NhcHR1cmVQaGFzZUxpc3RlbmVyLHRhcmdldCl7e2lmKG5vbkRlbGVnYXRlZEV2ZW50cy5oYXMoZG9tRXZlbnROYW1lKSYmIWlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpe2Vycm9yKCdEaWQgbm90IGV4cGVjdCBhIGxpc3RlblRvTmF0aXZlRXZlbnQoKSBjYWxsIGZvciBcIiVzXCIgaW4gdGhlIGJ1YmJsZSBwaGFzZS4gJysnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxkb21FdmVudE5hbWUpO319dmFyIGV2ZW50U3lzdGVtRmxhZ3M9MDtpZihpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKXtldmVudFN5c3RlbUZsYWdzfD1JU19DQVBUVVJFX1BIQVNFO31hZGRUcmFwcGVkRXZlbnRMaXN0ZW5lcih0YXJnZXQsZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcik7fS8vIFRoaXMgaXMgb25seSB1c2VkIGJ5IGNyZWF0ZUV2ZW50SGFuZGxlIHdoZW4gdGhlXG52YXIgbGlzdGVuaW5nTWFya2VyPSdfcmVhY3RMaXN0ZW5pbmcnK01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO2Z1bmN0aW9uIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHJvb3RDb250YWluZXJFbGVtZW50KXtpZighcm9vdENvbnRhaW5lckVsZW1lbnRbbGlzdGVuaW5nTWFya2VyXSl7cm9vdENvbnRhaW5lckVsZW1lbnRbbGlzdGVuaW5nTWFya2VyXT10cnVlO2FsbE5hdGl2ZUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGRvbUV2ZW50TmFtZSl7Ly8gV2UgaGFuZGxlIHNlbGVjdGlvbmNoYW5nZSBzZXBhcmF0ZWx5IGJlY2F1c2UgaXRcbi8vIGRvZXNuJ3QgYnViYmxlIGFuZCBuZWVkcyB0byBiZSBvbiB0aGUgZG9jdW1lbnQuXG5pZihkb21FdmVudE5hbWUhPT0nc2VsZWN0aW9uY2hhbmdlJyl7aWYoIW5vbkRlbGVnYXRlZEV2ZW50cy5oYXMoZG9tRXZlbnROYW1lKSl7bGlzdGVuVG9OYXRpdmVFdmVudChkb21FdmVudE5hbWUsZmFsc2Uscm9vdENvbnRhaW5lckVsZW1lbnQpO31saXN0ZW5Ub05hdGl2ZUV2ZW50KGRvbUV2ZW50TmFtZSx0cnVlLHJvb3RDb250YWluZXJFbGVtZW50KTt9fSk7dmFyIG93bmVyRG9jdW1lbnQ9cm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGU9PT1ET0NVTUVOVF9OT0RFP3Jvb3RDb250YWluZXJFbGVtZW50OnJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7aWYob3duZXJEb2N1bWVudCE9PW51bGwpey8vIFRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQgYWxzbyBuZWVkcyBkZWR1cGxpY2F0aW9uXG4vLyBidXQgaXQgaXMgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LlxuaWYoIW93bmVyRG9jdW1lbnRbbGlzdGVuaW5nTWFya2VyXSl7b3duZXJEb2N1bWVudFtsaXN0ZW5pbmdNYXJrZXJdPXRydWU7bGlzdGVuVG9OYXRpdmVFdmVudCgnc2VsZWN0aW9uY2hhbmdlJyxmYWxzZSxvd25lckRvY3VtZW50KTt9fX19ZnVuY3Rpb24gYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIodGFyZ2V0Q29udGFpbmVyLGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIsaXNEZWZlcnJlZExpc3RlbmVyRm9yTGVnYWN5RkJTdXBwb3J0KXt2YXIgbGlzdGVuZXI9Y3JlYXRlRXZlbnRMaXN0ZW5lcldyYXBwZXJXaXRoUHJpb3JpdHkodGFyZ2V0Q29udGFpbmVyLGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzKTsvLyBJZiBwYXNzaXZlIG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkLCB0aGVuIHRoZSBldmVudCB3aWxsIGJlXG4vLyBhY3RpdmUgYW5kIG5vdCBwYXNzaXZlLlxudmFyIGlzUGFzc2l2ZUxpc3RlbmVyPXVuZGVmaW5lZDtpZihwYXNzaXZlQnJvd3NlckV2ZW50c1N1cHBvcnRlZCl7Ly8gQnJvd3NlcnMgaW50cm9kdWNlZCBhbiBpbnRlcnZlbnRpb24sIG1ha2luZyB0aGVzZSBldmVudHNcbi8vIHBhc3NpdmUgYnkgZGVmYXVsdCBvbiBkb2N1bWVudC4gUmVhY3QgZG9lc24ndCBiaW5kIHRoZW1cbi8vIHRvIGRvY3VtZW50IGFueW1vcmUsIGJ1dCBjaGFuZ2luZyB0aGlzIG5vdyB3b3VsZCB1bmRvXG4vLyB0aGUgcGVyZm9ybWFuY2Ugd2lucyBmcm9tIHRoZSBjaGFuZ2UuIFNvIHdlIGVtdWxhdGVcbi8vIHRoZSBleGlzdGluZyBiZWhhdmlvciBtYW51YWxseSBvbiB0aGUgcm9vdHMgbm93LlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTY1MVxuaWYoZG9tRXZlbnROYW1lPT09J3RvdWNoc3RhcnQnfHxkb21FdmVudE5hbWU9PT0ndG91Y2htb3ZlJ3x8ZG9tRXZlbnROYW1lPT09J3doZWVsJyl7aXNQYXNzaXZlTGlzdGVuZXI9dHJ1ZTt9fXRhcmdldENvbnRhaW5lcj10YXJnZXRDb250YWluZXI7dmFyIHVuc3Vic2NyaWJlTGlzdGVuZXI7Ly8gV2hlbiBsZWdhY3lGQlN1cHBvcnQgaXMgZW5hYmxlZCwgaXQncyBmb3Igd2hlbiB3ZVxuaWYoaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcil7aWYoaXNQYXNzaXZlTGlzdGVuZXIhPT11bmRlZmluZWQpe3Vuc3Vic2NyaWJlTGlzdGVuZXI9YWRkRXZlbnRDYXB0dXJlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0Q29udGFpbmVyLGRvbUV2ZW50TmFtZSxsaXN0ZW5lcixpc1Bhc3NpdmVMaXN0ZW5lcik7fWVsc2V7dW5zdWJzY3JpYmVMaXN0ZW5lcj1hZGRFdmVudENhcHR1cmVMaXN0ZW5lcih0YXJnZXRDb250YWluZXIsZG9tRXZlbnROYW1lLGxpc3RlbmVyKTt9fWVsc2V7aWYoaXNQYXNzaXZlTGlzdGVuZXIhPT11bmRlZmluZWQpe3Vuc3Vic2NyaWJlTGlzdGVuZXI9YWRkRXZlbnRCdWJibGVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyh0YXJnZXRDb250YWluZXIsZG9tRXZlbnROYW1lLGxpc3RlbmVyLGlzUGFzc2l2ZUxpc3RlbmVyKTt9ZWxzZXt1bnN1YnNjcmliZUxpc3RlbmVyPWFkZEV2ZW50QnViYmxlTGlzdGVuZXIodGFyZ2V0Q29udGFpbmVyLGRvbUV2ZW50TmFtZSxsaXN0ZW5lcik7fX19ZnVuY3Rpb24gaXNNYXRjaGluZ1Jvb3RDb250YWluZXIoZ3JhbmRDb250YWluZXIsdGFyZ2V0Q29udGFpbmVyKXtyZXR1cm4gZ3JhbmRDb250YWluZXI9PT10YXJnZXRDb250YWluZXJ8fGdyYW5kQ29udGFpbmVyLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFJiZncmFuZENvbnRhaW5lci5wYXJlbnROb2RlPT09dGFyZ2V0Q29udGFpbmVyO31mdW5jdGlvbiBkaXNwYXRjaEV2ZW50Rm9yUGx1Z2luRXZlbnRTeXN0ZW0oZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsbmF0aXZlRXZlbnQsdGFyZ2V0SW5zdCx0YXJnZXRDb250YWluZXIpe3ZhciBhbmNlc3Rvckluc3Q9dGFyZ2V0SW5zdDtpZigoZXZlbnRTeXN0ZW1GbGFncyZJU19FVkVOVF9IQU5ETEVfTk9OX01BTkFHRURfTk9ERSk9PT0wJiYoZXZlbnRTeXN0ZW1GbGFncyZJU19OT05fREVMRUdBVEVEKT09PTApe3ZhciB0YXJnZXRDb250YWluZXJOb2RlPXRhcmdldENvbnRhaW5lcjsvLyBJZiB3ZSBhcmUgdXNpbmcgdGhlIGxlZ2FjeSBGQiBzdXBwb3J0IGZsYWcsIHdlXG5pZih0YXJnZXRJbnN0IT09bnVsbCl7Ly8gVGhlIGJlbG93IGxvZ2ljIGF0dGVtcHRzIHRvIHdvcmsgb3V0IGlmIHdlIG5lZWQgdG8gY2hhbmdlXG4vLyB0aGUgdGFyZ2V0IGZpYmVyIHRvIGEgZGlmZmVyZW50IGFuY2VzdG9yLiBXZSBoYWQgc2ltaWxhciBsb2dpY1xuLy8gaW4gdGhlIGxlZ2FjeSBldmVudCBzeXN0ZW0sIGV4Y2VwdCB0aGUgYmlnIGRpZmZlcmVuY2UgYmV0d2VlblxuLy8gc3lzdGVtcyBpcyB0aGF0IHRoZSBtb2Rlcm4gZXZlbnQgc3lzdGVtIG5vdyBoYXMgYW4gZXZlbnQgbGlzdGVuZXJcbi8vIGF0dGFjaGVkIHRvIGVhY2ggUmVhY3QgUm9vdCBhbmQgUmVhY3QgUG9ydGFsIFJvb3QuIFRvZ2V0aGVyLFxuLy8gdGhlIERPTSBub2RlcyByZXByZXNlbnRpbmcgdGhlc2Ugcm9vdHMgYXJlIHRoZSBcInJvb3RDb250YWluZXJcIi5cbi8vIFRvIGZpZ3VyZSBvdXQgd2hpY2ggYW5jZXN0b3IgaW5zdGFuY2Ugd2Ugc2hvdWxkIHVzZSwgd2UgdHJhdmVyc2Vcbi8vIHVwIHRoZSBmaWJlciB0cmVlIGZyb20gdGhlIHRhcmdldCBpbnN0YW5jZSBhbmQgYXR0ZW1wdCB0byBmaW5kXG4vLyByb290IGJvdW5kYXJpZXMgdGhhdCBtYXRjaCB0aGF0IG9mIG91ciBjdXJyZW50IFwicm9vdENvbnRhaW5lclwiLlxuLy8gSWYgd2UgZmluZCB0aGF0IFwicm9vdENvbnRhaW5lclwiLCB3ZSBmaW5kIHRoZSBwYXJlbnQgZmliZXJcbi8vIHN1Yi10cmVlIGZvciB0aGF0IHJvb3QgYW5kIG1ha2UgdGhhdCBvdXIgYW5jZXN0b3IgaW5zdGFuY2UuXG52YXIgbm9kZT10YXJnZXRJbnN0O21haW5Mb29wOndoaWxlKHRydWUpe2lmKG5vZGU9PT1udWxsKXtyZXR1cm47fXZhciBub2RlVGFnPW5vZGUudGFnO2lmKG5vZGVUYWc9PT1Ib3N0Um9vdHx8bm9kZVRhZz09PUhvc3RQb3J0YWwpe3ZhciBjb250YWluZXI9bm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztpZihpc01hdGNoaW5nUm9vdENvbnRhaW5lcihjb250YWluZXIsdGFyZ2V0Q29udGFpbmVyTm9kZSkpe2JyZWFrO31pZihub2RlVGFnPT09SG9zdFBvcnRhbCl7Ly8gVGhlIHRhcmdldCBpcyBhIHBvcnRhbCwgYnV0IGl0J3Mgbm90IHRoZSByb290Q29udGFpbmVyIHdlJ3JlIGxvb2tpbmcgZm9yLlxuLy8gTm9ybWFsbHkgcG9ydGFscyBoYW5kbGUgdGhlaXIgb3duIGV2ZW50cyBhbGwgdGhlIHdheSBkb3duIHRvIHRoZSByb290LlxuLy8gU28gd2Ugc2hvdWxkIGJlIGFibGUgdG8gc3RvcCBub3cuIEhvd2V2ZXIsIHdlIGRvbid0IGtub3cgaWYgdGhpcyBwb3J0YWxcbi8vIHdhcyBwYXJ0IG9mICpvdXIqIHJvb3QuXG52YXIgZ3JhbmROb2RlPW5vZGUucmV0dXJuO3doaWxlKGdyYW5kTm9kZSE9PW51bGwpe3ZhciBncmFuZFRhZz1ncmFuZE5vZGUudGFnO2lmKGdyYW5kVGFnPT09SG9zdFJvb3R8fGdyYW5kVGFnPT09SG9zdFBvcnRhbCl7dmFyIGdyYW5kQ29udGFpbmVyPWdyYW5kTm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztpZihpc01hdGNoaW5nUm9vdENvbnRhaW5lcihncmFuZENvbnRhaW5lcix0YXJnZXRDb250YWluZXJOb2RlKSl7Ly8gVGhpcyBpcyB0aGUgcm9vdENvbnRhaW5lciB3ZSdyZSBsb29raW5nIGZvciBhbmQgd2UgZm91bmQgaXQgYXNcbi8vIGEgcGFyZW50IG9mIHRoZSBQb3J0YWwuIFRoYXQgbWVhbnMgd2UgY2FuIGlnbm9yZSBpdCBiZWNhdXNlIHRoZVxuLy8gUG9ydGFsIHdpbGwgYnViYmxlIHRocm91Z2ggdG8gdXMuXG5yZXR1cm47fX1ncmFuZE5vZGU9Z3JhbmROb2RlLnJldHVybjt9fS8vIE5vdyB3ZSBuZWVkIHRvIGZpbmQgaXQncyBjb3JyZXNwb25kaW5nIGhvc3QgZmliZXIgaW4gdGhlIG90aGVyXG4vLyB0cmVlLiBUbyBkbyB0aGlzIHdlIGNhbiB1c2UgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsIGJ1dCB3ZVxuLy8gbmVlZCB0byB2YWxpZGF0ZSB0aGF0IHRoZSBmaWJlciBpcyBhIGhvc3QgaW5zdGFuY2UsIG90aGVyd2lzZVxuLy8gd2UgbmVlZCB0byB0cmF2ZXJzZSB1cCB0aHJvdWdoIHRoZSBET00gdGlsbCB3ZSBmaW5kIHRoZSBjb3JyZWN0XG4vLyBub2RlIHRoYXQgaXMgZnJvbSB0aGUgb3RoZXIgdHJlZS5cbndoaWxlKGNvbnRhaW5lciE9PW51bGwpe3ZhciBwYXJlbnROb2RlPWdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lcik7aWYocGFyZW50Tm9kZT09PW51bGwpe3JldHVybjt9dmFyIHBhcmVudFRhZz1wYXJlbnROb2RlLnRhZztpZihwYXJlbnRUYWc9PT1Ib3N0Q29tcG9uZW50fHxwYXJlbnRUYWc9PT1Ib3N0VGV4dCl7bm9kZT1hbmNlc3Rvckluc3Q9cGFyZW50Tm9kZTtjb250aW51ZSBtYWluTG9vcDt9Y29udGFpbmVyPWNvbnRhaW5lci5wYXJlbnROb2RlO319bm9kZT1ub2RlLnJldHVybjt9fX1iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbigpe3JldHVybiBkaXNwYXRjaEV2ZW50c0ZvclBsdWdpbnMoZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsbmF0aXZlRXZlbnQsYW5jZXN0b3JJbnN0KTt9KTt9ZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSxsaXN0ZW5lcixjdXJyZW50VGFyZ2V0KXtyZXR1cm57aW5zdGFuY2U6aW5zdGFuY2UsbGlzdGVuZXI6bGlzdGVuZXIsY3VycmVudFRhcmdldDpjdXJyZW50VGFyZ2V0fTt9ZnVuY3Rpb24gYWNjdW11bGF0ZVNpbmdsZVBoYXNlTGlzdGVuZXJzKHRhcmdldEZpYmVyLHJlYWN0TmFtZSxuYXRpdmVFdmVudFR5cGUsaW5DYXB0dXJlUGhhc2UsYWNjdW11bGF0ZVRhcmdldE9ubHksbmF0aXZlRXZlbnQpe3ZhciBjYXB0dXJlTmFtZT1yZWFjdE5hbWUhPT1udWxsP3JlYWN0TmFtZSsnQ2FwdHVyZSc6bnVsbDt2YXIgcmVhY3RFdmVudE5hbWU9aW5DYXB0dXJlUGhhc2U/Y2FwdHVyZU5hbWU6cmVhY3ROYW1lO3ZhciBsaXN0ZW5lcnM9W107dmFyIGluc3RhbmNlPXRhcmdldEZpYmVyO3ZhciBsYXN0SG9zdENvbXBvbmVudD1udWxsOy8vIEFjY3VtdWxhdGUgYWxsIGluc3RhbmNlcyBhbmQgbGlzdGVuZXJzIHZpYSB0aGUgdGFyZ2V0IC0+IHJvb3QgcGF0aC5cbndoaWxlKGluc3RhbmNlIT09bnVsbCl7dmFyIF9pbnN0YW5jZTI9aW5zdGFuY2Usc3RhdGVOb2RlPV9pbnN0YW5jZTIuc3RhdGVOb2RlLHRhZz1faW5zdGFuY2UyLnRhZzsvLyBIYW5kbGUgbGlzdGVuZXJzIHRoYXQgYXJlIG9uIEhvc3RDb21wb25lbnRzIChpLmUuIDxkaXY+KVxuaWYodGFnPT09SG9zdENvbXBvbmVudCYmc3RhdGVOb2RlIT09bnVsbCl7bGFzdEhvc3RDb21wb25lbnQ9c3RhdGVOb2RlOy8vIGNyZWF0ZUV2ZW50SGFuZGxlIGxpc3RlbmVyc1xuaWYocmVhY3RFdmVudE5hbWUhPT1udWxsKXt2YXIgbGlzdGVuZXI9Z2V0TGlzdGVuZXIoaW5zdGFuY2UscmVhY3RFdmVudE5hbWUpO2lmKGxpc3RlbmVyIT1udWxsKXtsaXN0ZW5lcnMucHVzaChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLGxpc3RlbmVyLGxhc3RIb3N0Q29tcG9uZW50KSk7fX19Ly8gSWYgd2UgYXJlIG9ubHkgYWNjdW11bGF0aW5nIGV2ZW50cyBmb3IgdGhlIHRhcmdldCwgdGhlbiB3ZSBkb24ndFxuLy8gY29udGludWUgdG8gcHJvcGFnYXRlIHRocm91Z2ggdGhlIFJlYWN0IGZpYmVyIHRyZWUgdG8gZmluZCBvdGhlclxuLy8gbGlzdGVuZXJzLlxuaWYoYWNjdW11bGF0ZVRhcmdldE9ubHkpe2JyZWFrO30vLyBJZiB3ZSBhcmUgcHJvY2Vzc2luZyB0aGUgb25CZWZvcmVCbHVyIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gdGFrZVxuaW5zdGFuY2U9aW5zdGFuY2UucmV0dXJuO31yZXR1cm4gbGlzdGVuZXJzO30vLyBXZSBzaG91bGQgb25seSB1c2UgdGhpcyBmdW5jdGlvbiBmb3I6XG4vLyAtIEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbi8vIC0gQ2hhbmdlRXZlbnRQbHVnaW5cbi8vIC0gU2VsZWN0RXZlbnRQbHVnaW5cbi8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBvbmx5IHByb2Nlc3MgdGhlc2UgcGx1Z2luc1xuLy8gaW4gdGhlIGJ1YmJsZSBwaGFzZSwgc28gd2UgbmVlZCB0byBhY2N1bXVsYXRlIHR3b1xuLy8gcGhhc2UgZXZlbnQgbGlzdGVuZXJzICh2aWEgZW11bGF0aW9uKS5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyh0YXJnZXRGaWJlcixyZWFjdE5hbWUpe3ZhciBjYXB0dXJlTmFtZT1yZWFjdE5hbWUrJ0NhcHR1cmUnO3ZhciBsaXN0ZW5lcnM9W107dmFyIGluc3RhbmNlPXRhcmdldEZpYmVyOy8vIEFjY3VtdWxhdGUgYWxsIGluc3RhbmNlcyBhbmQgbGlzdGVuZXJzIHZpYSB0aGUgdGFyZ2V0IC0+IHJvb3QgcGF0aC5cbndoaWxlKGluc3RhbmNlIT09bnVsbCl7dmFyIF9pbnN0YW5jZTM9aW5zdGFuY2Usc3RhdGVOb2RlPV9pbnN0YW5jZTMuc3RhdGVOb2RlLHRhZz1faW5zdGFuY2UzLnRhZzsvLyBIYW5kbGUgbGlzdGVuZXJzIHRoYXQgYXJlIG9uIEhvc3RDb21wb25lbnRzIChpLmUuIDxkaXY+KVxuaWYodGFnPT09SG9zdENvbXBvbmVudCYmc3RhdGVOb2RlIT09bnVsbCl7dmFyIGN1cnJlbnRUYXJnZXQ9c3RhdGVOb2RlO3ZhciBjYXB0dXJlTGlzdGVuZXI9Z2V0TGlzdGVuZXIoaW5zdGFuY2UsY2FwdHVyZU5hbWUpO2lmKGNhcHR1cmVMaXN0ZW5lciE9bnVsbCl7bGlzdGVuZXJzLnVuc2hpZnQoY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSxjYXB0dXJlTGlzdGVuZXIsY3VycmVudFRhcmdldCkpO312YXIgYnViYmxlTGlzdGVuZXI9Z2V0TGlzdGVuZXIoaW5zdGFuY2UscmVhY3ROYW1lKTtpZihidWJibGVMaXN0ZW5lciE9bnVsbCl7bGlzdGVuZXJzLnB1c2goY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSxidWJibGVMaXN0ZW5lcixjdXJyZW50VGFyZ2V0KSk7fX1pbnN0YW5jZT1pbnN0YW5jZS5yZXR1cm47fXJldHVybiBsaXN0ZW5lcnM7fWZ1bmN0aW9uIGdldFBhcmVudChpbnN0KXtpZihpbnN0PT09bnVsbCl7cmV0dXJuIG51bGw7fWRve2luc3Q9aW5zdC5yZXR1cm47Ly8gVE9ETzogSWYgdGhpcyBpcyBhIEhvc3RSb290IHdlIG1pZ2h0IHdhbnQgdG8gYmFpbCBvdXQuXG4vLyBUaGF0IGlzIGRlcGVuZGluZyBvbiBpZiB3ZSB3YW50IG5lc3RlZCBzdWJ0cmVlcyAobGF5ZXJzKSB0byBidWJibGVcbi8vIGV2ZW50cyB0byB0aGVpciBwYXJlbnQuIFdlIGNvdWxkIGFsc28gZ28gdGhyb3VnaCBwYXJlbnROb2RlIG9uIHRoZVxuLy8gaG9zdCBub2RlIGJ1dCB0aGF0IHdvdWxkbid0IHdvcmsgZm9yIFJlYWN0IE5hdGl2ZSBhbmQgZG9lc24ndCBsZXQgdXNcbi8vIGRvIHRoZSBwb3J0YWwgZmVhdHVyZS5cbn13aGlsZShpbnN0JiZpbnN0LnRhZyE9PUhvc3RDb21wb25lbnQpO2lmKGluc3Qpe3JldHVybiBpbnN0O31yZXR1cm4gbnVsbDt9LyoqXG4gKiBSZXR1cm4gdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3Igb2YgQSBhbmQgQiwgb3IgbnVsbCBpZiB0aGV5IGFyZSBpblxuICogZGlmZmVyZW50IHRyZWVzLlxuICovZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsaW5zdEIpe3ZhciBub2RlQT1pbnN0QTt2YXIgbm9kZUI9aW5zdEI7dmFyIGRlcHRoQT0wO2Zvcih2YXIgdGVtcEE9bm9kZUE7dGVtcEE7dGVtcEE9Z2V0UGFyZW50KHRlbXBBKSl7ZGVwdGhBKys7fXZhciBkZXB0aEI9MDtmb3IodmFyIHRlbXBCPW5vZGVCO3RlbXBCO3RlbXBCPWdldFBhcmVudCh0ZW1wQikpe2RlcHRoQisrO30vLyBJZiBBIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG53aGlsZShkZXB0aEEtZGVwdGhCPjApe25vZGVBPWdldFBhcmVudChub2RlQSk7ZGVwdGhBLS07fS8vIElmIEIgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbndoaWxlKGRlcHRoQi1kZXB0aEE+MCl7bm9kZUI9Z2V0UGFyZW50KG5vZGVCKTtkZXB0aEItLTt9Ly8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG52YXIgZGVwdGg9ZGVwdGhBO3doaWxlKGRlcHRoLS0pe2lmKG5vZGVBPT09bm9kZUJ8fG5vZGVCIT09bnVsbCYmbm9kZUE9PT1ub2RlQi5hbHRlcm5hdGUpe3JldHVybiBub2RlQTt9bm9kZUE9Z2V0UGFyZW50KG5vZGVBKTtub2RlQj1nZXRQYXJlbnQobm9kZUIpO31yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLGV2ZW50LHRhcmdldCxjb21tb24saW5DYXB0dXJlUGhhc2Upe3ZhciByZWdpc3RyYXRpb25OYW1lPWV2ZW50Ll9yZWFjdE5hbWU7dmFyIGxpc3RlbmVycz1bXTt2YXIgaW5zdGFuY2U9dGFyZ2V0O3doaWxlKGluc3RhbmNlIT09bnVsbCl7aWYoaW5zdGFuY2U9PT1jb21tb24pe2JyZWFrO312YXIgX2luc3RhbmNlND1pbnN0YW5jZSxhbHRlcm5hdGU9X2luc3RhbmNlNC5hbHRlcm5hdGUsc3RhdGVOb2RlPV9pbnN0YW5jZTQuc3RhdGVOb2RlLHRhZz1faW5zdGFuY2U0LnRhZztpZihhbHRlcm5hdGUhPT1udWxsJiZhbHRlcm5hdGU9PT1jb21tb24pe2JyZWFrO31pZih0YWc9PT1Ib3N0Q29tcG9uZW50JiZzdGF0ZU5vZGUhPT1udWxsKXt2YXIgY3VycmVudFRhcmdldD1zdGF0ZU5vZGU7aWYoaW5DYXB0dXJlUGhhc2Upe3ZhciBjYXB0dXJlTGlzdGVuZXI9Z2V0TGlzdGVuZXIoaW5zdGFuY2UscmVnaXN0cmF0aW9uTmFtZSk7aWYoY2FwdHVyZUxpc3RlbmVyIT1udWxsKXtsaXN0ZW5lcnMudW5zaGlmdChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLGNhcHR1cmVMaXN0ZW5lcixjdXJyZW50VGFyZ2V0KSk7fX1lbHNlIGlmKCFpbkNhcHR1cmVQaGFzZSl7dmFyIGJ1YmJsZUxpc3RlbmVyPWdldExpc3RlbmVyKGluc3RhbmNlLHJlZ2lzdHJhdGlvbk5hbWUpO2lmKGJ1YmJsZUxpc3RlbmVyIT1udWxsKXtsaXN0ZW5lcnMucHVzaChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLGJ1YmJsZUxpc3RlbmVyLGN1cnJlbnRUYXJnZXQpKTt9fX1pbnN0YW5jZT1pbnN0YW5jZS5yZXR1cm47fWlmKGxpc3RlbmVycy5sZW5ndGghPT0wKXtkaXNwYXRjaFF1ZXVlLnB1c2goe2V2ZW50OmV2ZW50LGxpc3RlbmVyczpsaXN0ZW5lcnN9KTt9fS8vIFdlIHNob3VsZCBvbmx5IHVzZSB0aGlzIGZ1bmN0aW9uIGZvcjpcbi8vIC0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luXG4vLyBUaGlzIGlzIGJlY2F1c2Ugd2Ugb25seSBwcm9jZXNzIHRoaXMgcGx1Z2luXG4vLyBpbiB0aGUgYnViYmxlIHBoYXNlLCBzbyB3ZSBuZWVkIHRvIGFjY3VtdWxhdGUgdHdvXG4vLyBwaGFzZSBldmVudCBsaXN0ZW5lcnMuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZVR3b1BoYXNlTGlzdGVuZXJzKGRpc3BhdGNoUXVldWUsbGVhdmVFdmVudCxlbnRlckV2ZW50LGZyb20sdG8pe3ZhciBjb21tb249ZnJvbSYmdG8/Z2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSx0byk6bnVsbDtpZihmcm9tIT09bnVsbCl7YWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLGxlYXZlRXZlbnQsZnJvbSxjb21tb24sZmFsc2UpO31pZih0byE9PW51bGwmJmVudGVyRXZlbnQhPT1udWxsKXthY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50KGRpc3BhdGNoUXVldWUsZW50ZXJFdmVudCx0byxjb21tb24sdHJ1ZSk7fX1mdW5jdGlvbiBnZXRMaXN0ZW5lclNldEtleShkb21FdmVudE5hbWUsY2FwdHVyZSl7cmV0dXJuIGRvbUV2ZW50TmFtZStcIl9fXCIrKGNhcHR1cmU/J2NhcHR1cmUnOididWJibGUnKTt9dmFyIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uPWZhbHNlO3ZhciBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTD0nZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO3ZhciBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkc9J3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc7dmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HPSdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO3ZhciBBVVRPRk9DVVM9J2F1dG9Gb2N1cyc7dmFyIENISUxEUkVOPSdjaGlsZHJlbic7dmFyIFNUWUxFPSdzdHlsZSc7dmFyIEhUTUwkMT0nX19odG1sJzt2YXIgd2FybmVkVW5rbm93blRhZ3M7dmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQ7dmFyIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZTt2YXIgd2FybkZvckV4dHJhQXR0cmlidXRlczt2YXIgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyO3ZhciBjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nO3ZhciBub3JtYWxpemVIVE1MO3t3YXJuZWRVbmtub3duVGFncz17Ly8gVGhlcmUgYXJlIHdvcmtpbmcgcG9seWZpbGxzIGZvciA8ZGlhbG9nPi4gTGV0IHBlb3BsZSB1c2UgaXQuXG5kaWFsb2c6dHJ1ZSwvLyBFbGVjdHJvbiBzaGlwcyBhIGN1c3RvbSA8d2Vidmlldz4gdGFnIHRvIGRpc3BsYXkgZXh0ZXJuYWwgd2ViIGNvbnRlbnQgaW5cbi8vIGFuIGlzb2xhdGVkIGZyYW1lIGFuZCBwcm9jZXNzLlxuLy8gVGhpcyB0YWcgaXMgbm90IHByZXNlbnQgaW4gbm9uIEVsZWN0cm9uIGVudmlyb25tZW50cyBzdWNoIGFzIEpTRG9tIHdoaWNoXG4vLyBpcyBvZnRlbiB1c2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuLy8gQHNlZSBodHRwczovL2VsZWN0cm9uanMub3JnL2RvY3MvYXBpL3dlYnZpZXctdGFnXG53ZWJ2aWV3OnRydWV9O3ZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQ9ZnVuY3Rpb24odHlwZSxwcm9wcyl7dmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUscHJvcHMpO3ZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUscHJvcHMpO3ZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUscHJvcHMse3JlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6cmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzOnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXN9KTt9Oy8vIElFIDExIHBhcnNlcyAmIG5vcm1hbGl6ZXMgdGhlIHN0eWxlIGF0dHJpYnV0ZSBhcyBvcHBvc2VkIHRvIG90aGVyXG4vLyBicm93c2Vycy4gSXQgYWRkcyBzcGFjZXMgYW5kIHNvcnRzIHRoZSBwcm9wZXJ0aWVzIGluIHNvbWVcbi8vIG5vbi1hbHBoYWJldGljYWwgb3JkZXIuIEhhbmRsaW5nIHRoYXQgd291bGQgcmVxdWlyZSBzb3J0aW5nIENTU1xuLy8gcHJvcGVydGllcyBpbiB0aGUgY2xpZW50ICYgc2VydmVyIHZlcnNpb25zIG9yIGFwcGx5aW5nXG4vLyBgZXhwZWN0ZWRTdHlsZWAgdG8gYSB0ZW1wb3JhcnkgRE9NIG5vZGUgdG8gcmVhZCBpdHMgYHN0eWxlYCBhdHRyaWJ1dGVcbi8vIG5vcm1hbGl6ZWQuIFNpbmNlIGl0IG9ubHkgYWZmZWN0cyBJRSwgd2UncmUgc2tpcHBpbmcgc3R5bGUgd2FybmluZ3Ncbi8vIGluIHRoYXQgYnJvd3NlciBjb21wbGV0ZWx5IGluIGZhdm9yIG9mIGRvaW5nIGFsbCB0aGF0IHdvcmsuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTgwN1xuY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZz1jYW5Vc2VET00mJiFkb2N1bWVudC5kb2N1bWVudE1vZGU7d2FybkZvclByb3BEaWZmZXJlbmNlPWZ1bmN0aW9uKHByb3BOYW1lLHNlcnZlclZhbHVlLGNsaWVudFZhbHVlKXtpZihkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbil7cmV0dXJuO312YXIgbm9ybWFsaXplZENsaWVudFZhbHVlPW5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSk7dmFyIG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZT1ub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVmFsdWUpO2lmKG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZT09PW5vcm1hbGl6ZWRDbGllbnRWYWx1ZSl7cmV0dXJuO31kaWRXYXJuSW52YWxpZEh5ZHJhdGlvbj10cnVlO2Vycm9yKCdQcm9wIGAlc2AgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiAlcyBDbGllbnQ6ICVzJyxwcm9wTmFtZSxKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkpO307d2FybkZvckV4dHJhQXR0cmlidXRlcz1mdW5jdGlvbihhdHRyaWJ1dGVOYW1lcyl7aWYoZGlkV2FybkludmFsaWRIeWRyYXRpb24pe3JldHVybjt9ZGlkV2FybkludmFsaWRIeWRyYXRpb249dHJ1ZTt2YXIgbmFtZXM9W107YXR0cmlidXRlTmFtZXMuZm9yRWFjaChmdW5jdGlvbihuYW1lKXtuYW1lcy5wdXNoKG5hbWUpO30pO2Vycm9yKCdFeHRyYSBhdHRyaWJ1dGVzIGZyb20gdGhlIHNlcnZlcjogJXMnLG5hbWVzKTt9O3dhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihyZWdpc3RyYXRpb25OYW1lLGxpc3RlbmVyKXtpZihsaXN0ZW5lcj09PWZhbHNlKXtlcnJvcignRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBgZmFsc2VgLlxcblxcbicrJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnKydwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLHJlZ2lzdHJhdGlvbk5hbWUscmVnaXN0cmF0aW9uTmFtZSxyZWdpc3RyYXRpb25OYW1lKTt9ZWxzZXtlcnJvcignRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4nLHJlZ2lzdHJhdGlvbk5hbWUsdHlwZW9mIGxpc3RlbmVyKTt9fTsvLyBQYXJzZSB0aGUgSFRNTCBhbmQgcmVhZCBpdCBiYWNrIHRvIG5vcm1hbGl6ZSB0aGUgSFRNTCBzdHJpbmcgc28gdGhhdCBpdFxuLy8gY2FuIGJlIHVzZWQgZm9yIGNvbXBhcmlzb24uXG5ub3JtYWxpemVIVE1MPWZ1bmN0aW9uKHBhcmVudCxodG1sKXsvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4vLyByZS1pbml0aWFsaXppbmcgY3VzdG9tIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3QuIEJ1dCB0aGlzIGJyZWFrc1xuLy8gaG93IDxub3NjcmlwdD4gaXMgYmVpbmcgaGFuZGxlZC4gU28gd2UgdXNlIHRoZSBzYW1lIGRvY3VtZW50LlxuLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxudmFyIHRlc3RFbGVtZW50PXBhcmVudC5uYW1lc3BhY2VVUkk9PT1IVE1MX05BTUVTUEFDRT9wYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHBhcmVudC50YWdOYW1lKTpwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocGFyZW50Lm5hbWVzcGFjZVVSSSxwYXJlbnQudGFnTmFtZSk7dGVzdEVsZW1lbnQuaW5uZXJIVE1MPWh0bWw7cmV0dXJuIHRlc3RFbGVtZW50LmlubmVySFRNTDt9O30vLyBIVE1MIHBhcnNpbmcgbm9ybWFsaXplcyBDUiBhbmQgQ1JMRiB0byBMRi5cbi8vIEl0IGFsc28gY2FuIHR1cm4gXFx1MDAwMCBpbnRvIFxcdUZGRkQgaW5zaWRlIGF0dHJpYnV0ZXMuXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc2luZ2xlLXBhZ2UuaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbi8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCwgaXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHRoYXQuXG4vLyBXZSB3aWxsIHN0aWxsIHBhdGNoIHVwIGluIHRoaXMgY2FzZSBidXQgbm90IGZpcmUgdGhlIHdhcm5pbmcuXG52YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYPS9cXHJcXG4/L2c7dmFyIE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWD0vXFx1MDAwMHxcXHVGRkZEL2c7ZnVuY3Rpb24gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKG1hcmt1cCl7e2NoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKG1hcmt1cCk7fXZhciBtYXJrdXBTdHJpbmc9dHlwZW9mIG1hcmt1cD09PSdzdHJpbmcnP21hcmt1cDonJyttYXJrdXA7cmV0dXJuIG1hcmt1cFN0cmluZy5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwnXFxuJykucmVwbGFjZShOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgsJycpO31mdW5jdGlvbiBjaGVja0ZvclVubWF0Y2hlZFRleHQoc2VydmVyVGV4dCxjbGllbnRUZXh0LGlzQ29uY3VycmVudE1vZGUsc2hvdWxkV2FybkRldil7dmFyIG5vcm1hbGl6ZWRDbGllbnRUZXh0PW5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRUZXh0KTt2YXIgbm9ybWFsaXplZFNlcnZlclRleHQ9bm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpO2lmKG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0PT09bm9ybWFsaXplZENsaWVudFRleHQpe3JldHVybjt9aWYoc2hvdWxkV2FybkRldil7e2lmKCFkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbil7ZGlkV2FybkludmFsaWRIeWRyYXRpb249dHJ1ZTtlcnJvcignVGV4dCBjb250ZW50IGRpZCBub3QgbWF0Y2guIFNlcnZlcjogXCIlc1wiIENsaWVudDogXCIlc1wiJyxub3JtYWxpemVkU2VydmVyVGV4dCxub3JtYWxpemVkQ2xpZW50VGV4dCk7fX19aWYoaXNDb25jdXJyZW50TW9kZSYmZW5hYmxlQ2xpZW50UmVuZGVyRmFsbGJhY2tPblRleHRNaXNtYXRjaCl7Ly8gSW4gY29uY3VycmVudCByb290cywgd2UgdGhyb3cgd2hlbiB0aGVyZSdzIGEgdGV4dCBtaXNtYXRjaCBhbmQgcmV2ZXJ0IHRvXG4vLyBjbGllbnQgcmVuZGVyaW5nLCB1cCB0byB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeS5cbnRocm93IG5ldyBFcnJvcignVGV4dCBjb250ZW50IGRvZXMgbm90IG1hdGNoIHNlcnZlci1yZW5kZXJlZCBIVE1MLicpO319ZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KXtyZXR1cm4gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGU9PT1ET0NVTUVOVF9OT0RFP3Jvb3RDb250YWluZXJFbGVtZW50OnJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7fWZ1bmN0aW9uIG5vb3AoKXt9ZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQobm9kZSl7Ly8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbi8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3Rcbi8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbi8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbi8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbi8vIGJvb2trZWVwaW5nIGZvciBpdC4gTm90IHN1cmUgaWYgd2UgbmVlZCB0byBjbGVhciBpdCB3aGVuIHRoZSBsaXN0ZW5lciBpc1xuLy8gcmVtb3ZlZC5cbi8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG5ub2RlLm9uY2xpY2s9bm9vcDt9ZnVuY3Rpb24gc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLGRvbUVsZW1lbnQscm9vdENvbnRhaW5lckVsZW1lbnQsbmV4dFByb3BzLGlzQ3VzdG9tQ29tcG9uZW50VGFnKXtmb3IodmFyIHByb3BLZXkgaW4gbmV4dFByb3BzKXtpZighbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKXtjb250aW51ZTt9dmFyIG5leHRQcm9wPW5leHRQcm9wc1twcm9wS2V5XTtpZihwcm9wS2V5PT09U1RZTEUpe3tpZihuZXh0UHJvcCl7Ly8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbi8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG5PYmplY3QuZnJlZXplKG5leHRQcm9wKTt9fS8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCxuZXh0UHJvcCk7fWVsc2UgaWYocHJvcEtleT09PURBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKXt2YXIgbmV4dEh0bWw9bmV4dFByb3A/bmV4dFByb3BbSFRNTCQxXTp1bmRlZmluZWQ7aWYobmV4dEh0bWwhPW51bGwpe3NldElubmVySFRNTChkb21FbGVtZW50LG5leHRIdG1sKTt9fWVsc2UgaWYocHJvcEtleT09PUNISUxEUkVOKXtpZih0eXBlb2YgbmV4dFByb3A9PT0nc3RyaW5nJyl7Ly8gQXZvaWQgc2V0dGluZyBpbml0aWFsIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuLy8gdGV4dENvbnRlbnQgb24gYSA8dGV4dGFyZWE+IHdpbGwgY2F1c2UgdGhlIHBsYWNlaG9sZGVyIHRvIG5vdFxuLy8gc2hvdyB3aXRoaW4gdGhlIDx0ZXh0YXJlYT4gdW50aWwgaXQgaGFzIGJlZW4gZm9jdXNlZCBhbmQgYmx1cnJlZCBhZ2Fpbi5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG52YXIgY2FuU2V0VGV4dENvbnRlbnQ9dGFnIT09J3RleHRhcmVhJ3x8bmV4dFByb3AhPT0nJztpZihjYW5TZXRUZXh0Q29udGVudCl7c2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCxuZXh0UHJvcCk7fX1lbHNlIGlmKHR5cGVvZiBuZXh0UHJvcD09PSdudW1iZXInKXtzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCcnK25leHRQcm9wKTt9fWVsc2UgaWYocHJvcEtleT09PVNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklOR3x8cHJvcEtleT09PVNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HKTtlbHNlIGlmKHByb3BLZXk9PT1BVVRPRk9DVVMpO2Vsc2UgaWYocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSl7aWYobmV4dFByb3AhPW51bGwpe2lmKHR5cGVvZiBuZXh0UHJvcCE9PSdmdW5jdGlvbicpe3dhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LG5leHRQcm9wKTt9aWYocHJvcEtleT09PSdvblNjcm9sbCcpe2xpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3Njcm9sbCcsZG9tRWxlbWVudCk7fX19ZWxzZSBpZihuZXh0UHJvcCE9bnVsbCl7c2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LHByb3BLZXksbmV4dFByb3AsaXNDdXN0b21Db21wb25lbnRUYWcpO319fWZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCx1cGRhdGVQYXlsb2FkLHdhc0N1c3RvbUNvbXBvbmVudFRhZyxpc0N1c3RvbUNvbXBvbmVudFRhZyl7Ly8gVE9ETzogSGFuZGxlIHdhc0N1c3RvbUNvbXBvbmVudFRhZ1xuZm9yKHZhciBpPTA7aTx1cGRhdGVQYXlsb2FkLmxlbmd0aDtpKz0yKXt2YXIgcHJvcEtleT11cGRhdGVQYXlsb2FkW2ldO3ZhciBwcm9wVmFsdWU9dXBkYXRlUGF5bG9hZFtpKzFdO2lmKHByb3BLZXk9PT1TVFlMRSl7c2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCxwcm9wVmFsdWUpO31lbHNlIGlmKHByb3BLZXk9PT1EQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCl7c2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQscHJvcFZhbHVlKTt9ZWxzZSBpZihwcm9wS2V5PT09Q0hJTERSRU4pe3NldFRleHRDb250ZW50KGRvbUVsZW1lbnQscHJvcFZhbHVlKTt9ZWxzZXtzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQscHJvcEtleSxwcm9wVmFsdWUsaXNDdXN0b21Db21wb25lbnRUYWcpO319fWZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSxwcm9wcyxyb290Q29udGFpbmVyRWxlbWVudCxwYXJlbnROYW1lc3BhY2Upe3ZhciBpc0N1c3RvbUNvbXBvbmVudFRhZzsvLyBXZSBjcmVhdGUgdGFncyBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoZWlyIHBhcmVudCBjb250YWluZXIsIGV4Y2VwdCBIVE1MXG4vLyB0YWdzIGdldCBubyBuYW1lc3BhY2UuXG52YXIgb3duZXJEb2N1bWVudD1nZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpO3ZhciBkb21FbGVtZW50O3ZhciBuYW1lc3BhY2VVUkk9cGFyZW50TmFtZXNwYWNlO2lmKG5hbWVzcGFjZVVSST09PUhUTUxfTkFNRVNQQUNFKXtuYW1lc3BhY2VVUkk9Z2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO31pZihuYW1lc3BhY2VVUkk9PT1IVE1MX05BTUVTUEFDRSl7e2lzQ3VzdG9tQ29tcG9uZW50VGFnPWlzQ3VzdG9tQ29tcG9uZW50KHR5cGUscHJvcHMpOy8vIFNob3VsZCB0aGlzIGNoZWNrIGJlIGdhdGVkIGJ5IHBhcmVudCBuYW1lc3BhY2U/IE5vdCBzdXJlIHdlIHdhbnQgdG9cbi8vIGFsbG93IDxTVkc+IG9yIDxtQVRIPi5cbmlmKCFpc0N1c3RvbUNvbXBvbmVudFRhZyYmdHlwZSE9PXR5cGUudG9Mb3dlckNhc2UoKSl7ZXJyb3IoJzwlcyAvPiBpcyB1c2luZyBpbmNvcnJlY3QgY2FzaW5nLiAnKydVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJysnb3IgbG93ZXJjYXNlIGZvciBIVE1MIGVsZW1lbnRzLicsdHlwZSk7fX1pZih0eXBlPT09J3NjcmlwdCcpey8vIENyZWF0ZSB0aGUgc2NyaXB0IHZpYSAuaW5uZXJIVE1MIHNvIGl0cyBcInBhcnNlci1pbnNlcnRlZFwiIGZsYWcgaXNcbi8vIHNldCB0byB0cnVlIGFuZCBpdCBkb2VzIG5vdCBleGVjdXRlXG52YXIgZGl2PW93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7ZGl2LmlubmVySFRNTD0nPHNjcmlwdD48JysnL3NjcmlwdD4nOy8vIGVzbGludC1kaXNhYmxlLWxpbmVcbi8vIFRoaXMgaXMgZ3VhcmFudGVlZCB0byB5aWVsZCBhIHNjcmlwdCBlbGVtZW50LlxudmFyIGZpcnN0Q2hpbGQ9ZGl2LmZpcnN0Q2hpbGQ7ZG9tRWxlbWVudD1kaXYucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7fWVsc2UgaWYodHlwZW9mIHByb3BzLmlzPT09J3N0cmluZycpey8vICRGbG93SXNzdWUgYGNyZWF0ZUVsZW1lbnRgIHNob3VsZCBiZSB1cGRhdGVkIGZvciBXZWIgQ29tcG9uZW50c1xuZG9tRWxlbWVudD1vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSx7aXM6cHJvcHMuaXN9KTt9ZWxzZXsvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbi8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbi8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbmRvbUVsZW1lbnQ9b3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpOy8vIE5vcm1hbGx5IGF0dHJpYnV0ZXMgYXJlIGFzc2lnbmVkIGluIGBzZXRJbml0aWFsRE9NUHJvcGVydGllc2AsIGhvd2V2ZXIgdGhlIGBtdWx0aXBsZWAgYW5kIGBzaXplYFxuLy8gYXR0cmlidXRlcyBvbiBgc2VsZWN0YHMgbmVlZHMgdG8gYmUgYWRkZWQgYmVmb3JlIGBvcHRpb25gcyBhcmUgaW5zZXJ0ZWQuXG4vLyBUaGlzIHByZXZlbnRzOlxuLy8gLSBhIGJ1ZyB3aGVyZSB0aGUgYHNlbGVjdGAgZG9lcyBub3Qgc2Nyb2xsIHRvIHRoZSBjb3JyZWN0IG9wdGlvbiBiZWNhdXNlIHNpbmd1bGFyXG4vLyAgYHNlbGVjdGAgZWxlbWVudHMgYXV0b21hdGljYWxseSBwaWNrIHRoZSBmaXJzdCBpdGVtICMxMzIyMlxuLy8gLSBhIGJ1ZyB3aGVyZSB0aGUgYHNlbGVjdGAgc2V0IHRoZSBmaXJzdCBpdGVtIGFzIHNlbGVjdGVkIGRlc3BpdGUgdGhlIGBzaXplYCBhdHRyaWJ1dGUgIzE0MjM5XG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzIyMlxuLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQyMzlcbmlmKHR5cGU9PT0nc2VsZWN0Jyl7dmFyIG5vZGU9ZG9tRWxlbWVudDtpZihwcm9wcy5tdWx0aXBsZSl7bm9kZS5tdWx0aXBsZT10cnVlO31lbHNlIGlmKHByb3BzLnNpemUpey8vIFNldHRpbmcgYSBzaXplIGdyZWF0ZXIgdGhhbiAxIGNhdXNlcyBhIHNlbGVjdCB0byBiZWhhdmUgbGlrZSBgbXVsdGlwbGU9dHJ1ZWAsIHdoZXJlXG4vLyBpdCBpcyBwb3NzaWJsZSB0aGF0IG5vIG9wdGlvbiBpcyBzZWxlY3RlZC5cbi8vXG4vLyBUaGlzIGlzIG9ubHkgbmVjZXNzYXJ5IHdoZW4gYSBzZWxlY3QgaW4gXCJzaW5nbGUgc2VsZWN0aW9uIG1vZGVcIi5cbm5vZGUuc2l6ZT1wcm9wcy5zaXplO319fX1lbHNle2RvbUVsZW1lbnQ9b3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLHR5cGUpO317aWYobmFtZXNwYWNlVVJJPT09SFRNTF9OQU1FU1BBQ0Upe2lmKCFpc0N1c3RvbUNvbXBvbmVudFRhZyYmT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvbUVsZW1lbnQpPT09J1tvYmplY3QgSFRNTFVua25vd25FbGVtZW50XScmJiFoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFVua25vd25UYWdzLHR5cGUpKXt3YXJuZWRVbmtub3duVGFnc1t0eXBlXT10cnVlO2Vycm9yKCdUaGUgdGFnIDwlcz4gaXMgdW5yZWNvZ25pemVkIGluIHRoaXMgYnJvd3Nlci4gJysnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnKydhbiB1cHBlcmNhc2UgbGV0dGVyLicsdHlwZSk7fX19cmV0dXJuIGRvbUVsZW1lbnQ7fWZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlKHRleHQscm9vdENvbnRhaW5lckVsZW1lbnQpe3JldHVybiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpLmNyZWF0ZVRleHROb2RlKHRleHQpO31mdW5jdGlvbiBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LHRhZyxyYXdQcm9wcyxyb290Q29udGFpbmVyRWxlbWVudCl7dmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnPWlzQ3VzdG9tQ29tcG9uZW50KHRhZyxyYXdQcm9wcyk7e3ZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLHJhd1Byb3BzKTt9Ly8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbnZhciBwcm9wcztzd2l0Y2godGFnKXtjYXNlJ2RpYWxvZyc6bGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnY2FuY2VsJyxkb21FbGVtZW50KTtsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdjbG9zZScsZG9tRWxlbWVudCk7cHJvcHM9cmF3UHJvcHM7YnJlYWs7Y2FzZSdpZnJhbWUnOmNhc2Unb2JqZWN0JzpjYXNlJ2VtYmVkJzovLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgbG9hZCBldmVudC5cbmxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2xvYWQnLGRvbUVsZW1lbnQpO3Byb3BzPXJhd1Byb3BzO2JyZWFrO2Nhc2UndmlkZW8nOmNhc2UnYXVkaW8nOi8vIFdlIGxpc3RlbiB0byB0aGVzZSBldmVudHMgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgYWxsIHRoZSBtZWRpYSBldmVudHMuXG5mb3IodmFyIGk9MDtpPG1lZGlhRXZlbnRUeXBlcy5sZW5ndGg7aSsrKXtsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KG1lZGlhRXZlbnRUeXBlc1tpXSxkb21FbGVtZW50KTt9cHJvcHM9cmF3UHJvcHM7YnJlYWs7Y2FzZSdzb3VyY2UnOi8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBlcnJvciBldmVudC5cbmxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Vycm9yJyxkb21FbGVtZW50KTtwcm9wcz1yYXdQcm9wczticmVhaztjYXNlJ2ltZyc6Y2FzZSdpbWFnZSc6Y2FzZSdsaW5rJzovLyBXZSBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIGVycm9yIGFuZCBsb2FkIGV2ZW50cy5cbmxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Vycm9yJyxkb21FbGVtZW50KTtsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdsb2FkJyxkb21FbGVtZW50KTtwcm9wcz1yYXdQcm9wczticmVhaztjYXNlJ2RldGFpbHMnOi8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSB0b2dnbGUgZXZlbnQuXG5saXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCd0b2dnbGUnLGRvbUVsZW1lbnQpO3Byb3BzPXJhd1Byb3BzO2JyZWFrO2Nhc2UnaW5wdXQnOmluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCxyYXdQcm9wcyk7cHJvcHM9Z2V0SG9zdFByb3BzKGRvbUVsZW1lbnQscmF3UHJvcHMpOy8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsZG9tRWxlbWVudCk7YnJlYWs7Y2FzZSdvcHRpb24nOnZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCxyYXdQcm9wcyk7cHJvcHM9cmF3UHJvcHM7YnJlYWs7Y2FzZSdzZWxlY3QnOmluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LHJhd1Byb3BzKTtwcm9wcz1nZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LHJhd1Byb3BzKTsvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cbmxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLGRvbUVsZW1lbnQpO2JyZWFrO2Nhc2UndGV4dGFyZWEnOmluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LHJhd1Byb3BzKTtwcm9wcz1nZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LHJhd1Byb3BzKTsvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cbmxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLGRvbUVsZW1lbnQpO2JyZWFrO2RlZmF1bHQ6cHJvcHM9cmF3UHJvcHM7fWFzc2VydFZhbGlkUHJvcHModGFnLHByb3BzKTtzZXRJbml0aWFsRE9NUHJvcGVydGllcyh0YWcsZG9tRWxlbWVudCxyb290Q29udGFpbmVyRWxlbWVudCxwcm9wcyxpc0N1c3RvbUNvbXBvbmVudFRhZyk7c3dpdGNoKHRhZyl7Y2FzZSdpbnB1dCc6Ly8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbnRyYWNrKGRvbUVsZW1lbnQpO3Bvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCxyYXdQcm9wcyxmYWxzZSk7YnJlYWs7Y2FzZSd0ZXh0YXJlYSc6Ly8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbnRyYWNrKGRvbUVsZW1lbnQpO3Bvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50KTticmVhaztjYXNlJ29wdGlvbic6cG9zdE1vdW50V3JhcHBlciQxKGRvbUVsZW1lbnQscmF3UHJvcHMpO2JyZWFrO2Nhc2Unc2VsZWN0Jzpwb3N0TW91bnRXcmFwcGVyJDIoZG9tRWxlbWVudCxyYXdQcm9wcyk7YnJlYWs7ZGVmYXVsdDppZih0eXBlb2YgcHJvcHMub25DbGljaz09PSdmdW5jdGlvbicpey8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG50cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTt9YnJlYWs7fX0vLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5mdW5jdGlvbiBkaWZmUHJvcGVydGllcyhkb21FbGVtZW50LHRhZyxsYXN0UmF3UHJvcHMsbmV4dFJhd1Byb3BzLHJvb3RDb250YWluZXJFbGVtZW50KXt7dmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsbmV4dFJhd1Byb3BzKTt9dmFyIHVwZGF0ZVBheWxvYWQ9bnVsbDt2YXIgbGFzdFByb3BzO3ZhciBuZXh0UHJvcHM7c3dpdGNoKHRhZyl7Y2FzZSdpbnB1dCc6bGFzdFByb3BzPWdldEhvc3RQcm9wcyhkb21FbGVtZW50LGxhc3RSYXdQcm9wcyk7bmV4dFByb3BzPWdldEhvc3RQcm9wcyhkb21FbGVtZW50LG5leHRSYXdQcm9wcyk7dXBkYXRlUGF5bG9hZD1bXTticmVhaztjYXNlJ3NlbGVjdCc6bGFzdFByb3BzPWdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsbGFzdFJhd1Byb3BzKTtuZXh0UHJvcHM9Z2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCxuZXh0UmF3UHJvcHMpO3VwZGF0ZVBheWxvYWQ9W107YnJlYWs7Y2FzZSd0ZXh0YXJlYSc6bGFzdFByb3BzPWdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsbGFzdFJhd1Byb3BzKTtuZXh0UHJvcHM9Z2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCxuZXh0UmF3UHJvcHMpO3VwZGF0ZVBheWxvYWQ9W107YnJlYWs7ZGVmYXVsdDpsYXN0UHJvcHM9bGFzdFJhd1Byb3BzO25leHRQcm9wcz1uZXh0UmF3UHJvcHM7aWYodHlwZW9mIGxhc3RQcm9wcy5vbkNsaWNrIT09J2Z1bmN0aW9uJyYmdHlwZW9mIG5leHRQcm9wcy5vbkNsaWNrPT09J2Z1bmN0aW9uJyl7Ly8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbnRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO31icmVhazt9YXNzZXJ0VmFsaWRQcm9wcyh0YWcsbmV4dFByb3BzKTt2YXIgcHJvcEtleTt2YXIgc3R5bGVOYW1lO3ZhciBzdHlsZVVwZGF0ZXM9bnVsbDtmb3IocHJvcEtleSBpbiBsYXN0UHJvcHMpe2lmKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KXx8IWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KXx8bGFzdFByb3BzW3Byb3BLZXldPT1udWxsKXtjb250aW51ZTt9aWYocHJvcEtleT09PVNUWUxFKXt2YXIgbGFzdFN0eWxlPWxhc3RQcm9wc1twcm9wS2V5XTtmb3Ioc3R5bGVOYW1lIGluIGxhc3RTdHlsZSl7aWYobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpe2lmKCFzdHlsZVVwZGF0ZXMpe3N0eWxlVXBkYXRlcz17fTt9c3R5bGVVcGRhdGVzW3N0eWxlTmFtZV09Jyc7fX19ZWxzZSBpZihwcm9wS2V5PT09REFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUx8fHByb3BLZXk9PT1DSElMRFJFTik7ZWxzZSBpZihwcm9wS2V5PT09U1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HfHxwcm9wS2V5PT09U1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcpO2Vsc2UgaWYocHJvcEtleT09PUFVVE9GT0NVUyk7ZWxzZSBpZihyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKXsvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgZmliZXIgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbmlmKCF1cGRhdGVQYXlsb2FkKXt1cGRhdGVQYXlsb2FkPVtdO319ZWxzZXsvLyBGb3IgYWxsIG90aGVyIGRlbGV0ZWQgcHJvcGVydGllcyB3ZSBhZGQgaXQgdG8gdGhlIHF1ZXVlLiBXZSB1c2Vcbi8vIHRoZSBhbGxvd2VkIHByb3BlcnR5IGxpc3QgaW4gdGhlIGNvbW1pdCBwaGFzZSBpbnN0ZWFkLlxuKHVwZGF0ZVBheWxvYWQ9dXBkYXRlUGF5bG9hZHx8W10pLnB1c2gocHJvcEtleSxudWxsKTt9fWZvcihwcm9wS2V5IGluIG5leHRQcm9wcyl7dmFyIG5leHRQcm9wPW5leHRQcm9wc1twcm9wS2V5XTt2YXIgbGFzdFByb3A9bGFzdFByb3BzIT1udWxsP2xhc3RQcm9wc1twcm9wS2V5XTp1bmRlZmluZWQ7aWYoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KXx8bmV4dFByb3A9PT1sYXN0UHJvcHx8bmV4dFByb3A9PW51bGwmJmxhc3RQcm9wPT1udWxsKXtjb250aW51ZTt9aWYocHJvcEtleT09PVNUWUxFKXt7aWYobmV4dFByb3Apey8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4vLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7fX1pZihsYXN0UHJvcCl7Ly8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuZm9yKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCl7aWYobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSYmKCFuZXh0UHJvcHx8IW5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpKXtpZighc3R5bGVVcGRhdGVzKXtzdHlsZVVwZGF0ZXM9e307fXN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdPScnO319Ly8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbmZvcihzdHlsZU5hbWUgaW4gbmV4dFByb3Ape2lmKG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkmJmxhc3RQcm9wW3N0eWxlTmFtZV0hPT1uZXh0UHJvcFtzdHlsZU5hbWVdKXtpZighc3R5bGVVcGRhdGVzKXtzdHlsZVVwZGF0ZXM9e307fXN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdPW5leHRQcm9wW3N0eWxlTmFtZV07fX19ZWxzZXsvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbmlmKCFzdHlsZVVwZGF0ZXMpe2lmKCF1cGRhdGVQYXlsb2FkKXt1cGRhdGVQYXlsb2FkPVtdO311cGRhdGVQYXlsb2FkLnB1c2gocHJvcEtleSxzdHlsZVVwZGF0ZXMpO31zdHlsZVVwZGF0ZXM9bmV4dFByb3A7fX1lbHNlIGlmKHByb3BLZXk9PT1EQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCl7dmFyIG5leHRIdG1sPW5leHRQcm9wP25leHRQcm9wW0hUTUwkMV06dW5kZWZpbmVkO3ZhciBsYXN0SHRtbD1sYXN0UHJvcD9sYXN0UHJvcFtIVE1MJDFdOnVuZGVmaW5lZDtpZihuZXh0SHRtbCE9bnVsbCl7aWYobGFzdEh0bWwhPT1uZXh0SHRtbCl7KHVwZGF0ZVBheWxvYWQ9dXBkYXRlUGF5bG9hZHx8W10pLnB1c2gocHJvcEtleSxuZXh0SHRtbCk7fX19ZWxzZSBpZihwcm9wS2V5PT09Q0hJTERSRU4pe2lmKHR5cGVvZiBuZXh0UHJvcD09PSdzdHJpbmcnfHx0eXBlb2YgbmV4dFByb3A9PT0nbnVtYmVyJyl7KHVwZGF0ZVBheWxvYWQ9dXBkYXRlUGF5bG9hZHx8W10pLnB1c2gocHJvcEtleSwnJytuZXh0UHJvcCk7fX1lbHNlIGlmKHByb3BLZXk9PT1TVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkd8fHByb3BLZXk9PT1TVVBQUkVTU19IWURSQVRJT05fV0FSTklORyk7ZWxzZSBpZihyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKXtpZihuZXh0UHJvcCE9bnVsbCl7Ly8gV2UgZWFnZXJseSBsaXN0ZW4gdG8gdGhpcyBldmVuIHRob3VnaCB3ZSBoYXZlbid0IGNvbW1pdHRlZCB5ZXQuXG5pZih0eXBlb2YgbmV4dFByb3AhPT0nZnVuY3Rpb24nKXt3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSxuZXh0UHJvcCk7fWlmKHByb3BLZXk9PT0nb25TY3JvbGwnKXtsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdzY3JvbGwnLGRvbUVsZW1lbnQpO319aWYoIXVwZGF0ZVBheWxvYWQmJmxhc3RQcm9wIT09bmV4dFByb3Apey8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4vLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBwcm9wcyBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4vLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxudXBkYXRlUGF5bG9hZD1bXTt9fWVsc2V7Ly8gRm9yIGFueSBvdGhlciBwcm9wZXJ0eSB3ZSBhbHdheXMgYWRkIGl0IHRvIHRoZSBxdWV1ZSBhbmQgdGhlbiB3ZVxuLy8gZmlsdGVyIGl0IG91dCB1c2luZyB0aGUgYWxsb3dlZCBwcm9wZXJ0eSBsaXN0IGR1cmluZyB0aGUgY29tbWl0LlxuKHVwZGF0ZVBheWxvYWQ9dXBkYXRlUGF5bG9hZHx8W10pLnB1c2gocHJvcEtleSxuZXh0UHJvcCk7fX1pZihzdHlsZVVwZGF0ZXMpe3t2YWxpZGF0ZVNob3J0aGFuZFByb3BlcnR5Q29sbGlzaW9uSW5EZXYoc3R5bGVVcGRhdGVzLG5leHRQcm9wc1tTVFlMRV0pO30odXBkYXRlUGF5bG9hZD11cGRhdGVQYXlsb2FkfHxbXSkucHVzaChTVFlMRSxzdHlsZVVwZGF0ZXMpO31yZXR1cm4gdXBkYXRlUGF5bG9hZDt9Ly8gQXBwbHkgdGhlIGRpZmYuXG5mdW5jdGlvbiB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsdXBkYXRlUGF5bG9hZCx0YWcsbGFzdFJhd1Byb3BzLG5leHRSYXdQcm9wcyl7Ly8gVXBkYXRlIGNoZWNrZWQgKmJlZm9yZSogbmFtZS5cbi8vIEluIHRoZSBtaWRkbGUgb2YgYW4gdXBkYXRlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIGNoZWNrZWQuXG4vLyBXaGVuIGEgY2hlY2tlZCByYWRpbyB0cmllcyB0byBjaGFuZ2UgbmFtZSwgYnJvd3NlciBtYWtlcyBhbm90aGVyIHJhZGlvJ3MgY2hlY2tlZCBmYWxzZS5cbmlmKHRhZz09PSdpbnB1dCcmJm5leHRSYXdQcm9wcy50eXBlPT09J3JhZGlvJyYmbmV4dFJhd1Byb3BzLm5hbWUhPW51bGwpe3VwZGF0ZUNoZWNrZWQoZG9tRWxlbWVudCxuZXh0UmF3UHJvcHMpO312YXIgd2FzQ3VzdG9tQ29tcG9uZW50VGFnPWlzQ3VzdG9tQ29tcG9uZW50KHRhZyxsYXN0UmF3UHJvcHMpO3ZhciBpc0N1c3RvbUNvbXBvbmVudFRhZz1pc0N1c3RvbUNvbXBvbmVudCh0YWcsbmV4dFJhd1Byb3BzKTsvLyBBcHBseSB0aGUgZGlmZi5cbnVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCx1cGRhdGVQYXlsb2FkLHdhc0N1c3RvbUNvbXBvbmVudFRhZyxpc0N1c3RvbUNvbXBvbmVudFRhZyk7Ly8gVE9ETzogRW5zdXJlIHRoYXQgYW4gdXBkYXRlIGdldHMgc2NoZWR1bGVkIGlmIGFueSBvZiB0aGUgc3BlY2lhbCBwcm9wc1xuLy8gY2hhbmdlZC5cbnN3aXRjaCh0YWcpe2Nhc2UnaW5wdXQnOi8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4vLyBoYXBwZW4gYWZ0ZXIgYHVwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbi8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbnVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCxuZXh0UmF3UHJvcHMpO2JyZWFrO2Nhc2UndGV4dGFyZWEnOnVwZGF0ZVdyYXBwZXIkMShkb21FbGVtZW50LG5leHRSYXdQcm9wcyk7YnJlYWs7Y2FzZSdzZWxlY3QnOi8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuLy8gcmVjb25jaWxpYXRpb25cbnBvc3RVcGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsbmV4dFJhd1Byb3BzKTticmVhazt9fWZ1bmN0aW9uIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lKHByb3BOYW1lKXt7dmFyIGxvd2VyQ2FzZWROYW1lPXByb3BOYW1lLnRvTG93ZXJDYXNlKCk7aWYoIXBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpe3JldHVybiBudWxsO31yZXR1cm4gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXXx8bnVsbDt9fWZ1bmN0aW9uIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoZG9tRWxlbWVudCx0YWcscmF3UHJvcHMscGFyZW50TmFtZXNwYWNlLHJvb3RDb250YWluZXJFbGVtZW50LGlzQ29uY3VycmVudE1vZGUsc2hvdWxkV2FybkRldil7dmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnO3ZhciBleHRyYUF0dHJpYnV0ZU5hbWVzO3tpc0N1c3RvbUNvbXBvbmVudFRhZz1pc0N1c3RvbUNvbXBvbmVudCh0YWcscmF3UHJvcHMpO3ZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLHJhd1Byb3BzKTt9Ly8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbnN3aXRjaCh0YWcpe2Nhc2UnZGlhbG9nJzpsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdjYW5jZWwnLGRvbUVsZW1lbnQpO2xpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Nsb3NlJyxkb21FbGVtZW50KTticmVhaztjYXNlJ2lmcmFtZSc6Y2FzZSdvYmplY3QnOmNhc2UnZW1iZWQnOi8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBsb2FkIGV2ZW50LlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsZG9tRWxlbWVudCk7YnJlYWs7Y2FzZSd2aWRlbyc6Y2FzZSdhdWRpbyc6Ly8gV2UgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciBhbGwgdGhlIG1lZGlhIGV2ZW50cy5cbmZvcih2YXIgaT0wO2k8bWVkaWFFdmVudFR5cGVzLmxlbmd0aDtpKyspe2xpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2ldLGRvbUVsZW1lbnQpO31icmVhaztjYXNlJ3NvdXJjZSc6Ly8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGVycm9yIGV2ZW50LlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLGRvbUVsZW1lbnQpO2JyZWFrO2Nhc2UnaW1nJzpjYXNlJ2ltYWdlJzpjYXNlJ2xpbmsnOi8vIFdlIGxpc3RlbiB0byB0aGVzZSBldmVudHMgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgZXJyb3IgYW5kIGxvYWQgZXZlbnRzLlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLGRvbUVsZW1lbnQpO2xpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2xvYWQnLGRvbUVsZW1lbnQpO2JyZWFrO2Nhc2UnZGV0YWlscyc6Ly8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIHRvZ2dsZSBldmVudC5cbmxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3RvZ2dsZScsZG9tRWxlbWVudCk7YnJlYWs7Y2FzZSdpbnB1dCc6aW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LHJhd1Byb3BzKTsvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cbmxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLGRvbUVsZW1lbnQpO2JyZWFrO2Nhc2Unb3B0aW9uJzp2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQscmF3UHJvcHMpO2JyZWFrO2Nhc2Unc2VsZWN0Jzppbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCxyYXdQcm9wcyk7Ly8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5saXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJyxkb21FbGVtZW50KTticmVhaztjYXNlJ3RleHRhcmVhJzppbml0V3JhcHBlclN0YXRlJDIoZG9tRWxlbWVudCxyYXdQcm9wcyk7Ly8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5saXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJyxkb21FbGVtZW50KTticmVhazt9YXNzZXJ0VmFsaWRQcm9wcyh0YWcscmF3UHJvcHMpO3tleHRyYUF0dHJpYnV0ZU5hbWVzPW5ldyBTZXQoKTt2YXIgYXR0cmlidXRlcz1kb21FbGVtZW50LmF0dHJpYnV0ZXM7Zm9yKHZhciBfaT0wO19pPGF0dHJpYnV0ZXMubGVuZ3RoO19pKyspe3ZhciBuYW1lPWF0dHJpYnV0ZXNbX2ldLm5hbWUudG9Mb3dlckNhc2UoKTtzd2l0Y2gobmFtZSl7Ly8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4vLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbmNhc2UndmFsdWUnOmJyZWFrO2Nhc2UnY2hlY2tlZCc6YnJlYWs7Y2FzZSdzZWxlY3RlZCc6YnJlYWs7ZGVmYXVsdDovLyBJbnRlbnRpb25hbGx5IHVzZSB0aGUgb3JpZ2luYWwgbmFtZS5cbi8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuZXh0cmFBdHRyaWJ1dGVOYW1lcy5hZGQoYXR0cmlidXRlc1tfaV0ubmFtZSk7fX19dmFyIHVwZGF0ZVBheWxvYWQ9bnVsbDtmb3IodmFyIHByb3BLZXkgaW4gcmF3UHJvcHMpe2lmKCFyYXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSl7Y29udGludWU7fXZhciBuZXh0UHJvcD1yYXdQcm9wc1twcm9wS2V5XTtpZihwcm9wS2V5PT09Q0hJTERSRU4pey8vIEZvciB0ZXh0IGNvbnRlbnQgY2hpbGRyZW4gd2UgY29tcGFyZSBhZ2FpbnN0IHRleHRDb250ZW50LiBUaGlzXG4vLyBtaWdodCBtYXRjaCBhZGRpdGlvbmFsIEhUTUwgdGhhdCBpcyBoaWRkZW4gd2hlbiB3ZSByZWFkIGl0IHVzaW5nXG4vLyB0ZXh0Q29udGVudC4gRS5nLiBcImZvb1wiIHdpbGwgbWF0Y2ggXCJmPHNwYW4+b288L3NwYW4+XCIgYnV0IHRoYXQgc3RpbGxcbi8vIHNhdGlzZmllcyBvdXIgcmVxdWlyZW1lbnQuIE91ciByZXF1aXJlbWVudCBpcyBub3QgdG8gcHJvZHVjZSBwZXJmZWN0XG4vLyBIVE1MIGFuZCBhdHRyaWJ1dGVzLiBJZGVhbGx5IHdlIHNob3VsZCBwcmVzZXJ2ZSBzdHJ1Y3R1cmUgYnV0IGl0J3Ncbi8vIG9rIG5vdCB0byBpZiB0aGUgdmlzaWJsZSBjb250ZW50IGlzIHN0aWxsIGVub3VnaCB0byBpbmRpY2F0ZSB3aGF0XG4vLyBldmVuIGxpc3RlbmVycyB0aGVzZSBub2RlcyBtaWdodCBiZSB3aXJlZCB1cCB0by5cbi8vIFRPRE86IFdhcm4gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIGEgc2luZ2xlIHRleHROb2RlIGFzIGEgY2hpbGQuXG4vLyBUT0RPOiBTaG91bGQgd2UgdXNlIGRvbUVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlVmFsdWUgdG8gY29tcGFyZT9cbmlmKHR5cGVvZiBuZXh0UHJvcD09PSdzdHJpbmcnKXtpZihkb21FbGVtZW50LnRleHRDb250ZW50IT09bmV4dFByb3Ape2lmKHJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSE9PXRydWUpe2NoZWNrRm9yVW5tYXRjaGVkVGV4dChkb21FbGVtZW50LnRleHRDb250ZW50LG5leHRQcm9wLGlzQ29uY3VycmVudE1vZGUsc2hvdWxkV2FybkRldik7fXVwZGF0ZVBheWxvYWQ9W0NISUxEUkVOLG5leHRQcm9wXTt9fWVsc2UgaWYodHlwZW9mIG5leHRQcm9wPT09J251bWJlcicpe2lmKGRvbUVsZW1lbnQudGV4dENvbnRlbnQhPT0nJytuZXh0UHJvcCl7aWYocmF3UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddIT09dHJ1ZSl7Y2hlY2tGb3JVbm1hdGNoZWRUZXh0KGRvbUVsZW1lbnQudGV4dENvbnRlbnQsbmV4dFByb3AsaXNDb25jdXJyZW50TW9kZSxzaG91bGRXYXJuRGV2KTt9dXBkYXRlUGF5bG9hZD1bQ0hJTERSRU4sJycrbmV4dFByb3BdO319fWVsc2UgaWYocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSl7aWYobmV4dFByb3AhPW51bGwpe2lmKHR5cGVvZiBuZXh0UHJvcCE9PSdmdW5jdGlvbicpe3dhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LG5leHRQcm9wKTt9aWYocHJvcEtleT09PSdvblNjcm9sbCcpe2xpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3Njcm9sbCcsZG9tRWxlbWVudCk7fX19ZWxzZSBpZihzaG91bGRXYXJuRGV2JiZ0cnVlJiYvLyBDb252aW5jZSBGbG93IHdlJ3ZlIGNhbGN1bGF0ZWQgaXQgKGl0J3MgREVWLW9ubHkgaW4gdGhpcyBtZXRob2QuKVxudHlwZW9mIGlzQ3VzdG9tQ29tcG9uZW50VGFnPT09J2Jvb2xlYW4nKXsvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxudmFyIHNlcnZlclZhbHVlPXZvaWQgMDt2YXIgcHJvcGVydHlJbmZvPWlzQ3VzdG9tQ29tcG9uZW50VGFnJiZlbmFibGVDdXN0b21FbGVtZW50UHJvcGVydHlTdXBwb3J0P251bGw6Z2V0UHJvcGVydHlJbmZvKHByb3BLZXkpO2lmKHJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXT09PXRydWUpO2Vsc2UgaWYocHJvcEtleT09PVNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklOR3x8cHJvcEtleT09PVNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HfHwvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbi8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxucHJvcEtleT09PSd2YWx1ZSd8fHByb3BLZXk9PT0nY2hlY2tlZCd8fHByb3BLZXk9PT0nc2VsZWN0ZWQnKTtlbHNlIGlmKHByb3BLZXk9PT1EQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCl7dmFyIHNlcnZlckhUTUw9ZG9tRWxlbWVudC5pbm5lckhUTUw7dmFyIG5leHRIdG1sPW5leHRQcm9wP25leHRQcm9wW0hUTUwkMV06dW5kZWZpbmVkO2lmKG5leHRIdG1sIT1udWxsKXt2YXIgZXhwZWN0ZWRIVE1MPW5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCxuZXh0SHRtbCk7aWYoZXhwZWN0ZWRIVE1MIT09c2VydmVySFRNTCl7d2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksc2VydmVySFRNTCxleHBlY3RlZEhUTUwpO319fWVsc2UgaWYocHJvcEtleT09PVNUWUxFKXsvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG5leHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5KTtpZihjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nKXt2YXIgZXhwZWN0ZWRTdHlsZT1jcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMobmV4dFByb3ApO3NlcnZlclZhbHVlPWRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO2lmKGV4cGVjdGVkU3R5bGUhPT1zZXJ2ZXJWYWx1ZSl7d2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksc2VydmVyVmFsdWUsZXhwZWN0ZWRTdHlsZSk7fX19ZWxzZSBpZihpc0N1c3RvbUNvbXBvbmVudFRhZyYmIWVuYWJsZUN1c3RvbUVsZW1lbnRQcm9wZXJ0eVN1cHBvcnQpey8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbmV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7c2VydmVyVmFsdWU9Z2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCxwcm9wS2V5LG5leHRQcm9wKTtpZihuZXh0UHJvcCE9PXNlcnZlclZhbHVlKXt3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSxzZXJ2ZXJWYWx1ZSxuZXh0UHJvcCk7fX1lbHNlIGlmKCFzaG91bGRJZ25vcmVBdHRyaWJ1dGUocHJvcEtleSxwcm9wZXJ0eUluZm8saXNDdXN0b21Db21wb25lbnRUYWcpJiYhc2hvdWxkUmVtb3ZlQXR0cmlidXRlKHByb3BLZXksbmV4dFByb3AscHJvcGVydHlJbmZvLGlzQ3VzdG9tQ29tcG9uZW50VGFnKSl7dmFyIGlzTWlzbWF0Y2hEdWVUb0JhZENhc2luZz1mYWxzZTtpZihwcm9wZXJ0eUluZm8hPT1udWxsKXsvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG5leHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7c2VydmVyVmFsdWU9Z2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LHByb3BLZXksbmV4dFByb3AscHJvcGVydHlJbmZvKTt9ZWxzZXt2YXIgb3duTmFtZXNwYWNlPXBhcmVudE5hbWVzcGFjZTtpZihvd25OYW1lc3BhY2U9PT1IVE1MX05BTUVTUEFDRSl7b3duTmFtZXNwYWNlPWdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO31pZihvd25OYW1lc3BhY2U9PT1IVE1MX05BTUVTUEFDRSl7Ly8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleS50b0xvd2VyQ2FzZSgpKTt9ZWxzZXt2YXIgc3RhbmRhcmROYW1lPWdldFBvc3NpYmxlU3RhbmRhcmROYW1lKHByb3BLZXkpO2lmKHN0YW5kYXJkTmFtZSE9PW51bGwmJnN0YW5kYXJkTmFtZSE9PXByb3BLZXkpey8vIElmIGFuIFNWRyBwcm9wIGlzIHN1cHBsaWVkIHdpdGggYmFkIGNhc2luZywgaXQgd2lsbFxuLy8gYmUgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBmcm9tIEhUTUwsIGJ1dCB3aWxsIHByb2R1Y2UgYSBtaXNtYXRjaFxuLy8gKGFuZCB3b3VsZCBiZSBpbmNvcnJlY3RseSByZW5kZXJlZCBvbiB0aGUgY2xpZW50KS5cbi8vIEhvd2V2ZXIsIHdlIGFscmVhZHkgd2FybiBhYm91dCBiYWQgY2FzaW5nIGVsc2V3aGVyZS5cbi8vIFNvIHdlJ2xsIHNraXAgdGhlIG1pc2xlYWRpbmcgZXh0cmEgbWlzbWF0Y2ggd2FybmluZyBpbiB0aGlzIGNhc2UuXG5pc01pc21hdGNoRHVlVG9CYWRDYXNpbmc9dHJ1ZTsvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG5leHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShzdGFuZGFyZE5hbWUpO30vLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG5leHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5KTt9c2VydmVyVmFsdWU9Z2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCxwcm9wS2V5LG5leHRQcm9wKTt9dmFyIGRvbnRXYXJuQ3VzdG9tRWxlbWVudD1lbmFibGVDdXN0b21FbGVtZW50UHJvcGVydHlTdXBwb3J0O2lmKCFkb250V2FybkN1c3RvbUVsZW1lbnQmJm5leHRQcm9wIT09c2VydmVyVmFsdWUmJiFpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcpe3dhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LHNlcnZlclZhbHVlLG5leHRQcm9wKTt9fX19e2lmKHNob3VsZFdhcm5EZXYpe2lmKC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbmV4dHJhQXR0cmlidXRlTmFtZXMuc2l6ZT4wJiZyYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10hPT10cnVlKXsvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG53YXJuRm9yRXh0cmFBdHRyaWJ1dGVzKGV4dHJhQXR0cmlidXRlTmFtZXMpO319fXN3aXRjaCh0YWcpe2Nhc2UnaW5wdXQnOi8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbi8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG50cmFjayhkb21FbGVtZW50KTtwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQscmF3UHJvcHMsdHJ1ZSk7YnJlYWs7Y2FzZSd0ZXh0YXJlYSc6Ly8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbnRyYWNrKGRvbUVsZW1lbnQpO3Bvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50KTticmVhaztjYXNlJ3NlbGVjdCc6Y2FzZSdvcHRpb24nOi8vIEZvciBpbnB1dCBhbmQgdGV4dGFyZWEgd2UgY3VycmVudCBhbHdheXMgc2V0IHRoZSB2YWx1ZSBwcm9wZXJ0eSBhdFxuLy8gcG9zdCBtb3VudCB0byBmb3JjZSBpdCB0byBkaXZlcmdlIGZyb20gYXR0cmlidXRlcy4gSG93ZXZlciwgZm9yXG4vLyBvcHRpb24gYW5kIHNlbGVjdCB3ZSBkb24ndCBxdWl0ZSBkbyB0aGUgc2FtZSB0aGluZyBhbmQgc2VsZWN0XG4vLyBpcyBub3QgcmVzaWxpZW50IHRvIHRoZSBET00gc3RhdGUgY2hhbmdpbmcgc28gd2UgZG9uJ3QgZG8gdGhhdCBoZXJlLlxuLy8gVE9ETzogQ29uc2lkZXIgbm90IGRvaW5nIHRoaXMgZm9yIGlucHV0IGFuZCB0ZXh0YXJlYS5cbmJyZWFrO2RlZmF1bHQ6aWYodHlwZW9mIHJhd1Byb3BzLm9uQ2xpY2s9PT0nZnVuY3Rpb24nKXsvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxudHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7fWJyZWFrO31yZXR1cm4gdXBkYXRlUGF5bG9hZDt9ZnVuY3Rpb24gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0Tm9kZSx0ZXh0LGlzQ29uY3VycmVudE1vZGUpe3ZhciBpc0RpZmZlcmVudD10ZXh0Tm9kZS5ub2RlVmFsdWUhPT10ZXh0O3JldHVybiBpc0RpZmZlcmVudDt9ZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnROb2RlLGNoaWxkKXt7aWYoZGlkV2FybkludmFsaWRIeWRyYXRpb24pe3JldHVybjt9ZGlkV2FybkludmFsaWRIeWRyYXRpb249dHJ1ZTtlcnJvcignRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIDwlcz4gaW4gPCVzPi4nLGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkscGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTt9fWZ1bmN0aW9uIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Tm9kZSxjaGlsZCl7e2lmKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKXtyZXR1cm47fWRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uPXRydWU7ZXJyb3IoJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gdGhlIHRleHQgbm9kZSBcIiVzXCIgaW4gPCVzPi4nLGNoaWxkLm5vZGVWYWx1ZSxwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO319ZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudE5vZGUsdGFnLHByb3BzKXt7aWYoZGlkV2FybkludmFsaWRIeWRyYXRpb24pe3JldHVybjt9ZGlkV2FybkludmFsaWRIeWRyYXRpb249dHJ1ZTtlcnJvcignRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIDwlcz4gaW4gPCVzPi4nLHRhZyxwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO319ZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudE5vZGUsdGV4dCl7e2lmKHRleHQ9PT0nJyl7Ly8gV2UgZXhwZWN0IHRvIGluc2VydCBlbXB0eSB0ZXh0IG5vZGVzIHNpbmNlIHRoZXkncmUgbm90IHJlcHJlc2VudGVkIGluXG4vLyB0aGUgSFRNTC5cbi8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBpZiB3ZSBjYW4ganVzdCBhdm9pZCBpbnNlcnRpbmcgZW1wdHlcbi8vIHRleHQgbm9kZXMuXG5yZXR1cm47fWlmKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKXtyZXR1cm47fWRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uPXRydWU7ZXJyb3IoJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LicsdGV4dCxwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO319ZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKGRvbUVsZW1lbnQsdGFnLHByb3BzKXtzd2l0Y2godGFnKXtjYXNlJ2lucHV0JzpyZXN0b3JlQ29udHJvbGxlZFN0YXRlKGRvbUVsZW1lbnQscHJvcHMpO3JldHVybjtjYXNlJ3RleHRhcmVhJzpyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZG9tRWxlbWVudCxwcm9wcyk7cmV0dXJuO2Nhc2Unc2VsZWN0JzpyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEoZG9tRWxlbWVudCxwcm9wcyk7cmV0dXJuO319dmFyIHZhbGlkYXRlRE9NTmVzdGluZz1mdW5jdGlvbigpe307dmFyIHVwZGF0ZWRBbmNlc3RvckluZm89ZnVuY3Rpb24oKXt9O3svLyBUaGlzIHZhbGlkYXRpb24gY29kZSB3YXMgd3JpdHRlbiBiYXNlZCBvbiB0aGUgSFRNTDUgcGFyc2luZyBzcGVjOlxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbi8vXG4vLyBOb3RlOiB0aGlzIGRvZXMgbm90IGNhdGNoIGFsbCBpbnZhbGlkIG5lc3RpbmcsIG5vciBkb2VzIGl0IHRyeSB0byAoYXMgaXQnc1xuLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbi8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuLy8gaW50ZW5kZWQuIEZvciBleGFtcGxlLCA8Yj48ZGl2PjwvZGl2PjwvYj4gaXMgaW52YWxpZCBidXQgd2UgZG9uJ3Qgd2FyblxuLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4vLyBmaXJzdCwgY2F1c2luZyBhIGNvbmZ1c2luZyBtZXNzLlxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxudmFyIHNwZWNpYWxUYWdzPVsnYWRkcmVzcycsJ2FwcGxldCcsJ2FyZWEnLCdhcnRpY2xlJywnYXNpZGUnLCdiYXNlJywnYmFzZWZvbnQnLCdiZ3NvdW5kJywnYmxvY2txdW90ZScsJ2JvZHknLCdicicsJ2J1dHRvbicsJ2NhcHRpb24nLCdjZW50ZXInLCdjb2wnLCdjb2xncm91cCcsJ2RkJywnZGV0YWlscycsJ2RpcicsJ2RpdicsJ2RsJywnZHQnLCdlbWJlZCcsJ2ZpZWxkc2V0JywnZmlnY2FwdGlvbicsJ2ZpZ3VyZScsJ2Zvb3RlcicsJ2Zvcm0nLCdmcmFtZScsJ2ZyYW1lc2V0JywnaDEnLCdoMicsJ2gzJywnaDQnLCdoNScsJ2g2JywnaGVhZCcsJ2hlYWRlcicsJ2hncm91cCcsJ2hyJywnaHRtbCcsJ2lmcmFtZScsJ2ltZycsJ2lucHV0JywnaXNpbmRleCcsJ2xpJywnbGluaycsJ2xpc3RpbmcnLCdtYWluJywnbWFycXVlZScsJ21lbnUnLCdtZW51aXRlbScsJ21ldGEnLCduYXYnLCdub2VtYmVkJywnbm9mcmFtZXMnLCdub3NjcmlwdCcsJ29iamVjdCcsJ29sJywncCcsJ3BhcmFtJywncGxhaW50ZXh0JywncHJlJywnc2NyaXB0Jywnc2VjdGlvbicsJ3NlbGVjdCcsJ3NvdXJjZScsJ3N0eWxlJywnc3VtbWFyeScsJ3RhYmxlJywndGJvZHknLCd0ZCcsJ3RlbXBsYXRlJywndGV4dGFyZWEnLCd0Zm9vdCcsJ3RoJywndGhlYWQnLCd0aXRsZScsJ3RyJywndHJhY2snLCd1bCcsJ3dicicsJ3htcCddOy8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG52YXIgaW5TY29wZVRhZ3M9WydhcHBsZXQnLCdjYXB0aW9uJywnaHRtbCcsJ3RhYmxlJywndGQnLCd0aCcsJ21hcnF1ZWUnLCdvYmplY3QnLCd0ZW1wbGF0ZScsLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4vLyBlcnJzIG9uIHRoZSBzaWRlIG9mIGZld2VyIHdhcm5pbmdzXG4nZm9yZWlnbk9iamVjdCcsJ2Rlc2MnLCd0aXRsZSddOy8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxudmFyIGJ1dHRvblNjb3BlVGFncz1pblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xudmFyIGltcGxpZWRFbmRUYWdzPVsnZGQnLCdkdCcsJ2xpJywnb3B0aW9uJywnb3B0Z3JvdXAnLCdwJywncnAnLCdydCddO3ZhciBlbXB0eUFuY2VzdG9ySW5mbz17Y3VycmVudDpudWxsLGZvcm1UYWc6bnVsbCxhVGFnSW5TY29wZTpudWxsLGJ1dHRvblRhZ0luU2NvcGU6bnVsbCxub2JyVGFnSW5TY29wZTpudWxsLHBUYWdJbkJ1dHRvblNjb3BlOm51bGwsbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzpudWxsLGRsSXRlbVRhZ0F1dG9jbG9zaW5nOm51bGx9O3VwZGF0ZWRBbmNlc3RvckluZm89ZnVuY3Rpb24ob2xkSW5mbyx0YWcpe3ZhciBhbmNlc3RvckluZm89YXNzaWduKHt9LG9sZEluZm98fGVtcHR5QW5jZXN0b3JJbmZvKTt2YXIgaW5mbz17dGFnOnRhZ307aWYoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpIT09LTEpe2FuY2VzdG9ySW5mby5hVGFnSW5TY29wZT1udWxsO2FuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlPW51bGw7YW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlPW51bGw7fWlmKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykhPT0tMSl7YW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlPW51bGw7fS8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG5pZihzcGVjaWFsVGFncy5pbmRleE9mKHRhZykhPT0tMSYmdGFnIT09J2FkZHJlc3MnJiZ0YWchPT0nZGl2JyYmdGFnIT09J3AnKXthbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZz1udWxsO2FuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZz1udWxsO31hbmNlc3RvckluZm8uY3VycmVudD1pbmZvO2lmKHRhZz09PSdmb3JtJyl7YW5jZXN0b3JJbmZvLmZvcm1UYWc9aW5mbzt9aWYodGFnPT09J2EnKXthbmNlc3RvckluZm8uYVRhZ0luU2NvcGU9aW5mbzt9aWYodGFnPT09J2J1dHRvbicpe2FuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlPWluZm87fWlmKHRhZz09PSdub2JyJyl7YW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlPWluZm87fWlmKHRhZz09PSdwJyl7YW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlPWluZm87fWlmKHRhZz09PSdsaScpe2FuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nPWluZm87fWlmKHRhZz09PSdkZCd8fHRhZz09PSdkdCcpe2FuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZz1pbmZvO31yZXR1cm4gYW5jZXN0b3JJbmZvO307LyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi92YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQ9ZnVuY3Rpb24odGFnLHBhcmVudFRhZyl7Ly8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG5zd2l0Y2gocGFyZW50VGFnKXsvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbmNhc2Unc2VsZWN0JzpyZXR1cm4gdGFnPT09J29wdGlvbid8fHRhZz09PSdvcHRncm91cCd8fHRhZz09PScjdGV4dCc7Y2FzZSdvcHRncm91cCc6cmV0dXJuIHRhZz09PSdvcHRpb24nfHx0YWc9PT0nI3RleHQnOy8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbi8vIGJ1dFxuY2FzZSdvcHRpb24nOnJldHVybiB0YWc9PT0nI3RleHQnOy8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4vLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG5jYXNlJ3RyJzpyZXR1cm4gdGFnPT09J3RoJ3x8dGFnPT09J3RkJ3x8dGFnPT09J3N0eWxlJ3x8dGFnPT09J3NjcmlwdCd8fHRhZz09PSd0ZW1wbGF0ZSc7Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbmNhc2UndGJvZHknOmNhc2UndGhlYWQnOmNhc2UndGZvb3QnOnJldHVybiB0YWc9PT0ndHInfHx0YWc9PT0nc3R5bGUnfHx0YWc9PT0nc2NyaXB0J3x8dGFnPT09J3RlbXBsYXRlJzsvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuY2FzZSdjb2xncm91cCc6cmV0dXJuIHRhZz09PSdjb2wnfHx0YWc9PT0ndGVtcGxhdGUnOy8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG5jYXNlJ3RhYmxlJzpyZXR1cm4gdGFnPT09J2NhcHRpb24nfHx0YWc9PT0nY29sZ3JvdXAnfHx0YWc9PT0ndGJvZHknfHx0YWc9PT0ndGZvb3QnfHx0YWc9PT0ndGhlYWQnfHx0YWc9PT0nc3R5bGUnfHx0YWc9PT0nc2NyaXB0J3x8dGFnPT09J3RlbXBsYXRlJzsvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG5jYXNlJ2hlYWQnOnJldHVybiB0YWc9PT0nYmFzZSd8fHRhZz09PSdiYXNlZm9udCd8fHRhZz09PSdiZ3NvdW5kJ3x8dGFnPT09J2xpbmsnfHx0YWc9PT0nbWV0YSd8fHRhZz09PSd0aXRsZSd8fHRhZz09PSdub3NjcmlwdCd8fHRhZz09PSdub2ZyYW1lcyd8fHRhZz09PSdzdHlsZSd8fHRhZz09PSdzY3JpcHQnfHx0YWc9PT0ndGVtcGxhdGUnOy8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbmNhc2UnaHRtbCc6cmV0dXJuIHRhZz09PSdoZWFkJ3x8dGFnPT09J2JvZHknfHx0YWc9PT0nZnJhbWVzZXQnO2Nhc2UnZnJhbWVzZXQnOnJldHVybiB0YWc9PT0nZnJhbWUnO2Nhc2UnI2RvY3VtZW50JzpyZXR1cm4gdGFnPT09J2h0bWwnO30vLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4vLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG5zd2l0Y2godGFnKXtjYXNlJ2gxJzpjYXNlJ2gyJzpjYXNlJ2gzJzpjYXNlJ2g0JzpjYXNlJ2g1JzpjYXNlJ2g2JzpyZXR1cm4gcGFyZW50VGFnIT09J2gxJyYmcGFyZW50VGFnIT09J2gyJyYmcGFyZW50VGFnIT09J2gzJyYmcGFyZW50VGFnIT09J2g0JyYmcGFyZW50VGFnIT09J2g1JyYmcGFyZW50VGFnIT09J2g2JztjYXNlJ3JwJzpjYXNlJ3J0JzpyZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpPT09LTE7Y2FzZSdib2R5JzpjYXNlJ2NhcHRpb24nOmNhc2UnY29sJzpjYXNlJ2NvbGdyb3VwJzpjYXNlJ2ZyYW1lc2V0JzpjYXNlJ2ZyYW1lJzpjYXNlJ2hlYWQnOmNhc2UnaHRtbCc6Y2FzZSd0Ym9keSc6Y2FzZSd0ZCc6Y2FzZSd0Zm9vdCc6Y2FzZSd0aCc6Y2FzZSd0aGVhZCc6Y2FzZSd0cic6Ly8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbi8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbi8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuLy8gY2FzZXMgYXJlIGludmFsaWQuXG5yZXR1cm4gcGFyZW50VGFnPT1udWxsO31yZXR1cm4gdHJ1ZTt9Oy8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWc9ZnVuY3Rpb24odGFnLGFuY2VzdG9ySW5mbyl7c3dpdGNoKHRhZyl7Y2FzZSdhZGRyZXNzJzpjYXNlJ2FydGljbGUnOmNhc2UnYXNpZGUnOmNhc2UnYmxvY2txdW90ZSc6Y2FzZSdjZW50ZXInOmNhc2UnZGV0YWlscyc6Y2FzZSdkaWFsb2cnOmNhc2UnZGlyJzpjYXNlJ2Rpdic6Y2FzZSdkbCc6Y2FzZSdmaWVsZHNldCc6Y2FzZSdmaWdjYXB0aW9uJzpjYXNlJ2ZpZ3VyZSc6Y2FzZSdmb290ZXInOmNhc2UnaGVhZGVyJzpjYXNlJ2hncm91cCc6Y2FzZSdtYWluJzpjYXNlJ21lbnUnOmNhc2UnbmF2JzpjYXNlJ29sJzpjYXNlJ3AnOmNhc2Unc2VjdGlvbic6Y2FzZSdzdW1tYXJ5JzpjYXNlJ3VsJzpjYXNlJ3ByZSc6Y2FzZSdsaXN0aW5nJzpjYXNlJ3RhYmxlJzpjYXNlJ2hyJzpjYXNlJ3htcCc6Y2FzZSdoMSc6Y2FzZSdoMic6Y2FzZSdoMyc6Y2FzZSdoNCc6Y2FzZSdoNSc6Y2FzZSdoNic6cmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtjYXNlJ2Zvcm0nOnJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZ3x8YW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO2Nhc2UnbGknOnJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztjYXNlJ2RkJzpjYXNlJ2R0JzpyZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO2Nhc2UnYnV0dG9uJzpyZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7Y2FzZSdhJzovLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbi8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbnJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7Y2FzZSdub2JyJzpyZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO31yZXR1cm4gbnVsbDt9O3ZhciBkaWRXYXJuJDE9e307dmFsaWRhdGVET01OZXN0aW5nPWZ1bmN0aW9uKGNoaWxkVGFnLGNoaWxkVGV4dCxhbmNlc3RvckluZm8pe2FuY2VzdG9ySW5mbz1hbmNlc3RvckluZm98fGVtcHR5QW5jZXN0b3JJbmZvO3ZhciBwYXJlbnRJbmZvPWFuY2VzdG9ySW5mby5jdXJyZW50O3ZhciBwYXJlbnRUYWc9cGFyZW50SW5mbyYmcGFyZW50SW5mby50YWc7aWYoY2hpbGRUZXh0IT1udWxsKXtpZihjaGlsZFRhZyE9bnVsbCl7ZXJyb3IoJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpO31jaGlsZFRhZz0nI3RleHQnO312YXIgaW52YWxpZFBhcmVudD1pc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZyxwYXJlbnRUYWcpP251bGw6cGFyZW50SW5mbzt2YXIgaW52YWxpZEFuY2VzdG9yPWludmFsaWRQYXJlbnQ/bnVsbDpmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLGFuY2VzdG9ySW5mbyk7dmFyIGludmFsaWRQYXJlbnRPckFuY2VzdG9yPWludmFsaWRQYXJlbnR8fGludmFsaWRBbmNlc3RvcjtpZighaW52YWxpZFBhcmVudE9yQW5jZXN0b3Ipe3JldHVybjt9dmFyIGFuY2VzdG9yVGFnPWludmFsaWRQYXJlbnRPckFuY2VzdG9yLnRhZzt2YXIgd2FybktleT0hIWludmFsaWRQYXJlbnQrJ3wnK2NoaWxkVGFnKyd8JythbmNlc3RvclRhZztpZihkaWRXYXJuJDFbd2FybktleV0pe3JldHVybjt9ZGlkV2FybiQxW3dhcm5LZXldPXRydWU7dmFyIHRhZ0Rpc3BsYXlOYW1lPWNoaWxkVGFnO3ZhciB3aGl0ZXNwYWNlSW5mbz0nJztpZihjaGlsZFRhZz09PScjdGV4dCcpe2lmKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSl7dGFnRGlzcGxheU5hbWU9J1RleHQgbm9kZXMnO31lbHNle3RhZ0Rpc3BsYXlOYW1lPSdXaGl0ZXNwYWNlIHRleHQgbm9kZXMnO3doaXRlc3BhY2VJbmZvPVwiIE1ha2Ugc3VyZSB5b3UgZG9uJ3QgaGF2ZSBhbnkgZXh0cmEgd2hpdGVzcGFjZSBiZXR3ZWVuIHRhZ3Mgb24gXCIrJ2VhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLic7fX1lbHNle3RhZ0Rpc3BsYXlOYW1lPSc8JytjaGlsZFRhZysnPic7fWlmKGludmFsaWRQYXJlbnQpe3ZhciBpbmZvPScnO2lmKGFuY2VzdG9yVGFnPT09J3RhYmxlJyYmY2hpbGRUYWc9PT0ndHInKXtpbmZvKz0nIEFkZCBhIDx0Ym9keT4sIDx0aGVhZD4gb3IgPHRmb290PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnKyd0aGUgYnJvd3Nlci4nO31lcnJvcigndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiVzJXMnLHRhZ0Rpc3BsYXlOYW1lLGFuY2VzdG9yVGFnLHdoaXRlc3BhY2VJbmZvLGluZm8pO31lbHNle2Vycm9yKCd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJysnPCVzPi4nLHRhZ0Rpc3BsYXlOYW1lLGFuY2VzdG9yVGFnKTt9fTt9dmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDE9J3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7dmFyIFNVU1BFTlNFX1NUQVJUX0RBVEE9JyQnO3ZhciBTVVNQRU5TRV9FTkRfREFUQT0nLyQnO3ZhciBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEE9JyQ/Jzt2YXIgU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQT0nJCEnO3ZhciBTVFlMRSQxPSdzdHlsZSc7dmFyIGV2ZW50c0VuYWJsZWQ9bnVsbDt2YXIgc2VsZWN0aW9uSW5mb3JtYXRpb249bnVsbDtmdW5jdGlvbiBnZXRSb290SG9zdENvbnRleHQocm9vdENvbnRhaW5lckluc3RhbmNlKXt2YXIgdHlwZTt2YXIgbmFtZXNwYWNlO3ZhciBub2RlVHlwZT1yb290Q29udGFpbmVySW5zdGFuY2Uubm9kZVR5cGU7c3dpdGNoKG5vZGVUeXBlKXtjYXNlIERPQ1VNRU5UX05PREU6Y2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOnt0eXBlPW5vZGVUeXBlPT09RE9DVU1FTlRfTk9ERT8nI2RvY3VtZW50JzonI2ZyYWdtZW50Jzt2YXIgcm9vdD1yb290Q29udGFpbmVySW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50O25hbWVzcGFjZT1yb290P3Jvb3QubmFtZXNwYWNlVVJJOmdldENoaWxkTmFtZXNwYWNlKG51bGwsJycpO2JyZWFrO31kZWZhdWx0Ont2YXIgY29udGFpbmVyPW5vZGVUeXBlPT09Q09NTUVOVF9OT0RFP3Jvb3RDb250YWluZXJJbnN0YW5jZS5wYXJlbnROb2RlOnJvb3RDb250YWluZXJJbnN0YW5jZTt2YXIgb3duTmFtZXNwYWNlPWNvbnRhaW5lci5uYW1lc3BhY2VVUkl8fG51bGw7dHlwZT1jb250YWluZXIudGFnTmFtZTtuYW1lc3BhY2U9Z2V0Q2hpbGROYW1lc3BhY2Uob3duTmFtZXNwYWNlLHR5cGUpO2JyZWFrO319e3ZhciB2YWxpZGF0ZWRUYWc9dHlwZS50b0xvd2VyQ2FzZSgpO3ZhciBhbmNlc3RvckluZm89dXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLHZhbGlkYXRlZFRhZyk7cmV0dXJue25hbWVzcGFjZTpuYW1lc3BhY2UsYW5jZXN0b3JJbmZvOmFuY2VzdG9ySW5mb307fX1mdW5jdGlvbiBnZXRDaGlsZEhvc3RDb250ZXh0KHBhcmVudEhvc3RDb250ZXh0LHR5cGUscm9vdENvbnRhaW5lckluc3RhbmNlKXt7dmFyIHBhcmVudEhvc3RDb250ZXh0RGV2PXBhcmVudEhvc3RDb250ZXh0O3ZhciBuYW1lc3BhY2U9Z2V0Q2hpbGROYW1lc3BhY2UocGFyZW50SG9zdENvbnRleHREZXYubmFtZXNwYWNlLHR5cGUpO3ZhciBhbmNlc3RvckluZm89dXBkYXRlZEFuY2VzdG9ySW5mbyhwYXJlbnRIb3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sdHlwZSk7cmV0dXJue25hbWVzcGFjZTpuYW1lc3BhY2UsYW5jZXN0b3JJbmZvOmFuY2VzdG9ySW5mb307fX1mdW5jdGlvbiBnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSl7cmV0dXJuIGluc3RhbmNlO31mdW5jdGlvbiBwcmVwYXJlRm9yQ29tbWl0KGNvbnRhaW5lckluZm8pe2V2ZW50c0VuYWJsZWQ9aXNFbmFibGVkKCk7c2VsZWN0aW9uSW5mb3JtYXRpb249Z2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKTt2YXIgYWN0aXZlSW5zdGFuY2U9bnVsbDtzZXRFbmFibGVkKGZhbHNlKTtyZXR1cm4gYWN0aXZlSW5zdGFuY2U7fWZ1bmN0aW9uIHJlc2V0QWZ0ZXJDb21taXQoY29udGFpbmVySW5mbyl7cmVzdG9yZVNlbGVjdGlvbihzZWxlY3Rpb25JbmZvcm1hdGlvbik7c2V0RW5hYmxlZChldmVudHNFbmFibGVkKTtldmVudHNFbmFibGVkPW51bGw7c2VsZWN0aW9uSW5mb3JtYXRpb249bnVsbDt9ZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UodHlwZSxwcm9wcyxyb290Q29udGFpbmVySW5zdGFuY2UsaG9zdENvbnRleHQsaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSl7dmFyIHBhcmVudE5hbWVzcGFjZTt7Ly8gVE9ETzogdGFrZSBuYW1lc3BhY2UgaW50byBhY2NvdW50IHdoZW4gdmFsaWRhdGluZy5cbnZhciBob3N0Q29udGV4dERldj1ob3N0Q29udGV4dDt2YWxpZGF0ZURPTU5lc3RpbmcodHlwZSxudWxsLGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7aWYodHlwZW9mIHByb3BzLmNoaWxkcmVuPT09J3N0cmluZyd8fHR5cGVvZiBwcm9wcy5jaGlsZHJlbj09PSdudW1iZXInKXt2YXIgc3RyaW5nPScnK3Byb3BzLmNoaWxkcmVuO3ZhciBvd25BbmNlc3RvckluZm89dXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sdHlwZSk7dmFsaWRhdGVET01OZXN0aW5nKG51bGwsc3RyaW5nLG93bkFuY2VzdG9ySW5mbyk7fXBhcmVudE5hbWVzcGFjZT1ob3N0Q29udGV4dERldi5uYW1lc3BhY2U7fXZhciBkb21FbGVtZW50PWNyZWF0ZUVsZW1lbnQodHlwZSxwcm9wcyxyb290Q29udGFpbmVySW5zdGFuY2UscGFyZW50TmFtZXNwYWNlKTtwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLGRvbUVsZW1lbnQpO3VwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCxwcm9wcyk7cmV0dXJuIGRvbUVsZW1lbnQ7fWZ1bmN0aW9uIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnRJbnN0YW5jZSxjaGlsZCl7cGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO31mdW5jdGlvbiBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihkb21FbGVtZW50LHR5cGUscHJvcHMscm9vdENvbnRhaW5lckluc3RhbmNlLGhvc3RDb250ZXh0KXtzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LHR5cGUscHJvcHMscm9vdENvbnRhaW5lckluc3RhbmNlKTtzd2l0Y2godHlwZSl7Y2FzZSdidXR0b24nOmNhc2UnaW5wdXQnOmNhc2Unc2VsZWN0JzpjYXNlJ3RleHRhcmVhJzpyZXR1cm4hIXByb3BzLmF1dG9Gb2N1cztjYXNlJ2ltZyc6cmV0dXJuIHRydWU7ZGVmYXVsdDpyZXR1cm4gZmFsc2U7fX1mdW5jdGlvbiBwcmVwYXJlVXBkYXRlKGRvbUVsZW1lbnQsdHlwZSxvbGRQcm9wcyxuZXdQcm9wcyxyb290Q29udGFpbmVySW5zdGFuY2UsaG9zdENvbnRleHQpe3t2YXIgaG9zdENvbnRleHREZXY9aG9zdENvbnRleHQ7aWYodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuIT09dHlwZW9mIG9sZFByb3BzLmNoaWxkcmVuJiYodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuPT09J3N0cmluZyd8fHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbj09PSdudW1iZXInKSl7dmFyIHN0cmluZz0nJytuZXdQcm9wcy5jaGlsZHJlbjt2YXIgb3duQW5jZXN0b3JJbmZvPXVwZGF0ZWRBbmNlc3RvckluZm8oaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLHR5cGUpO3ZhbGlkYXRlRE9NTmVzdGluZyhudWxsLHN0cmluZyxvd25BbmNlc3RvckluZm8pO319cmV0dXJuIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsdHlwZSxvbGRQcm9wcyxuZXdQcm9wcyk7fWZ1bmN0aW9uIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUscHJvcHMpe3JldHVybiB0eXBlPT09J3RleHRhcmVhJ3x8dHlwZT09PSdub3NjcmlwdCd8fHR5cGVvZiBwcm9wcy5jaGlsZHJlbj09PSdzdHJpbmcnfHx0eXBlb2YgcHJvcHMuY2hpbGRyZW49PT0nbnVtYmVyJ3x8dHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPT09J29iamVjdCcmJnByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIT09bnVsbCYmcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sIT1udWxsO31mdW5jdGlvbiBjcmVhdGVUZXh0SW5zdGFuY2UodGV4dCxyb290Q29udGFpbmVySW5zdGFuY2UsaG9zdENvbnRleHQsaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSl7e3ZhciBob3N0Q29udGV4dERldj1ob3N0Q29udGV4dDt2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCx0ZXh0LGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7fXZhciB0ZXh0Tm9kZT1jcmVhdGVUZXh0Tm9kZSh0ZXh0LHJvb3RDb250YWluZXJJbnN0YW5jZSk7cHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSx0ZXh0Tm9kZSk7cmV0dXJuIHRleHROb2RlO31mdW5jdGlvbiBnZXRDdXJyZW50RXZlbnRQcmlvcml0eSgpe3ZhciBjdXJyZW50RXZlbnQ9d2luZG93LmV2ZW50O2lmKGN1cnJlbnRFdmVudD09PXVuZGVmaW5lZCl7cmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O31yZXR1cm4gZ2V0RXZlbnRQcmlvcml0eShjdXJyZW50RXZlbnQudHlwZSk7fS8vIGlmIGEgY29tcG9uZW50IGp1c3QgaW1wb3J0cyBSZWFjdERPTSAoZS5nLiBmb3IgZmluZERPTU5vZGUpLlxuLy8gU29tZSBlbnZpcm9ubWVudHMgbWlnaHQgbm90IGhhdmUgc2V0VGltZW91dCBvciBjbGVhclRpbWVvdXQuXG52YXIgc2NoZWR1bGVUaW1lb3V0PXR5cGVvZiBzZXRUaW1lb3V0PT09J2Z1bmN0aW9uJz9zZXRUaW1lb3V0OnVuZGVmaW5lZDt2YXIgY2FuY2VsVGltZW91dD10eXBlb2YgY2xlYXJUaW1lb3V0PT09J2Z1bmN0aW9uJz9jbGVhclRpbWVvdXQ6dW5kZWZpbmVkO3ZhciBub1RpbWVvdXQ9LTE7dmFyIGxvY2FsUHJvbWlzZT10eXBlb2YgUHJvbWlzZT09PSdmdW5jdGlvbic/UHJvbWlzZTp1bmRlZmluZWQ7Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIHNjaGVkdWxlTWljcm90YXNrPXR5cGVvZiBxdWV1ZU1pY3JvdGFzaz09PSdmdW5jdGlvbic/cXVldWVNaWNyb3Rhc2s6dHlwZW9mIGxvY2FsUHJvbWlzZSE9PSd1bmRlZmluZWQnP2Z1bmN0aW9uKGNhbGxiYWNrKXtyZXR1cm4gbG9jYWxQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbihjYWxsYmFjaykuY2F0Y2goaGFuZGxlRXJyb3JJbk5leHRUaWNrKTt9OnNjaGVkdWxlVGltZW91dDsvLyBUT0RPOiBEZXRlcm1pbmUgdGhlIGJlc3QgZmFsbGJhY2sgaGVyZS5cbmZ1bmN0aW9uIGhhbmRsZUVycm9ySW5OZXh0VGljayhlcnJvcil7c2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGVycm9yO30pO30vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBjb21taXRNb3VudChkb21FbGVtZW50LHR5cGUsbmV3UHJvcHMsaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSl7Ly8gRGVzcGl0ZSB0aGUgbmFtaW5nIHRoYXQgbWlnaHQgaW1wbHkgb3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCBvbmx5XG4vLyBmaXJlcyBpZiB0aGVyZSBpcyBhbiBgVXBkYXRlYCBlZmZlY3Qgc2NoZWR1bGVkIGR1cmluZyBtb3VudGluZy5cbi8vIFRoaXMgaGFwcGVucyBpZiBgZmluYWxpemVJbml0aWFsQ2hpbGRyZW5gIHJldHVybnMgYHRydWVgICh3aGljaCBpdFxuLy8gZG9lcyB0byBpbXBsZW1lbnQgdGhlIGBhdXRvRm9jdXNgIGF0dHJpYnV0ZSBvbiB0aGUgY2xpZW50KS4gQnV0XG4vLyB0aGVyZSBhcmUgYWxzbyBvdGhlciBjYXNlcyB3aGVuIHRoaXMgbWlnaHQgaGFwcGVuIChzdWNoIGFzIHBhdGNoaW5nXG4vLyB1cCB0ZXh0IGNvbnRlbnQgZHVyaW5nIGh5ZHJhdGlvbiBtaXNtYXRjaCkuIFNvIHdlJ2xsIGNoZWNrIHRoaXMgYWdhaW4uXG5zd2l0Y2godHlwZSl7Y2FzZSdidXR0b24nOmNhc2UnaW5wdXQnOmNhc2Unc2VsZWN0JzpjYXNlJ3RleHRhcmVhJzppZihuZXdQcm9wcy5hdXRvRm9jdXMpe2RvbUVsZW1lbnQuZm9jdXMoKTt9cmV0dXJuO2Nhc2UnaW1nJzp7aWYobmV3UHJvcHMuc3JjKXtkb21FbGVtZW50LnNyYz1uZXdQcm9wcy5zcmM7fXJldHVybjt9fX1mdW5jdGlvbiBjb21taXRVcGRhdGUoZG9tRWxlbWVudCx1cGRhdGVQYXlsb2FkLHR5cGUsb2xkUHJvcHMsbmV3UHJvcHMsaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSl7Ly8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIERPTSBub2RlLlxudXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LHVwZGF0ZVBheWxvYWQsdHlwZSxvbGRQcm9wcyxuZXdQcm9wcyk7Ly8gVXBkYXRlIHRoZSBwcm9wcyBoYW5kbGUgc28gdGhhdCB3ZSBrbm93IHdoaWNoIHByb3BzIGFyZSB0aGUgb25lcyB3aXRoXG4vLyB3aXRoIGN1cnJlbnQgZXZlbnQgaGFuZGxlcnMuXG51cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsbmV3UHJvcHMpO31mdW5jdGlvbiByZXNldFRleHRDb250ZW50KGRvbUVsZW1lbnQpe3NldFRleHRDb250ZW50KGRvbUVsZW1lbnQsJycpO31mdW5jdGlvbiBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSxvbGRUZXh0LG5ld1RleHQpe3RleHRJbnN0YW5jZS5ub2RlVmFsdWU9bmV3VGV4dDt9ZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50SW5zdGFuY2UsY2hpbGQpe3BhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTt9ZnVuY3Rpb24gYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihjb250YWluZXIsY2hpbGQpe3ZhciBwYXJlbnROb2RlO2lmKGNvbnRhaW5lci5ub2RlVHlwZT09PUNPTU1FTlRfTk9ERSl7cGFyZW50Tm9kZT1jb250YWluZXIucGFyZW50Tm9kZTtwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCxjb250YWluZXIpO31lbHNle3BhcmVudE5vZGU9Y29udGFpbmVyO3BhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO30vLyBUaGlzIGNvbnRhaW5lciBtaWdodCBiZSB1c2VkIGZvciBhIHBvcnRhbC5cbi8vIElmIHNvbWV0aGluZyBpbnNpZGUgYSBwb3J0YWwgaXMgY2xpY2tlZCwgdGhhdCBjbGljayBzaG91bGQgYnViYmxlXG4vLyB0aHJvdWdoIHRoZSBSZWFjdCB0cmVlLiBIb3dldmVyLCBvbiBNb2JpbGUgU2FmYXJpIHRoZSBjbGljayB3b3VsZFxuLy8gbmV2ZXIgYnViYmxlIHRocm91Z2ggdGhlICpET00qIHRyZWUgdW5sZXNzIGFuIGFuY2VzdG9yIHdpdGggb25jbGlja1xuLy8gZXZlbnQgZXhpc3RzLiBTbyB3ZSB3b3VsZG4ndCBzZWUgaXQgYW5kIGRpc3BhdGNoIGl0LlxuLy8gVGhpcyBpcyB3aHkgd2UgZW5zdXJlIHRoYXQgbm9uIFJlYWN0IHJvb3QgY29udGFpbmVycyBoYXZlIGlubGluZSBvbmNsaWNrXG4vLyBkZWZpbmVkLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTkxOFxudmFyIHJlYWN0Um9vdENvbnRhaW5lcj1jb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtpZigocmVhY3RSb290Q29udGFpbmVyPT09bnVsbHx8cmVhY3RSb290Q29udGFpbmVyPT09dW5kZWZpbmVkKSYmcGFyZW50Tm9kZS5vbmNsaWNrPT09bnVsbCl7Ly8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbnRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KHBhcmVudE5vZGUpO319ZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudEluc3RhbmNlLGNoaWxkLGJlZm9yZUNoaWxkKXtwYXJlbnRJbnN0YW5jZS5pbnNlcnRCZWZvcmUoY2hpbGQsYmVmb3JlQ2hpbGQpO31mdW5jdGlvbiBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShjb250YWluZXIsY2hpbGQsYmVmb3JlQ2hpbGQpe2lmKGNvbnRhaW5lci5ub2RlVHlwZT09PUNPTU1FTlRfTk9ERSl7Y29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLGJlZm9yZUNoaWxkKTt9ZWxzZXtjb250YWluZXIuaW5zZXJ0QmVmb3JlKGNoaWxkLGJlZm9yZUNoaWxkKTt9fWZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudEluc3RhbmNlLGNoaWxkKXtwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChjaGlsZCk7fWZ1bmN0aW9uIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjb250YWluZXIsY2hpbGQpe2lmKGNvbnRhaW5lci5ub2RlVHlwZT09PUNPTU1FTlRfTk9ERSl7Y29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO31lbHNle2NvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7fX1mdW5jdGlvbiBjbGVhclN1c3BlbnNlQm91bmRhcnkocGFyZW50SW5zdGFuY2Usc3VzcGVuc2VJbnN0YW5jZSl7dmFyIG5vZGU9c3VzcGVuc2VJbnN0YW5jZTsvLyBEZWxldGUgYWxsIG5vZGVzIHdpdGhpbiB0aGlzIHN1c3BlbnNlIGJvdW5kYXJ5LlxuLy8gVGhlcmUgbWlnaHQgYmUgbmVzdGVkIG5vZGVzIHNvIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBob3dcbi8vIGRlZXAgd2UgYXJlIGFuZCBvbmx5IGJyZWFrIG91dCB3aGVuIHdlJ3JlIGJhY2sgb24gdG9wLlxudmFyIGRlcHRoPTA7ZG97dmFyIG5leHROb2RlPW5vZGUubmV4dFNpYmxpbmc7cGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQobm9kZSk7aWYobmV4dE5vZGUmJm5leHROb2RlLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFKXt2YXIgZGF0YT1uZXh0Tm9kZS5kYXRhO2lmKGRhdGE9PT1TVVNQRU5TRV9FTkRfREFUQSl7aWYoZGVwdGg9PT0wKXtwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChuZXh0Tm9kZSk7Ly8gUmV0cnkgaWYgYW55IGV2ZW50IHJlcGxheWluZyB3YXMgYmxvY2tlZCBvbiB0aGlzLlxucmV0cnlJZkJsb2NrZWRPbihzdXNwZW5zZUluc3RhbmNlKTtyZXR1cm47fWVsc2V7ZGVwdGgtLTt9fWVsc2UgaWYoZGF0YT09PVNVU1BFTlNFX1NUQVJUX0RBVEF8fGRhdGE9PT1TVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEF8fGRhdGE9PT1TVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBKXtkZXB0aCsrO319bm9kZT1uZXh0Tm9kZTt9d2hpbGUobm9kZSk7Ly8gVE9ETzogV2Fybiwgd2UgZGlkbid0IGZpbmQgdGhlIGVuZCBjb21tZW50IGJvdW5kYXJ5LlxuLy8gUmV0cnkgaWYgYW55IGV2ZW50IHJlcGxheWluZyB3YXMgYmxvY2tlZCBvbiB0aGlzLlxucmV0cnlJZkJsb2NrZWRPbihzdXNwZW5zZUluc3RhbmNlKTt9ZnVuY3Rpb24gY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcihjb250YWluZXIsc3VzcGVuc2VJbnN0YW5jZSl7aWYoY29udGFpbmVyLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFKXtjbGVhclN1c3BlbnNlQm91bmRhcnkoY29udGFpbmVyLnBhcmVudE5vZGUsc3VzcGVuc2VJbnN0YW5jZSk7fWVsc2UgaWYoY29udGFpbmVyLm5vZGVUeXBlPT09RUxFTUVOVF9OT0RFKXtjbGVhclN1c3BlbnNlQm91bmRhcnkoY29udGFpbmVyLHN1c3BlbnNlSW5zdGFuY2UpO30vLyBSZXRyeSBpZiBhbnkgZXZlbnQgcmVwbGF5aW5nIHdhcyBibG9ja2VkIG9uIHRoaXMuXG5yZXRyeUlmQmxvY2tlZE9uKGNvbnRhaW5lcik7fWZ1bmN0aW9uIGhpZGVJbnN0YW5jZShpbnN0YW5jZSl7Ly8gVE9ETzogRG9lcyB0aGlzIHdvcmsgZm9yIGFsbCBlbGVtZW50IHR5cGVzPyBXaGF0IGFib3V0IE1hdGhNTD8gU2hvdWxkIHdlXG4vLyBwYXNzIGhvc3QgY29udGV4dCB0byB0aGlzIG1ldGhvZD9cbmluc3RhbmNlPWluc3RhbmNlO3ZhciBzdHlsZT1pbnN0YW5jZS5zdHlsZTtpZih0eXBlb2Ygc3R5bGUuc2V0UHJvcGVydHk9PT0nZnVuY3Rpb24nKXtzdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsJ25vbmUnLCdpbXBvcnRhbnQnKTt9ZWxzZXtzdHlsZS5kaXNwbGF5PSdub25lJzt9fWZ1bmN0aW9uIGhpZGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlKXt0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlPScnO31mdW5jdGlvbiB1bmhpZGVJbnN0YW5jZShpbnN0YW5jZSxwcm9wcyl7aW5zdGFuY2U9aW5zdGFuY2U7dmFyIHN0eWxlUHJvcD1wcm9wc1tTVFlMRSQxXTt2YXIgZGlzcGxheT1zdHlsZVByb3AhPT11bmRlZmluZWQmJnN0eWxlUHJvcCE9PW51bGwmJnN0eWxlUHJvcC5oYXNPd25Qcm9wZXJ0eSgnZGlzcGxheScpP3N0eWxlUHJvcC5kaXNwbGF5Om51bGw7aW5zdGFuY2Uuc3R5bGUuZGlzcGxheT1kYW5nZXJvdXNTdHlsZVZhbHVlKCdkaXNwbGF5JyxkaXNwbGF5KTt9ZnVuY3Rpb24gdW5oaWRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSx0ZXh0KXt0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlPXRleHQ7fWZ1bmN0aW9uIGNsZWFyQ29udGFpbmVyKGNvbnRhaW5lcil7aWYoY29udGFpbmVyLm5vZGVUeXBlPT09RUxFTUVOVF9OT0RFKXtjb250YWluZXIudGV4dENvbnRlbnQ9Jyc7fWVsc2UgaWYoY29udGFpbmVyLm5vZGVUeXBlPT09RE9DVU1FTlRfTk9ERSl7aWYoY29udGFpbmVyLmRvY3VtZW50RWxlbWVudCl7Y29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQpO319fS8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSx0eXBlLHByb3BzKXtpZihpbnN0YW5jZS5ub2RlVHlwZSE9PUVMRU1FTlRfTk9ERXx8dHlwZS50b0xvd2VyQ2FzZSgpIT09aW5zdGFuY2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSl7cmV0dXJuIG51bGw7fS8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYW4gZWxlbWVudCBub2RlLlxucmV0dXJuIGluc3RhbmNlO31mdW5jdGlvbiBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKGluc3RhbmNlLHRleHQpe2lmKHRleHQ9PT0nJ3x8aW5zdGFuY2Uubm9kZVR5cGUhPT1URVhUX05PREUpey8vIEVtcHR5IHN0cmluZ3MgYXJlIG5vdCBwYXJzZWQgYnkgSFRNTCBzbyB0aGVyZSB3b24ndCBiZSBhIGNvcnJlY3QgbWF0Y2ggaGVyZS5cbnJldHVybiBudWxsO30vLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGEgdGV4dCBub2RlLlxucmV0dXJuIGluc3RhbmNlO31mdW5jdGlvbiBjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZShpbnN0YW5jZSl7aWYoaW5zdGFuY2Uubm9kZVR5cGUhPT1DT01NRU5UX05PREUpey8vIEVtcHR5IHN0cmluZ3MgYXJlIG5vdCBwYXJzZWQgYnkgSFRNTCBzbyB0aGVyZSB3b24ndCBiZSBhIGNvcnJlY3QgbWF0Y2ggaGVyZS5cbnJldHVybiBudWxsO30vLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGEgc3VzcGVuc2Ugbm9kZS5cbnJldHVybiBpbnN0YW5jZTt9ZnVuY3Rpb24gaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhpbnN0YW5jZSl7cmV0dXJuIGluc3RhbmNlLmRhdGE9PT1TVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEE7fWZ1bmN0aW9uIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKGluc3RhbmNlKXtyZXR1cm4gaW5zdGFuY2UuZGF0YT09PVNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEE7fWZ1bmN0aW9uIGdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscyhpbnN0YW5jZSl7dmFyIGRhdGFzZXQ9aW5zdGFuY2UubmV4dFNpYmxpbmcmJmluc3RhbmNlLm5leHRTaWJsaW5nLmRhdGFzZXQ7dmFyIGRpZ2VzdCxtZXNzYWdlLHN0YWNrO2lmKGRhdGFzZXQpe2RpZ2VzdD1kYXRhc2V0LmRnc3Q7e21lc3NhZ2U9ZGF0YXNldC5tc2c7c3RhY2s9ZGF0YXNldC5zdGNrO319e3JldHVybnttZXNzYWdlOm1lc3NhZ2UsZGlnZXN0OmRpZ2VzdCxzdGFjazpzdGFja307fS8vIGxldCB2YWx1ZSA9IHttZXNzYWdlOiB1bmRlZmluZWQsIGhhc2g6IHVuZGVmaW5lZH07XG4vLyBjb25zdCBuZXh0U2libGluZyA9IGluc3RhbmNlLm5leHRTaWJsaW5nO1xuLy8gaWYgKG5leHRTaWJsaW5nKSB7XG4vLyAgIGNvbnN0IGRhdGFzZXQgPSAoKG5leHRTaWJsaW5nOiBhbnkpOiBIVE1MVGVtcGxhdGVFbGVtZW50KS5kYXRhc2V0O1xuLy8gICB2YWx1ZS5tZXNzYWdlID0gZGF0YXNldC5tc2c7XG4vLyAgIHZhbHVlLmhhc2ggPSBkYXRhc2V0Lmhhc2g7XG4vLyAgIGlmICh0cnVlKSB7XG4vLyAgICAgdmFsdWUuc3RhY2sgPSBkYXRhc2V0LnN0YWNrO1xuLy8gICB9XG4vLyB9XG4vLyByZXR1cm4gdmFsdWU7XG59ZnVuY3Rpb24gcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkoaW5zdGFuY2UsY2FsbGJhY2spe2luc3RhbmNlLl9yZWFjdFJldHJ5PWNhbGxiYWNrO31mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZShub2RlKXsvLyBTa2lwIG5vbi1oeWRyYXRhYmxlIG5vZGVzLlxuZm9yKDtub2RlIT1udWxsO25vZGU9bm9kZS5uZXh0U2libGluZyl7dmFyIG5vZGVUeXBlPW5vZGUubm9kZVR5cGU7aWYobm9kZVR5cGU9PT1FTEVNRU5UX05PREV8fG5vZGVUeXBlPT09VEVYVF9OT0RFKXticmVhazt9aWYobm9kZVR5cGU9PT1DT01NRU5UX05PREUpe3ZhciBub2RlRGF0YT1ub2RlLmRhdGE7aWYobm9kZURhdGE9PT1TVVNQRU5TRV9TVEFSVF9EQVRBfHxub2RlRGF0YT09PVNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEF8fG5vZGVEYXRhPT09U1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBKXticmVhazt9aWYobm9kZURhdGE9PT1TVVNQRU5TRV9FTkRfREFUQSl7cmV0dXJuIG51bGw7fX19cmV0dXJuIG5vZGU7fWZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlU2libGluZyhpbnN0YW5jZSl7cmV0dXJuIGdldE5leHRIeWRyYXRhYmxlKGluc3RhbmNlLm5leHRTaWJsaW5nKTt9ZnVuY3Rpb24gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQocGFyZW50SW5zdGFuY2Upe3JldHVybiBnZXROZXh0SHlkcmF0YWJsZShwYXJlbnRJbnN0YW5jZS5maXJzdENoaWxkKTt9ZnVuY3Rpb24gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIocGFyZW50Q29udGFpbmVyKXtyZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGUocGFyZW50Q29udGFpbmVyLmZpcnN0Q2hpbGQpO31mdW5jdGlvbiBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UocGFyZW50SW5zdGFuY2Upe3JldHVybiBnZXROZXh0SHlkcmF0YWJsZShwYXJlbnRJbnN0YW5jZS5uZXh0U2libGluZyk7fWZ1bmN0aW9uIGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSx0eXBlLHByb3BzLHJvb3RDb250YWluZXJJbnN0YW5jZSxob3N0Q29udGV4dCxpbnRlcm5hbEluc3RhbmNlSGFuZGxlLHNob3VsZFdhcm5EZXYpe3ByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsaW5zdGFuY2UpOy8vIFRPRE86IFBvc3NpYmx5IGRlZmVyIHRoaXMgdW50aWwgdGhlIGNvbW1pdCBwaGFzZSB3aGVyZSBhbGwgdGhlIGV2ZW50c1xuLy8gZ2V0IGF0dGFjaGVkLlxudXBkYXRlRmliZXJQcm9wcyhpbnN0YW5jZSxwcm9wcyk7dmFyIHBhcmVudE5hbWVzcGFjZTt7dmFyIGhvc3RDb250ZXh0RGV2PWhvc3RDb250ZXh0O3BhcmVudE5hbWVzcGFjZT1ob3N0Q29udGV4dERldi5uYW1lc3BhY2U7fS8vIFRPRE86IFRlbXBvcmFyeSBoYWNrIHRvIGNoZWNrIGlmIHdlJ3JlIGluIGEgY29uY3VycmVudCByb290LiBXZSBjYW4gZGVsZXRlXG4vLyB3aGVuIHRoZSBsZWdhY3kgcm9vdCBBUEkgaXMgcmVtb3ZlZC5cbnZhciBpc0NvbmN1cnJlbnRNb2RlPShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLm1vZGUmQ29uY3VycmVudE1vZGUpIT09Tm9Nb2RlO3JldHVybiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzKGluc3RhbmNlLHR5cGUscHJvcHMscGFyZW50TmFtZXNwYWNlLHJvb3RDb250YWluZXJJbnN0YW5jZSxpc0NvbmN1cnJlbnRNb2RlLHNob3VsZFdhcm5EZXYpO31mdW5jdGlvbiBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSx0ZXh0LGludGVybmFsSW5zdGFuY2VIYW5kbGUsc2hvdWxkV2FybkRldil7cHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSx0ZXh0SW5zdGFuY2UpOy8vIFRPRE86IFRlbXBvcmFyeSBoYWNrIHRvIGNoZWNrIGlmIHdlJ3JlIGluIGEgY29uY3VycmVudCByb290LiBXZSBjYW4gZGVsZXRlXG4vLyB3aGVuIHRoZSBsZWdhY3kgcm9vdCBBUEkgaXMgcmVtb3ZlZC5cbnZhciBpc0NvbmN1cnJlbnRNb2RlPShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLm1vZGUmQ29uY3VycmVudE1vZGUpIT09Tm9Nb2RlO3JldHVybiBkaWZmSHlkcmF0ZWRUZXh0KHRleHRJbnN0YW5jZSx0ZXh0KTt9ZnVuY3Rpb24gaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSxpbnRlcm5hbEluc3RhbmNlSGFuZGxlKXtwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLHN1c3BlbnNlSW5zdGFuY2UpO31mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2Upe3ZhciBub2RlPXN1c3BlbnNlSW5zdGFuY2UubmV4dFNpYmxpbmc7Ly8gU2tpcCBwYXN0IGFsbCBub2RlcyB3aXRoaW4gdGhpcyBzdXNwZW5zZSBib3VuZGFyeS5cbi8vIFRoZXJlIG1pZ2h0IGJlIG5lc3RlZCBub2RlcyBzbyB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgaG93XG4vLyBkZWVwIHdlIGFyZSBhbmQgb25seSBicmVhayBvdXQgd2hlbiB3ZSdyZSBiYWNrIG9uIHRvcC5cbnZhciBkZXB0aD0wO3doaWxlKG5vZGUpe2lmKG5vZGUubm9kZVR5cGU9PT1DT01NRU5UX05PREUpe3ZhciBkYXRhPW5vZGUuZGF0YTtpZihkYXRhPT09U1VTUEVOU0VfRU5EX0RBVEEpe2lmKGRlcHRoPT09MCl7cmV0dXJuIGdldE5leHRIeWRyYXRhYmxlU2libGluZyhub2RlKTt9ZWxzZXtkZXB0aC0tO319ZWxzZSBpZihkYXRhPT09U1VTUEVOU0VfU1RBUlRfREFUQXx8ZGF0YT09PVNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEF8fGRhdGE9PT1TVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEpe2RlcHRoKys7fX1ub2RlPW5vZGUubmV4dFNpYmxpbmc7fS8vIFRPRE86IFdhcm4sIHdlIGRpZG4ndCBmaW5kIHRoZSBlbmQgY29tbWVudCBib3VuZGFyeS5cbnJldHVybiBudWxsO30vLyBSZXR1cm5zIHRoZSBTdXNwZW5zZUluc3RhbmNlIGlmIHRoaXMgbm9kZSBpcyBhIGRpcmVjdCBjaGlsZCBvZiBhXG4vLyBTdXNwZW5zZUluc3RhbmNlLiBJLmUuIGlmIGl0cyBwcmV2aW91cyBzaWJsaW5nIGlzIGEgQ29tbWVudCB3aXRoXG4vLyBTVVNQRU5TRV94X1NUQVJUX0RBVEEuIE90aGVyd2lzZSwgbnVsbC5cbmZ1bmN0aW9uIGdldFBhcmVudFN1c3BlbnNlSW5zdGFuY2UodGFyZ2V0SW5zdGFuY2Upe3ZhciBub2RlPXRhcmdldEluc3RhbmNlLnByZXZpb3VzU2libGluZzsvLyBTa2lwIHBhc3QgYWxsIG5vZGVzIHdpdGhpbiB0aGlzIHN1c3BlbnNlIGJvdW5kYXJ5LlxuLy8gVGhlcmUgbWlnaHQgYmUgbmVzdGVkIG5vZGVzIHNvIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBob3dcbi8vIGRlZXAgd2UgYXJlIGFuZCBvbmx5IGJyZWFrIG91dCB3aGVuIHdlJ3JlIGJhY2sgb24gdG9wLlxudmFyIGRlcHRoPTA7d2hpbGUobm9kZSl7aWYobm9kZS5ub2RlVHlwZT09PUNPTU1FTlRfTk9ERSl7dmFyIGRhdGE9bm9kZS5kYXRhO2lmKGRhdGE9PT1TVVNQRU5TRV9TVEFSVF9EQVRBfHxkYXRhPT09U1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQXx8ZGF0YT09PVNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQSl7aWYoZGVwdGg9PT0wKXtyZXR1cm4gbm9kZTt9ZWxzZXtkZXB0aC0tO319ZWxzZSBpZihkYXRhPT09U1VTUEVOU0VfRU5EX0RBVEEpe2RlcHRoKys7fX1ub2RlPW5vZGUucHJldmlvdXNTaWJsaW5nO31yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gY29tbWl0SHlkcmF0ZWRDb250YWluZXIoY29udGFpbmVyKXsvLyBSZXRyeSBpZiBhbnkgZXZlbnQgcmVwbGF5aW5nIHdhcyBibG9ja2VkIG9uIHRoaXMuXG5yZXRyeUlmQmxvY2tlZE9uKGNvbnRhaW5lcik7fWZ1bmN0aW9uIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKXsvLyBSZXRyeSBpZiBhbnkgZXZlbnQgcmVwbGF5aW5nIHdhcyBibG9ja2VkIG9uIHRoaXMuXG5yZXRyeUlmQmxvY2tlZE9uKHN1c3BlbnNlSW5zdGFuY2UpO31mdW5jdGlvbiBzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyhwYXJlbnRUeXBlKXtyZXR1cm4gcGFyZW50VHlwZSE9PSdoZWFkJyYmcGFyZW50VHlwZSE9PSdib2R5Jzt9ZnVuY3Rpb24gZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsdGV4dEluc3RhbmNlLHRleHQsaXNDb25jdXJyZW50TW9kZSl7dmFyIHNob3VsZFdhcm5EZXY9dHJ1ZTtjaGVja0ZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLm5vZGVWYWx1ZSx0ZXh0LGlzQ29uY3VycmVudE1vZGUsc2hvdWxkV2FybkRldik7fWZ1bmN0aW9uIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSxwYXJlbnRQcm9wcyxwYXJlbnRJbnN0YW5jZSx0ZXh0SW5zdGFuY2UsdGV4dCxpc0NvbmN1cnJlbnRNb2RlKXtpZihwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSE9PXRydWUpe3ZhciBzaG91bGRXYXJuRGV2PXRydWU7Y2hlY2tGb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZS5ub2RlVmFsdWUsdGV4dCxpc0NvbmN1cnJlbnRNb2RlLHNob3VsZFdhcm5EZXYpO319ZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lcixpbnN0YW5jZSl7e2lmKGluc3RhbmNlLm5vZGVUeXBlPT09RUxFTUVOVF9OT0RFKXt3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudENvbnRhaW5lcixpbnN0YW5jZSk7fWVsc2UgaWYoaW5zdGFuY2Uubm9kZVR5cGU9PT1DT01NRU5UX05PREUpO2Vsc2V7d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRDb250YWluZXIsaW5zdGFuY2UpO319fWZ1bmN0aW9uIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UocGFyZW50SW5zdGFuY2UsaW5zdGFuY2Upe3svLyAkRmxvd0ZpeE1lOiBPbmx5IEVsZW1lbnQgb3IgRG9jdW1lbnQgY2FuIGJlIHBhcmVudCBub2Rlcy5cbnZhciBwYXJlbnROb2RlPXBhcmVudEluc3RhbmNlLnBhcmVudE5vZGU7aWYocGFyZW50Tm9kZSE9PW51bGwpe2lmKGluc3RhbmNlLm5vZGVUeXBlPT09RUxFTUVOVF9OT0RFKXt3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudE5vZGUsaW5zdGFuY2UpO31lbHNlIGlmKGluc3RhbmNlLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFKTtlbHNle3dhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Tm9kZSxpbnN0YW5jZSk7fX19fWZ1bmN0aW9uIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShwYXJlbnRUeXBlLHBhcmVudFByb3BzLHBhcmVudEluc3RhbmNlLGluc3RhbmNlLGlzQ29uY3VycmVudE1vZGUpe3tpZihpc0NvbmN1cnJlbnRNb2RlfHxwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSE9PXRydWUpe2lmKGluc3RhbmNlLm5vZGVUeXBlPT09RUxFTUVOVF9OT0RFKXt3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLGluc3RhbmNlKTt9ZWxzZSBpZihpbnN0YW5jZS5ub2RlVHlwZT09PUNPTU1FTlRfTk9ERSk7ZWxzZXt3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudEluc3RhbmNlLGluc3RhbmNlKTt9fX19ZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcihwYXJlbnRDb250YWluZXIsdHlwZSxwcm9wcyl7e3dhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRDb250YWluZXIsdHlwZSk7fX1mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcihwYXJlbnRDb250YWluZXIsdGV4dCl7e3dhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRDb250YWluZXIsdGV4dCk7fX1mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRJbnN0YW5jZSx0eXBlLHByb3BzKXt7Ly8gJEZsb3dGaXhNZTogT25seSBFbGVtZW50IG9yIERvY3VtZW50IGNhbiBiZSBwYXJlbnQgbm9kZXMuXG52YXIgcGFyZW50Tm9kZT1wYXJlbnRJbnN0YW5jZS5wYXJlbnROb2RlO2lmKHBhcmVudE5vZGUhPT1udWxsKXdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnROb2RlLHR5cGUpO319ZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlKHBhcmVudEluc3RhbmNlLHRleHQpe3svLyAkRmxvd0ZpeE1lOiBPbmx5IEVsZW1lbnQgb3IgRG9jdW1lbnQgY2FuIGJlIHBhcmVudCBub2Rlcy5cbnZhciBwYXJlbnROb2RlPXBhcmVudEluc3RhbmNlLnBhcmVudE5vZGU7aWYocGFyZW50Tm9kZSE9PW51bGwpd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudE5vZGUsdGV4dCk7fX1mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUscGFyZW50UHJvcHMscGFyZW50SW5zdGFuY2UsdHlwZSxwcm9wcyxpc0NvbmN1cnJlbnRNb2RlKXt7aWYoaXNDb25jdXJyZW50TW9kZXx8cGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMV0hPT10cnVlKXt3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50SW5zdGFuY2UsdHlwZSk7fX19ZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSxwYXJlbnRQcm9wcyxwYXJlbnRJbnN0YW5jZSx0ZXh0LGlzQ29uY3VycmVudE1vZGUpe3tpZihpc0NvbmN1cnJlbnRNb2RlfHxwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSE9PXRydWUpe3dhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSx0ZXh0KTt9fX1mdW5jdGlvbiBlcnJvckh5ZHJhdGluZ0NvbnRhaW5lcihwYXJlbnRDb250YWluZXIpe3svLyBUT0RPOiBUaGlzIGdldHMgbG9nZ2VkIGJ5IG9uUmVjb3ZlcmFibGVFcnJvciwgdG9vLCBzbyB3ZSBzaG91bGQgYmVcbi8vIGFibGUgdG8gcmVtb3ZlIGl0LlxuZXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkIGR1cmluZyBoeWRyYXRpb24uIFRoZSBzZXJ2ZXIgSFRNTCB3YXMgcmVwbGFjZWQgd2l0aCBjbGllbnQgY29udGVudCBpbiA8JXM+LicscGFyZW50Q29udGFpbmVyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO319ZnVuY3Rpb24gcHJlcGFyZVBvcnRhbE1vdW50KHBvcnRhbEluc3RhbmNlKXtsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhwb3J0YWxJbnN0YW5jZSk7fXZhciByYW5kb21LZXk9TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7dmFyIGludGVybmFsSW5zdGFuY2VLZXk9J19fcmVhY3RGaWJlciQnK3JhbmRvbUtleTt2YXIgaW50ZXJuYWxQcm9wc0tleT0nX19yZWFjdFByb3BzJCcrcmFuZG9tS2V5O3ZhciBpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5PSdfX3JlYWN0Q29udGFpbmVyJCcrcmFuZG9tS2V5O3ZhciBpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXk9J19fcmVhY3RFdmVudHMkJytyYW5kb21LZXk7dmFyIGludGVybmFsRXZlbnRIYW5kbGVyTGlzdGVuZXJzS2V5PSdfX3JlYWN0TGlzdGVuZXJzJCcrcmFuZG9tS2V5O3ZhciBpbnRlcm5hbEV2ZW50SGFuZGxlc1NldEtleT0nX19yZWFjdEhhbmRsZXMkJytyYW5kb21LZXk7ZnVuY3Rpb24gZGV0YWNoRGVsZXRlZEluc3RhbmNlKG5vZGUpey8vIFRPRE86IFRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgb24gaG9zdCBjb21wb25lbnRzLiBJIGRvbid0IHRoaW5rIGFsbCBvZlxuLy8gdGhlc2UgZmllbGRzIGFyZSByZWxldmFudC5cbmRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO2RlbGV0ZSBub2RlW2ludGVybmFsUHJvcHNLZXldO2RlbGV0ZSBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV07ZGVsZXRlIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJMaXN0ZW5lcnNLZXldO2RlbGV0ZSBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVzU2V0S2V5XTt9ZnVuY3Rpb24gcHJlY2FjaGVGaWJlck5vZGUoaG9zdEluc3Qsbm9kZSl7bm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XT1ob3N0SW5zdDt9ZnVuY3Rpb24gbWFya0NvbnRhaW5lckFzUm9vdChob3N0Um9vdCxub2RlKXtub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldPWhvc3RSb290O31mdW5jdGlvbiB1bm1hcmtDb250YWluZXJBc1Jvb3Qobm9kZSl7bm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XT1udWxsO31mdW5jdGlvbiBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChub2RlKXtyZXR1cm4hIW5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV07fS8vIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgY2xvc2VzdCBIb3N0Q29tcG9uZW50IG9yIEhvc3RUZXh0IGZpYmVyIGFuY2VzdG9yLlxuLy8gSWYgdGhlIHRhcmdldCBub2RlIGlzIHBhcnQgb2YgYSBoeWRyYXRlZCBvciBub3QgeWV0IHJlbmRlcmVkIHN1YnRyZWUsIHRoZW5cbi8vIHRoaXMgbWF5IGFsc28gcmV0dXJuIGEgU3VzcGVuc2VDb21wb25lbnQgb3IgSG9zdFJvb3QgdG8gaW5kaWNhdGUgdGhhdC5cbi8vIENvbmNlcHR1YWxseSB0aGUgSG9zdFJvb3QgZmliZXIgaXMgYSBjaGlsZCBvZiB0aGUgQ29udGFpbmVyIG5vZGUuIFNvIGlmIHlvdVxuLy8gcGFzcyB0aGUgQ29udGFpbmVyIG5vZGUgYXMgdGhlIHRhcmdldE5vZGUsIHlvdSB3aWxsIG5vdCBhY3R1YWxseSBnZXQgdGhlXG4vLyBIb3N0Um9vdCBiYWNrLiBUbyBnZXQgdG8gdGhlIEhvc3RSb290LCB5b3UgbmVlZCB0byBwYXNzIGEgY2hpbGQgb2YgaXQuXG4vLyBUaGUgc2FtZSB0aGluZyBhcHBsaWVzIHRvIFN1c3BlbnNlIGJvdW5kYXJpZXMuXG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXROb2RlKXt2YXIgdGFyZ2V0SW5zdD10YXJnZXROb2RlW2ludGVybmFsSW5zdGFuY2VLZXldO2lmKHRhcmdldEluc3Qpey8vIERvbid0IHJldHVybiBIb3N0Um9vdCBvciBTdXNwZW5zZUNvbXBvbmVudCBoZXJlLlxucmV0dXJuIHRhcmdldEluc3Q7fS8vIElmIHRoZSBkaXJlY3QgZXZlbnQgdGFyZ2V0IGlzbid0IGEgUmVhY3Qgb3duZWQgRE9NIG5vZGUsIHdlIG5lZWQgdG8gbG9va1xuLy8gdG8gc2VlIGlmIG9uZSBvZiBpdHMgcGFyZW50cyBpcyBhIFJlYWN0IG93bmVkIERPTSBub2RlLlxudmFyIHBhcmVudE5vZGU9dGFyZ2V0Tm9kZS5wYXJlbnROb2RlO3doaWxlKHBhcmVudE5vZGUpey8vIFdlJ2xsIGNoZWNrIGlmIHRoaXMgaXMgYSBjb250YWluZXIgcm9vdCB0aGF0IGNvdWxkIGluY2x1ZGVcbi8vIFJlYWN0IG5vZGVzIGluIHRoZSBmdXR1cmUuIFdlIG5lZWQgdG8gY2hlY2sgdGhpcyBmaXJzdCBiZWNhdXNlXG4vLyBpZiB3ZSdyZSBhIGNoaWxkIG9mIGEgZGVoeWRyYXRlZCBjb250YWluZXIsIHdlIG5lZWQgdG8gZmlyc3Rcbi8vIGZpbmQgdGhhdCBpbm5lciBjb250YWluZXIgYmVmb3JlIG1vdmluZyBvbiB0byBmaW5kaW5nIHRoZSBwYXJlbnRcbi8vIGluc3RhbmNlLiBOb3RlIHRoYXQgd2UgZG9uJ3QgY2hlY2sgdGhpcyBmaWVsZCBvbiAgdGhlIHRhcmdldE5vZGVcbi8vIGl0c2VsZiBiZWNhdXNlIHRoZSBmaWJlcnMgYXJlIGNvbmNlcHR1YWxseSBiZXR3ZWVuIHRoZSBjb250YWluZXJcbi8vIG5vZGUgYW5kIHRoZSBmaXJzdCBjaGlsZC4gSXQgaXNuJ3Qgc3Vycm91bmRpbmcgdGhlIGNvbnRhaW5lciBub2RlLlxuLy8gSWYgaXQncyBub3QgYSBjb250YWluZXIsIHdlIGNoZWNrIGlmIGl0J3MgYW4gaW5zdGFuY2UuXG50YXJnZXRJbnN0PXBhcmVudE5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV18fHBhcmVudE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07aWYodGFyZ2V0SW5zdCl7Ly8gU2luY2UgdGhpcyB3YXNuJ3QgdGhlIGRpcmVjdCB0YXJnZXQgb2YgdGhlIGV2ZW50LCB3ZSBtaWdodCBoYXZlXG4vLyBzdGVwcGVkIHBhc3QgZGVoeWRyYXRlZCBET00gbm9kZXMgdG8gZ2V0IGhlcmUuIEhvd2V2ZXIgdGhleSBjb3VsZFxuLy8gYWxzbyBoYXZlIGJlZW4gbm9uLVJlYWN0IG5vZGVzLiBXZSBuZWVkIHRvIGFuc3dlciB3aGljaCBvbmUuXG4vLyBJZiB3ZSB0aGUgaW5zdGFuY2UgZG9lc24ndCBoYXZlIGFueSBjaGlsZHJlbiwgdGhlbiB0aGVyZSBjYW4ndCBiZVxuLy8gYSBuZXN0ZWQgc3VzcGVuc2UgYm91bmRhcnkgd2l0aGluIGl0LiBTbyB3ZSBjYW4gdXNlIHRoaXMgYXMgYSBmYXN0XG4vLyBiYWlsb3V0LiBNb3N0IG9mIHRoZSB0aW1lLCB3aGVuIHBlb3BsZSBhZGQgbm9uLVJlYWN0IGNoaWxkcmVuIHRvXG4vLyB0aGUgdHJlZSwgaXQgaXMgdXNpbmcgYSByZWYgdG8gYSBjaGlsZC1sZXNzIERPTSBub2RlLlxuLy8gTm9ybWFsbHkgd2UnZCBvbmx5IG5lZWQgdG8gY2hlY2sgb25lIG9mIHRoZSBmaWJlcnMgYmVjYXVzZSBpZiBpdFxuLy8gaGFzIGV2ZXIgZ29uZSBmcm9tIGhhdmluZyBjaGlsZHJlbiB0byBkZWxldGluZyB0aGVtIG9yIHZpY2UgdmVyc2Fcbi8vIGl0IHdvdWxkIGhhdmUgZGVsZXRlZCB0aGUgZGVoeWRyYXRlZCBib3VuZGFyeSBuZXN0ZWQgaW5zaWRlIGFscmVhZHkuXG4vLyBIb3dldmVyLCBzaW5jZSB0aGUgSG9zdFJvb3Qgc3RhcnRzIG91dCB3aXRoIGFuIGFsdGVybmF0ZSBpdCBtaWdodFxuLy8gaGF2ZSBvbmUgb24gdGhlIGFsdGVybmF0ZSBzbyB3ZSBuZWVkIHRvIGNoZWNrIGluIGNhc2UgdGhpcyB3YXMgYVxuLy8gcm9vdC5cbnZhciBhbHRlcm5hdGU9dGFyZ2V0SW5zdC5hbHRlcm5hdGU7aWYodGFyZ2V0SW5zdC5jaGlsZCE9PW51bGx8fGFsdGVybmF0ZSE9PW51bGwmJmFsdGVybmF0ZS5jaGlsZCE9PW51bGwpey8vIE5leHQgd2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoZSBub2RlIHRoYXQgc2tpcHBlZCBwYXN0IGlzXG4vLyBuZXN0ZWQgd2l0aGluIGEgZGVoeWRyYXRlZCBib3VuZGFyeSBhbmQgaWYgc28sIHdoaWNoIG9uZS5cbnZhciBzdXNwZW5zZUluc3RhbmNlPWdldFBhcmVudFN1c3BlbnNlSW5zdGFuY2UodGFyZ2V0Tm9kZSk7d2hpbGUoc3VzcGVuc2VJbnN0YW5jZSE9PW51bGwpey8vIFdlIGZvdW5kIGEgc3VzcGVuc2UgaW5zdGFuY2UuIFRoYXQgbWVhbnMgdGhhdCB3ZSBoYXZlbid0XG4vLyBoeWRyYXRlZCBpdCB5ZXQuIEV2ZW4gdGhvdWdoIHdlIGxlYXZlIHRoZSBjb21tZW50cyBpbiB0aGVcbi8vIERPTSBhZnRlciBoeWRyYXRpbmcsIGFuZCB0aGVyZSBhcmUgYm91bmRhcmllcyBpbiB0aGUgRE9NXG4vLyB0aGF0IGNvdWxkIGFscmVhZHkgYmUgaHlkcmF0ZWQsIHdlIHdvdWxkbid0IGhhdmUgZm91bmQgdGhlbVxuLy8gdGhyb3VnaCB0aGlzIHBhc3Mgc2luY2UgaWYgdGhlIHRhcmdldCBpcyBoeWRyYXRlZCBpdCB3b3VsZFxuLy8gaGF2ZSBoYWQgYW4gaW50ZXJuYWxJbnN0YW5jZUtleSBvbiBpdC5cbi8vIExldCdzIGdldCB0aGUgZmliZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBTdXNwZW5zZUNvbXBvbmVudFxuLy8gYXMgdGhlIGRlZXBlc3QgaW5zdGFuY2UuXG52YXIgdGFyZ2V0U3VzcGVuc2VJbnN0PXN1c3BlbnNlSW5zdGFuY2VbaW50ZXJuYWxJbnN0YW5jZUtleV07aWYodGFyZ2V0U3VzcGVuc2VJbnN0KXtyZXR1cm4gdGFyZ2V0U3VzcGVuc2VJbnN0O30vLyBJZiB3ZSBkb24ndCBmaW5kIGEgRmliZXIgb24gdGhlIGNvbW1lbnQsIGl0IG1pZ2h0IGJlIGJlY2F1c2Vcbi8vIHdlIGhhdmVuJ3QgZ290dGVuIHRvIGh5ZHJhdGUgaXQgeWV0LiBUaGVyZSBtaWdodCBzdGlsbCBiZSBhXG4vLyBwYXJlbnQgYm91bmRhcnkgdGhhdCBoYXNuJ3QgYWJvdmUgdGhpcyBvbmUgc28gd2UgbmVlZCB0byBmaW5kXG4vLyB0aGUgb3V0ZXIgbW9zdCB0aGF0IGlzIGtub3duLlxuc3VzcGVuc2VJbnN0YW5jZT1nZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpOy8vIElmIHdlIGRvbid0IGZpbmQgb25lLCB0aGVuIHRoYXQgc2hvdWxkIG1lYW4gdGhhdCB0aGUgcGFyZW50XG4vLyBob3N0IGNvbXBvbmVudCBhbHNvIGhhc24ndCBoeWRyYXRlZCB5ZXQuIFdlIGNhbiByZXR1cm4gaXRcbi8vIGJlbG93IHNpbmNlIGl0IHdpbGwgYmFpbCBvdXQgb24gdGhlIGlzTW91bnRlZCBjaGVjayBsYXRlci5cbn19cmV0dXJuIHRhcmdldEluc3Q7fXRhcmdldE5vZGU9cGFyZW50Tm9kZTtwYXJlbnROb2RlPXRhcmdldE5vZGUucGFyZW50Tm9kZTt9cmV0dXJuIG51bGw7fS8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cbiAqL2Z1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUobm9kZSl7dmFyIGluc3Q9bm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XXx8bm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XTtpZihpbnN0KXtpZihpbnN0LnRhZz09PUhvc3RDb21wb25lbnR8fGluc3QudGFnPT09SG9zdFRleHR8fGluc3QudGFnPT09U3VzcGVuc2VDb21wb25lbnR8fGluc3QudGFnPT09SG9zdFJvb3Qpe3JldHVybiBpbnN0O31lbHNle3JldHVybiBudWxsO319cmV0dXJuIG51bGw7fS8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlKGluc3Qpe2lmKGluc3QudGFnPT09SG9zdENvbXBvbmVudHx8aW5zdC50YWc9PT1Ib3N0VGV4dCl7Ly8gSW4gRmliZXIgdGhpcywgaXMganVzdCB0aGUgc3RhdGUgbm9kZSByaWdodCBub3cuIFdlIGFzc3VtZSBpdCB3aWxsIGJlXG4vLyBhIGhvc3QgY29tcG9uZW50IG9yIGhvc3QgdGV4dC5cbnJldHVybiBpbnN0LnN0YXRlTm9kZTt9Ly8gV2l0aG91dCB0aGlzIGZpcnN0IGludmFyaWFudCwgcGFzc2luZyBhIG5vbi1ET00tY29tcG9uZW50IHRyaWdnZXJzIHRoZSBuZXh0XG4vLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbnRocm93IG5ldyBFcnJvcignZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKTt9ZnVuY3Rpb24gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShub2RlKXtyZXR1cm4gbm9kZVtpbnRlcm5hbFByb3BzS2V5XXx8bnVsbDt9ZnVuY3Rpb24gdXBkYXRlRmliZXJQcm9wcyhub2RlLHByb3BzKXtub2RlW2ludGVybmFsUHJvcHNLZXldPXByb3BzO31mdW5jdGlvbiBnZXRFdmVudExpc3RlbmVyU2V0KG5vZGUpe3ZhciBlbGVtZW50TGlzdGVuZXJTZXQ9bm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldO2lmKGVsZW1lbnRMaXN0ZW5lclNldD09PXVuZGVmaW5lZCl7ZWxlbWVudExpc3RlbmVyU2V0PW5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XT1uZXcgU2V0KCk7fXJldHVybiBlbGVtZW50TGlzdGVuZXJTZXQ7fXZhciBsb2dnZWRUeXBlRmFpbHVyZXM9e307dmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMT1SZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO2Z1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpe3tpZihlbGVtZW50KXt2YXIgb3duZXI9ZWxlbWVudC5fb3duZXI7dmFyIHN0YWNrPWRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsZWxlbWVudC5fc291cmNlLG93bmVyP293bmVyLnR5cGU6bnVsbCk7UmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7fWVsc2V7UmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTt9fX1mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsdmFsdWVzLGxvY2F0aW9uLGNvbXBvbmVudE5hbWUsZWxlbWVudCl7ey8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbnZhciBoYXM9RnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtmb3IodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3Mpe2lmKGhhcyh0eXBlU3BlY3MsdHlwZVNwZWNOYW1lKSl7dmFyIGVycm9yJDE9dm9pZCAwOy8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4vLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4vLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG50cnl7Ly8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4vLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG5pZih0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0hPT0nZnVuY3Rpb24nKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xudmFyIGVycj1FcnJvcigoY29tcG9uZW50TmFtZXx8J1JlYWN0IGNsYXNzJykrJzogJytsb2NhdGlvbisnIHR5cGUgYCcrdHlwZVNwZWNOYW1lKydgIGlzIGludmFsaWQ7ICcrJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnK3R5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSsnYC4nKydUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtlcnIubmFtZT0nSW52YXJpYW50IFZpb2xhdGlvbic7dGhyb3cgZXJyO31lcnJvciQxPXR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcyx0eXBlU3BlY05hbWUsY29tcG9uZW50TmFtZSxsb2NhdGlvbixudWxsLCdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO31jYXRjaChleCl7ZXJyb3IkMT1leDt9aWYoZXJyb3IkMSYmIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKXtzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycrJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJysnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcrJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcrJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJysnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsY29tcG9uZW50TmFtZXx8J1JlYWN0IGNsYXNzJyxsb2NhdGlvbix0eXBlU3BlY05hbWUsdHlwZW9mIGVycm9yJDEpO3NldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO31pZihlcnJvciQxIGluc3RhbmNlb2YgRXJyb3ImJiEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpey8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuLy8gc2FtZSBlcnJvci5cbmxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdPXRydWU7c2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7ZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsbG9jYXRpb24sZXJyb3IkMS5tZXNzYWdlKTtzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTt9fX19fXZhciB2YWx1ZVN0YWNrPVtdO3ZhciBmaWJlclN0YWNrO3tmaWJlclN0YWNrPVtdO312YXIgaW5kZXg9LTE7ZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSl7cmV0dXJue2N1cnJlbnQ6ZGVmYXVsdFZhbHVlfTt9ZnVuY3Rpb24gcG9wKGN1cnNvcixmaWJlcil7aWYoaW5kZXg8MCl7e2Vycm9yKCdVbmV4cGVjdGVkIHBvcC4nKTt9cmV0dXJuO317aWYoZmliZXIhPT1maWJlclN0YWNrW2luZGV4XSl7ZXJyb3IoJ1VuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLicpO319Y3Vyc29yLmN1cnJlbnQ9dmFsdWVTdGFja1tpbmRleF07dmFsdWVTdGFja1tpbmRleF09bnVsbDt7ZmliZXJTdGFja1tpbmRleF09bnVsbDt9aW5kZXgtLTt9ZnVuY3Rpb24gcHVzaChjdXJzb3IsdmFsdWUsZmliZXIpe2luZGV4Kys7dmFsdWVTdGFja1tpbmRleF09Y3Vyc29yLmN1cnJlbnQ7e2ZpYmVyU3RhY2tbaW5kZXhdPWZpYmVyO31jdXJzb3IuY3VycmVudD12YWx1ZTt9dmFyIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dDt7d2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0PXt9O312YXIgZW1wdHlDb250ZXh0T2JqZWN0PXt9O3tPYmplY3QuZnJlZXplKGVtcHR5Q29udGV4dE9iamVjdCk7fS8vIEEgY3Vyc29yIHRvIHRoZSBjdXJyZW50IG1lcmdlZCBjb250ZXh0IG9iamVjdCBvbiB0aGUgc3RhY2suXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yPWNyZWF0ZUN1cnNvcihlbXB0eUNvbnRleHRPYmplY3QpOy8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG52YXIgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvcj1jcmVhdGVDdXJzb3IoZmFsc2UpOy8vIEtlZXAgdHJhY2sgb2YgdGhlIHByZXZpb3VzIGNvbnRleHQgb2JqZWN0IHRoYXQgd2FzIG9uIHRoZSBzdGFjay5cbi8vIFdlIHVzZSB0aGlzIHRvIGdldCBhY2Nlc3MgdG8gdGhlIHBhcmVudCBjb250ZXh0IGFmdGVyIHdlIGhhdmUgYWxyZWFkeVxuLy8gcHVzaGVkIHRoZSBuZXh0IGNvbnRleHQgcHJvdmlkZXIsIGFuZCBub3cgbmVlZCB0byBtZXJnZSB0aGVpciBjb250ZXh0cy5cbnZhciBwcmV2aW91c0NvbnRleHQ9ZW1wdHlDb250ZXh0T2JqZWN0O2Z1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyKXt7aWYoZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyJiZpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKXsvLyBJZiB0aGUgZmliZXIgaXMgYSBjb250ZXh0IHByb3ZpZGVyIGl0c2VsZiwgd2hlbiB3ZSByZWFkIGl0cyBjb250ZXh0XG4vLyB3ZSBtYXkgaGF2ZSBhbHJlYWR5IHB1c2hlZCBpdHMgb3duIGNoaWxkIGNvbnRleHQgb24gdGhlIHN0YWNrLiBBIGNvbnRleHRcbi8vIHByb3ZpZGVyIHNob3VsZCBub3QgXCJzZWVcIiBpdHMgb3duIGNoaWxkIGNvbnRleHQuIFRoZXJlZm9yZSB3ZSByZWFkIHRoZVxuLy8gcHJldmlvdXMgKHBhcmVudCkgY29udGV4dCBpbnN0ZWFkIGZvciBhIGNvbnRleHQgcHJvdmlkZXIuXG5yZXR1cm4gcHJldmlvdXNDb250ZXh0O31yZXR1cm4gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7fX1mdW5jdGlvbiBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsdW5tYXNrZWRDb250ZXh0LG1hc2tlZENvbnRleHQpe3t2YXIgaW5zdGFuY2U9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO2luc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9dW5tYXNrZWRDb250ZXh0O2luc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PW1hc2tlZENvbnRleHQ7fX1mdW5jdGlvbiBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLHVubWFza2VkQ29udGV4dCl7e3ZhciB0eXBlPXdvcmtJblByb2dyZXNzLnR5cGU7dmFyIGNvbnRleHRUeXBlcz10eXBlLmNvbnRleHRUeXBlcztpZighY29udGV4dFR5cGVzKXtyZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O30vLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuLy8gRmFpbGluZyB0byBkbyB0aGlzIHdpbGwgcmVzdWx0IGluIHVubmVjZXNzYXJ5IGNhbGxzIHRvIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuXG4vLyBUaGlzIG1heSB0cmlnZ2VyIGluZmluaXRlIGxvb3BzIGlmIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgY2FsbHMgc2V0U3RhdGUuXG52YXIgaW5zdGFuY2U9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO2lmKGluc3RhbmNlJiZpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PT09dW5tYXNrZWRDb250ZXh0KXtyZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7fXZhciBjb250ZXh0PXt9O2Zvcih2YXIga2V5IGluIGNvbnRleHRUeXBlcyl7Y29udGV4dFtrZXldPXVubWFza2VkQ29udGV4dFtrZXldO317dmFyIG5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcyl8fCdVbmtub3duJztjaGVja1Byb3BUeXBlcyhjb250ZXh0VHlwZXMsY29udGV4dCwnY29udGV4dCcsbmFtZSk7fS8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbi8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuaWYoaW5zdGFuY2Upe2NhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyx1bm1hc2tlZENvbnRleHQsY29udGV4dCk7fXJldHVybiBjb250ZXh0O319ZnVuY3Rpb24gaGFzQ29udGV4dENoYW5nZWQoKXt7cmV0dXJuIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudDt9fWZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKHR5cGUpe3t2YXIgY2hpbGRDb250ZXh0VHlwZXM9dHlwZS5jaGlsZENvbnRleHRUeXBlcztyZXR1cm4gY2hpbGRDb250ZXh0VHlwZXMhPT1udWxsJiZjaGlsZENvbnRleHRUeXBlcyE9PXVuZGVmaW5lZDt9fWZ1bmN0aW9uIHBvcENvbnRleHQoZmliZXIpe3twb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvcixmaWJlcik7cG9wKGNvbnRleHRTdGFja0N1cnNvcixmaWJlcik7fX1mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpe3twb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvcixmaWJlcik7cG9wKGNvbnRleHRTdGFja0N1cnNvcixmaWJlcik7fX1mdW5jdGlvbiBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyLGNvbnRleHQsZGlkQ2hhbmdlKXt7aWYoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQhPT1lbXB0eUNvbnRleHRPYmplY3Qpe3Rocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiAnKydUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31wdXNoKGNvbnRleHRTdGFja0N1cnNvcixjb250ZXh0LGZpYmVyKTtwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsZGlkQ2hhbmdlLGZpYmVyKTt9fWZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsdHlwZSxwYXJlbnRDb250ZXh0KXt7dmFyIGluc3RhbmNlPWZpYmVyLnN0YXRlTm9kZTt2YXIgY2hpbGRDb250ZXh0VHlwZXM9dHlwZS5jaGlsZENvbnRleHRUeXBlczsvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuLy8gSXQgaGFzIG9ubHkgYmVlbiBhZGRlZCBpbiBGaWJlciB0byBtYXRjaCB0aGUgKHVuaW50ZW50aW9uYWwpIGJlaGF2aW9yIGluIFN0YWNrLlxuaWYodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCE9PSdmdW5jdGlvbicpe3t2YXIgY29tcG9uZW50TmFtZT1nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J1Vua25vd24nO2lmKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pe3dhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXT10cnVlO2Vycm9yKCclcy5jaGlsZENvbnRleHRUeXBlcyBpcyBzcGVjaWZpZWQgYnV0IHRoZXJlIGlzIG5vIGdldENoaWxkQ29udGV4dCgpIG1ldGhvZCAnKydvbiB0aGUgaW5zdGFuY2UuIFlvdSBjYW4gZWl0aGVyIGRlZmluZSBnZXRDaGlsZENvbnRleHQoKSBvbiAlcyBvciByZW1vdmUgJysnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLGNvbXBvbmVudE5hbWUsY29tcG9uZW50TmFtZSk7fX1yZXR1cm4gcGFyZW50Q29udGV4dDt9dmFyIGNoaWxkQ29udGV4dD1pbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtmb3IodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KXtpZighKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpKXt0aHJvdyBuZXcgRXJyb3IoKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpfHwnVW5rbm93bicpK1wiLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXFxcIlwiK2NvbnRleHRLZXkrXCJcXFwiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLlwiKTt9fXt2YXIgbmFtZT1nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J1Vua25vd24nO2NoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLGNoaWxkQ29udGV4dCwnY2hpbGQgY29udGV4dCcsbmFtZSk7fXJldHVybiBhc3NpZ24oe30scGFyZW50Q29udGV4dCxjaGlsZENvbnRleHQpO319ZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyl7e3ZhciBpbnN0YW5jZT13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7Ly8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuLy8gSWYgdGhlIGluc3RhbmNlIGRvZXMgbm90IGV4aXN0IHlldCwgd2Ugd2lsbCBwdXNoIG51bGwgYXQgZmlyc3QsXG4vLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG52YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ9aW5zdGFuY2UmJmluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0fHxlbXB0eUNvbnRleHRPYmplY3Q7Ly8gUmVtZW1iZXIgdGhlIHBhcmVudCBjb250ZXh0IHNvIHdlIGNhbiBtZXJnZSB3aXRoIGl0IGxhdGVyLlxuLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGlkLXBlcmZvcm0td29yayB2YWx1ZSB0byBhdm9pZCBpbmFkdmVydGVudGx5IGJsb2NraW5nIHVwZGF0ZXMuXG5wcmV2aW91c0NvbnRleHQ9Y29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7cHVzaChjb250ZXh0U3RhY2tDdXJzb3IsbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQsd29ya0luUHJvZ3Jlc3MpO3B1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvcixkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQsd29ya0luUHJvZ3Jlc3MpO3JldHVybiB0cnVlO319ZnVuY3Rpb24gaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyx0eXBlLGRpZENoYW5nZSl7e3ZhciBpbnN0YW5jZT13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7aWYoIWluc3RhbmNlKXt0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gJysnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9aWYoZGlkQ2hhbmdlKXsvLyBNZXJnZSBwYXJlbnQgYW5kIG93biBjb250ZXh0LlxuLy8gU2tpcCB0aGlzIGlmIHdlJ3JlIG5vdCB1cGRhdGluZyBkdWUgdG8gc0NVLlxuLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG52YXIgbWVyZ2VkQ29udGV4dD1wcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLHR5cGUscHJldmlvdXNDb250ZXh0KTtpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dD1tZXJnZWRDb250ZXh0Oy8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbi8vIEl0IGlzIGltcG9ydGFudCB0byB1bndpbmQgdGhlIGNvbnRleHQgaW4gdGhlIHJldmVyc2Ugb3JkZXIuXG5wb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvcix3b3JrSW5Qcm9ncmVzcyk7cG9wKGNvbnRleHRTdGFja0N1cnNvcix3b3JrSW5Qcm9ncmVzcyk7Ly8gTm93IHB1c2ggdGhlIG5ldyBjb250ZXh0IGFuZCBtYXJrIHRoYXQgaXQgaGFzIGNoYW5nZWQuXG5wdXNoKGNvbnRleHRTdGFja0N1cnNvcixtZXJnZWRDb250ZXh0LHdvcmtJblByb2dyZXNzKTtwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsZGlkQ2hhbmdlLHdvcmtJblByb2dyZXNzKTt9ZWxzZXtwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvcix3b3JrSW5Qcm9ncmVzcyk7cHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLGRpZENoYW5nZSx3b3JrSW5Qcm9ncmVzcyk7fX19ZnVuY3Rpb24gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpe3svLyBDdXJyZW50bHkgdGhpcyBpcyBvbmx5IHVzZWQgd2l0aCByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjsgbm90IHN1cmUgaWYgaXRcbi8vIG1ha2VzIHNlbnNlIGVsc2V3aGVyZVxuaWYoIWlzRmliZXJNb3VudGVkKGZpYmVyKXx8ZmliZXIudGFnIT09Q2xhc3NDb21wb25lbnQpe3Rocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgc3VidHJlZSBwYXJlbnQgdG8gYmUgYSBtb3VudGVkIGNsYXNzIGNvbXBvbmVudC4gJysnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9dmFyIG5vZGU9ZmliZXI7ZG97c3dpdGNoKG5vZGUudGFnKXtjYXNlIEhvc3RSb290OnJldHVybiBub2RlLnN0YXRlTm9kZS5jb250ZXh0O2Nhc2UgQ2xhc3NDb21wb25lbnQ6e3ZhciBDb21wb25lbnQ9bm9kZS50eXBlO2lmKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpe3JldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDt9YnJlYWs7fX1ub2RlPW5vZGUucmV0dXJuO313aGlsZShub2RlIT09bnVsbCk7dGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1bmV4cGVjdGVkIGRldGFjaGVkIHN1YnRyZWUgcGFyZW50LiAnKydUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO319dmFyIExlZ2FjeVJvb3Q9MDt2YXIgQ29uY3VycmVudFJvb3Q9MTt2YXIgc3luY1F1ZXVlPW51bGw7dmFyIGluY2x1ZGVzTGVnYWN5U3luY0NhbGxiYWNrcz1mYWxzZTt2YXIgaXNGbHVzaGluZ1N5bmNRdWV1ZT1mYWxzZTtmdW5jdGlvbiBzY2hlZHVsZVN5bmNDYWxsYmFjayhjYWxsYmFjayl7Ly8gUHVzaCB0aGlzIGNhbGxiYWNrIGludG8gYW4gaW50ZXJuYWwgcXVldWUuIFdlJ2xsIGZsdXNoIHRoZXNlIGVpdGhlciBpblxuLy8gdGhlIG5leHQgdGljaywgb3IgZWFybGllciBpZiBzb21ldGhpbmcgY2FsbHMgYGZsdXNoU3luY0NhbGxiYWNrUXVldWVgLlxuaWYoc3luY1F1ZXVlPT09bnVsbCl7c3luY1F1ZXVlPVtjYWxsYmFja107fWVsc2V7Ly8gUHVzaCBvbnRvIGV4aXN0aW5nIHF1ZXVlLiBEb24ndCBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2sgYmVjYXVzZVxuLy8gd2UgYWxyZWFkeSBzY2hlZHVsZWQgb25lIHdoZW4gd2UgY3JlYXRlZCB0aGUgcXVldWUuXG5zeW5jUXVldWUucHVzaChjYWxsYmFjayk7fX1mdW5jdGlvbiBzY2hlZHVsZUxlZ2FjeVN5bmNDYWxsYmFjayhjYWxsYmFjayl7aW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzPXRydWU7c2NoZWR1bGVTeW5jQ2FsbGJhY2soY2FsbGJhY2spO31mdW5jdGlvbiBmbHVzaFN5bmNDYWxsYmFja3NPbmx5SW5MZWdhY3lNb2RlKCl7Ly8gT25seSBmbHVzaGVzIHRoZSBxdWV1ZSBpZiB0aGVyZSdzIGEgbGVnYWN5IHN5bmMgY2FsbGJhY2sgc2NoZWR1bGVkLlxuLy8gVE9ETzogVGhlcmUncyBvbmx5IGEgc2luZ2xlIHR5cGUgb2YgY2FsbGJhY2s6IHBlcmZvcm1TeW5jT25Xb3JrT25Sb290LiBTb1xuLy8gaXQgbWlnaHQgbWFrZSBtb3JlIHNlbnNlIGZvciB0aGUgcXVldWUgdG8gYmUgYSBsaXN0IG9mIHJvb3RzIGluc3RlYWQgb2YgYVxuLy8gbGlzdCBvZiBnZW5lcmljIGNhbGxiYWNrcy4gVGhlbiB3ZSBjYW4gaGF2ZSB0d286IG9uZSBmb3IgbGVnYWN5IHJvb3RzLCBvbmVcbi8vIGZvciBjb25jdXJyZW50IHJvb3RzLiBBbmQgdGhpcyBtZXRob2Qgd291bGQgb25seSBmbHVzaCB0aGUgbGVnYWN5IG9uZXMuXG5pZihpbmNsdWRlc0xlZ2FjeVN5bmNDYWxsYmFja3Mpe2ZsdXNoU3luY0NhbGxiYWNrcygpO319ZnVuY3Rpb24gZmx1c2hTeW5jQ2FsbGJhY2tzKCl7aWYoIWlzRmx1c2hpbmdTeW5jUXVldWUmJnN5bmNRdWV1ZSE9PW51bGwpey8vIFByZXZlbnQgcmUtZW50cmFuY2UuXG5pc0ZsdXNoaW5nU3luY1F1ZXVlPXRydWU7dmFyIGk9MDt2YXIgcHJldmlvdXNVcGRhdGVQcmlvcml0eT1nZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTt0cnl7dmFyIGlzU3luYz10cnVlO3ZhciBxdWV1ZT1zeW5jUXVldWU7Ly8gVE9ETzogSXMgdGhpcyBuZWNlc3NhcnkgYW55bW9yZT8gVGhlIG9ubHkgdXNlciBjb2RlIHRoYXQgcnVucyBpbiB0aGlzXG4vLyBxdWV1ZSBpcyBpbiB0aGUgcmVuZGVyIG9yIGNvbW1pdCBwaGFzZXMuXG5zZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtmb3IoO2k8cXVldWUubGVuZ3RoO2krKyl7dmFyIGNhbGxiYWNrPXF1ZXVlW2ldO2Rve2NhbGxiYWNrPWNhbGxiYWNrKGlzU3luYyk7fXdoaWxlKGNhbGxiYWNrIT09bnVsbCk7fXN5bmNRdWV1ZT1udWxsO2luY2x1ZGVzTGVnYWN5U3luY0NhbGxiYWNrcz1mYWxzZTt9Y2F0Y2goZXJyb3Ipey8vIElmIHNvbWV0aGluZyB0aHJvd3MsIGxlYXZlIHRoZSByZW1haW5pbmcgY2FsbGJhY2tzIG9uIHRoZSBxdWV1ZS5cbmlmKHN5bmNRdWV1ZSE9PW51bGwpe3N5bmNRdWV1ZT1zeW5jUXVldWUuc2xpY2UoaSsxKTt9Ly8gUmVzdW1lIGZsdXNoaW5nIGluIHRoZSBuZXh0IHRpY2tcbnNjaGVkdWxlQ2FsbGJhY2soSW1tZWRpYXRlUHJpb3JpdHksZmx1c2hTeW5jQ2FsbGJhY2tzKTt0aHJvdyBlcnJvcjt9ZmluYWxseXtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNVcGRhdGVQcmlvcml0eSk7aXNGbHVzaGluZ1N5bmNRdWV1ZT1mYWxzZTt9fXJldHVybiBudWxsO30vLyBUT0RPOiBVc2UgdGhlIHVuaWZpZWQgZmliZXIgc3RhY2sgbW9kdWxlIGluc3RlYWQgb2YgdGhpcyBsb2NhbCBvbmU/XG4vLyBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBpdCB5ZXQgdG8gZGVyaXNrIHRoZSBpbml0aWFsIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlXG4vLyB0aGUgd2F5IHdlIHB1c2gvcG9wIHRoZXNlIHZhbHVlcyBpcyBhIGJpdCB1bnVzdWFsLiBJZiB0aGVyZSdzIGEgbWlzdGFrZSwgSSdkXG4vLyByYXRoZXIgdGhlIGlkcyBiZSB3cm9uZyB0aGFuIGNyYXNoIHRoZSB3aG9sZSByZWNvbmNpbGVyLlxudmFyIGZvcmtTdGFjaz1bXTt2YXIgZm9ya1N0YWNrSW5kZXg9MDt2YXIgdHJlZUZvcmtQcm92aWRlcj1udWxsO3ZhciB0cmVlRm9ya0NvdW50PTA7dmFyIGlkU3RhY2s9W107dmFyIGlkU3RhY2tJbmRleD0wO3ZhciB0cmVlQ29udGV4dFByb3ZpZGVyPW51bGw7dmFyIHRyZWVDb250ZXh0SWQ9MTt2YXIgdHJlZUNvbnRleHRPdmVyZmxvdz0nJztmdW5jdGlvbiBpc0ZvcmtlZENoaWxkKHdvcmtJblByb2dyZXNzKXt3YXJuSWZOb3RIeWRyYXRpbmcoKTtyZXR1cm4od29ya0luUHJvZ3Jlc3MuZmxhZ3MmRm9ya2VkKSE9PU5vRmxhZ3M7fWZ1bmN0aW9uIGdldEZvcmtzQXRMZXZlbCh3b3JrSW5Qcm9ncmVzcyl7d2FybklmTm90SHlkcmF0aW5nKCk7cmV0dXJuIHRyZWVGb3JrQ291bnQ7fWZ1bmN0aW9uIGdldFRyZWVJZCgpe3ZhciBvdmVyZmxvdz10cmVlQ29udGV4dE92ZXJmbG93O3ZhciBpZFdpdGhMZWFkaW5nQml0PXRyZWVDb250ZXh0SWQ7dmFyIGlkPWlkV2l0aExlYWRpbmdCaXQmfmdldExlYWRpbmdCaXQoaWRXaXRoTGVhZGluZ0JpdCk7cmV0dXJuIGlkLnRvU3RyaW5nKDMyKStvdmVyZmxvdzt9ZnVuY3Rpb24gcHVzaFRyZWVGb3JrKHdvcmtJblByb2dyZXNzLHRvdGFsQ2hpbGRyZW4pey8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIHdlIHJlY29uY2lsZSBhbiBhcnJheSAob3IgaXRlcmF0b3IpIG9mIGNoaWxkXG4vLyBmaWJlcnMsIGJlY2F1c2UgdGhhdCdzIHRoZSBvbmx5IHBsYWNlIHdoZXJlIHdlIGtub3cgaG93IG1hbnkgY2hpbGRyZW4gaW5cbi8vIHRoZSB3aG9sZSBzZXQgd2l0aG91dCBkb2luZyBleHRyYSB3b3JrIGxhdGVyLCBvciBzdG9yaW5nIGFkZHRpb25hbFxuLy8gaW5mb3JtYXRpb24gb24gdGhlIGZpYmVyLlxuLy9cbi8vIFRoYXQncyB3aHkgdGhpcyBmdW5jdGlvbiBpcyBzZXBhcmF0ZSBmcm9tIHB1c2hUcmVlSWQg4oCUIGl0J3MgY2FsbGVkIGR1cmluZ1xuLy8gdGhlIHJlbmRlciBwaGFzZSBvZiB0aGUgZm9yayBwYXJlbnQsIG5vdCB0aGUgY2hpbGQsIHdoaWNoIGlzIHdoZXJlIHdlIHB1c2hcbi8vIHRoZSBvdGhlciBjb250ZXh0IHZhbHVlcy5cbi8vXG4vLyBJbiB0aGUgRml6eiBpbXBsZW1lbnRhdGlvbiB0aGlzIGlzIG11Y2ggc2ltcGxlciBiZWNhdXNlIHRoZSBjaGlsZCBpc1xuLy8gcmVuZGVyZWQgaW4gdGhlIHNhbWUgY2FsbHN0YWNrIGFzIHRoZSBwYXJlbnQuXG4vL1xuLy8gSXQgbWlnaHQgYmUgYmV0dGVyIHRvIGp1c3QgYWRkIGEgYGZvcmtzYCBmaWVsZCB0byB0aGUgRmliZXIgdHlwZS4gSXQgd291bGRcbi8vIG1ha2UgdGhpcyBtb2R1bGUgc2ltcGxlci5cbndhcm5JZk5vdEh5ZHJhdGluZygpO2ZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXT10cmVlRm9ya0NvdW50O2ZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXT10cmVlRm9ya1Byb3ZpZGVyO3RyZWVGb3JrUHJvdmlkZXI9d29ya0luUHJvZ3Jlc3M7dHJlZUZvcmtDb3VudD10b3RhbENoaWxkcmVuO31mdW5jdGlvbiBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLHRvdGFsQ2hpbGRyZW4saW5kZXgpe3dhcm5JZk5vdEh5ZHJhdGluZygpO2lkU3RhY2tbaWRTdGFja0luZGV4KytdPXRyZWVDb250ZXh0SWQ7aWRTdGFja1tpZFN0YWNrSW5kZXgrK109dHJlZUNvbnRleHRPdmVyZmxvdztpZFN0YWNrW2lkU3RhY2tJbmRleCsrXT10cmVlQ29udGV4dFByb3ZpZGVyO3RyZWVDb250ZXh0UHJvdmlkZXI9d29ya0luUHJvZ3Jlc3M7dmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0PXRyZWVDb250ZXh0SWQ7dmFyIGJhc2VPdmVyZmxvdz10cmVlQ29udGV4dE92ZXJmbG93Oy8vIFRoZSBsZWZ0bW9zdCAxIG1hcmtzIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLCBub24taW5jbHVzaXZlLiBJdCdzIG5vdCBwYXJ0XG4vLyBvZiB0aGUgaWQ7IHdlIHVzZSBpdCB0byBhY2NvdW50IGZvciBsZWFkaW5nIDBzLlxudmFyIGJhc2VMZW5ndGg9Z2V0Qml0TGVuZ3RoKGJhc2VJZFdpdGhMZWFkaW5nQml0KS0xO3ZhciBiYXNlSWQ9YmFzZUlkV2l0aExlYWRpbmdCaXQmfigxPDxiYXNlTGVuZ3RoKTt2YXIgc2xvdD1pbmRleCsxO3ZhciBsZW5ndGg9Z2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pK2Jhc2VMZW5ndGg7Ly8gMzAgaXMgdGhlIG1heCBsZW5ndGggd2UgY2FuIHN0b3JlIHdpdGhvdXQgb3ZlcmZsb3dpbmcsIHRha2luZyBpbnRvXG4vLyBjb25zaWRlcmF0aW9uIHRoZSBsZWFkaW5nIDEgd2UgdXNlIHRvIG1hcmsgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG5pZihsZW5ndGg+MzApey8vIFdlIG92ZXJmbG93ZWQgdGhlIGJpdHdpc2Utc2FmZSByYW5nZS4gRmFsbCBiYWNrIHRvIHNsb3dlciBhbGdvcml0aG0uXG4vLyBUaGlzIGJyYW5jaCBhc3N1bWVzIHRoZSBsZW5ndGggb2YgdGhlIGJhc2UgaWQgaXMgZ3JlYXRlciB0aGFuIDU7IGl0IHdvbid0XG4vLyB3b3JrIGZvciBzbWFsbGVyIGlkcywgYmVjYXVzZSB5b3UgbmVlZCA1IGJpdHMgcGVyIGNoYXJhY3Rlci5cbi8vXG4vLyBXZSBlbmNvZGUgdGhlIGlkIGluIG11bHRpcGxlIHN0ZXBzOiBmaXJzdCB0aGUgYmFzZSBpZCwgdGhlbiB0aGVcbi8vIHJlbWFpbmluZyBkaWdpdHMuXG4vL1xuLy8gRWFjaCA1IGJpdCBzZXF1ZW5jZSBjb3JyZXNwb25kcyB0byBhIHNpbmdsZSBiYXNlIDMyIGNoYXJhY3Rlci4gU28gZm9yXG4vLyBleGFtcGxlLCBpZiB0aGUgY3VycmVudCBpZCBpcyAyMyBiaXRzIGxvbmcsIHdlIGNhbiBjb252ZXJ0IDIwIG9mIHRob3NlXG4vLyBiaXRzIGludG8gYSBzdHJpbmcgb2YgNCBjaGFyYWN0ZXJzLCB3aXRoIDMgYml0cyBsZWZ0IG92ZXIuXG4vL1xuLy8gRmlyc3QgY2FsY3VsYXRlIGhvdyBtYW55IGJpdHMgaW4gdGhlIGJhc2UgaWQgcmVwcmVzZW50IGEgY29tcGxldGVcbi8vIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMuXG52YXIgbnVtYmVyT2ZPdmVyZmxvd0JpdHM9YmFzZUxlbmd0aC1iYXNlTGVuZ3RoJTU7Ly8gVGhlbiBjcmVhdGUgYSBiaXRtYXNrIHRoYXQgc2VsZWN0cyBvbmx5IHRob3NlIGJpdHMuXG52YXIgbmV3T3ZlcmZsb3dCaXRzPSgxPDxudW1iZXJPZk92ZXJmbG93Qml0cyktMTsvLyBTZWxlY3QgdGhlIGJpdHMsIGFuZCBjb252ZXJ0IHRoZW0gdG8gYSBiYXNlIDMyIHN0cmluZy5cbnZhciBuZXdPdmVyZmxvdz0oYmFzZUlkJm5ld092ZXJmbG93Qml0cykudG9TdHJpbmcoMzIpOy8vIE5vdyB3ZSBjYW4gcmVtb3ZlIHRob3NlIGJpdHMgZnJvbSB0aGUgYmFzZSBpZC5cbnZhciByZXN0T2ZCYXNlSWQ9YmFzZUlkPj5udW1iZXJPZk92ZXJmbG93Qml0czt2YXIgcmVzdE9mQmFzZUxlbmd0aD1iYXNlTGVuZ3RoLW51bWJlck9mT3ZlcmZsb3dCaXRzOy8vIEZpbmFsbHksIGVuY29kZSB0aGUgcmVzdCBvZiB0aGUgYml0cyB1c2luZyB0aGUgbm9ybWFsIGFsZ29yaXRobS4gQmVjYXVzZVxuLy8gd2UgbWFkZSBtb3JlIHJvb20sIHRoaXMgdGltZSBpdCB3b24ndCBvdmVyZmxvdy5cbnZhciByZXN0T2ZMZW5ndGg9Z2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pK3Jlc3RPZkJhc2VMZW5ndGg7dmFyIHJlc3RPZk5ld0JpdHM9c2xvdDw8cmVzdE9mQmFzZUxlbmd0aDt2YXIgaWQ9cmVzdE9mTmV3Qml0c3xyZXN0T2ZCYXNlSWQ7dmFyIG92ZXJmbG93PW5ld092ZXJmbG93K2Jhc2VPdmVyZmxvdzt0cmVlQ29udGV4dElkPTE8PHJlc3RPZkxlbmd0aHxpZDt0cmVlQ29udGV4dE92ZXJmbG93PW92ZXJmbG93O31lbHNley8vIE5vcm1hbCBwYXRoXG52YXIgbmV3Qml0cz1zbG90PDxiYXNlTGVuZ3RoO3ZhciBfaWQ9bmV3Qml0c3xiYXNlSWQ7dmFyIF9vdmVyZmxvdz1iYXNlT3ZlcmZsb3c7dHJlZUNvbnRleHRJZD0xPDxsZW5ndGh8X2lkO3RyZWVDb250ZXh0T3ZlcmZsb3c9X292ZXJmbG93O319ZnVuY3Rpb24gcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyl7d2FybklmTm90SHlkcmF0aW5nKCk7Ly8gVGhpcyBjb21wb25lbnQgbWF0ZXJpYWxpemVkIGFuIGlkLiBUaGlzIHdpbGwgYWZmZWN0IGFueSBpZHMgdGhhdCBhcHBlYXJcbi8vIGluIGl0cyBjaGlsZHJlbi5cbnZhciByZXR1cm5GaWJlcj13b3JrSW5Qcm9ncmVzcy5yZXR1cm47aWYocmV0dXJuRmliZXIhPT1udWxsKXt2YXIgbnVtYmVyT2ZGb3Jrcz0xO3ZhciBzbG90SW5kZXg9MDtwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsbnVtYmVyT2ZGb3Jrcyk7cHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyxudW1iZXJPZkZvcmtzLHNsb3RJbmRleCk7fX1mdW5jdGlvbiBnZXRCaXRMZW5ndGgobnVtYmVyKXtyZXR1cm4gMzItY2x6MzIobnVtYmVyKTt9ZnVuY3Rpb24gZ2V0TGVhZGluZ0JpdChpZCl7cmV0dXJuIDE8PGdldEJpdExlbmd0aChpZCktMTt9ZnVuY3Rpb24gcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3Mpey8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIHZhbHVlcy5cbi8vIFRoaXMgaXMgYSBiaXQgbW9yZSBjb21wbGljYXRlZCB0aGFuIG90aGVyIGNvbnRleHQtbGlrZSBtb2R1bGVzIGluIEZpYmVyXG4vLyBiZWNhdXNlIHRoZSBzYW1lIEZpYmVyIG1heSBhcHBlYXIgb24gdGhlIHN0YWNrIG11bHRpcGxlIHRpbWVzIGFuZCBmb3Jcbi8vIGRpZmZlcmVudCByZWFzb25zLiBXZSBoYXZlIHRvIGtlZXAgcG9wcGluZyB1bnRpbCB0aGUgd29yay1pbi1wcm9ncmVzcyBpc1xuLy8gbm8gbG9uZ2VyIGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrLlxud2hpbGUod29ya0luUHJvZ3Jlc3M9PT10cmVlRm9ya1Byb3ZpZGVyKXt0cmVlRm9ya1Byb3ZpZGVyPWZvcmtTdGFja1stLWZvcmtTdGFja0luZGV4XTtmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdPW51bGw7dHJlZUZvcmtDb3VudD1mb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF07Zm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XT1udWxsO313aGlsZSh3b3JrSW5Qcm9ncmVzcz09PXRyZWVDb250ZXh0UHJvdmlkZXIpe3RyZWVDb250ZXh0UHJvdmlkZXI9aWRTdGFja1stLWlkU3RhY2tJbmRleF07aWRTdGFja1tpZFN0YWNrSW5kZXhdPW51bGw7dHJlZUNvbnRleHRPdmVyZmxvdz1pZFN0YWNrWy0taWRTdGFja0luZGV4XTtpZFN0YWNrW2lkU3RhY2tJbmRleF09bnVsbDt0cmVlQ29udGV4dElkPWlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdO2lkU3RhY2tbaWRTdGFja0luZGV4XT1udWxsO319ZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVHJlZUNvbnRleHQoKXt3YXJuSWZOb3RIeWRyYXRpbmcoKTtpZih0cmVlQ29udGV4dFByb3ZpZGVyIT09bnVsbCl7cmV0dXJue2lkOnRyZWVDb250ZXh0SWQsb3ZlcmZsb3c6dHJlZUNvbnRleHRPdmVyZmxvd307fWVsc2V7cmV0dXJuIG51bGw7fX1mdW5jdGlvbiByZXN0b3JlU3VzcGVuZGVkVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3Msc3VzcGVuZGVkQ29udGV4dCl7d2FybklmTm90SHlkcmF0aW5nKCk7aWRTdGFja1tpZFN0YWNrSW5kZXgrK109dHJlZUNvbnRleHRJZDtpZFN0YWNrW2lkU3RhY2tJbmRleCsrXT10cmVlQ29udGV4dE92ZXJmbG93O2lkU3RhY2tbaWRTdGFja0luZGV4KytdPXRyZWVDb250ZXh0UHJvdmlkZXI7dHJlZUNvbnRleHRJZD1zdXNwZW5kZWRDb250ZXh0LmlkO3RyZWVDb250ZXh0T3ZlcmZsb3c9c3VzcGVuZGVkQ29udGV4dC5vdmVyZmxvdzt0cmVlQ29udGV4dFByb3ZpZGVyPXdvcmtJblByb2dyZXNzO31mdW5jdGlvbiB3YXJuSWZOb3RIeWRyYXRpbmcoKXt7aWYoIWdldElzSHlkcmF0aW5nKCkpe2Vycm9yKCdFeHBlY3RlZCB0byBiZSBoeWRyYXRpbmcuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlICcrJ2FuIGlzc3VlLicpO319fS8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG52YXIgaHlkcmF0aW9uUGFyZW50RmliZXI9bnVsbDt2YXIgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZT1udWxsO3ZhciBpc0h5ZHJhdGluZz1mYWxzZTsvLyBUaGlzIGZsYWcgYWxsb3dzIGZvciB3YXJuaW5nIHN1cHJlc3Npb24gd2hlbiB3ZSBleHBlY3QgdGhlcmUgdG8gYmUgbWlzbWF0Y2hlc1xuLy8gZHVlIHRvIGVhcmxpZXIgbWlzbWF0Y2hlcyBvciBhIHN1c3BlbmRlZCBmaWJlci5cbnZhciBkaWRTdXNwZW5kT3JFcnJvckRFVj1mYWxzZTsvLyBIeWRyYXRpb24gZXJyb3JzIHRoYXQgd2VyZSB0aHJvd24gaW5zaWRlIHRoaXMgYm91bmRhcnlcbnZhciBoeWRyYXRpb25FcnJvcnM9bnVsbDtmdW5jdGlvbiB3YXJuSWZIeWRyYXRpbmcoKXt7aWYoaXNIeWRyYXRpbmcpe2Vycm9yKCdXZSBzaG91bGQgbm90IGJlIGh5ZHJhdGluZyBoZXJlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhIGJ1Zy4nKTt9fX1mdW5jdGlvbiBtYXJrRGlkVGhyb3dXaGlsZUh5ZHJhdGluZ0RFVigpe3tkaWRTdXNwZW5kT3JFcnJvckRFVj10cnVlO319ZnVuY3Rpb24gZGlkU3VzcGVuZE9yRXJyb3JXaGlsZUh5ZHJhdGluZ0RFVigpe3tyZXR1cm4gZGlkU3VzcGVuZE9yRXJyb3JERVY7fX1mdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKXt2YXIgcGFyZW50SW5zdGFuY2U9ZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87bmV4dEh5ZHJhdGFibGVJbnN0YW5jZT1nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lcihwYXJlbnRJbnN0YW5jZSk7aHlkcmF0aW9uUGFyZW50RmliZXI9ZmliZXI7aXNIeWRyYXRpbmc9dHJ1ZTtoeWRyYXRpb25FcnJvcnM9bnVsbDtkaWRTdXNwZW5kT3JFcnJvckRFVj1mYWxzZTtyZXR1cm4gdHJ1ZTt9ZnVuY3Rpb24gcmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyLHN1c3BlbnNlSW5zdGFuY2UsdHJlZUNvbnRleHQpe25leHRIeWRyYXRhYmxlSW5zdGFuY2U9Z2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO2h5ZHJhdGlvblBhcmVudEZpYmVyPWZpYmVyO2lzSHlkcmF0aW5nPXRydWU7aHlkcmF0aW9uRXJyb3JzPW51bGw7ZGlkU3VzcGVuZE9yRXJyb3JERVY9ZmFsc2U7aWYodHJlZUNvbnRleHQhPT1udWxsKXtyZXN0b3JlU3VzcGVuZGVkVHJlZUNvbnRleHQoZmliZXIsdHJlZUNvbnRleHQpO31yZXR1cm4gdHJ1ZTt9ZnVuY3Rpb24gd2FyblVuaHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlcixpbnN0YW5jZSl7e3N3aXRjaChyZXR1cm5GaWJlci50YWcpe2Nhc2UgSG9zdFJvb3Q6e2RpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcihyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyxpbnN0YW5jZSk7YnJlYWs7fWNhc2UgSG9zdENvbXBvbmVudDp7dmFyIGlzQ29uY3VycmVudE1vZGU9KHJldHVybkZpYmVyLm1vZGUmQ29uY3VycmVudE1vZGUpIT09Tm9Nb2RlO2RpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHMscmV0dXJuRmliZXIuc3RhdGVOb2RlLGluc3RhbmNlLC8vIFRPRE86IERlbGV0ZSB0aGlzIGFyZ3VtZW50IHdoZW4gd2UgcmVtb3ZlIHRoZSBsZWdhY3kgcm9vdCBBUEkuXG5pc0NvbmN1cnJlbnRNb2RlKTticmVhazt9Y2FzZSBTdXNwZW5zZUNvbXBvbmVudDp7dmFyIHN1c3BlbnNlU3RhdGU9cmV0dXJuRmliZXIubWVtb2l6ZWRTdGF0ZTtpZihzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQhPT1udWxsKWRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkLGluc3RhbmNlKTticmVhazt9fX19ZnVuY3Rpb24gZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKHJldHVybkZpYmVyLGluc3RhbmNlKXt3YXJuVW5oeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLGluc3RhbmNlKTt2YXIgY2hpbGRUb0RlbGV0ZT1jcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpO2NoaWxkVG9EZWxldGUuc3RhdGVOb2RlPWluc3RhbmNlO2NoaWxkVG9EZWxldGUucmV0dXJuPXJldHVybkZpYmVyO3ZhciBkZWxldGlvbnM9cmV0dXJuRmliZXIuZGVsZXRpb25zO2lmKGRlbGV0aW9ucz09PW51bGwpe3JldHVybkZpYmVyLmRlbGV0aW9ucz1bY2hpbGRUb0RlbGV0ZV07cmV0dXJuRmliZXIuZmxhZ3N8PUNoaWxkRGVsZXRpb247fWVsc2V7ZGVsZXRpb25zLnB1c2goY2hpbGRUb0RlbGV0ZSk7fX1mdW5jdGlvbiB3YXJuTm9uaHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlcixmaWJlcil7e2lmKGRpZFN1c3BlbmRPckVycm9yREVWKXsvLyBJbnNpZGUgYSBib3VuZGFyeSB0aGF0IGFscmVhZHkgc3VzcGVuZGVkLiBXZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nIHRoZVxuLy8gc2libGluZ3Mgb2YgYSBzdXNwZW5kZWQgbm9kZS4gVGhlIG1pc21hdGNoIG1heSBiZSBkdWUgdG8gdGhlIG1pc3Npbmdcbi8vIGRhdGEsIHNvIGl0J3MgcHJvYmFibHkgYSBmYWxzZSBwb3NpdGl2ZS5cbnJldHVybjt9c3dpdGNoKHJldHVybkZpYmVyLnRhZyl7Y2FzZSBIb3N0Um9vdDp7dmFyIHBhcmVudENvbnRhaW5lcj1yZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztzd2l0Y2goZmliZXIudGFnKXtjYXNlIEhvc3RDb21wb25lbnQ6dmFyIHR5cGU9ZmliZXIudHlwZTt2YXIgcHJvcHM9ZmliZXIucGVuZGluZ1Byb3BzO2RpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2VXaXRoaW5Db250YWluZXIocGFyZW50Q29udGFpbmVyLHR5cGUpO2JyZWFrO2Nhc2UgSG9zdFRleHQ6dmFyIHRleHQ9ZmliZXIucGVuZGluZ1Byb3BzO2RpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lcix0ZXh0KTticmVhazt9YnJlYWs7fWNhc2UgSG9zdENvbXBvbmVudDp7dmFyIHBhcmVudFR5cGU9cmV0dXJuRmliZXIudHlwZTt2YXIgcGFyZW50UHJvcHM9cmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wczt2YXIgcGFyZW50SW5zdGFuY2U9cmV0dXJuRmliZXIuc3RhdGVOb2RlO3N3aXRjaChmaWJlci50YWcpe2Nhc2UgSG9zdENvbXBvbmVudDp7dmFyIF90eXBlPWZpYmVyLnR5cGU7dmFyIF9wcm9wcz1maWJlci5wZW5kaW5nUHJvcHM7dmFyIGlzQ29uY3VycmVudE1vZGU9KHJldHVybkZpYmVyLm1vZGUmQ29uY3VycmVudE1vZGUpIT09Tm9Nb2RlO2RpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSxwYXJlbnRQcm9wcyxwYXJlbnRJbnN0YW5jZSxfdHlwZSxfcHJvcHMsLy8gVE9ETzogRGVsZXRlIHRoaXMgYXJndW1lbnQgd2hlbiB3ZSByZW1vdmUgdGhlIGxlZ2FjeSByb290IEFQSS5cbmlzQ29uY3VycmVudE1vZGUpO2JyZWFrO31jYXNlIEhvc3RUZXh0Ont2YXIgX3RleHQ9ZmliZXIucGVuZGluZ1Byb3BzO3ZhciBfaXNDb25jdXJyZW50TW9kZT0ocmV0dXJuRmliZXIubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGU7ZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSxwYXJlbnRQcm9wcyxwYXJlbnRJbnN0YW5jZSxfdGV4dCwvLyBUT0RPOiBEZWxldGUgdGhpcyBhcmd1bWVudCB3aGVuIHdlIHJlbW92ZSB0aGUgbGVnYWN5IHJvb3QgQVBJLlxuX2lzQ29uY3VycmVudE1vZGUpO2JyZWFrO319YnJlYWs7fWNhc2UgU3VzcGVuc2VDb21wb25lbnQ6e3ZhciBzdXNwZW5zZVN0YXRlPXJldHVybkZpYmVyLm1lbW9pemVkU3RhdGU7dmFyIF9wYXJlbnRJbnN0YW5jZT1zdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7aWYoX3BhcmVudEluc3RhbmNlIT09bnVsbClzd2l0Y2goZmliZXIudGFnKXtjYXNlIEhvc3RDb21wb25lbnQ6dmFyIF90eXBlMj1maWJlci50eXBlO3ZhciBfcHJvcHMyPWZpYmVyLnBlbmRpbmdQcm9wcztkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShfcGFyZW50SW5zdGFuY2UsX3R5cGUyKTticmVhaztjYXNlIEhvc3RUZXh0OnZhciBfdGV4dDI9ZmliZXIucGVuZGluZ1Byb3BzO2RpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShfcGFyZW50SW5zdGFuY2UsX3RleHQyKTticmVhazt9YnJlYWs7fWRlZmF1bHQ6cmV0dXJuO319fWZ1bmN0aW9uIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsZmliZXIpe2ZpYmVyLmZsYWdzPWZpYmVyLmZsYWdzJn5IeWRyYXRpbmd8UGxhY2VtZW50O3dhcm5Ob25oeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLGZpYmVyKTt9ZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlcixuZXh0SW5zdGFuY2Upe3N3aXRjaChmaWJlci50YWcpe2Nhc2UgSG9zdENvbXBvbmVudDp7dmFyIHR5cGU9ZmliZXIudHlwZTt2YXIgcHJvcHM9ZmliZXIucGVuZGluZ1Byb3BzO3ZhciBpbnN0YW5jZT1jYW5IeWRyYXRlSW5zdGFuY2UobmV4dEluc3RhbmNlLHR5cGUpO2lmKGluc3RhbmNlIT09bnVsbCl7ZmliZXIuc3RhdGVOb2RlPWluc3RhbmNlO2h5ZHJhdGlvblBhcmVudEZpYmVyPWZpYmVyO25leHRIeWRyYXRhYmxlSW5zdGFuY2U9Z2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQoaW5zdGFuY2UpO3JldHVybiB0cnVlO31yZXR1cm4gZmFsc2U7fWNhc2UgSG9zdFRleHQ6e3ZhciB0ZXh0PWZpYmVyLnBlbmRpbmdQcm9wczt2YXIgdGV4dEluc3RhbmNlPWNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLHRleHQpO2lmKHRleHRJbnN0YW5jZSE9PW51bGwpe2ZpYmVyLnN0YXRlTm9kZT10ZXh0SW5zdGFuY2U7aHlkcmF0aW9uUGFyZW50RmliZXI9ZmliZXI7Ly8gVGV4dCBJbnN0YW5jZXMgZG9uJ3QgaGF2ZSBjaGlsZHJlbiBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gaHlkcmF0ZS5cbm5leHRIeWRyYXRhYmxlSW5zdGFuY2U9bnVsbDtyZXR1cm4gdHJ1ZTt9cmV0dXJuIGZhbHNlO31jYXNlIFN1c3BlbnNlQ29tcG9uZW50Ont2YXIgc3VzcGVuc2VJbnN0YW5jZT1jYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZShuZXh0SW5zdGFuY2UpO2lmKHN1c3BlbnNlSW5zdGFuY2UhPT1udWxsKXt2YXIgc3VzcGVuc2VTdGF0ZT17ZGVoeWRyYXRlZDpzdXNwZW5zZUluc3RhbmNlLHRyZWVDb250ZXh0OmdldFN1c3BlbmRlZFRyZWVDb250ZXh0KCkscmV0cnlMYW5lOk9mZnNjcmVlbkxhbmV9O2ZpYmVyLm1lbW9pemVkU3RhdGU9c3VzcGVuc2VTdGF0ZTsvLyBTdG9yZSB0aGUgZGVoeWRyYXRlZCBmcmFnbWVudCBhcyBhIGNoaWxkIGZpYmVyLlxuLy8gVGhpcyBzaW1wbGlmaWVzIHRoZSBjb2RlIGZvciBnZXRIb3N0U2libGluZyBhbmQgZGVsZXRpbmcgbm9kZXMsXG4vLyBzaW5jZSBpdCBkb2Vzbid0IGhhdmUgdG8gY29uc2lkZXIgYWxsIFN1c3BlbnNlIGJvdW5kYXJpZXMgYW5kXG4vLyBjaGVjayBpZiB0aGV5J3JlIGRlaHlkcmF0ZWQgb25lcyBvciBub3QuXG52YXIgZGVoeWRyYXRlZEZyYWdtZW50PWNyZWF0ZUZpYmVyRnJvbURlaHlkcmF0ZWRGcmFnbWVudChzdXNwZW5zZUluc3RhbmNlKTtkZWh5ZHJhdGVkRnJhZ21lbnQucmV0dXJuPWZpYmVyO2ZpYmVyLmNoaWxkPWRlaHlkcmF0ZWRGcmFnbWVudDtoeWRyYXRpb25QYXJlbnRGaWJlcj1maWJlcjsvLyBXaGlsZSBhIFN1c3BlbnNlIEluc3RhbmNlIGRvZXMgaGF2ZSBjaGlsZHJlbiwgd2Ugd29uJ3Qgc3RlcCBpbnRvXG4vLyBpdCBkdXJpbmcgdGhlIGZpcnN0IHBhc3MuIEluc3RlYWQsIHdlJ2xsIHJlZW50ZXIgaXQgbGF0ZXIuXG5uZXh0SHlkcmF0YWJsZUluc3RhbmNlPW51bGw7cmV0dXJuIHRydWU7fXJldHVybiBmYWxzZTt9ZGVmYXVsdDpyZXR1cm4gZmFsc2U7fX1mdW5jdGlvbiBzaG91bGRDbGllbnRSZW5kZXJPbk1pc21hdGNoKGZpYmVyKXtyZXR1cm4oZmliZXIubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGUmJihmaWJlci5mbGFncyZEaWRDYXB0dXJlKT09PU5vRmxhZ3M7fWZ1bmN0aW9uIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcil7dGhyb3cgbmV3IEVycm9yKCdIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIGluaXRpYWwgVUkgZG9lcyBub3QgbWF0Y2ggd2hhdCB3YXMgJysncmVuZGVyZWQgb24gdGhlIHNlcnZlci4nKTt9ZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIpe2lmKCFpc0h5ZHJhdGluZyl7cmV0dXJuO312YXIgbmV4dEluc3RhbmNlPW5leHRIeWRyYXRhYmxlSW5zdGFuY2U7aWYoIW5leHRJbnN0YW5jZSl7aWYoc2hvdWxkQ2xpZW50UmVuZGVyT25NaXNtYXRjaChmaWJlcikpe3dhcm5Ob25oeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLGZpYmVyKTt0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goKTt9Ly8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbmluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsZmliZXIpO2lzSHlkcmF0aW5nPWZhbHNlO2h5ZHJhdGlvblBhcmVudEZpYmVyPWZpYmVyO3JldHVybjt9dmFyIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2U9bmV4dEluc3RhbmNlO2lmKCF0cnlIeWRyYXRlKGZpYmVyLG5leHRJbnN0YW5jZSkpe2lmKHNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2goZmliZXIpKXt3YXJuTm9uaHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlcixmaWJlcik7dGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKCk7fS8vIElmIHdlIGNhbid0IGh5ZHJhdGUgdGhpcyBpbnN0YW5jZSBsZXQncyB0cnkgdGhlIG5leHQgb25lLlxuLy8gV2UgdXNlIHRoaXMgYXMgYSBoZXVyaXN0aWMuIEl0J3MgYmFzZWQgb24gaW50dWl0aW9uIGFuZCBub3QgZGF0YSBzbyBpdFxuLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxubmV4dEluc3RhbmNlPWdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaXJzdEF0dGVtcHRlZEluc3RhbmNlKTt2YXIgcHJldkh5ZHJhdGlvblBhcmVudEZpYmVyPWh5ZHJhdGlvblBhcmVudEZpYmVyO2lmKCFuZXh0SW5zdGFuY2V8fCF0cnlIeWRyYXRlKGZpYmVyLG5leHRJbnN0YW5jZSkpey8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG5pbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLGZpYmVyKTtpc0h5ZHJhdGluZz1mYWxzZTtoeWRyYXRpb25QYXJlbnRGaWJlcj1maWJlcjtyZXR1cm47fS8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbi8vIHN1cGVyZmx1b3VzIGFuZCB3ZSdsbCBkZWxldGUgaXQuIFNpbmNlIHdlIGNhbid0IGVhZ2VybHkgZGVsZXRlIGl0XG4vLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4vLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG5kZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocHJldkh5ZHJhdGlvblBhcmVudEZpYmVyLGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO319ZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlcixyb290Q29udGFpbmVySW5zdGFuY2UsaG9zdENvbnRleHQpe3ZhciBpbnN0YW5jZT1maWJlci5zdGF0ZU5vZGU7dmFyIHNob3VsZFdhcm5JZk1pc21hdGNoRGV2PSFkaWRTdXNwZW5kT3JFcnJvckRFVjt2YXIgdXBkYXRlUGF5bG9hZD1oeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsZmliZXIudHlwZSxmaWJlci5tZW1vaXplZFByb3BzLHJvb3RDb250YWluZXJJbnN0YW5jZSxob3N0Q29udGV4dCxmaWJlcixzaG91bGRXYXJuSWZNaXNtYXRjaERldik7Ly8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG5maWJlci51cGRhdGVRdWV1ZT11cGRhdGVQYXlsb2FkOy8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuXG5pZih1cGRhdGVQYXlsb2FkIT09bnVsbCl7cmV0dXJuIHRydWU7fXJldHVybiBmYWxzZTt9ZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoZmliZXIpe3ZhciB0ZXh0SW5zdGFuY2U9ZmliZXIuc3RhdGVOb2RlO3ZhciB0ZXh0Q29udGVudD1maWJlci5tZW1vaXplZFByb3BzO3ZhciBzaG91bGRVcGRhdGU9aHlkcmF0ZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsdGV4dENvbnRlbnQsZmliZXIpO2lmKHNob3VsZFVwZGF0ZSl7Ly8gV2UgYXNzdW1lIHRoYXQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgaXMgY2FsbGVkIGluIGEgY29udGV4dCB3aGVyZSB0aGVcbi8vIGh5ZHJhdGlvbiBwYXJlbnQgaXMgdGhlIHBhcmVudCBob3N0IGNvbXBvbmVudCBvZiB0aGlzIGhvc3QgdGV4dC5cbnZhciByZXR1cm5GaWJlcj1oeWRyYXRpb25QYXJlbnRGaWJlcjtpZihyZXR1cm5GaWJlciE9PW51bGwpe3N3aXRjaChyZXR1cm5GaWJlci50YWcpe2Nhc2UgSG9zdFJvb3Q6e3ZhciBwYXJlbnRDb250YWluZXI9cmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87dmFyIGlzQ29uY3VycmVudE1vZGU9KHJldHVybkZpYmVyLm1vZGUmQ29uY3VycmVudE1vZGUpIT09Tm9Nb2RlO2RpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLHRleHRJbnN0YW5jZSx0ZXh0Q29udGVudCwvLyBUT0RPOiBEZWxldGUgdGhpcyBhcmd1bWVudCB3aGVuIHdlIHJlbW92ZSB0aGUgbGVnYWN5IHJvb3QgQVBJLlxuaXNDb25jdXJyZW50TW9kZSk7YnJlYWs7fWNhc2UgSG9zdENvbXBvbmVudDp7dmFyIHBhcmVudFR5cGU9cmV0dXJuRmliZXIudHlwZTt2YXIgcGFyZW50UHJvcHM9cmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wczt2YXIgcGFyZW50SW5zdGFuY2U9cmV0dXJuRmliZXIuc3RhdGVOb2RlO3ZhciBfaXNDb25jdXJyZW50TW9kZTI9KHJldHVybkZpYmVyLm1vZGUmQ29uY3VycmVudE1vZGUpIT09Tm9Nb2RlO2RpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSxwYXJlbnRQcm9wcyxwYXJlbnRJbnN0YW5jZSx0ZXh0SW5zdGFuY2UsdGV4dENvbnRlbnQsLy8gVE9ETzogRGVsZXRlIHRoaXMgYXJndW1lbnQgd2hlbiB3ZSByZW1vdmUgdGhlIGxlZ2FjeSByb290IEFQSS5cbl9pc0NvbmN1cnJlbnRNb2RlMik7YnJlYWs7fX19fXJldHVybiBzaG91bGRVcGRhdGU7fWZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZShmaWJlcil7dmFyIHN1c3BlbnNlU3RhdGU9ZmliZXIubWVtb2l6ZWRTdGF0ZTt2YXIgc3VzcGVuc2VJbnN0YW5jZT1zdXNwZW5zZVN0YXRlIT09bnVsbD9zdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ6bnVsbDtpZighc3VzcGVuc2VJbnN0YW5jZSl7dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuICcrJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fWh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UsZmliZXIpO31mdW5jdGlvbiBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyKXt2YXIgc3VzcGVuc2VTdGF0ZT1maWJlci5tZW1vaXplZFN0YXRlO3ZhciBzdXNwZW5zZUluc3RhbmNlPXN1c3BlbnNlU3RhdGUhPT1udWxsP3N1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZDpudWxsO2lmKCFzdXNwZW5zZUluc3RhbmNlKXt0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gJysnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9cmV0dXJuIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7fWZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpe3ZhciBwYXJlbnQ9ZmliZXIucmV0dXJuO3doaWxlKHBhcmVudCE9PW51bGwmJnBhcmVudC50YWchPT1Ib3N0Q29tcG9uZW50JiZwYXJlbnQudGFnIT09SG9zdFJvb3QmJnBhcmVudC50YWchPT1TdXNwZW5zZUNvbXBvbmVudCl7cGFyZW50PXBhcmVudC5yZXR1cm47fWh5ZHJhdGlvblBhcmVudEZpYmVyPXBhcmVudDt9ZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpe2lmKGZpYmVyIT09aHlkcmF0aW9uUGFyZW50RmliZXIpey8vIFdlJ3JlIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IGh5ZHJhdGlvbiBjb250ZXh0LCBpbnNpZGUgYW4gaW5zZXJ0ZWRcbi8vIHRyZWUuXG5yZXR1cm4gZmFsc2U7fWlmKCFpc0h5ZHJhdGluZyl7Ly8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbi8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4vLyBzaWJsaW5ncy5cbnBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO2lzSHlkcmF0aW5nPXRydWU7cmV0dXJuIGZhbHNlO30vLyBJZiB3ZSBoYXZlIGFueSByZW1haW5pbmcgaHlkcmF0YWJsZSBub2Rlcywgd2UgbmVlZCB0byBkZWxldGUgdGhlbSBub3cuXG4vLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbi8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuLy8gc2lkZSBvZiB0aGVtLiBXZSBhbHNvIGRvbid0IGRlbGV0ZSBhbnl0aGluZyBpbnNpZGUgdGhlIHJvb3QgY29udGFpbmVyLlxuaWYoZmliZXIudGFnIT09SG9zdFJvb3QmJihmaWJlci50YWchPT1Ib3N0Q29tcG9uZW50fHxzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyhmaWJlci50eXBlKSYmIXNob3VsZFNldFRleHRDb250ZW50KGZpYmVyLnR5cGUsZmliZXIubWVtb2l6ZWRQcm9wcykpKXt2YXIgbmV4dEluc3RhbmNlPW5leHRIeWRyYXRhYmxlSW5zdGFuY2U7aWYobmV4dEluc3RhbmNlKXtpZihzaG91bGRDbGllbnRSZW5kZXJPbk1pc21hdGNoKGZpYmVyKSl7d2FybklmVW5oeWRyYXRlZFRhaWxOb2RlcyhmaWJlcik7dGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKCk7fWVsc2V7d2hpbGUobmV4dEluc3RhbmNlKXtkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIsbmV4dEluc3RhbmNlKTtuZXh0SW5zdGFuY2U9Z2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7fX19fXBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO2lmKGZpYmVyLnRhZz09PVN1c3BlbnNlQ29tcG9uZW50KXtuZXh0SHlkcmF0YWJsZUluc3RhbmNlPXNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpO31lbHNle25leHRIeWRyYXRhYmxlSW5zdGFuY2U9aHlkcmF0aW9uUGFyZW50RmliZXI/Z2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSk6bnVsbDt9cmV0dXJuIHRydWU7fWZ1bmN0aW9uIGhhc1VuaHlkcmF0ZWRUYWlsTm9kZXMoKXtyZXR1cm4gaXNIeWRyYXRpbmcmJm5leHRIeWRyYXRhYmxlSW5zdGFuY2UhPT1udWxsO31mdW5jdGlvbiB3YXJuSWZVbmh5ZHJhdGVkVGFpbE5vZGVzKGZpYmVyKXt2YXIgbmV4dEluc3RhbmNlPW5leHRIeWRyYXRhYmxlSW5zdGFuY2U7d2hpbGUobmV4dEluc3RhbmNlKXt3YXJuVW5oeWRyYXRlZEluc3RhbmNlKGZpYmVyLG5leHRJbnN0YW5jZSk7bmV4dEluc3RhbmNlPWdldE5leHRIeWRyYXRhYmxlU2libGluZyhuZXh0SW5zdGFuY2UpO319ZnVuY3Rpb24gcmVzZXRIeWRyYXRpb25TdGF0ZSgpe2h5ZHJhdGlvblBhcmVudEZpYmVyPW51bGw7bmV4dEh5ZHJhdGFibGVJbnN0YW5jZT1udWxsO2lzSHlkcmF0aW5nPWZhbHNlO2RpZFN1c3BlbmRPckVycm9yREVWPWZhbHNlO31mdW5jdGlvbiB1cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSgpe2lmKGh5ZHJhdGlvbkVycm9ycyE9PW51bGwpey8vIFN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgYSBmb3JjZWQgY2xpZW50IHJlbmRlci4gVGhlIGVycm9ycyB0aGF0IG9jY3VycmVkXG4vLyBkdXJpbmcgdGhlIGh5ZHJhdGlvbiBhdHRlbXB0IGFyZSBub3cgcmVjb3ZlcmVkLiBXZSB3aWxsIGxvZyB0aGVtIGluXG4vLyBjb21taXQgcGhhc2UsIG9uY2UgdGhlIGVudGlyZSB0cmVlIGhhcyBmaW5pc2hlZC5cbnF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoaHlkcmF0aW9uRXJyb3JzKTtoeWRyYXRpb25FcnJvcnM9bnVsbDt9fWZ1bmN0aW9uIGdldElzSHlkcmF0aW5nKCl7cmV0dXJuIGlzSHlkcmF0aW5nO31mdW5jdGlvbiBxdWV1ZUh5ZHJhdGlvbkVycm9yKGVycm9yKXtpZihoeWRyYXRpb25FcnJvcnM9PT1udWxsKXtoeWRyYXRpb25FcnJvcnM9W2Vycm9yXTt9ZWxzZXtoeWRyYXRpb25FcnJvcnMucHVzaChlcnJvcik7fX12YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMT1SZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZzt2YXIgTm9UcmFuc2l0aW9uPW51bGw7ZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCl7cmV0dXJuIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjt9dmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzPXtyZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczpmdW5jdGlvbihmaWJlcixpbnN0YW5jZSl7fSxmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczpmdW5jdGlvbigpe30scmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6ZnVuY3Rpb24oZmliZXIsaW5zdGFuY2Upe30sZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZzpmdW5jdGlvbigpe30sZGlzY2FyZFBlbmRpbmdXYXJuaW5nczpmdW5jdGlvbigpe319O3t2YXIgZmluZFN0cmljdFJvb3Q9ZnVuY3Rpb24oZmliZXIpe3ZhciBtYXliZVN0cmljdFJvb3Q9bnVsbDt2YXIgbm9kZT1maWJlcjt3aGlsZShub2RlIT09bnVsbCl7aWYobm9kZS5tb2RlJlN0cmljdExlZ2FjeU1vZGUpe21heWJlU3RyaWN0Um9vdD1ub2RlO31ub2RlPW5vZGUucmV0dXJuO31yZXR1cm4gbWF5YmVTdHJpY3RSb290O307dmFyIHNldFRvU29ydGVkU3RyaW5nPWZ1bmN0aW9uKHNldCl7dmFyIGFycmF5PVtdO3NldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKXthcnJheS5wdXNoKHZhbHVlKTt9KTtyZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oJywgJyk7fTt2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzPVtdO3ZhciBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzPVtdO3ZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzPVtdO3ZhciBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncz1bXTt2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncz1bXTt2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3M9W107Ly8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cbnZhciBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzPW5ldyBTZXQoKTtSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncz1mdW5jdGlvbihmaWJlcixpbnN0YW5jZSl7Ly8gRGVkdXBlIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbmlmKGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuaGFzKGZpYmVyLnR5cGUpKXtyZXR1cm47fWlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nJiYvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cy5cbmluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nIT09dHJ1ZSl7cGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO31pZihmaWJlci5tb2RlJlN0cmljdExlZ2FjeU1vZGUmJnR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50PT09J2Z1bmN0aW9uJyl7cGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5wdXNoKGZpYmVyKTt9aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM9PT0nZnVuY3Rpb24nJiZpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmchPT10cnVlKXtwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO31pZihmaWJlci5tb2RlJlN0cmljdExlZ2FjeU1vZGUmJnR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcz09PSdmdW5jdGlvbicpe3BlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO31pZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZT09PSdmdW5jdGlvbicmJmluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyE9PXRydWUpe3BlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7fWlmKGZpYmVyLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSYmdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlPT09J2Z1bmN0aW9uJyl7cGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7fX07UmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3M9ZnVuY3Rpb24oKXsvLyBXZSBkbyBhbiBpbml0aWFsIHBhc3MgdG8gZ2F0aGVyIGNvbXBvbmVudCBuYW1lc1xudmFyIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzPW5ldyBTZXQoKTtpZihwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoPjApe3BlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKGZpYmVyKXtjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcil8fCdDb21wb25lbnQnKTtkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTt9KTtwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3M9W107fXZhciBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXM9bmV3IFNldCgpO2lmKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoPjApe3BlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbihmaWJlcil7VU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J0NvbXBvbmVudCcpO2RpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO30pO3BlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3M9W107fXZhciBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXM9bmV3IFNldCgpO2lmKHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoPjApe3BlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbihmaWJlcil7Y29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J0NvbXBvbmVudCcpO2RpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO30pO3BlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3M9W107fXZhciBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzPW5ldyBTZXQoKTtpZihwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGg+MCl7cGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbihmaWJlcil7VU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcil8fCdDb21wb25lbnQnKTtkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTt9KTtwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncz1bXTt9dmFyIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcz1uZXcgU2V0KCk7aWYocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGg+MCl7cGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKGZpYmVyKXtjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpfHwnQ29tcG9uZW50Jyk7ZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7fSk7cGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncz1bXTt9dmFyIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXM9bmV3IFNldCgpO2lmKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aD4wKXtwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKGZpYmVyKXtVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J0NvbXBvbmVudCcpO2RpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO30pO3BlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzPVtdO30vLyBGaW5hbGx5LCB3ZSBmbHVzaCBhbGwgdGhlIHdhcm5pbmdzXG4vLyBVTlNBRkVfIG9uZXMgYmVmb3JlIHRoZSBkZXByZWNhdGVkIG9uZXMsIHNpbmNlIHRoZXknbGwgYmUgJ2xvdWRlcidcbmlmKFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplPjApe3ZhciBzb3J0ZWROYW1lcz1zZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpO2Vycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnKydTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nKycqIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4nKydcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLHNvcnRlZE5hbWVzKTt9aWYoVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplPjApe3ZhciBfc29ydGVkTmFtZXM9c2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyk7ZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCAnKydhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnKydTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nKycqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJytcIiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgXCIrJ3JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvICcrJ3N0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9kZXJpdmVkLXN0YXRlXFxuJysnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyxfc29ydGVkTmFtZXMpO31pZihVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemU+MCl7dmFyIF9zb3J0ZWROYW1lczI9c2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyk7ZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCAnKydhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnKydTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nKycqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJysnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyxfc29ydGVkTmFtZXMyKTt9aWYoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZT4wKXt2YXIgX3NvcnRlZE5hbWVzMz1zZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyk7d2FybignY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJysnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJysnKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuJysnKiBSZW5hbWUgY29tcG9uZW50V2lsbE1vdW50IHRvIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgdG8gc3VwcHJlc3MgJysndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJysnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnKydgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nKydcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLF9zb3J0ZWROYW1lczMpO31pZihjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZT4wKXt2YXIgX3NvcnRlZE5hbWVzND1zZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMpO3dhcm4oJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnKydTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nKycqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJytcIiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgcmVmYWN0b3IgeW91ciBcIisnY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvICcrJ3N0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9kZXJpdmVkLXN0YXRlXFxuJysnKiBSZW5hbWUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBzdXBwcmVzcyAnKyd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnKydUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcrJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicrJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsX3NvcnRlZE5hbWVzNCk7fWlmKGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplPjApe3ZhciBfc29ydGVkTmFtZXM1PXNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyk7d2FybignY29tcG9uZW50V2lsbFVwZGF0ZSBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcrJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicrJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nKycqIFJlbmFtZSBjb21wb25lbnRXaWxsVXBkYXRlIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIHRvIHN1cHByZXNzICcrJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcrJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJysnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJysnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyxfc29ydGVkTmFtZXM1KTt9fTt2YXIgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nPW5ldyBNYXAoKTsvLyBUcmFja3MgY29tcG9uZW50cyB3ZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0LlxudmFyIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQ9bmV3IFNldCgpO1JlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nPWZ1bmN0aW9uKGZpYmVyLGluc3RhbmNlKXt2YXIgc3RyaWN0Um9vdD1maW5kU3RyaWN0Um9vdChmaWJlcik7aWYoc3RyaWN0Um9vdD09PW51bGwpe2Vycm9yKCdFeHBlY3RlZCB0byBmaW5kIGEgU3RyaWN0TW9kZSBjb21wb25lbnQgaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnKydUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO3JldHVybjt9Ly8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuaWYoZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5oYXMoZmliZXIudHlwZSkpe3JldHVybjt9dmFyIHdhcm5pbmdzRm9yUm9vdD1wZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZ2V0KHN0cmljdFJvb3QpO2lmKGZpYmVyLnR5cGUuY29udGV4dFR5cGVzIT1udWxsfHxmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzIT1udWxsfHxpbnN0YW5jZSE9PW51bGwmJnR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQ9PT0nZnVuY3Rpb24nKXtpZih3YXJuaW5nc0ZvclJvb3Q9PT11bmRlZmluZWQpe3dhcm5pbmdzRm9yUm9vdD1bXTtwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuc2V0KHN0cmljdFJvb3Qsd2FybmluZ3NGb3JSb290KTt9d2FybmluZ3NGb3JSb290LnB1c2goZmliZXIpO319O1JlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmc9ZnVuY3Rpb24oKXtwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZm9yRWFjaChmdW5jdGlvbihmaWJlckFycmF5LHN0cmljdFJvb3Qpe2lmKGZpYmVyQXJyYXkubGVuZ3RoPT09MCl7cmV0dXJuO312YXIgZmlyc3RGaWJlcj1maWJlckFycmF5WzBdO3ZhciB1bmlxdWVOYW1lcz1uZXcgU2V0KCk7ZmliZXJBcnJheS5mb3JFYWNoKGZ1bmN0aW9uKGZpYmVyKXt1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcil8fCdDb21wb25lbnQnKTtkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmFkZChmaWJlci50eXBlKTt9KTt2YXIgc29ydGVkTmFtZXM9c2V0VG9Tb3J0ZWRTdHJpbmcodW5pcXVlTmFtZXMpO3RyeXtzZXRDdXJyZW50RmliZXIoZmlyc3RGaWJlcik7ZXJyb3IoJ0xlZ2FjeSBjb250ZXh0IEFQSSBoYXMgYmVlbiBkZXRlY3RlZCB3aXRoaW4gYSBzdHJpY3QtbW9kZSB0cmVlLicrJ1xcblxcblRoZSBvbGQgQVBJIHdpbGwgYmUgc3VwcG9ydGVkIGluIGFsbCAxNi54IHJlbGVhc2VzLCBidXQgYXBwbGljYXRpb25zICcrJ3VzaW5nIGl0IHNob3VsZCBtaWdyYXRlIHRvIHRoZSBuZXcgdmVyc2lvbi4nKydcXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnKydcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvbGVnYWN5LWNvbnRleHQnLHNvcnRlZE5hbWVzKTt9ZmluYWxseXtyZXNldEN1cnJlbnRGaWJlcigpO319KTt9O1JlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmRpc2NhcmRQZW5kaW5nV2FybmluZ3M9ZnVuY3Rpb24oKXtwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3M9W107cGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncz1bXTtwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzPVtdO3BlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzPVtdO3BlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3M9W107cGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3M9W107cGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nPW5ldyBNYXAoKTt9O312YXIgZGlkV2FybkFib3V0TWFwczt2YXIgZGlkV2FybkFib3V0R2VuZXJhdG9yczt2YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmczt2YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nO3ZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmc7dmFyIHdhcm5Gb3JNaXNzaW5nS2V5PWZ1bmN0aW9uKGNoaWxkLHJldHVybkZpYmVyKXt9O3tkaWRXYXJuQWJvdXRNYXBzPWZhbHNlO2RpZFdhcm5BYm91dEdlbmVyYXRvcnM9ZmFsc2U7ZGlkV2FybkFib3V0U3RyaW5nUmVmcz17fTsvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovb3duZXJIYXNLZXlVc2VXYXJuaW5nPXt9O293bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZz17fTt3YXJuRm9yTWlzc2luZ0tleT1mdW5jdGlvbihjaGlsZCxyZXR1cm5GaWJlcil7aWYoY2hpbGQ9PT1udWxsfHx0eXBlb2YgY2hpbGQhPT0nb2JqZWN0Jyl7cmV0dXJuO31pZighY2hpbGQuX3N0b3JlfHxjaGlsZC5fc3RvcmUudmFsaWRhdGVkfHxjaGlsZC5rZXkhPW51bGwpe3JldHVybjt9aWYodHlwZW9mIGNoaWxkLl9zdG9yZSE9PSdvYmplY3QnKXt0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gJysnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9Y2hpbGQuX3N0b3JlLnZhbGlkYXRlZD10cnVlO3ZhciBjb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpfHwnQ29tcG9uZW50JztpZihvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50TmFtZV0pe3JldHVybjt9b3duZXJIYXNLZXlVc2VXYXJuaW5nW2NvbXBvbmVudE5hbWVdPXRydWU7ZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlICcrJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yICcrJ21vcmUgaW5mb3JtYXRpb24uJyk7fTt9ZnVuY3Rpb24gaXNSZWFjdENsYXNzKHR5cGUpe3JldHVybiB0eXBlLnByb3RvdHlwZSYmdHlwZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDt9ZnVuY3Rpb24gY29lcmNlUmVmKHJldHVybkZpYmVyLGN1cnJlbnQsZWxlbWVudCl7dmFyIG1peGVkUmVmPWVsZW1lbnQucmVmO2lmKG1peGVkUmVmIT09bnVsbCYmdHlwZW9mIG1peGVkUmVmIT09J2Z1bmN0aW9uJyYmdHlwZW9mIG1peGVkUmVmIT09J29iamVjdCcpe3svLyBUT0RPOiBDbGVhbiB0aGlzIHVwIG9uY2Ugd2UgdHVybiBvbiB0aGUgc3RyaW5nIHJlZiB3YXJuaW5nIGZvclxuLy8gZXZlcnlvbmUsIGJlY2F1c2UgdGhlIHN0cmljdCBtb2RlIGNhc2Ugd2lsbCBubyBsb25nZXIgYmUgcmVsZXZhbnRcbmlmKChyZXR1cm5GaWJlci5tb2RlJlN0cmljdExlZ2FjeU1vZGV8fHdhcm5BYm91dFN0cmluZ1JlZnMpJiYvLyBXZSB3YXJuIGluIFJlYWN0RWxlbWVudC5qcyBpZiBvd25lciBhbmQgc2VsZiBhcmUgZXF1YWwgZm9yIHN0cmluZyByZWZzXG4vLyBiZWNhdXNlIHRoZXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvblxuLy8gdXNpbmcgYSBjb2RlbW9kLiBUaGVyZWZvcmUsIHdlIGRvbid0IGhhdmUgdG8gd2FybiBhYm91dCBzdHJpbmcgcmVmcyBhZ2Fpbi5cbiEoZWxlbWVudC5fb3duZXImJmVsZW1lbnQuX3NlbGYmJmVsZW1lbnQuX293bmVyLnN0YXRlTm9kZSE9PWVsZW1lbnQuX3NlbGYpJiYvLyBXaWxsIGFscmVhZHkgdGhyb3cgd2l0aCBcIkZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgc3RyaW5nIHJlZnNcIlxuIShlbGVtZW50Ll9vd25lciYmZWxlbWVudC5fb3duZXIudGFnIT09Q2xhc3NDb21wb25lbnQpJiYvLyBXaWxsIGFscmVhZHkgd2FybiB3aXRoIFwiRnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmc1wiXG4hKHR5cGVvZiBlbGVtZW50LnR5cGU9PT0nZnVuY3Rpb24nJiYhaXNSZWFjdENsYXNzKGVsZW1lbnQudHlwZSkpJiYvLyBXaWxsIGFscmVhZHkgdGhyb3cgd2l0aCBcIkVsZW1lbnQgcmVmIHdhcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKHNvbWVTdHJpbmdSZWYpIGJ1dCBubyBvd25lciB3YXMgc2V0XCJcbmVsZW1lbnQuX293bmVyKXt2YXIgY29tcG9uZW50TmFtZT1nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKXx8J0NvbXBvbmVudCc7aWYoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pe3tlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuIFN1cHBvcnQgZm9yIHN0cmluZyByZWZzICcrJ3dpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBXZSByZWNvbW1lbmQgdXNpbmcgJysndXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJysnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnKydodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsY29tcG9uZW50TmFtZSxtaXhlZFJlZik7fWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV09dHJ1ZTt9fX1pZihlbGVtZW50Ll9vd25lcil7dmFyIG93bmVyPWVsZW1lbnQuX293bmVyO3ZhciBpbnN0O2lmKG93bmVyKXt2YXIgb3duZXJGaWJlcj1vd25lcjtpZihvd25lckZpYmVyLnRhZyE9PUNsYXNzQ29tcG9uZW50KXt0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgc3RyaW5nIHJlZnMuICcrJ1dlIHJlY29tbWVuZCB1c2luZyB1c2VSZWYoKSBpbnN0ZWFkLiAnKydMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJyk7fWluc3Q9b3duZXJGaWJlci5zdGF0ZU5vZGU7fWlmKCFpbnN0KXt0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIG93bmVyIGZvciBzdHJpbmcgcmVmIFwiK21peGVkUmVmK1wiLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBcIisnYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9Ly8gQXNzaWduaW5nIHRoaXMgdG8gYSBjb25zdCBzbyBGbG93IGtub3dzIGl0IHdvbid0IGNoYW5nZSBpbiB0aGUgY2xvc3VyZVxudmFyIHJlc29sdmVkSW5zdD1pbnN0O3tjaGVja1Byb3BTdHJpbmdDb2VyY2lvbihtaXhlZFJlZiwncmVmJyk7fXZhciBzdHJpbmdSZWY9JycrbWl4ZWRSZWY7Ly8gQ2hlY2sgaWYgcHJldmlvdXMgc3RyaW5nIHJlZiBtYXRjaGVzIG5ldyBzdHJpbmcgcmVmXG5pZihjdXJyZW50IT09bnVsbCYmY3VycmVudC5yZWYhPT1udWxsJiZ0eXBlb2YgY3VycmVudC5yZWY9PT0nZnVuY3Rpb24nJiZjdXJyZW50LnJlZi5fc3RyaW5nUmVmPT09c3RyaW5nUmVmKXtyZXR1cm4gY3VycmVudC5yZWY7fXZhciByZWY9ZnVuY3Rpb24odmFsdWUpe3ZhciByZWZzPXJlc29sdmVkSW5zdC5yZWZzO2lmKHZhbHVlPT09bnVsbCl7ZGVsZXRlIHJlZnNbc3RyaW5nUmVmXTt9ZWxzZXtyZWZzW3N0cmluZ1JlZl09dmFsdWU7fX07cmVmLl9zdHJpbmdSZWY9c3RyaW5nUmVmO3JldHVybiByZWY7fWVsc2V7aWYodHlwZW9mIG1peGVkUmVmIT09J3N0cmluZycpe3Rocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24sIGEgc3RyaW5nLCBhbiBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlUmVmKCksIG9yIG51bGwuJyk7fWlmKCFlbGVtZW50Ll9vd25lcil7dGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoXCIrbWl4ZWRSZWYrXCIpIGJ1dCBubyBvd25lciB3YXMgc2V0LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mXCIrJyB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuJysnMS4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBmdW5jdGlvbiBjb21wb25lbnRcXG4nK1wiMi4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50J3MgcmVuZGVyIG1ldGhvZFxcblwiKyczLiBZb3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkXFxuJysnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWZzLW11c3QtaGF2ZS1vd25lciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTt9fX1yZXR1cm4gbWl4ZWRSZWY7fWZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlcixuZXdDaGlsZCl7dmFyIGNoaWxkU3RyaW5nPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZCk7dGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIisoY2hpbGRTdHJpbmc9PT0nW29iamVjdCBPYmplY3RdJz8nb2JqZWN0IHdpdGgga2V5cyB7JytPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbignLCAnKSsnfSc6Y2hpbGRTdHJpbmcpK1wiKS4gXCIrJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJysnaW5zdGVhZC4nKTt9ZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKXt7dmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcil8fCdDb21wb25lbnQnO2lmKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjb21wb25lbnROYW1lXSl7cmV0dXJuO31vd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY29tcG9uZW50TmFtZV09dHJ1ZTtlcnJvcignRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcrJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnKydPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nKTt9fWZ1bmN0aW9uIHJlc29sdmVMYXp5KGxhenlUeXBlKXt2YXIgcGF5bG9hZD1sYXp5VHlwZS5fcGF5bG9hZDt2YXIgaW5pdD1sYXp5VHlwZS5faW5pdDtyZXR1cm4gaW5pdChwYXlsb2FkKTt9Ly8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGV4aXN0cyBiZWNhdXNlIEkgZXhwZWN0IHRvIGNsb25lIHRoZSBjb2RlIGluIGVhY2ggcGF0aFxuLy8gdG8gYmUgYWJsZSB0byBvcHRpbWl6ZSBlYWNoIHBhdGggaW5kaXZpZHVhbGx5IGJ5IGJyYW5jaGluZyBlYXJseS4gVGhpcyBuZWVkc1xuLy8gYSBjb21waWxlciBvciB3ZSBjYW4gZG8gaXQgbWFudWFsbHkuIEhlbHBlcnMgdGhhdCBkb24ndCBuZWVkIHRoaXMgYnJhbmNoaW5nXG4vLyBsaXZlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cbmZ1bmN0aW9uIENoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKXtmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlcixjaGlsZFRvRGVsZXRlKXtpZighc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyl7Ly8gTm9vcC5cbnJldHVybjt9dmFyIGRlbGV0aW9ucz1yZXR1cm5GaWJlci5kZWxldGlvbnM7aWYoZGVsZXRpb25zPT09bnVsbCl7cmV0dXJuRmliZXIuZGVsZXRpb25zPVtjaGlsZFRvRGVsZXRlXTtyZXR1cm5GaWJlci5mbGFnc3w9Q2hpbGREZWxldGlvbjt9ZWxzZXtkZWxldGlvbnMucHVzaChjaGlsZFRvRGVsZXRlKTt9fWZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkKXtpZighc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyl7Ly8gTm9vcC5cbnJldHVybiBudWxsO30vLyBUT0RPOiBGb3IgdGhlIHNob3VsZENsb25lIGNhc2UsIHRoaXMgY291bGQgYmUgbWljcm8tb3B0aW1pemVkIGEgYml0IGJ5XG4vLyBhc3N1bWluZyB0aGF0IGFmdGVyIHRoZSBmaXJzdCBjaGlsZCB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGV2ZXJ5dGhpbmcuXG52YXIgY2hpbGRUb0RlbGV0ZT1jdXJyZW50Rmlyc3RDaGlsZDt3aGlsZShjaGlsZFRvRGVsZXRlIT09bnVsbCl7ZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsY2hpbGRUb0RlbGV0ZSk7Y2hpbGRUb0RlbGV0ZT1jaGlsZFRvRGVsZXRlLnNpYmxpbmc7fXJldHVybiBudWxsO31mdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCl7Ly8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuLy8gaW5zdGVhZC5cbnZhciBleGlzdGluZ0NoaWxkcmVuPW5ldyBNYXAoKTt2YXIgZXhpc3RpbmdDaGlsZD1jdXJyZW50Rmlyc3RDaGlsZDt3aGlsZShleGlzdGluZ0NoaWxkIT09bnVsbCl7aWYoZXhpc3RpbmdDaGlsZC5rZXkhPT1udWxsKXtleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmtleSxleGlzdGluZ0NoaWxkKTt9ZWxzZXtleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmluZGV4LGV4aXN0aW5nQ2hpbGQpO31leGlzdGluZ0NoaWxkPWV4aXN0aW5nQ2hpbGQuc2libGluZzt9cmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47fWZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLHBlbmRpbmdQcm9wcyl7Ly8gV2UgY3VycmVudGx5IHNldCBzaWJsaW5nIHRvIG51bGwgYW5kIGluZGV4IHRvIDAgaGVyZSBiZWNhdXNlIGl0IGlzIGVhc3lcbi8vIHRvIGZvcmdldCB0byBkbyBiZWZvcmUgcmV0dXJuaW5nIGl0LiBFLmcuIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuXG52YXIgY2xvbmU9Y3JlYXRlV29ya0luUHJvZ3Jlc3MoZmliZXIscGVuZGluZ1Byb3BzKTtjbG9uZS5pbmRleD0wO2Nsb25lLnNpYmxpbmc9bnVsbDtyZXR1cm4gY2xvbmU7fWZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsbGFzdFBsYWNlZEluZGV4LG5ld0luZGV4KXtuZXdGaWJlci5pbmRleD1uZXdJbmRleDtpZighc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyl7Ly8gRHVyaW5nIGh5ZHJhdGlvbiwgdGhlIHVzZUlkIGFsZ29yaXRobSBuZWVkcyB0byBrbm93IHdoaWNoIGZpYmVycyBhcmVcbi8vIHBhcnQgb2YgYSBsaXN0IG9mIGNoaWxkcmVuIChhcnJheXMsIGl0ZXJhdG9ycykuXG5uZXdGaWJlci5mbGFnc3w9Rm9ya2VkO3JldHVybiBsYXN0UGxhY2VkSW5kZXg7fXZhciBjdXJyZW50PW5ld0ZpYmVyLmFsdGVybmF0ZTtpZihjdXJyZW50IT09bnVsbCl7dmFyIG9sZEluZGV4PWN1cnJlbnQuaW5kZXg7aWYob2xkSW5kZXg8bGFzdFBsYWNlZEluZGV4KXsvLyBUaGlzIGlzIGEgbW92ZS5cbm5ld0ZpYmVyLmZsYWdzfD1QbGFjZW1lbnQ7cmV0dXJuIGxhc3RQbGFjZWRJbmRleDt9ZWxzZXsvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG5yZXR1cm4gb2xkSW5kZXg7fX1lbHNley8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uLlxubmV3RmliZXIuZmxhZ3N8PVBsYWNlbWVudDtyZXR1cm4gbGFzdFBsYWNlZEluZGV4O319ZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcil7Ly8gVGhpcyBpcyBzaW1wbGVyIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuIFdlIG9ubHkgbmVlZCB0byBkbyBhXG4vLyBwbGFjZW1lbnQgZm9yIGluc2VydGluZyBuZXcgY2hpbGRyZW4uXG5pZihzaG91bGRUcmFja1NpZGVFZmZlY3RzJiZuZXdGaWJlci5hbHRlcm5hdGU9PT1udWxsKXtuZXdGaWJlci5mbGFnc3w9UGxhY2VtZW50O31yZXR1cm4gbmV3RmliZXI7fWZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLGN1cnJlbnQsdGV4dENvbnRlbnQsbGFuZXMpe2lmKGN1cnJlbnQ9PT1udWxsfHxjdXJyZW50LnRhZyE9PUhvc3RUZXh0KXsvLyBJbnNlcnRcbnZhciBjcmVhdGVkPWNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQscmV0dXJuRmliZXIubW9kZSxsYW5lcyk7Y3JlYXRlZC5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIGNyZWF0ZWQ7fWVsc2V7Ly8gVXBkYXRlXG52YXIgZXhpc3Rpbmc9dXNlRmliZXIoY3VycmVudCx0ZXh0Q29udGVudCk7ZXhpc3RpbmcucmV0dXJuPXJldHVybkZpYmVyO3JldHVybiBleGlzdGluZzt9fWZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsY3VycmVudCxlbGVtZW50LGxhbmVzKXt2YXIgZWxlbWVudFR5cGU9ZWxlbWVudC50eXBlO2lmKGVsZW1lbnRUeXBlPT09UkVBQ1RfRlJBR01FTlRfVFlQRSl7cmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLGN1cnJlbnQsZWxlbWVudC5wcm9wcy5jaGlsZHJlbixsYW5lcyxlbGVtZW50LmtleSk7fWlmKGN1cnJlbnQhPT1udWxsKXtpZihjdXJyZW50LmVsZW1lbnRUeXBlPT09ZWxlbWVudFR5cGV8fC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGN1cnJlbnQsZWxlbWVudCl8fC8vIExhenkgdHlwZXMgc2hvdWxkIHJlY29uY2lsZSB0aGVpciByZXNvbHZlZCB0eXBlLlxuLy8gV2UgbmVlZCB0byBkbyB0aGlzIGFmdGVyIHRoZSBIb3QgUmVsb2FkaW5nIGNoZWNrIGFib3ZlLFxuLy8gYmVjYXVzZSBob3QgcmVsb2FkaW5nIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzIHRoYW4gcHJvZCBiZWNhdXNlXG4vLyBpdCBkb2Vzbid0IHJlc3VzcGVuZC4gU28gd2UgY2FuJ3QgbGV0IHRoZSBjYWxsIGJlbG93IHN1c3BlbmQuXG50eXBlb2YgZWxlbWVudFR5cGU9PT0nb2JqZWN0JyYmZWxlbWVudFR5cGUhPT1udWxsJiZlbGVtZW50VHlwZS4kJHR5cGVvZj09PVJFQUNUX0xBWllfVFlQRSYmcmVzb2x2ZUxhenkoZWxlbWVudFR5cGUpPT09Y3VycmVudC50eXBlKXsvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG52YXIgZXhpc3Rpbmc9dXNlRmliZXIoY3VycmVudCxlbGVtZW50LnByb3BzKTtleGlzdGluZy5yZWY9Y29lcmNlUmVmKHJldHVybkZpYmVyLGN1cnJlbnQsZWxlbWVudCk7ZXhpc3RpbmcucmV0dXJuPXJldHVybkZpYmVyO3tleGlzdGluZy5fZGVidWdTb3VyY2U9ZWxlbWVudC5fc291cmNlO2V4aXN0aW5nLl9kZWJ1Z093bmVyPWVsZW1lbnQuX293bmVyO31yZXR1cm4gZXhpc3Rpbmc7fX0vLyBJbnNlcnRcbnZhciBjcmVhdGVkPWNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCxyZXR1cm5GaWJlci5tb2RlLGxhbmVzKTtjcmVhdGVkLnJlZj1jb2VyY2VSZWYocmV0dXJuRmliZXIsY3VycmVudCxlbGVtZW50KTtjcmVhdGVkLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gY3JlYXRlZDt9ZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLGN1cnJlbnQscG9ydGFsLGxhbmVzKXtpZihjdXJyZW50PT09bnVsbHx8Y3VycmVudC50YWchPT1Ib3N0UG9ydGFsfHxjdXJyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvIT09cG9ydGFsLmNvbnRhaW5lckluZm98fGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uIT09cG9ydGFsLmltcGxlbWVudGF0aW9uKXsvLyBJbnNlcnRcbnZhciBjcmVhdGVkPWNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwscmV0dXJuRmliZXIubW9kZSxsYW5lcyk7Y3JlYXRlZC5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIGNyZWF0ZWQ7fWVsc2V7Ly8gVXBkYXRlXG52YXIgZXhpc3Rpbmc9dXNlRmliZXIoY3VycmVudCxwb3J0YWwuY2hpbGRyZW58fFtdKTtleGlzdGluZy5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIGV4aXN0aW5nO319ZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsY3VycmVudCxmcmFnbWVudCxsYW5lcyxrZXkpe2lmKGN1cnJlbnQ9PT1udWxsfHxjdXJyZW50LnRhZyE9PUZyYWdtZW50KXsvLyBJbnNlcnRcbnZhciBjcmVhdGVkPWNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZyYWdtZW50LHJldHVybkZpYmVyLm1vZGUsbGFuZXMsa2V5KTtjcmVhdGVkLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gY3JlYXRlZDt9ZWxzZXsvLyBVcGRhdGVcbnZhciBleGlzdGluZz11c2VGaWJlcihjdXJyZW50LGZyYWdtZW50KTtleGlzdGluZy5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIGV4aXN0aW5nO319ZnVuY3Rpb24gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsbmV3Q2hpbGQsbGFuZXMpe2lmKHR5cGVvZiBuZXdDaGlsZD09PSdzdHJpbmcnJiZuZXdDaGlsZCE9PScnfHx0eXBlb2YgbmV3Q2hpbGQ9PT0nbnVtYmVyJyl7Ly8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbi8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4vLyBub2RlLlxudmFyIGNyZWF0ZWQ9Y3JlYXRlRmliZXJGcm9tVGV4dCgnJytuZXdDaGlsZCxyZXR1cm5GaWJlci5tb2RlLGxhbmVzKTtjcmVhdGVkLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gY3JlYXRlZDt9aWYodHlwZW9mIG5ld0NoaWxkPT09J29iamVjdCcmJm5ld0NoaWxkIT09bnVsbCl7c3dpdGNoKG5ld0NoaWxkLiQkdHlwZW9mKXtjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTp7dmFyIF9jcmVhdGVkPWNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQscmV0dXJuRmliZXIubW9kZSxsYW5lcyk7X2NyZWF0ZWQucmVmPWNvZXJjZVJlZihyZXR1cm5GaWJlcixudWxsLG5ld0NoaWxkKTtfY3JlYXRlZC5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIF9jcmVhdGVkO31jYXNlIFJFQUNUX1BPUlRBTF9UWVBFOnt2YXIgX2NyZWF0ZWQyPWNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCxyZXR1cm5GaWJlci5tb2RlLGxhbmVzKTtfY3JlYXRlZDIucmV0dXJuPXJldHVybkZpYmVyO3JldHVybiBfY3JlYXRlZDI7fWNhc2UgUkVBQ1RfTEFaWV9UWVBFOnt2YXIgcGF5bG9hZD1uZXdDaGlsZC5fcGF5bG9hZDt2YXIgaW5pdD1uZXdDaGlsZC5faW5pdDtyZXR1cm4gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsaW5pdChwYXlsb2FkKSxsYW5lcyk7fX1pZihpc0FycmF5KG5ld0NoaWxkKXx8Z2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpe3ZhciBfY3JlYXRlZDM9Y3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQscmV0dXJuRmliZXIubW9kZSxsYW5lcyxudWxsKTtfY3JlYXRlZDMucmV0dXJuPXJldHVybkZpYmVyO3JldHVybiBfY3JlYXRlZDM7fXRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlcixuZXdDaGlsZCk7fXtpZih0eXBlb2YgbmV3Q2hpbGQ9PT0nZnVuY3Rpb24nKXt3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO319cmV0dXJuIG51bGw7fWZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsb2xkRmliZXIsbmV3Q2hpbGQsbGFuZXMpey8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cbnZhciBrZXk9b2xkRmliZXIhPT1udWxsP29sZEZpYmVyLmtleTpudWxsO2lmKHR5cGVvZiBuZXdDaGlsZD09PSdzdHJpbmcnJiZuZXdDaGlsZCE9PScnfHx0eXBlb2YgbmV3Q2hpbGQ9PT0nbnVtYmVyJyl7Ly8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbi8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4vLyBub2RlLlxuaWYoa2V5IT09bnVsbCl7cmV0dXJuIG51bGw7fXJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlcixvbGRGaWJlciwnJytuZXdDaGlsZCxsYW5lcyk7fWlmKHR5cGVvZiBuZXdDaGlsZD09PSdvYmplY3QnJiZuZXdDaGlsZCE9PW51bGwpe3N3aXRjaChuZXdDaGlsZC4kJHR5cGVvZil7Y2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6e2lmKG5ld0NoaWxkLmtleT09PWtleSl7cmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsb2xkRmliZXIsbmV3Q2hpbGQsbGFuZXMpO31lbHNle3JldHVybiBudWxsO319Y2FzZSBSRUFDVF9QT1JUQUxfVFlQRTp7aWYobmV3Q2hpbGQua2V5PT09a2V5KXtyZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLG9sZEZpYmVyLG5ld0NoaWxkLGxhbmVzKTt9ZWxzZXtyZXR1cm4gbnVsbDt9fWNhc2UgUkVBQ1RfTEFaWV9UWVBFOnt2YXIgcGF5bG9hZD1uZXdDaGlsZC5fcGF5bG9hZDt2YXIgaW5pdD1uZXdDaGlsZC5faW5pdDtyZXR1cm4gdXBkYXRlU2xvdChyZXR1cm5GaWJlcixvbGRGaWJlcixpbml0KHBheWxvYWQpLGxhbmVzKTt9fWlmKGlzQXJyYXkobmV3Q2hpbGQpfHxnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSl7aWYoa2V5IT09bnVsbCl7cmV0dXJuIG51bGw7fXJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlcixvbGRGaWJlcixuZXdDaGlsZCxsYW5lcyxudWxsKTt9dGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLG5ld0NoaWxkKTt9e2lmKHR5cGVvZiBuZXdDaGlsZD09PSdmdW5jdGlvbicpe3dhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7fX1yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLHJldHVybkZpYmVyLG5ld0lkeCxuZXdDaGlsZCxsYW5lcyl7aWYodHlwZW9mIG5ld0NoaWxkPT09J3N0cmluZycmJm5ld0NoaWxkIT09Jyd8fHR5cGVvZiBuZXdDaGlsZD09PSdudW1iZXInKXsvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4vLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgdGV4dCBub2RlcywgdGhleSBtYXRjaC5cbnZhciBtYXRjaGVkRmliZXI9ZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KXx8bnVsbDtyZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsbWF0Y2hlZEZpYmVyLCcnK25ld0NoaWxkLGxhbmVzKTt9aWYodHlwZW9mIG5ld0NoaWxkPT09J29iamVjdCcmJm5ld0NoaWxkIT09bnVsbCl7c3dpdGNoKG5ld0NoaWxkLiQkdHlwZW9mKXtjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTp7dmFyIF9tYXRjaGVkRmliZXI9ZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5PT09bnVsbD9uZXdJZHg6bmV3Q2hpbGQua2V5KXx8bnVsbDtyZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlcixfbWF0Y2hlZEZpYmVyLG5ld0NoaWxkLGxhbmVzKTt9Y2FzZSBSRUFDVF9QT1JUQUxfVFlQRTp7dmFyIF9tYXRjaGVkRmliZXIyPWV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleT09PW51bGw/bmV3SWR4Om5ld0NoaWxkLmtleSl8fG51bGw7cmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlcixfbWF0Y2hlZEZpYmVyMixuZXdDaGlsZCxsYW5lcyk7fWNhc2UgUkVBQ1RfTEFaWV9UWVBFOnZhciBwYXlsb2FkPW5ld0NoaWxkLl9wYXlsb2FkO3ZhciBpbml0PW5ld0NoaWxkLl9pbml0O3JldHVybiB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4scmV0dXJuRmliZXIsbmV3SWR4LGluaXQocGF5bG9hZCksbGFuZXMpO31pZihpc0FycmF5KG5ld0NoaWxkKXx8Z2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpe3ZhciBfbWF0Y2hlZEZpYmVyMz1leGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpfHxudWxsO3JldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlcixfbWF0Y2hlZEZpYmVyMyxuZXdDaGlsZCxsYW5lcyxudWxsKTt9dGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLG5ld0NoaWxkKTt9e2lmKHR5cGVvZiBuZXdDaGlsZD09PSdmdW5jdGlvbicpe3dhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7fX1yZXR1cm4gbnVsbDt9LyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL2Z1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsa25vd25LZXlzLHJldHVybkZpYmVyKXt7aWYodHlwZW9mIGNoaWxkIT09J29iamVjdCd8fGNoaWxkPT09bnVsbCl7cmV0dXJuIGtub3duS2V5czt9c3dpdGNoKGNoaWxkLiQkdHlwZW9mKXtjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOndhcm5Gb3JNaXNzaW5nS2V5KGNoaWxkLHJldHVybkZpYmVyKTt2YXIga2V5PWNoaWxkLmtleTtpZih0eXBlb2Yga2V5IT09J3N0cmluZycpe2JyZWFrO31pZihrbm93bktleXM9PT1udWxsKXtrbm93bktleXM9bmV3IFNldCgpO2tub3duS2V5cy5hZGQoa2V5KTticmVhazt9aWYoIWtub3duS2V5cy5oYXMoa2V5KSl7a25vd25LZXlzLmFkZChrZXkpO2JyZWFrO31lcnJvcignRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiAnKydLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcrJ2Fjcm9zcyB1cGRhdGVzLiBOb24tdW5pcXVlIGtleXMgbWF5IGNhdXNlIGNoaWxkcmVuIHRvIGJlICcrJ2R1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQg4oCUIHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgJysnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJyxrZXkpO2JyZWFrO2Nhc2UgUkVBQ1RfTEFaWV9UWVBFOnZhciBwYXlsb2FkPWNoaWxkLl9wYXlsb2FkO3ZhciBpbml0PWNoaWxkLl9pbml0O3dhcm5PbkludmFsaWRLZXkoaW5pdChwYXlsb2FkKSxrbm93bktleXMscmV0dXJuRmliZXIpO2JyZWFrO319cmV0dXJuIGtub3duS2V5czt9ZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCxuZXdDaGlsZHJlbixsYW5lcyl7Ly8gVGhpcyBhbGdvcml0aG0gY2FuJ3Qgb3B0aW1pemUgYnkgc2VhcmNoaW5nIGZyb20gYm90aCBlbmRzIHNpbmNlIHdlXG4vLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuLy8gd2l0aCB0aGF0IG1vZGVsLiBJZiBpdCBlbmRzIHVwIG5vdCBiZWluZyB3b3J0aCB0aGUgdHJhZGVvZmZzLCB3ZSBjYW5cbi8vIGFkZCBpdCBsYXRlci5cbi8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2Vcbi8vIHdoZXJlIHRoZXJlIGFyZSBmZXcgY2hhbmdlcyBhbmQgYnJ1dGUgZm9yY2UgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZlxuLy8gZ29pbmcgZm9yIHRoZSBNYXAuIEl0J2QgbGlrZSB0byBleHBsb3JlIGhpdHRpbmcgdGhhdCBwYXRoIGZpcnN0IGluXG4vLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbi8vIGxvdHMgb2YgbG9vayBhaGVhZC4gVGhpcyBkb2Vzbid0IGhhbmRsZSByZXZlcnNhbCBhcyB3ZWxsIGFzIHR3byBlbmRlZFxuLy8gc2VhcmNoIGJ1dCB0aGF0J3MgdW51c3VhbC4gQmVzaWRlcywgZm9yIHRoZSB0d28gZW5kZWQgb3B0aW1pemF0aW9uIHRvXG4vLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cbi8vIEluIHRoaXMgZmlyc3QgaXRlcmF0aW9uLCB3ZSdsbCBqdXN0IGxpdmUgd2l0aCBoaXR0aW5nIHRoZSBiYWQgY2FzZVxuLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG4vLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4vLyB1c2VzIHRoZSBzYW1lIGFsZ29yaXRobS5cbnsvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbnZhciBrbm93bktleXM9bnVsbDtmb3IodmFyIGk9MDtpPG5ld0NoaWxkcmVuLmxlbmd0aDtpKyspe3ZhciBjaGlsZD1uZXdDaGlsZHJlbltpXTtrbm93bktleXM9d2Fybk9uSW52YWxpZEtleShjaGlsZCxrbm93bktleXMscmV0dXJuRmliZXIpO319dmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ9bnVsbDt2YXIgcHJldmlvdXNOZXdGaWJlcj1udWxsO3ZhciBvbGRGaWJlcj1jdXJyZW50Rmlyc3RDaGlsZDt2YXIgbGFzdFBsYWNlZEluZGV4PTA7dmFyIG5ld0lkeD0wO3ZhciBuZXh0T2xkRmliZXI9bnVsbDtmb3IoO29sZEZpYmVyIT09bnVsbCYmbmV3SWR4PG5ld0NoaWxkcmVuLmxlbmd0aDtuZXdJZHgrKyl7aWYob2xkRmliZXIuaW5kZXg+bmV3SWR4KXtuZXh0T2xkRmliZXI9b2xkRmliZXI7b2xkRmliZXI9bnVsbDt9ZWxzZXtuZXh0T2xkRmliZXI9b2xkRmliZXIuc2libGluZzt9dmFyIG5ld0ZpYmVyPXVwZGF0ZVNsb3QocmV0dXJuRmliZXIsb2xkRmliZXIsbmV3Q2hpbGRyZW5bbmV3SWR4XSxsYW5lcyk7aWYobmV3RmliZXI9PT1udWxsKXsvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4vLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbmlmKG9sZEZpYmVyPT09bnVsbCl7b2xkRmliZXI9bmV4dE9sZEZpYmVyO31icmVhazt9aWYoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyl7aWYob2xkRmliZXImJm5ld0ZpYmVyLmFsdGVybmF0ZT09PW51bGwpey8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsb2xkRmliZXIpO319bGFzdFBsYWNlZEluZGV4PXBsYWNlQ2hpbGQobmV3RmliZXIsbGFzdFBsYWNlZEluZGV4LG5ld0lkeCk7aWYocHJldmlvdXNOZXdGaWJlcj09PW51bGwpey8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbnJlc3VsdGluZ0ZpcnN0Q2hpbGQ9bmV3RmliZXI7fWVsc2V7Ly8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxucHJldmlvdXNOZXdGaWJlci5zaWJsaW5nPW5ld0ZpYmVyO31wcmV2aW91c05ld0ZpYmVyPW5ld0ZpYmVyO29sZEZpYmVyPW5leHRPbGRGaWJlcjt9aWYobmV3SWR4PT09bmV3Q2hpbGRyZW4ubGVuZ3RoKXsvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbmRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLG9sZEZpYmVyKTtpZihnZXRJc0h5ZHJhdGluZygpKXt2YXIgbnVtYmVyT2ZGb3Jrcz1uZXdJZHg7cHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLG51bWJlck9mRm9ya3MpO31yZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDt9aWYob2xkRmliZXI9PT1udWxsKXsvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbi8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG5mb3IoO25ld0lkeDxuZXdDaGlsZHJlbi5sZW5ndGg7bmV3SWR4Kyspe3ZhciBfbmV3RmliZXI9Y3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsbmV3Q2hpbGRyZW5bbmV3SWR4XSxsYW5lcyk7aWYoX25ld0ZpYmVyPT09bnVsbCl7Y29udGludWU7fWxhc3RQbGFjZWRJbmRleD1wbGFjZUNoaWxkKF9uZXdGaWJlcixsYXN0UGxhY2VkSW5kZXgsbmV3SWR4KTtpZihwcmV2aW91c05ld0ZpYmVyPT09bnVsbCl7Ly8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxucmVzdWx0aW5nRmlyc3RDaGlsZD1fbmV3RmliZXI7fWVsc2V7cHJldmlvdXNOZXdGaWJlci5zaWJsaW5nPV9uZXdGaWJlcjt9cHJldmlvdXNOZXdGaWJlcj1fbmV3RmliZXI7fWlmKGdldElzSHlkcmF0aW5nKCkpe3ZhciBfbnVtYmVyT2ZGb3Jrcz1uZXdJZHg7cHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLF9udW1iZXJPZkZvcmtzKTt9cmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7fS8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxudmFyIGV4aXN0aW5nQ2hpbGRyZW49bWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsb2xkRmliZXIpOy8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbmZvcig7bmV3SWR4PG5ld0NoaWxkcmVuLmxlbmd0aDtuZXdJZHgrKyl7dmFyIF9uZXdGaWJlcjI9dXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLHJldHVybkZpYmVyLG5ld0lkeCxuZXdDaGlsZHJlbltuZXdJZHhdLGxhbmVzKTtpZihfbmV3RmliZXIyIT09bnVsbCl7aWYoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyl7aWYoX25ld0ZpYmVyMi5hbHRlcm5hdGUhPT1udWxsKXsvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4vLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbi8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4vLyBsaXN0LlxuZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyMi5rZXk9PT1udWxsP25ld0lkeDpfbmV3RmliZXIyLmtleSk7fX1sYXN0UGxhY2VkSW5kZXg9cGxhY2VDaGlsZChfbmV3RmliZXIyLGxhc3RQbGFjZWRJbmRleCxuZXdJZHgpO2lmKHByZXZpb3VzTmV3RmliZXI9PT1udWxsKXtyZXN1bHRpbmdGaXJzdENoaWxkPV9uZXdGaWJlcjI7fWVsc2V7cHJldmlvdXNOZXdGaWJlci5zaWJsaW5nPV9uZXdGaWJlcjI7fXByZXZpb3VzTmV3RmliZXI9X25ld0ZpYmVyMjt9fWlmKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpey8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4vLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbmV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCl7cmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLGNoaWxkKTt9KTt9aWYoZ2V0SXNIeWRyYXRpbmcoKSl7dmFyIF9udW1iZXJPZkZvcmtzMj1uZXdJZHg7cHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLF9udW1iZXJPZkZvcmtzMik7fXJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO31mdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkLG5ld0NoaWxkcmVuSXRlcmFibGUsbGFuZXMpey8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuLy8gYnV0IHVzaW5nIHRoZSBpdGVyYXRvciBpbnN0ZWFkLlxudmFyIGl0ZXJhdG9yRm49Z2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbkl0ZXJhYmxlKTtpZih0eXBlb2YgaXRlcmF0b3JGbiE9PSdmdW5jdGlvbicpe3Rocm93IG5ldyBFcnJvcignQW4gb2JqZWN0IGlzIG5vdCBhbiBpdGVyYWJsZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluICcrJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9ey8vIFdlIGRvbid0IHN1cHBvcnQgcmVuZGVyaW5nIEdlbmVyYXRvcnMgYmVjYXVzZSBpdCdzIGEgbXV0YXRpb24uXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjk5NVxuaWYodHlwZW9mIFN5bWJvbD09PSdmdW5jdGlvbicmJi8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgdG9TdHJpbmdUYWdcbm5ld0NoaWxkcmVuSXRlcmFibGVbU3ltYm9sLnRvU3RyaW5nVGFnXT09PSdHZW5lcmF0b3InKXtpZighZGlkV2FybkFib3V0R2VuZXJhdG9ycyl7ZXJyb3IoJ1VzaW5nIEdlbmVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcrJ3VuZXhwZWN0ZWQgcmVzdWx0cyBiZWNhdXNlIGVudW1lcmF0aW5nIGEgZ2VuZXJhdG9yIG11dGF0ZXMgaXQuICcrJ1lvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSAnKydgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIEtlZXAgaW4gbWluZCAnKyd5b3UgbWlnaHQgbmVlZCB0byBwb2x5ZmlsbCB0aGVzZSBmZWF0dXJlcyBmb3Igb2xkZXIgYnJvd3NlcnMuJyk7fWRpZFdhcm5BYm91dEdlbmVyYXRvcnM9dHJ1ZTt9Ly8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG5pZihuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXM9PT1pdGVyYXRvckZuKXtpZighZGlkV2FybkFib3V0TWFwcyl7ZXJyb3IoJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJysnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTt9ZGlkV2FybkFib3V0TWFwcz10cnVlO30vLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbi8vIFdlJ2xsIGdldCBhIGRpZmZlcmVudCBpdGVyYXRvciBsYXRlciBmb3IgdGhlIG1haW4gcGFzcy5cbnZhciBfbmV3Q2hpbGRyZW49aXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO2lmKF9uZXdDaGlsZHJlbil7dmFyIGtub3duS2V5cz1udWxsO3ZhciBfc3RlcD1fbmV3Q2hpbGRyZW4ubmV4dCgpO2Zvcig7IV9zdGVwLmRvbmU7X3N0ZXA9X25ld0NoaWxkcmVuLm5leHQoKSl7dmFyIGNoaWxkPV9zdGVwLnZhbHVlO2tub3duS2V5cz13YXJuT25JbnZhbGlkS2V5KGNoaWxkLGtub3duS2V5cyxyZXR1cm5GaWJlcik7fX19dmFyIG5ld0NoaWxkcmVuPWl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtpZihuZXdDaGlsZHJlbj09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJyk7fXZhciByZXN1bHRpbmdGaXJzdENoaWxkPW51bGw7dmFyIHByZXZpb3VzTmV3RmliZXI9bnVsbDt2YXIgb2xkRmliZXI9Y3VycmVudEZpcnN0Q2hpbGQ7dmFyIGxhc3RQbGFjZWRJbmRleD0wO3ZhciBuZXdJZHg9MDt2YXIgbmV4dE9sZEZpYmVyPW51bGw7dmFyIHN0ZXA9bmV3Q2hpbGRyZW4ubmV4dCgpO2Zvcig7b2xkRmliZXIhPT1udWxsJiYhc3RlcC5kb25lO25ld0lkeCsrLHN0ZXA9bmV3Q2hpbGRyZW4ubmV4dCgpKXtpZihvbGRGaWJlci5pbmRleD5uZXdJZHgpe25leHRPbGRGaWJlcj1vbGRGaWJlcjtvbGRGaWJlcj1udWxsO31lbHNle25leHRPbGRGaWJlcj1vbGRGaWJlci5zaWJsaW5nO312YXIgbmV3RmliZXI9dXBkYXRlU2xvdChyZXR1cm5GaWJlcixvbGRGaWJlcixzdGVwLnZhbHVlLGxhbmVzKTtpZihuZXdGaWJlcj09PW51bGwpey8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4vLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4vLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbi8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuaWYob2xkRmliZXI9PT1udWxsKXtvbGRGaWJlcj1uZXh0T2xkRmliZXI7fWJyZWFrO31pZihzaG91bGRUcmFja1NpZGVFZmZlY3RzKXtpZihvbGRGaWJlciYmbmV3RmliZXIuYWx0ZXJuYXRlPT09bnVsbCl7Ly8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4vLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG5kZWxldGVDaGlsZChyZXR1cm5GaWJlcixvbGRGaWJlcik7fX1sYXN0UGxhY2VkSW5kZXg9cGxhY2VDaGlsZChuZXdGaWJlcixsYXN0UGxhY2VkSW5kZXgsbmV3SWR4KTtpZihwcmV2aW91c05ld0ZpYmVyPT09bnVsbCl7Ly8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxucmVzdWx0aW5nRmlyc3RDaGlsZD1uZXdGaWJlcjt9ZWxzZXsvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4vLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4vLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4vLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG5wcmV2aW91c05ld0ZpYmVyLnNpYmxpbmc9bmV3RmliZXI7fXByZXZpb3VzTmV3RmliZXI9bmV3RmliZXI7b2xkRmliZXI9bmV4dE9sZEZpYmVyO31pZihzdGVwLmRvbmUpey8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsb2xkRmliZXIpO2lmKGdldElzSHlkcmF0aW5nKCkpe3ZhciBudW1iZXJPZkZvcmtzPW5ld0lkeDtwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsbnVtYmVyT2ZGb3Jrcyk7fXJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO31pZihvbGRGaWJlcj09PW51bGwpey8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbmZvcig7IXN0ZXAuZG9uZTtuZXdJZHgrKyxzdGVwPW5ld0NoaWxkcmVuLm5leHQoKSl7dmFyIF9uZXdGaWJlcjM9Y3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsc3RlcC52YWx1ZSxsYW5lcyk7aWYoX25ld0ZpYmVyMz09PW51bGwpe2NvbnRpbnVlO31sYXN0UGxhY2VkSW5kZXg9cGxhY2VDaGlsZChfbmV3RmliZXIzLGxhc3RQbGFjZWRJbmRleCxuZXdJZHgpO2lmKHByZXZpb3VzTmV3RmliZXI9PT1udWxsKXsvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG5yZXN1bHRpbmdGaXJzdENoaWxkPV9uZXdGaWJlcjM7fWVsc2V7cHJldmlvdXNOZXdGaWJlci5zaWJsaW5nPV9uZXdGaWJlcjM7fXByZXZpb3VzTmV3RmliZXI9X25ld0ZpYmVyMzt9aWYoZ2V0SXNIeWRyYXRpbmcoKSl7dmFyIF9udW1iZXJPZkZvcmtzMz1uZXdJZHg7cHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLF9udW1iZXJPZkZvcmtzMyk7fXJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO30vLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbnZhciBleGlzdGluZ0NoaWxkcmVuPW1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLG9sZEZpYmVyKTsvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG5mb3IoOyFzdGVwLmRvbmU7bmV3SWR4Kyssc3RlcD1uZXdDaGlsZHJlbi5uZXh0KCkpe3ZhciBfbmV3RmliZXI0PXVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbixyZXR1cm5GaWJlcixuZXdJZHgsc3RlcC52YWx1ZSxsYW5lcyk7aWYoX25ld0ZpYmVyNCE9PW51bGwpe2lmKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpe2lmKF9uZXdGaWJlcjQuYWx0ZXJuYXRlIT09bnVsbCl7Ly8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4vLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuLy8gbGlzdC5cbmV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjQua2V5PT09bnVsbD9uZXdJZHg6X25ld0ZpYmVyNC5rZXkpO319bGFzdFBsYWNlZEluZGV4PXBsYWNlQ2hpbGQoX25ld0ZpYmVyNCxsYXN0UGxhY2VkSW5kZXgsbmV3SWR4KTtpZihwcmV2aW91c05ld0ZpYmVyPT09bnVsbCl7cmVzdWx0aW5nRmlyc3RDaGlsZD1fbmV3RmliZXI0O31lbHNle3ByZXZpb3VzTmV3RmliZXIuc2libGluZz1fbmV3RmliZXI0O31wcmV2aW91c05ld0ZpYmVyPV9uZXdGaWJlcjQ7fX1pZihzaG91bGRUcmFja1NpZGVFZmZlY3RzKXsvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG5leGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpe3JldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlcixjaGlsZCk7fSk7fWlmKGdldElzSHlkcmF0aW5nKCkpe3ZhciBfbnVtYmVyT2ZGb3JrczQ9bmV3SWR4O3B1c2hUcmVlRm9yayhyZXR1cm5GaWJlcixfbnVtYmVyT2ZGb3JrczQpO31yZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDt9ZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQsdGV4dENvbnRlbnQsbGFuZXMpey8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuLy8gd2F5IHRvIGRlZmluZSB0aGVtLlxuaWYoY3VycmVudEZpcnN0Q2hpbGQhPT1udWxsJiZjdXJyZW50Rmlyc3RDaGlsZC50YWc9PT1Ib3N0VGV4dCl7Ly8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuLy8gdGhlIHJlc3QuXG5kZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTt2YXIgZXhpc3Rpbmc9dXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsdGV4dENvbnRlbnQpO2V4aXN0aW5nLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gZXhpc3Rpbmc7fS8vIFRoZSBleGlzdGluZyBmaXJzdCBjaGlsZCBpcyBub3QgYSB0ZXh0IG5vZGUgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4vLyBhbmQgZGVsZXRlIHRoZSBleGlzdGluZyBvbmVzLlxuZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQpO3ZhciBjcmVhdGVkPWNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQscmV0dXJuRmliZXIubW9kZSxsYW5lcyk7Y3JlYXRlZC5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIGNyZWF0ZWQ7fWZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQsZWxlbWVudCxsYW5lcyl7dmFyIGtleT1lbGVtZW50LmtleTt2YXIgY2hpbGQ9Y3VycmVudEZpcnN0Q2hpbGQ7d2hpbGUoY2hpbGQhPT1udWxsKXsvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG5pZihjaGlsZC5rZXk9PT1rZXkpe3ZhciBlbGVtZW50VHlwZT1lbGVtZW50LnR5cGU7aWYoZWxlbWVudFR5cGU9PT1SRUFDVF9GUkFHTUVOVF9UWVBFKXtpZihjaGlsZC50YWc9PT1GcmFnbWVudCl7ZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsY2hpbGQuc2libGluZyk7dmFyIGV4aXN0aW5nPXVzZUZpYmVyKGNoaWxkLGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pO2V4aXN0aW5nLnJldHVybj1yZXR1cm5GaWJlcjt7ZXhpc3RpbmcuX2RlYnVnU291cmNlPWVsZW1lbnQuX3NvdXJjZTtleGlzdGluZy5fZGVidWdPd25lcj1lbGVtZW50Ll9vd25lcjt9cmV0dXJuIGV4aXN0aW5nO319ZWxzZXtpZihjaGlsZC5lbGVtZW50VHlwZT09PWVsZW1lbnRUeXBlfHwvLyBLZWVwIHRoaXMgY2hlY2sgaW5saW5lIHNvIGl0IG9ubHkgcnVucyBvbiB0aGUgZmFsc2UgcGF0aDpcbmlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhjaGlsZCxlbGVtZW50KXx8Ly8gTGF6eSB0eXBlcyBzaG91bGQgcmVjb25jaWxlIHRoZWlyIHJlc29sdmVkIHR5cGUuXG4vLyBXZSBuZWVkIHRvIGRvIHRoaXMgYWZ0ZXIgdGhlIEhvdCBSZWxvYWRpbmcgY2hlY2sgYWJvdmUsXG4vLyBiZWNhdXNlIGhvdCByZWxvYWRpbmcgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgdGhhbiBwcm9kIGJlY2F1c2Vcbi8vIGl0IGRvZXNuJ3QgcmVzdXNwZW5kLiBTbyB3ZSBjYW4ndCBsZXQgdGhlIGNhbGwgYmVsb3cgc3VzcGVuZC5cbnR5cGVvZiBlbGVtZW50VHlwZT09PSdvYmplY3QnJiZlbGVtZW50VHlwZSE9PW51bGwmJmVsZW1lbnRUeXBlLiQkdHlwZW9mPT09UkVBQ1RfTEFaWV9UWVBFJiZyZXNvbHZlTGF6eShlbGVtZW50VHlwZSk9PT1jaGlsZC50eXBlKXtkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlcixjaGlsZC5zaWJsaW5nKTt2YXIgX2V4aXN0aW5nPXVzZUZpYmVyKGNoaWxkLGVsZW1lbnQucHJvcHMpO19leGlzdGluZy5yZWY9Y29lcmNlUmVmKHJldHVybkZpYmVyLGNoaWxkLGVsZW1lbnQpO19leGlzdGluZy5yZXR1cm49cmV0dXJuRmliZXI7e19leGlzdGluZy5fZGVidWdTb3VyY2U9ZWxlbWVudC5fc291cmNlO19leGlzdGluZy5fZGVidWdPd25lcj1lbGVtZW50Ll9vd25lcjt9cmV0dXJuIF9leGlzdGluZzt9fS8vIERpZG4ndCBtYXRjaC5cbmRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLGNoaWxkKTticmVhazt9ZWxzZXtkZWxldGVDaGlsZChyZXR1cm5GaWJlcixjaGlsZCk7fWNoaWxkPWNoaWxkLnNpYmxpbmc7fWlmKGVsZW1lbnQudHlwZT09PVJFQUNUX0ZSQUdNRU5UX1RZUEUpe3ZhciBjcmVhdGVkPWNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnQucHJvcHMuY2hpbGRyZW4scmV0dXJuRmliZXIubW9kZSxsYW5lcyxlbGVtZW50LmtleSk7Y3JlYXRlZC5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIGNyZWF0ZWQ7fWVsc2V7dmFyIF9jcmVhdGVkND1jcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQscmV0dXJuRmliZXIubW9kZSxsYW5lcyk7X2NyZWF0ZWQ0LnJlZj1jb2VyY2VSZWYocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQsZWxlbWVudCk7X2NyZWF0ZWQ0LnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gX2NyZWF0ZWQ0O319ZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkLHBvcnRhbCxsYW5lcyl7dmFyIGtleT1wb3J0YWwua2V5O3ZhciBjaGlsZD1jdXJyZW50Rmlyc3RDaGlsZDt3aGlsZShjaGlsZCE9PW51bGwpey8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4vLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbmlmKGNoaWxkLmtleT09PWtleSl7aWYoY2hpbGQudGFnPT09SG9zdFBvcnRhbCYmY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm89PT1wb3J0YWwuY29udGFpbmVySW5mbyYmY2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uPT09cG9ydGFsLmltcGxlbWVudGF0aW9uKXtkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlcixjaGlsZC5zaWJsaW5nKTt2YXIgZXhpc3Rpbmc9dXNlRmliZXIoY2hpbGQscG9ydGFsLmNoaWxkcmVufHxbXSk7ZXhpc3RpbmcucmV0dXJuPXJldHVybkZpYmVyO3JldHVybiBleGlzdGluZzt9ZWxzZXtkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlcixjaGlsZCk7YnJlYWs7fX1lbHNle2RlbGV0ZUNoaWxkKHJldHVybkZpYmVyLGNoaWxkKTt9Y2hpbGQ9Y2hpbGQuc2libGluZzt9dmFyIGNyZWF0ZWQ9Y3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCxyZXR1cm5GaWJlci5tb2RlLGxhbmVzKTtjcmVhdGVkLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gY3JlYXRlZDt9Ly8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuLy8gaXRzZWxmLiBUaGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNpZGUtZWZmZWN0IGxpc3QgYXMgd2UgcGFzcyB0aHJvdWdoIHRoZVxuLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG5mdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCxuZXdDaGlsZCxsYW5lcyl7Ly8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuLy8gSWYgdGhlIHRvcCBsZXZlbCBpdGVtIGlzIGFuIGFycmF5LCB3ZSB0cmVhdCBpdCBhcyBhIHNldCBvZiBjaGlsZHJlbixcbi8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cbi8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbi8vIFRoaXMgbGVhZHMgdG8gYW4gYW1iaWd1aXR5IGJldHdlZW4gPD57Wy4uLl19PC8+IGFuZCA8Pi4uLjwvPi5cbi8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG52YXIgaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudD10eXBlb2YgbmV3Q2hpbGQ9PT0nb2JqZWN0JyYmbmV3Q2hpbGQhPT1udWxsJiZuZXdDaGlsZC50eXBlPT09UkVBQ1RfRlJBR01FTlRfVFlQRSYmbmV3Q2hpbGQua2V5PT09bnVsbDtpZihpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50KXtuZXdDaGlsZD1uZXdDaGlsZC5wcm9wcy5jaGlsZHJlbjt9Ly8gSGFuZGxlIG9iamVjdCB0eXBlc1xuaWYodHlwZW9mIG5ld0NoaWxkPT09J29iamVjdCcmJm5ld0NoaWxkIT09bnVsbCl7c3dpdGNoKG5ld0NoaWxkLiQkdHlwZW9mKXtjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpyZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkLG5ld0NoaWxkLGxhbmVzKSk7Y2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpyZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQsbmV3Q2hpbGQsbGFuZXMpKTtjYXNlIFJFQUNUX0xBWllfVFlQRTp2YXIgcGF5bG9hZD1uZXdDaGlsZC5fcGF5bG9hZDt2YXIgaW5pdD1uZXdDaGlsZC5faW5pdDsvLyBUT0RPOiBUaGlzIGZ1bmN0aW9uIGlzIHN1cHBvc2VkIHRvIGJlIG5vbi1yZWN1cnNpdmUuXG5yZXR1cm4gcmVjb25jaWxlQ2hpbGRGaWJlcnMocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQsaW5pdChwYXlsb2FkKSxsYW5lcyk7fWlmKGlzQXJyYXkobmV3Q2hpbGQpKXtyZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCxuZXdDaGlsZCxsYW5lcyk7fWlmKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKXtyZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCxuZXdDaGlsZCxsYW5lcyk7fXRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlcixuZXdDaGlsZCk7fWlmKHR5cGVvZiBuZXdDaGlsZD09PSdzdHJpbmcnJiZuZXdDaGlsZCE9PScnfHx0eXBlb2YgbmV3Q2hpbGQ9PT0nbnVtYmVyJyl7cmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQsJycrbmV3Q2hpbGQsbGFuZXMpKTt9e2lmKHR5cGVvZiBuZXdDaGlsZD09PSdmdW5jdGlvbicpe3dhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7fX0vLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxucmV0dXJuIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkKTt9cmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO312YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnM9Q2hpbGRSZWNvbmNpbGVyKHRydWUpO3ZhciBtb3VudENoaWxkRmliZXJzPUNoaWxkUmVjb25jaWxlcihmYWxzZSk7ZnVuY3Rpb24gY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LHdvcmtJblByb2dyZXNzKXtpZihjdXJyZW50IT09bnVsbCYmd29ya0luUHJvZ3Jlc3MuY2hpbGQhPT1jdXJyZW50LmNoaWxkKXt0aHJvdyBuZXcgRXJyb3IoJ1Jlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC4nKTt9aWYod29ya0luUHJvZ3Jlc3MuY2hpbGQ9PT1udWxsKXtyZXR1cm47fXZhciBjdXJyZW50Q2hpbGQ9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7dmFyIG5ld0NoaWxkPWNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCxjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzKTt3b3JrSW5Qcm9ncmVzcy5jaGlsZD1uZXdDaGlsZDtuZXdDaGlsZC5yZXR1cm49d29ya0luUHJvZ3Jlc3M7d2hpbGUoY3VycmVudENoaWxkLnNpYmxpbmchPT1udWxsKXtjdXJyZW50Q2hpbGQ9Y3VycmVudENoaWxkLnNpYmxpbmc7bmV3Q2hpbGQ9bmV3Q2hpbGQuc2libGluZz1jcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyk7bmV3Q2hpbGQucmV0dXJuPXdvcmtJblByb2dyZXNzO31uZXdDaGlsZC5zaWJsaW5nPW51bGw7fS8vIFJlc2V0IGEgd29ya0luUHJvZ3Jlc3MgY2hpbGQgc2V0IHRvIHByZXBhcmUgaXQgZm9yIGEgc2Vjb25kIHBhc3MuXG5mdW5jdGlvbiByZXNldENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLGxhbmVzKXt2YXIgY2hpbGQ9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7d2hpbGUoY2hpbGQhPT1udWxsKXtyZXNldFdvcmtJblByb2dyZXNzKGNoaWxkLGxhbmVzKTtjaGlsZD1jaGlsZC5zaWJsaW5nO319dmFyIHZhbHVlQ3Vyc29yPWNyZWF0ZUN1cnNvcihudWxsKTt2YXIgcmVuZGVyZXJTaWdpbDt7Ly8gVXNlIHRoaXMgdG8gZGV0ZWN0IG11bHRpcGxlIHJlbmRlcmVycyB1c2luZyB0aGUgc2FtZSBjb250ZXh0XG5yZW5kZXJlclNpZ2lsPXt9O312YXIgY3VycmVudGx5UmVuZGVyaW5nRmliZXI9bnVsbDt2YXIgbGFzdENvbnRleHREZXBlbmRlbmN5PW51bGw7dmFyIGxhc3RGdWxseU9ic2VydmVkQ29udGV4dD1udWxsO3ZhciBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWPWZhbHNlO2Z1bmN0aW9uIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpey8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGJlZm9yZSBSZWFjdCB5aWVsZHMgZXhlY3V0aW9uLCB0byBlbnN1cmUgYHJlYWRDb250ZXh0YFxuLy8gY2Fubm90IGJlIGNhbGxlZCBvdXRzaWRlIHRoZSByZW5kZXIgcGhhc2UuXG5jdXJyZW50bHlSZW5kZXJpbmdGaWJlcj1udWxsO2xhc3RDb250ZXh0RGVwZW5kZW5jeT1udWxsO2xhc3RGdWxseU9ic2VydmVkQ29udGV4dD1udWxsO3tpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWPWZhbHNlO319ZnVuY3Rpb24gZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpe3tpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWPXRydWU7fX1mdW5jdGlvbiBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKXt7aXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVj1mYWxzZTt9fWZ1bmN0aW9uIHB1c2hQcm92aWRlcihwcm92aWRlckZpYmVyLGNvbnRleHQsbmV4dFZhbHVlKXt7cHVzaCh2YWx1ZUN1cnNvcixjb250ZXh0Ll9jdXJyZW50VmFsdWUscHJvdmlkZXJGaWJlcik7Y29udGV4dC5fY3VycmVudFZhbHVlPW5leHRWYWx1ZTt7aWYoY29udGV4dC5fY3VycmVudFJlbmRlcmVyIT09dW5kZWZpbmVkJiZjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIhPT1udWxsJiZjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIhPT1yZW5kZXJlclNpZ2lsKXtlcnJvcignRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcrJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJyk7fWNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcj1yZW5kZXJlclNpZ2lsO319fWZ1bmN0aW9uIHBvcFByb3ZpZGVyKGNvbnRleHQscHJvdmlkZXJGaWJlcil7dmFyIGN1cnJlbnRWYWx1ZT12YWx1ZUN1cnNvci5jdXJyZW50O3BvcCh2YWx1ZUN1cnNvcixwcm92aWRlckZpYmVyKTt7e2NvbnRleHQuX2N1cnJlbnRWYWx1ZT1jdXJyZW50VmFsdWU7fX19ZnVuY3Rpb24gc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChwYXJlbnQscmVuZGVyTGFuZXMscHJvcGFnYXRpb25Sb290KXsvLyBVcGRhdGUgdGhlIGNoaWxkIGxhbmVzIG9mIGFsbCB0aGUgYW5jZXN0b3JzLCBpbmNsdWRpbmcgdGhlIGFsdGVybmF0ZXMuXG52YXIgbm9kZT1wYXJlbnQ7d2hpbGUobm9kZSE9PW51bGwpe3ZhciBhbHRlcm5hdGU9bm9kZS5hbHRlcm5hdGU7aWYoIWlzU3Vic2V0T2ZMYW5lcyhub2RlLmNoaWxkTGFuZXMscmVuZGVyTGFuZXMpKXtub2RlLmNoaWxkTGFuZXM9bWVyZ2VMYW5lcyhub2RlLmNoaWxkTGFuZXMscmVuZGVyTGFuZXMpO2lmKGFsdGVybmF0ZSE9PW51bGwpe2FsdGVybmF0ZS5jaGlsZExhbmVzPW1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMscmVuZGVyTGFuZXMpO319ZWxzZSBpZihhbHRlcm5hdGUhPT1udWxsJiYhaXNTdWJzZXRPZkxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLHJlbmRlckxhbmVzKSl7YWx0ZXJuYXRlLmNoaWxkTGFuZXM9bWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcyxyZW5kZXJMYW5lcyk7fWlmKG5vZGU9PT1wcm9wYWdhdGlvblJvb3Qpe2JyZWFrO31ub2RlPW5vZGUucmV0dXJuO317aWYobm9kZSE9PXByb3BhZ2F0aW9uUm9vdCl7ZXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByb3BhZ2F0aW9uIHJvb3Qgd2hlbiBzY2hlZHVsaW5nIGNvbnRleHQgd29yay4gJysnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9fX1mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLGNvbnRleHQscmVuZGVyTGFuZXMpe3twcm9wYWdhdGVDb250ZXh0Q2hhbmdlX2VhZ2VyKHdvcmtJblByb2dyZXNzLGNvbnRleHQscmVuZGVyTGFuZXMpO319ZnVuY3Rpb24gcHJvcGFnYXRlQ29udGV4dENoYW5nZV9lYWdlcih3b3JrSW5Qcm9ncmVzcyxjb250ZXh0LHJlbmRlckxhbmVzKXt2YXIgZmliZXI9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7aWYoZmliZXIhPT1udWxsKXsvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbmZpYmVyLnJldHVybj13b3JrSW5Qcm9ncmVzczt9d2hpbGUoZmliZXIhPT1udWxsKXt2YXIgbmV4dEZpYmVyPXZvaWQgMDsvLyBWaXNpdCB0aGlzIGZpYmVyLlxudmFyIGxpc3Q9ZmliZXIuZGVwZW5kZW5jaWVzO2lmKGxpc3QhPT1udWxsKXtuZXh0RmliZXI9ZmliZXIuY2hpbGQ7dmFyIGRlcGVuZGVuY3k9bGlzdC5maXJzdENvbnRleHQ7d2hpbGUoZGVwZW5kZW5jeSE9PW51bGwpey8vIENoZWNrIGlmIHRoZSBjb250ZXh0IG1hdGNoZXMuXG5pZihkZXBlbmRlbmN5LmNvbnRleHQ9PT1jb250ZXh0KXsvLyBNYXRjaCEgU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoaXMgZmliZXIuXG5pZihmaWJlci50YWc9PT1DbGFzc0NvbXBvbmVudCl7Ly8gU2NoZWR1bGUgYSBmb3JjZSB1cGRhdGUgb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MuXG52YXIgbGFuZT1waWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcyk7dmFyIHVwZGF0ZT1jcmVhdGVVcGRhdGUoTm9UaW1lc3RhbXAsbGFuZSk7dXBkYXRlLnRhZz1Gb3JjZVVwZGF0ZTsvLyBUT0RPOiBCZWNhdXNlIHdlIGRvbid0IGhhdmUgYSB3b3JrLWluLXByb2dyZXNzLCB0aGlzIHdpbGwgYWRkIHRoZVxuLy8gdXBkYXRlIHRvIHRoZSBjdXJyZW50IGZpYmVyLCB0b28sIHdoaWNoIG1lYW5zIGl0IHdpbGwgcGVyc2lzdCBldmVuIGlmXG4vLyB0aGlzIHJlbmRlciBpcyB0aHJvd24gYXdheS4gU2luY2UgaXQncyBhIHJhY2UgY29uZGl0aW9uLCBub3Qgc3VyZSBpdCdzXG4vLyB3b3J0aCBmaXhpbmcuXG4vLyBJbmxpbmVkIGBlbnF1ZXVlVXBkYXRlYCB0byByZW1vdmUgaW50ZXJsZWF2ZWQgdXBkYXRlIGNoZWNrXG52YXIgdXBkYXRlUXVldWU9ZmliZXIudXBkYXRlUXVldWU7aWYodXBkYXRlUXVldWU9PT1udWxsKTtlbHNle3ZhciBzaGFyZWRRdWV1ZT11cGRhdGVRdWV1ZS5zaGFyZWQ7dmFyIHBlbmRpbmc9c2hhcmVkUXVldWUucGVuZGluZztpZihwZW5kaW5nPT09bnVsbCl7Ly8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxudXBkYXRlLm5leHQ9dXBkYXRlO31lbHNle3VwZGF0ZS5uZXh0PXBlbmRpbmcubmV4dDtwZW5kaW5nLm5leHQ9dXBkYXRlO31zaGFyZWRRdWV1ZS5wZW5kaW5nPXVwZGF0ZTt9fWZpYmVyLmxhbmVzPW1lcmdlTGFuZXMoZmliZXIubGFuZXMscmVuZGVyTGFuZXMpO3ZhciBhbHRlcm5hdGU9ZmliZXIuYWx0ZXJuYXRlO2lmKGFsdGVybmF0ZSE9PW51bGwpe2FsdGVybmF0ZS5sYW5lcz1tZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcyxyZW5kZXJMYW5lcyk7fXNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLHJlbmRlckxhbmVzLHdvcmtJblByb2dyZXNzKTsvLyBNYXJrIHRoZSB1cGRhdGVkIGxhbmVzIG9uIHRoZSBsaXN0LCB0b28uXG5saXN0LmxhbmVzPW1lcmdlTGFuZXMobGlzdC5sYW5lcyxyZW5kZXJMYW5lcyk7Ly8gU2luY2Ugd2UgYWxyZWFkeSBmb3VuZCBhIG1hdGNoLCB3ZSBjYW4gc3RvcCB0cmF2ZXJzaW5nIHRoZVxuLy8gZGVwZW5kZW5jeSBsaXN0LlxuYnJlYWs7fWRlcGVuZGVuY3k9ZGVwZW5kZW5jeS5uZXh0O319ZWxzZSBpZihmaWJlci50YWc9PT1Db250ZXh0UHJvdmlkZXIpey8vIERvbid0IHNjYW4gZGVlcGVyIGlmIHRoaXMgaXMgYSBtYXRjaGluZyBwcm92aWRlclxubmV4dEZpYmVyPWZpYmVyLnR5cGU9PT13b3JrSW5Qcm9ncmVzcy50eXBlP251bGw6ZmliZXIuY2hpbGQ7fWVsc2UgaWYoZmliZXIudGFnPT09RGVoeWRyYXRlZEZyYWdtZW50KXsvLyBJZiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgYm91bmRhcnkgaXMgaW4gdGhpcyBzdWJ0cmVlLCB3ZSBkb24ndCBrbm93XG4vLyBpZiBpdCB3aWxsIGhhdmUgYW55IGNvbnRleHQgY29uc3VtZXJzIGluIGl0LiBUaGUgYmVzdCB3ZSBjYW4gZG8gaXNcbi8vIG1hcmsgaXQgYXMgaGF2aW5nIHVwZGF0ZXMuXG52YXIgcGFyZW50U3VzcGVuc2U9ZmliZXIucmV0dXJuO2lmKHBhcmVudFN1c3BlbnNlPT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdXZSBqdXN0IGNhbWUgZnJvbSBhIHBhcmVudCBzbyB3ZSBtdXN0IGhhdmUgaGFkIGEgcGFyZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO31wYXJlbnRTdXNwZW5zZS5sYW5lcz1tZXJnZUxhbmVzKHBhcmVudFN1c3BlbnNlLmxhbmVzLHJlbmRlckxhbmVzKTt2YXIgX2FsdGVybmF0ZT1wYXJlbnRTdXNwZW5zZS5hbHRlcm5hdGU7aWYoX2FsdGVybmF0ZSE9PW51bGwpe19hbHRlcm5hdGUubGFuZXM9bWVyZ2VMYW5lcyhfYWx0ZXJuYXRlLmxhbmVzLHJlbmRlckxhbmVzKTt9Ly8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHBhc3NpbmcgdGhpcyBmaWJlciBhcyB0aGUgcGFyZW50XG4vLyBiZWNhdXNlIHdlIHdhbnQgdG8gc2NoZWR1bGUgdGhpcyBmaWJlciBhcyBoYXZpbmcgd29ya1xuLy8gb24gaXRzIGNoaWxkcmVuLiBXZSdsbCB1c2UgdGhlIGNoaWxkTGFuZXMgb25cbi8vIHRoaXMgZmliZXIgdG8gaW5kaWNhdGUgdGhhdCBhIGNvbnRleHQgaGFzIGNoYW5nZWQuXG5zY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKHBhcmVudFN1c3BlbnNlLHJlbmRlckxhbmVzLHdvcmtJblByb2dyZXNzKTtuZXh0RmliZXI9ZmliZXIuc2libGluZzt9ZWxzZXsvLyBUcmF2ZXJzZSBkb3duLlxubmV4dEZpYmVyPWZpYmVyLmNoaWxkO31pZihuZXh0RmliZXIhPT1udWxsKXsvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbm5leHRGaWJlci5yZXR1cm49ZmliZXI7fWVsc2V7Ly8gTm8gY2hpbGQuIFRyYXZlcnNlIHRvIG5leHQgc2libGluZy5cbm5leHRGaWJlcj1maWJlcjt3aGlsZShuZXh0RmliZXIhPT1udWxsKXtpZihuZXh0RmliZXI9PT13b3JrSW5Qcm9ncmVzcyl7Ly8gV2UncmUgYmFjayB0byB0aGUgcm9vdCBvZiB0aGlzIHN1YnRyZWUuIEV4aXQuXG5uZXh0RmliZXI9bnVsbDticmVhazt9dmFyIHNpYmxpbmc9bmV4dEZpYmVyLnNpYmxpbmc7aWYoc2libGluZyE9PW51bGwpey8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIHNpYmxpbmcgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG5zaWJsaW5nLnJldHVybj1uZXh0RmliZXIucmV0dXJuO25leHRGaWJlcj1zaWJsaW5nO2JyZWFrO30vLyBObyBtb3JlIHNpYmxpbmdzLiBUcmF2ZXJzZSB1cC5cbm5leHRGaWJlcj1uZXh0RmliZXIucmV0dXJuO319ZmliZXI9bmV4dEZpYmVyO319ZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe2N1cnJlbnRseVJlbmRlcmluZ0ZpYmVyPXdvcmtJblByb2dyZXNzO2xhc3RDb250ZXh0RGVwZW5kZW5jeT1udWxsO2xhc3RGdWxseU9ic2VydmVkQ29udGV4dD1udWxsO3ZhciBkZXBlbmRlbmNpZXM9d29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzO2lmKGRlcGVuZGVuY2llcyE9PW51bGwpe3t2YXIgZmlyc3RDb250ZXh0PWRlcGVuZGVuY2llcy5maXJzdENvbnRleHQ7aWYoZmlyc3RDb250ZXh0IT09bnVsbCl7aWYoaW5jbHVkZXNTb21lTGFuZShkZXBlbmRlbmNpZXMubGFuZXMscmVuZGVyTGFuZXMpKXsvLyBDb250ZXh0IGxpc3QgaGFzIGEgcGVuZGluZyB1cGRhdGUuIE1hcmsgdGhhdCB0aGlzIGZpYmVyIHBlcmZvcm1lZCB3b3JrLlxubWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTt9Ly8gUmVzZXQgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgbGlzdFxuZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dD1udWxsO319fX1mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0KXt7Ly8gVGhpcyB3YXJuaW5nIHdvdWxkIGZpcmUgaWYgeW91IHJlYWQgY29udGV4dCBpbnNpZGUgYSBIb29rIGxpa2UgdXNlTWVtby5cbi8vIFVubGlrZSB0aGUgY2xhc3MgY2hlY2sgYmVsb3csIGl0J3Mgbm90IGVuZm9yY2VkIGluIHByb2R1Y3Rpb24gZm9yIHBlcmYuXG5pZihpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKXtlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJysnSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gJysnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcrJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7fX12YXIgdmFsdWU9Y29udGV4dC5fY3VycmVudFZhbHVlO2lmKGxhc3RGdWxseU9ic2VydmVkQ29udGV4dD09PWNvbnRleHQpO2Vsc2V7dmFyIGNvbnRleHRJdGVtPXtjb250ZXh0OmNvbnRleHQsbWVtb2l6ZWRWYWx1ZTp2YWx1ZSxuZXh0Om51bGx9O2lmKGxhc3RDb250ZXh0RGVwZW5kZW5jeT09PW51bGwpe2lmKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyPT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnKydJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnKydJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJysnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTt9Ly8gVGhpcyBpcyB0aGUgZmlyc3QgZGVwZW5kZW5jeSBmb3IgdGhpcyBjb21wb25lbnQuIENyZWF0ZSBhIG5ldyBsaXN0LlxubGFzdENvbnRleHREZXBlbmRlbmN5PWNvbnRleHRJdGVtO2N1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLmRlcGVuZGVuY2llcz17bGFuZXM6Tm9MYW5lcyxmaXJzdENvbnRleHQ6Y29udGV4dEl0ZW19O31lbHNley8vIEFwcGVuZCBhIG5ldyBjb250ZXh0IGl0ZW0uXG5sYXN0Q29udGV4dERlcGVuZGVuY3k9bGFzdENvbnRleHREZXBlbmRlbmN5Lm5leHQ9Y29udGV4dEl0ZW07fX1yZXR1cm4gdmFsdWU7fS8vIHJlbmRlci4gV2hlbiB0aGlzIHJlbmRlciBleGl0cywgZWl0aGVyIGJlY2F1c2UgaXQgZmluaXNoZXMgb3IgYmVjYXVzZSBpdCBpc1xuLy8gaW50ZXJydXB0ZWQsIHRoZSBpbnRlcmxlYXZlZCB1cGRhdGVzIHdpbGwgYmUgdHJhbnNmZXJyZWQgb250byB0aGUgbWFpbiBwYXJ0XG4vLyBvZiB0aGUgcXVldWUuXG52YXIgY29uY3VycmVudFF1ZXVlcz1udWxsO2Z1bmN0aW9uIHB1c2hDb25jdXJyZW50VXBkYXRlUXVldWUocXVldWUpe2lmKGNvbmN1cnJlbnRRdWV1ZXM9PT1udWxsKXtjb25jdXJyZW50UXVldWVzPVtxdWV1ZV07fWVsc2V7Y29uY3VycmVudFF1ZXVlcy5wdXNoKHF1ZXVlKTt9fWZ1bmN0aW9uIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKXsvLyBUcmFuc2ZlciB0aGUgaW50ZXJsZWF2ZWQgdXBkYXRlcyBvbnRvIHRoZSBtYWluIHF1ZXVlLiBFYWNoIHF1ZXVlIGhhcyBhXG4vLyBgcGVuZGluZ2AgZmllbGQgYW5kIGFuIGBpbnRlcmxlYXZlZGAgZmllbGQuIFdoZW4gdGhleSBhcmUgbm90IG51bGwsIHRoZXlcbi8vIHBvaW50IHRvIHRoZSBsYXN0IG5vZGUgaW4gYSBjaXJjdWxhciBsaW5rZWQgbGlzdC4gV2UgbmVlZCB0byBhcHBlbmQgdGhlXG4vLyBpbnRlcmxlYXZlZCBsaXN0IHRvIHRoZSBlbmQgb2YgdGhlIHBlbmRpbmcgbGlzdCBieSBqb2luaW5nIHRoZW0gaW50byBhXG4vLyBzaW5nbGUsIGNpcmN1bGFyIGxpc3QuXG5pZihjb25jdXJyZW50UXVldWVzIT09bnVsbCl7Zm9yKHZhciBpPTA7aTxjb25jdXJyZW50UXVldWVzLmxlbmd0aDtpKyspe3ZhciBxdWV1ZT1jb25jdXJyZW50UXVldWVzW2ldO3ZhciBsYXN0SW50ZXJsZWF2ZWRVcGRhdGU9cXVldWUuaW50ZXJsZWF2ZWQ7aWYobGFzdEludGVybGVhdmVkVXBkYXRlIT09bnVsbCl7cXVldWUuaW50ZXJsZWF2ZWQ9bnVsbDt2YXIgZmlyc3RJbnRlcmxlYXZlZFVwZGF0ZT1sYXN0SW50ZXJsZWF2ZWRVcGRhdGUubmV4dDt2YXIgbGFzdFBlbmRpbmdVcGRhdGU9cXVldWUucGVuZGluZztpZihsYXN0UGVuZGluZ1VwZGF0ZSE9PW51bGwpe3ZhciBmaXJzdFBlbmRpbmdVcGRhdGU9bGFzdFBlbmRpbmdVcGRhdGUubmV4dDtsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0PWZpcnN0SW50ZXJsZWF2ZWRVcGRhdGU7bGFzdEludGVybGVhdmVkVXBkYXRlLm5leHQ9Zmlyc3RQZW5kaW5nVXBkYXRlO31xdWV1ZS5wZW5kaW5nPWxhc3RJbnRlcmxlYXZlZFVwZGF0ZTt9fWNvbmN1cnJlbnRRdWV1ZXM9bnVsbDt9fWZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlcixxdWV1ZSx1cGRhdGUsbGFuZSl7dmFyIGludGVybGVhdmVkPXF1ZXVlLmludGVybGVhdmVkO2lmKGludGVybGVhdmVkPT09bnVsbCl7Ly8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxudXBkYXRlLm5leHQ9dXBkYXRlOy8vIEF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgcmVuZGVyLCB0aGlzIHF1ZXVlJ3MgaW50ZXJsZWF2ZWQgdXBkYXRlcyB3aWxsXG4vLyBiZSB0cmFuc2ZlcnJlZCB0byB0aGUgcGVuZGluZyBxdWV1ZS5cbnB1c2hDb25jdXJyZW50VXBkYXRlUXVldWUocXVldWUpO31lbHNle3VwZGF0ZS5uZXh0PWludGVybGVhdmVkLm5leHQ7aW50ZXJsZWF2ZWQubmV4dD11cGRhdGU7fXF1ZXVlLmludGVybGVhdmVkPXVwZGF0ZTtyZXR1cm4gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsbGFuZSk7fWZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZUFuZEVhZ2VybHlCYWlsb3V0KGZpYmVyLHF1ZXVlLHVwZGF0ZSxsYW5lKXt2YXIgaW50ZXJsZWF2ZWQ9cXVldWUuaW50ZXJsZWF2ZWQ7aWYoaW50ZXJsZWF2ZWQ9PT1udWxsKXsvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG51cGRhdGUubmV4dD11cGRhdGU7Ly8gQXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByZW5kZXIsIHRoaXMgcXVldWUncyBpbnRlcmxlYXZlZCB1cGRhdGVzIHdpbGxcbi8vIGJlIHRyYW5zZmVycmVkIHRvIHRoZSBwZW5kaW5nIHF1ZXVlLlxucHVzaENvbmN1cnJlbnRVcGRhdGVRdWV1ZShxdWV1ZSk7fWVsc2V7dXBkYXRlLm5leHQ9aW50ZXJsZWF2ZWQubmV4dDtpbnRlcmxlYXZlZC5uZXh0PXVwZGF0ZTt9cXVldWUuaW50ZXJsZWF2ZWQ9dXBkYXRlO31mdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudENsYXNzVXBkYXRlKGZpYmVyLHF1ZXVlLHVwZGF0ZSxsYW5lKXt2YXIgaW50ZXJsZWF2ZWQ9cXVldWUuaW50ZXJsZWF2ZWQ7aWYoaW50ZXJsZWF2ZWQ9PT1udWxsKXsvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG51cGRhdGUubmV4dD11cGRhdGU7Ly8gQXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByZW5kZXIsIHRoaXMgcXVldWUncyBpbnRlcmxlYXZlZCB1cGRhdGVzIHdpbGxcbi8vIGJlIHRyYW5zZmVycmVkIHRvIHRoZSBwZW5kaW5nIHF1ZXVlLlxucHVzaENvbmN1cnJlbnRVcGRhdGVRdWV1ZShxdWV1ZSk7fWVsc2V7dXBkYXRlLm5leHQ9aW50ZXJsZWF2ZWQubmV4dDtpbnRlcmxlYXZlZC5uZXh0PXVwZGF0ZTt9cXVldWUuaW50ZXJsZWF2ZWQ9dXBkYXRlO3JldHVybiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlcixsYW5lKTt9ZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLGxhbmUpe3JldHVybiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlcixsYW5lKTt9Ly8gQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIG91dHNpZGUgdGhpcyBtb2R1bGUgc2hvdWxkIG9ubHkgYmUgZG9uZSBmb3IgYmFja3dhcmRzXG4vLyBjb21wYXRpYmlsaXR5IGFuZCBzaG91bGQgYWx3YXlzIGJlIGFjY29tcGFuaWVkIGJ5IGEgd2FybmluZy5cbnZhciB1bnNhZmVfbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Q9bWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Q7ZnVuY3Rpb24gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Qoc291cmNlRmliZXIsbGFuZSl7Ly8gVXBkYXRlIHRoZSBzb3VyY2UgZmliZXIncyBsYW5lc1xuc291cmNlRmliZXIubGFuZXM9bWVyZ2VMYW5lcyhzb3VyY2VGaWJlci5sYW5lcyxsYW5lKTt2YXIgYWx0ZXJuYXRlPXNvdXJjZUZpYmVyLmFsdGVybmF0ZTtpZihhbHRlcm5hdGUhPT1udWxsKXthbHRlcm5hdGUubGFuZXM9bWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsbGFuZSk7fXtpZihhbHRlcm5hdGU9PT1udWxsJiYoc291cmNlRmliZXIuZmxhZ3MmKFBsYWNlbWVudHxIeWRyYXRpbmcpKSE9PU5vRmxhZ3Mpe3dhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoc291cmNlRmliZXIpO319Ly8gV2FsayB0aGUgcGFyZW50IHBhdGggdG8gdGhlIHJvb3QgYW5kIHVwZGF0ZSB0aGUgY2hpbGQgbGFuZXMuXG52YXIgbm9kZT1zb3VyY2VGaWJlcjt2YXIgcGFyZW50PXNvdXJjZUZpYmVyLnJldHVybjt3aGlsZShwYXJlbnQhPT1udWxsKXtwYXJlbnQuY2hpbGRMYW5lcz1tZXJnZUxhbmVzKHBhcmVudC5jaGlsZExhbmVzLGxhbmUpO2FsdGVybmF0ZT1wYXJlbnQuYWx0ZXJuYXRlO2lmKGFsdGVybmF0ZSE9PW51bGwpe2FsdGVybmF0ZS5jaGlsZExhbmVzPW1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsbGFuZSk7fWVsc2V7e2lmKChwYXJlbnQuZmxhZ3MmKFBsYWNlbWVudHxIeWRyYXRpbmcpKSE9PU5vRmxhZ3Mpe3dhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoc291cmNlRmliZXIpO319fW5vZGU9cGFyZW50O3BhcmVudD1wYXJlbnQucmV0dXJuO31pZihub2RlLnRhZz09PUhvc3RSb290KXt2YXIgcm9vdD1ub2RlLnN0YXRlTm9kZTtyZXR1cm4gcm9vdDt9ZWxzZXtyZXR1cm4gbnVsbDt9fXZhciBVcGRhdGVTdGF0ZT0wO3ZhciBSZXBsYWNlU3RhdGU9MTt2YXIgRm9yY2VVcGRhdGU9Mjt2YXIgQ2FwdHVyZVVwZGF0ZT0zOy8vIEdsb2JhbCBzdGF0ZSB0aGF0IGlzIHJlc2V0IGF0IHRoZSBiZWdpbm5pbmcgb2YgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYC5cbi8vIEl0IHNob3VsZCBvbmx5IGJlIHJlYWQgcmlnaHQgYWZ0ZXIgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYCwgdmlhXG4vLyBgY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZ2AuXG52YXIgaGFzRm9yY2VVcGRhdGU9ZmFsc2U7dmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGU7dmFyIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZTt7ZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZT1mYWxzZTtjdXJyZW50bHlQcm9jZXNzaW5nUXVldWU9bnVsbDt9ZnVuY3Rpb24gaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGZpYmVyKXt2YXIgcXVldWU9e2Jhc2VTdGF0ZTpmaWJlci5tZW1vaXplZFN0YXRlLGZpcnN0QmFzZVVwZGF0ZTpudWxsLGxhc3RCYXNlVXBkYXRlOm51bGwsc2hhcmVkOntwZW5kaW5nOm51bGwsaW50ZXJsZWF2ZWQ6bnVsbCxsYW5lczpOb0xhbmVzfSxlZmZlY3RzOm51bGx9O2ZpYmVyLnVwZGF0ZVF1ZXVlPXF1ZXVlO31mdW5jdGlvbiBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3Mpey8vIENsb25lIHRoZSB1cGRhdGUgcXVldWUgZnJvbSBjdXJyZW50LiBVbmxlc3MgaXQncyBhbHJlYWR5IGEgY2xvbmUuXG52YXIgcXVldWU9d29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7dmFyIGN1cnJlbnRRdWV1ZT1jdXJyZW50LnVwZGF0ZVF1ZXVlO2lmKHF1ZXVlPT09Y3VycmVudFF1ZXVlKXt2YXIgY2xvbmU9e2Jhc2VTdGF0ZTpjdXJyZW50UXVldWUuYmFzZVN0YXRlLGZpcnN0QmFzZVVwZGF0ZTpjdXJyZW50UXVldWUuZmlyc3RCYXNlVXBkYXRlLGxhc3RCYXNlVXBkYXRlOmN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSxzaGFyZWQ6Y3VycmVudFF1ZXVlLnNoYXJlZCxlZmZlY3RzOmN1cnJlbnRRdWV1ZS5lZmZlY3RzfTt3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT1jbG9uZTt9fWZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsbGFuZSl7dmFyIHVwZGF0ZT17ZXZlbnRUaW1lOmV2ZW50VGltZSxsYW5lOmxhbmUsdGFnOlVwZGF0ZVN0YXRlLHBheWxvYWQ6bnVsbCxjYWxsYmFjazpudWxsLG5leHQ6bnVsbH07cmV0dXJuIHVwZGF0ZTt9ZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlcix1cGRhdGUsbGFuZSl7dmFyIHVwZGF0ZVF1ZXVlPWZpYmVyLnVwZGF0ZVF1ZXVlO2lmKHVwZGF0ZVF1ZXVlPT09bnVsbCl7Ly8gT25seSBvY2N1cnMgaWYgdGhlIGZpYmVyIGhhcyBiZWVuIHVubW91bnRlZC5cbnJldHVybiBudWxsO312YXIgc2hhcmVkUXVldWU9dXBkYXRlUXVldWUuc2hhcmVkO3tpZihjdXJyZW50bHlQcm9jZXNzaW5nUXVldWU9PT1zaGFyZWRRdWV1ZSYmIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUpe2Vycm9yKCdBbiB1cGRhdGUgKHNldFN0YXRlLCByZXBsYWNlU3RhdGUsIG9yIGZvcmNlVXBkYXRlKSB3YXMgc2NoZWR1bGVkICcrJ2Zyb20gaW5zaWRlIGFuIHVwZGF0ZSBmdW5jdGlvbi4gVXBkYXRlIGZ1bmN0aW9ucyBzaG91bGQgYmUgcHVyZSwgJysnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJysnY2FsbGJhY2suJyk7ZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZT10cnVlO319aWYoaXNVbnNhZmVDbGFzc1JlbmRlclBoYXNlVXBkYXRlKCkpey8vIFRoaXMgaXMgYW4gdW5zYWZlIHJlbmRlciBwaGFzZSB1cGRhdGUuIEFkZCBkaXJlY3RseSB0byB0aGUgdXBkYXRlXG4vLyBxdWV1ZSBzbyB3ZSBjYW4gcHJvY2VzcyBpdCBpbW1lZGlhdGVseSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyLlxudmFyIHBlbmRpbmc9c2hhcmVkUXVldWUucGVuZGluZztpZihwZW5kaW5nPT09bnVsbCl7Ly8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxudXBkYXRlLm5leHQ9dXBkYXRlO31lbHNle3VwZGF0ZS5uZXh0PXBlbmRpbmcubmV4dDtwZW5kaW5nLm5leHQ9dXBkYXRlO31zaGFyZWRRdWV1ZS5wZW5kaW5nPXVwZGF0ZTsvLyBVcGRhdGUgdGhlIGNoaWxkTGFuZXMgZXZlbiB0aG91Z2ggd2UncmUgbW9zdCBsaWtlbHkgYWxyZWFkeSByZW5kZXJpbmdcbi8vIHRoaXMgZmliZXIuIFRoaXMgaXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGluIHRoZSBjYXNlIHdoZXJlIHlvdVxuLy8gdXBkYXRlIGEgZGlmZmVyZW50IGNvbXBvbmVudCBkdXJpbmcgcmVuZGVyIHBoYXNlIHRoYW4gdGhlIG9uZSB0aGF0IGlzXG4vLyBjdXJyZW50bHkgcmVuZGVyaW5ncyAoYSBwYXR0ZXJuIHRoYXQgaXMgYWNjb21wYW5pZWQgYnkgYSB3YXJuaW5nKS5cbnJldHVybiB1bnNhZmVfbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsbGFuZSk7fWVsc2V7cmV0dXJuIGVucXVldWVDb25jdXJyZW50Q2xhc3NVcGRhdGUoZmliZXIsc2hhcmVkUXVldWUsdXBkYXRlLGxhbmUpO319ZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LGZpYmVyLGxhbmUpe3ZhciB1cGRhdGVRdWV1ZT1maWJlci51cGRhdGVRdWV1ZTtpZih1cGRhdGVRdWV1ZT09PW51bGwpey8vIE9ubHkgb2NjdXJzIGlmIHRoZSBmaWJlciBoYXMgYmVlbiB1bm1vdW50ZWQuXG5yZXR1cm47fXZhciBzaGFyZWRRdWV1ZT11cGRhdGVRdWV1ZS5zaGFyZWQ7aWYoaXNUcmFuc2l0aW9uTGFuZShsYW5lKSl7dmFyIHF1ZXVlTGFuZXM9c2hhcmVkUXVldWUubGFuZXM7Ly8gSWYgYW55IGVudGFuZ2xlZCBsYW5lcyBhcmUgbm8gbG9uZ2VyIHBlbmRpbmcgb24gdGhlIHJvb3QsIHRoZW4gdGhleSBtdXN0XG4vLyBoYXZlIGZpbmlzaGVkLiBXZSBjYW4gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc2hhcmVkIHF1ZXVlLCB3aGljaCByZXByZXNlbnRzXG4vLyBhIHN1cGVyc2V0IG9mIHRoZSBhY3R1YWxseSBwZW5kaW5nIGxhbmVzLiBJbiBzb21lIGNhc2VzIHdlIG1heSBlbnRhbmdsZVxuLy8gbW9yZSB0aGFuIHdlIG5lZWQgdG8sIGJ1dCB0aGF0J3MgT0suIEluIGZhY3QgaXQncyB3b3JzZSBpZiB3ZSAqZG9uJ3QqXG4vLyBlbnRhbmdsZSB3aGVuIHdlIHNob3VsZC5cbnF1ZXVlTGFuZXM9aW50ZXJzZWN0TGFuZXMocXVldWVMYW5lcyxyb290LnBlbmRpbmdMYW5lcyk7Ly8gRW50YW5nbGUgdGhlIG5ldyB0cmFuc2l0aW9uIGxhbmUgd2l0aCB0aGUgb3RoZXIgdHJhbnNpdGlvbiBsYW5lcy5cbnZhciBuZXdRdWV1ZUxhbmVzPW1lcmdlTGFuZXMocXVldWVMYW5lcyxsYW5lKTtzaGFyZWRRdWV1ZS5sYW5lcz1uZXdRdWV1ZUxhbmVzOy8vIEV2ZW4gaWYgcXVldWUubGFuZXMgYWxyZWFkeSBpbmNsdWRlIGxhbmUsIHdlIGRvbid0IGtub3cgZm9yIGNlcnRhaW4gaWZcbi8vIHRoZSBsYW5lIGZpbmlzaGVkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2UgZW50YW5nbGVkIGl0LiBTbyB3ZSBuZWVkIHRvXG4vLyBlbnRhbmdsZSBpdCBhZ2FpbiwganVzdCB0byBiZSBzdXJlLlxubWFya1Jvb3RFbnRhbmdsZWQocm9vdCxuZXdRdWV1ZUxhbmVzKTt9fWZ1bmN0aW9uIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcyxjYXB0dXJlZFVwZGF0ZSl7Ly8gQ2FwdHVyZWQgdXBkYXRlcyBhcmUgdXBkYXRlcyB0aGF0IGFyZSB0aHJvd24gYnkgYSBjaGlsZCBkdXJpbmcgdGhlIHJlbmRlclxuLy8gcGhhc2UuIFRoZXkgc2hvdWxkIGJlIGRpc2NhcmRlZCBpZiB0aGUgcmVuZGVyIGlzIGFib3J0ZWQuIFRoZXJlZm9yZSxcbi8vIHdlIHNob3VsZCBvbmx5IHB1dCB0aGVtIG9uIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlLCBub3QgdGhlIGN1cnJlbnQgb25lLlxudmFyIHF1ZXVlPXdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlOy8vIENoZWNrIGlmIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIGEgY2xvbmUuXG52YXIgY3VycmVudD13b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7aWYoY3VycmVudCE9PW51bGwpe3ZhciBjdXJyZW50UXVldWU9Y3VycmVudC51cGRhdGVRdWV1ZTtpZihxdWV1ZT09PWN1cnJlbnRRdWV1ZSl7Ly8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgdGhlIHNhbWUgYXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW5cbi8vIHdlIGJhaWwgb3V0IG9uIGEgcGFyZW50IGZpYmVyIHRoYXQgdGhlbiBjYXB0dXJlcyBhbiBlcnJvciB0aHJvd24gYnlcbi8vIGEgY2hpbGQuIFNpbmNlIHdlIHdhbnQgdG8gYXBwZW5kIHRoZSB1cGRhdGUgb25seSB0byB0aGUgd29yay1pblxuLy8gLXByb2dyZXNzIHF1ZXVlLCB3ZSBuZWVkIHRvIGNsb25lIHRoZSB1cGRhdGVzLiBXZSB1c3VhbGx5IGNsb25lIGR1cmluZ1xuLy8gcHJvY2Vzc1VwZGF0ZVF1ZXVlLCBidXQgdGhhdCBkaWRuJ3QgaGFwcGVuIGluIHRoaXMgY2FzZSBiZWNhdXNlIHdlXG4vLyBza2lwcGVkIG92ZXIgdGhlIHBhcmVudCB3aGVuIHdlIGJhaWxlZCBvdXQuXG52YXIgbmV3Rmlyc3Q9bnVsbDt2YXIgbmV3TGFzdD1udWxsO3ZhciBmaXJzdEJhc2VVcGRhdGU9cXVldWUuZmlyc3RCYXNlVXBkYXRlO2lmKGZpcnN0QmFzZVVwZGF0ZSE9PW51bGwpey8vIExvb3AgdGhyb3VnaCB0aGUgdXBkYXRlcyBhbmQgY2xvbmUgdGhlbS5cbnZhciB1cGRhdGU9Zmlyc3RCYXNlVXBkYXRlO2Rve3ZhciBjbG9uZT17ZXZlbnRUaW1lOnVwZGF0ZS5ldmVudFRpbWUsbGFuZTp1cGRhdGUubGFuZSx0YWc6dXBkYXRlLnRhZyxwYXlsb2FkOnVwZGF0ZS5wYXlsb2FkLGNhbGxiYWNrOnVwZGF0ZS5jYWxsYmFjayxuZXh0Om51bGx9O2lmKG5ld0xhc3Q9PT1udWxsKXtuZXdGaXJzdD1uZXdMYXN0PWNsb25lO31lbHNle25ld0xhc3QubmV4dD1jbG9uZTtuZXdMYXN0PWNsb25lO311cGRhdGU9dXBkYXRlLm5leHQ7fXdoaWxlKHVwZGF0ZSE9PW51bGwpOy8vIEFwcGVuZCB0aGUgY2FwdHVyZWQgdXBkYXRlIHRoZSBlbmQgb2YgdGhlIGNsb25lZCBsaXN0LlxuaWYobmV3TGFzdD09PW51bGwpe25ld0ZpcnN0PW5ld0xhc3Q9Y2FwdHVyZWRVcGRhdGU7fWVsc2V7bmV3TGFzdC5uZXh0PWNhcHR1cmVkVXBkYXRlO25ld0xhc3Q9Y2FwdHVyZWRVcGRhdGU7fX1lbHNley8vIFRoZXJlIGFyZSBubyBiYXNlIHVwZGF0ZXMuXG5uZXdGaXJzdD1uZXdMYXN0PWNhcHR1cmVkVXBkYXRlO31xdWV1ZT17YmFzZVN0YXRlOmN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsZmlyc3RCYXNlVXBkYXRlOm5ld0ZpcnN0LGxhc3RCYXNlVXBkYXRlOm5ld0xhc3Qsc2hhcmVkOmN1cnJlbnRRdWV1ZS5zaGFyZWQsZWZmZWN0czpjdXJyZW50UXVldWUuZWZmZWN0c307d29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU9cXVldWU7cmV0dXJuO319Ly8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbnZhciBsYXN0QmFzZVVwZGF0ZT1xdWV1ZS5sYXN0QmFzZVVwZGF0ZTtpZihsYXN0QmFzZVVwZGF0ZT09PW51bGwpe3F1ZXVlLmZpcnN0QmFzZVVwZGF0ZT1jYXB0dXJlZFVwZGF0ZTt9ZWxzZXtsYXN0QmFzZVVwZGF0ZS5uZXh0PWNhcHR1cmVkVXBkYXRlO31xdWV1ZS5sYXN0QmFzZVVwZGF0ZT1jYXB0dXJlZFVwZGF0ZTt9ZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLHF1ZXVlLHVwZGF0ZSxwcmV2U3RhdGUsbmV4dFByb3BzLGluc3RhbmNlKXtzd2l0Y2godXBkYXRlLnRhZyl7Y2FzZSBSZXBsYWNlU3RhdGU6e3ZhciBwYXlsb2FkPXVwZGF0ZS5wYXlsb2FkO2lmKHR5cGVvZiBwYXlsb2FkPT09J2Z1bmN0aW9uJyl7Ly8gVXBkYXRlciBmdW5jdGlvblxue2VudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTt9dmFyIG5leHRTdGF0ZT1wYXlsb2FkLmNhbGwoaW5zdGFuY2UscHJldlN0YXRlLG5leHRQcm9wcyk7e2lmKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7dHJ5e3BheWxvYWQuY2FsbChpbnN0YW5jZSxwcmV2U3RhdGUsbmV4dFByb3BzKTt9ZmluYWxseXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7fX1leGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTt9cmV0dXJuIG5leHRTdGF0ZTt9Ly8gU3RhdGUgb2JqZWN0XG5yZXR1cm4gcGF5bG9hZDt9Y2FzZSBDYXB0dXJlVXBkYXRlOnt3b3JrSW5Qcm9ncmVzcy5mbGFncz13b3JrSW5Qcm9ncmVzcy5mbGFncyZ+U2hvdWxkQ2FwdHVyZXxEaWRDYXB0dXJlO30vLyBJbnRlbnRpb25hbCBmYWxsdGhyb3VnaFxuY2FzZSBVcGRhdGVTdGF0ZTp7dmFyIF9wYXlsb2FkPXVwZGF0ZS5wYXlsb2FkO3ZhciBwYXJ0aWFsU3RhdGU7aWYodHlwZW9mIF9wYXlsb2FkPT09J2Z1bmN0aW9uJyl7Ly8gVXBkYXRlciBmdW5jdGlvblxue2VudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTt9cGFydGlhbFN0YXRlPV9wYXlsb2FkLmNhbGwoaW5zdGFuY2UscHJldlN0YXRlLG5leHRQcm9wcyk7e2lmKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7dHJ5e19wYXlsb2FkLmNhbGwoaW5zdGFuY2UscHJldlN0YXRlLG5leHRQcm9wcyk7fWZpbmFsbHl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO319ZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7fX1lbHNley8vIFBhcnRpYWwgc3RhdGUgb2JqZWN0XG5wYXJ0aWFsU3RhdGU9X3BheWxvYWQ7fWlmKHBhcnRpYWxTdGF0ZT09PW51bGx8fHBhcnRpYWxTdGF0ZT09PXVuZGVmaW5lZCl7Ly8gTnVsbCBhbmQgdW5kZWZpbmVkIGFyZSB0cmVhdGVkIGFzIG5vLW9wcy5cbnJldHVybiBwcmV2U3RhdGU7fS8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG5yZXR1cm4gYXNzaWduKHt9LHByZXZTdGF0ZSxwYXJ0aWFsU3RhdGUpO31jYXNlIEZvcmNlVXBkYXRlOntoYXNGb3JjZVVwZGF0ZT10cnVlO3JldHVybiBwcmV2U3RhdGU7fX1yZXR1cm4gcHJldlN0YXRlO31mdW5jdGlvbiBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MscHJvcHMsaW5zdGFuY2UscmVuZGVyTGFuZXMpey8vIFRoaXMgaXMgYWx3YXlzIG5vbi1udWxsIG9uIGEgQ2xhc3NDb21wb25lbnQgb3IgSG9zdFJvb3RcbnZhciBxdWV1ZT13b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtoYXNGb3JjZVVwZGF0ZT1mYWxzZTt7Y3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlPXF1ZXVlLnNoYXJlZDt9dmFyIGZpcnN0QmFzZVVwZGF0ZT1xdWV1ZS5maXJzdEJhc2VVcGRhdGU7dmFyIGxhc3RCYXNlVXBkYXRlPXF1ZXVlLmxhc3RCYXNlVXBkYXRlOy8vIENoZWNrIGlmIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIElmIHNvLCB0cmFuc2ZlciB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxudmFyIHBlbmRpbmdRdWV1ZT1xdWV1ZS5zaGFyZWQucGVuZGluZztpZihwZW5kaW5nUXVldWUhPT1udWxsKXtxdWV1ZS5zaGFyZWQucGVuZGluZz1udWxsOy8vIFRoZSBwZW5kaW5nIHF1ZXVlIGlzIGNpcmN1bGFyLiBEaXNjb25uZWN0IHRoZSBwb2ludGVyIGJldHdlZW4gZmlyc3Rcbi8vIGFuZCBsYXN0IHNvIHRoYXQgaXQncyBub24tY2lyY3VsYXIuXG52YXIgbGFzdFBlbmRpbmdVcGRhdGU9cGVuZGluZ1F1ZXVlO3ZhciBmaXJzdFBlbmRpbmdVcGRhdGU9bGFzdFBlbmRpbmdVcGRhdGUubmV4dDtsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0PW51bGw7Ly8gQXBwZW5kIHBlbmRpbmcgdXBkYXRlcyB0byBiYXNlIHF1ZXVlXG5pZihsYXN0QmFzZVVwZGF0ZT09PW51bGwpe2ZpcnN0QmFzZVVwZGF0ZT1maXJzdFBlbmRpbmdVcGRhdGU7fWVsc2V7bGFzdEJhc2VVcGRhdGUubmV4dD1maXJzdFBlbmRpbmdVcGRhdGU7fWxhc3RCYXNlVXBkYXRlPWxhc3RQZW5kaW5nVXBkYXRlOy8vIElmIHRoZXJlJ3MgYSBjdXJyZW50IHF1ZXVlLCBhbmQgaXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgYmFzZSBxdWV1ZSwgdGhlblxuLy8gd2UgbmVlZCB0byB0cmFuc2ZlciB0aGUgdXBkYXRlcyB0byB0aGF0IHF1ZXVlLCB0b28uIEJlY2F1c2UgdGhlIGJhc2Vcbi8vIHF1ZXVlIGlzIGEgc2luZ2x5LWxpbmtlZCBsaXN0IHdpdGggbm8gY3ljbGVzLCB3ZSBjYW4gYXBwZW5kIHRvIGJvdGhcbi8vIGxpc3RzIGFuZCB0YWtlIGFkdmFudGFnZSBvZiBzdHJ1Y3R1cmFsIHNoYXJpbmcuXG4vLyBUT0RPOiBQYXNzIGBjdXJyZW50YCBhcyBhcmd1bWVudFxudmFyIGN1cnJlbnQ9d29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO2lmKGN1cnJlbnQhPT1udWxsKXsvLyBUaGlzIGlzIGFsd2F5cyBub24tbnVsbCBvbiBhIENsYXNzQ29tcG9uZW50IG9yIEhvc3RSb290XG52YXIgY3VycmVudFF1ZXVlPWN1cnJlbnQudXBkYXRlUXVldWU7dmFyIGN1cnJlbnRMYXN0QmFzZVVwZGF0ZT1jdXJyZW50UXVldWUubGFzdEJhc2VVcGRhdGU7aWYoY3VycmVudExhc3RCYXNlVXBkYXRlIT09bGFzdEJhc2VVcGRhdGUpe2lmKGN1cnJlbnRMYXN0QmFzZVVwZGF0ZT09PW51bGwpe2N1cnJlbnRRdWV1ZS5maXJzdEJhc2VVcGRhdGU9Zmlyc3RQZW5kaW5nVXBkYXRlO31lbHNle2N1cnJlbnRMYXN0QmFzZVVwZGF0ZS5uZXh0PWZpcnN0UGVuZGluZ1VwZGF0ZTt9Y3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlPWxhc3RQZW5kaW5nVXBkYXRlO319fS8vIFRoZXNlIHZhbHVlcyBtYXkgY2hhbmdlIGFzIHdlIHByb2Nlc3MgdGhlIHF1ZXVlLlxuaWYoZmlyc3RCYXNlVXBkYXRlIT09bnVsbCl7Ly8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBsaXN0IG9mIHVwZGF0ZXMgdG8gY29tcHV0ZSB0aGUgcmVzdWx0LlxudmFyIG5ld1N0YXRlPXF1ZXVlLmJhc2VTdGF0ZTsvLyBUT0RPOiBEb24ndCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhpcy4gSW5zdGVhZCwgd2UgY2FuIHJlbW92ZSByZW5kZXJMYW5lc1xuLy8gZnJvbSB0aGUgb3JpZ2luYWwgbGFuZXMuXG52YXIgbmV3TGFuZXM9Tm9MYW5lczt2YXIgbmV3QmFzZVN0YXRlPW51bGw7dmFyIG5ld0ZpcnN0QmFzZVVwZGF0ZT1udWxsO3ZhciBuZXdMYXN0QmFzZVVwZGF0ZT1udWxsO3ZhciB1cGRhdGU9Zmlyc3RCYXNlVXBkYXRlO2Rve3ZhciB1cGRhdGVMYW5lPXVwZGF0ZS5sYW5lO3ZhciB1cGRhdGVFdmVudFRpbWU9dXBkYXRlLmV2ZW50VGltZTtpZighaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLHVwZGF0ZUxhbmUpKXsvLyBQcmlvcml0eSBpcyBpbnN1ZmZpY2llbnQuIFNraXAgdGhpcyB1cGRhdGUuIElmIHRoaXMgaXMgdGhlIGZpcnN0XG4vLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2Vcbi8vIHVwZGF0ZS9zdGF0ZS5cbnZhciBjbG9uZT17ZXZlbnRUaW1lOnVwZGF0ZUV2ZW50VGltZSxsYW5lOnVwZGF0ZUxhbmUsdGFnOnVwZGF0ZS50YWcscGF5bG9hZDp1cGRhdGUucGF5bG9hZCxjYWxsYmFjazp1cGRhdGUuY2FsbGJhY2ssbmV4dDpudWxsfTtpZihuZXdMYXN0QmFzZVVwZGF0ZT09PW51bGwpe25ld0ZpcnN0QmFzZVVwZGF0ZT1uZXdMYXN0QmFzZVVwZGF0ZT1jbG9uZTtuZXdCYXNlU3RhdGU9bmV3U3RhdGU7fWVsc2V7bmV3TGFzdEJhc2VVcGRhdGU9bmV3TGFzdEJhc2VVcGRhdGUubmV4dD1jbG9uZTt9Ly8gVXBkYXRlIHRoZSByZW1haW5pbmcgcHJpb3JpdHkgaW4gdGhlIHF1ZXVlLlxubmV3TGFuZXM9bWVyZ2VMYW5lcyhuZXdMYW5lcyx1cGRhdGVMYW5lKTt9ZWxzZXsvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cbmlmKG5ld0xhc3RCYXNlVXBkYXRlIT09bnVsbCl7dmFyIF9jbG9uZT17ZXZlbnRUaW1lOnVwZGF0ZUV2ZW50VGltZSwvLyBUaGlzIHVwZGF0ZSBpcyBnb2luZyB0byBiZSBjb21taXR0ZWQgc28gd2UgbmV2ZXIgd2FudCB1bmNvbW1pdFxuLy8gaXQuIFVzaW5nIE5vTGFuZSB3b3JrcyBiZWNhdXNlIDAgaXMgYSBzdWJzZXQgb2YgYWxsIGJpdG1hc2tzLCBzb1xuLy8gdGhpcyB3aWxsIG5ldmVyIGJlIHNraXBwZWQgYnkgdGhlIGNoZWNrIGFib3ZlLlxubGFuZTpOb0xhbmUsdGFnOnVwZGF0ZS50YWcscGF5bG9hZDp1cGRhdGUucGF5bG9hZCxjYWxsYmFjazp1cGRhdGUuY2FsbGJhY2ssbmV4dDpudWxsfTtuZXdMYXN0QmFzZVVwZGF0ZT1uZXdMYXN0QmFzZVVwZGF0ZS5uZXh0PV9jbG9uZTt9Ly8gUHJvY2VzcyB0aGlzIHVwZGF0ZS5cbm5ld1N0YXRlPWdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcyxxdWV1ZSx1cGRhdGUsbmV3U3RhdGUscHJvcHMsaW5zdGFuY2UpO3ZhciBjYWxsYmFjaz11cGRhdGUuY2FsbGJhY2s7aWYoY2FsbGJhY2shPT1udWxsJiYvLyBJZiB0aGUgdXBkYXRlIHdhcyBhbHJlYWR5IGNvbW1pdHRlZCwgd2Ugc2hvdWxkIG5vdCBxdWV1ZSBpdHNcbi8vIGNhbGxiYWNrIGFnYWluLlxudXBkYXRlLmxhbmUhPT1Ob0xhbmUpe3dvcmtJblByb2dyZXNzLmZsYWdzfD1DYWxsYmFjazt2YXIgZWZmZWN0cz1xdWV1ZS5lZmZlY3RzO2lmKGVmZmVjdHM9PT1udWxsKXtxdWV1ZS5lZmZlY3RzPVt1cGRhdGVdO31lbHNle2VmZmVjdHMucHVzaCh1cGRhdGUpO319fXVwZGF0ZT11cGRhdGUubmV4dDtpZih1cGRhdGU9PT1udWxsKXtwZW5kaW5nUXVldWU9cXVldWUuc2hhcmVkLnBlbmRpbmc7aWYocGVuZGluZ1F1ZXVlPT09bnVsbCl7YnJlYWs7fWVsc2V7Ly8gQW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgZnJvbSBpbnNpZGUgYSByZWR1Y2VyLiBBZGQgdGhlIG5ld1xuLy8gcGVuZGluZyB1cGRhdGVzIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIGtlZXAgcHJvY2Vzc2luZy5cbnZhciBfbGFzdFBlbmRpbmdVcGRhdGU9cGVuZGluZ1F1ZXVlOy8vIEludGVudGlvbmFsbHkgdW5zb3VuZC4gUGVuZGluZyB1cGRhdGVzIGZvcm0gYSBjaXJjdWxhciBsaXN0LCBidXQgd2Vcbi8vIHVucmF2ZWwgdGhlbSB3aGVuIHRyYW5zZmVycmluZyB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxudmFyIF9maXJzdFBlbmRpbmdVcGRhdGU9X2xhc3RQZW5kaW5nVXBkYXRlLm5leHQ7X2xhc3RQZW5kaW5nVXBkYXRlLm5leHQ9bnVsbDt1cGRhdGU9X2ZpcnN0UGVuZGluZ1VwZGF0ZTtxdWV1ZS5sYXN0QmFzZVVwZGF0ZT1fbGFzdFBlbmRpbmdVcGRhdGU7cXVldWUuc2hhcmVkLnBlbmRpbmc9bnVsbDt9fX13aGlsZSh0cnVlKTtpZihuZXdMYXN0QmFzZVVwZGF0ZT09PW51bGwpe25ld0Jhc2VTdGF0ZT1uZXdTdGF0ZTt9cXVldWUuYmFzZVN0YXRlPW5ld0Jhc2VTdGF0ZTtxdWV1ZS5maXJzdEJhc2VVcGRhdGU9bmV3Rmlyc3RCYXNlVXBkYXRlO3F1ZXVlLmxhc3RCYXNlVXBkYXRlPW5ld0xhc3RCYXNlVXBkYXRlOy8vIEludGVybGVhdmVkIHVwZGF0ZXMgYXJlIHN0b3JlZCBvbiBhIHNlcGFyYXRlIHF1ZXVlLiBXZSBhcmVuJ3QgZ29pbmcgdG9cbi8vIHByb2Nlc3MgdGhlbSBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCB3ZSBkbyBuZWVkIHRvIHRyYWNrIHdoaWNoIGxhbmVzXG4vLyBhcmUgcmVtYWluaW5nLlxudmFyIGxhc3RJbnRlcmxlYXZlZD1xdWV1ZS5zaGFyZWQuaW50ZXJsZWF2ZWQ7aWYobGFzdEludGVybGVhdmVkIT09bnVsbCl7dmFyIGludGVybGVhdmVkPWxhc3RJbnRlcmxlYXZlZDtkb3tuZXdMYW5lcz1tZXJnZUxhbmVzKG5ld0xhbmVzLGludGVybGVhdmVkLmxhbmUpO2ludGVybGVhdmVkPWludGVybGVhdmVkLm5leHQ7fXdoaWxlKGludGVybGVhdmVkIT09bGFzdEludGVybGVhdmVkKTt9ZWxzZSBpZihmaXJzdEJhc2VVcGRhdGU9PT1udWxsKXsvLyBgcXVldWUubGFuZXNgIGlzIHVzZWQgZm9yIGVudGFuZ2xpbmcgdHJhbnNpdGlvbnMuIFdlIGNhbiBzZXQgaXQgYmFjayB0b1xuLy8gemVybyBvbmNlIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbnF1ZXVlLnNoYXJlZC5sYW5lcz1Ob0xhbmVzO30vLyBTZXQgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUgdG8gYmUgd2hhdGV2ZXIgaXMgcmVtYWluaW5nIGluIHRoZSBxdWV1ZS5cbi8vIFRoaXMgc2hvdWxkIGJlIGZpbmUgYmVjYXVzZSB0aGUgb25seSB0d28gb3RoZXIgdGhpbmdzIHRoYXQgY29udHJpYnV0ZSB0b1xuLy8gZXhwaXJhdGlvbiB0aW1lIGFyZSBwcm9wcyBhbmQgY29udGV4dC4gV2UncmUgYWxyZWFkeSBpbiB0aGUgbWlkZGxlIG9mIHRoZVxuLy8gYmVnaW4gcGhhc2UgYnkgdGhlIHRpbWUgd2Ugc3RhcnQgcHJvY2Vzc2luZyB0aGUgcXVldWUsIHNvIHdlJ3ZlIGFscmVhZHlcbi8vIGRlYWx0IHdpdGggdGhlIHByb3BzLiBDb250ZXh0IGluIGNvbXBvbmVudHMgdGhhdCBzcGVjaWZ5XG4vLyBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdHJpY2t5OyBidXQgd2UnbGwgaGF2ZSB0byBhY2NvdW50IGZvclxuLy8gdGhhdCByZWdhcmRsZXNzLlxubWFya1NraXBwZWRVcGRhdGVMYW5lcyhuZXdMYW5lcyk7d29ya0luUHJvZ3Jlc3MubGFuZXM9bmV3TGFuZXM7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1uZXdTdGF0ZTt9e2N1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZT1udWxsO319ZnVuY3Rpb24gY2FsbENhbGxiYWNrKGNhbGxiYWNrLGNvbnRleHQpe2lmKHR5cGVvZiBjYWxsYmFjayE9PSdmdW5jdGlvbicpe3Rocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgJysoXCJyZWNlaXZlZDogXCIrY2FsbGJhY2spKTt9Y2FsbGJhY2suY2FsbChjb250ZXh0KTt9ZnVuY3Rpb24gcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKXtoYXNGb3JjZVVwZGF0ZT1mYWxzZTt9ZnVuY3Rpb24gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpe3JldHVybiBoYXNGb3JjZVVwZGF0ZTt9ZnVuY3Rpb24gY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLGZpbmlzaGVkUXVldWUsaW5zdGFuY2Upey8vIENvbW1pdCB0aGUgZWZmZWN0c1xudmFyIGVmZmVjdHM9ZmluaXNoZWRRdWV1ZS5lZmZlY3RzO2ZpbmlzaGVkUXVldWUuZWZmZWN0cz1udWxsO2lmKGVmZmVjdHMhPT1udWxsKXtmb3IodmFyIGk9MDtpPGVmZmVjdHMubGVuZ3RoO2krKyl7dmFyIGVmZmVjdD1lZmZlY3RzW2ldO3ZhciBjYWxsYmFjaz1lZmZlY3QuY2FsbGJhY2s7aWYoY2FsbGJhY2shPT1udWxsKXtlZmZlY3QuY2FsbGJhY2s9bnVsbDtjYWxsQ2FsbGJhY2soY2FsbGJhY2ssaW5zdGFuY2UpO319fX12YXIgTk9fQ09OVEVYVD17fTt2YXIgY29udGV4dFN0YWNrQ3Vyc29yJDE9Y3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO3ZhciBjb250ZXh0RmliZXJTdGFja0N1cnNvcj1jcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7dmFyIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yPWNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYyl7aWYoYz09PU5PX0NPTlRFWFQpe3Rocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJysnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31yZXR1cm4gYzt9ZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKXt2YXIgcm9vdEluc3RhbmNlPXJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtyZXR1cm4gcm9vdEluc3RhbmNlO31mdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlcixuZXh0Um9vdEluc3RhbmNlKXsvLyBQdXNoIGN1cnJlbnQgcm9vdCBpbnN0YW5jZSBvbnRvIHRoZSBzdGFjaztcbi8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG5wdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLG5leHRSb290SW5zdGFuY2UsZmliZXIpOy8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbi8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbnB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsZmliZXIsZmliZXIpOy8vIEZpbmFsbHksIHdlIG5lZWQgdG8gcHVzaCB0aGUgaG9zdCBjb250ZXh0IHRvIHRoZSBzdGFjay5cbi8vIEhvd2V2ZXIsIHdlIGNhbid0IGp1c3QgY2FsbCBnZXRSb290SG9zdENvbnRleHQoKSBhbmQgcHVzaCBpdCBiZWNhdXNlXG4vLyB3ZSdkIGhhdmUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGVudHJpZXMgb24gdGhlIHN0YWNrIGRlcGVuZGluZyBvblxuLy8gd2hldGhlciBnZXRSb290SG9zdENvbnRleHQoKSB0aHJvd3Mgc29tZXdoZXJlIGluIHJlbmRlcmVyIGNvZGUgb3Igbm90LlxuLy8gU28gd2UgcHVzaCBhbiBlbXB0eSB2YWx1ZSBmaXJzdC4gVGhpcyBsZXRzIHVzIHNhZmVseSB1bndpbmQgb24gZXJyb3JzLlxucHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSxOT19DT05URVhULGZpYmVyKTt2YXIgbmV4dFJvb3RDb250ZXh0PWdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTsvLyBOb3cgdGhhdCB3ZSBrbm93IHRoaXMgZnVuY3Rpb24gZG9lc24ndCB0aHJvdywgcmVwbGFjZSBpdC5cbnBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSxmaWJlcik7cHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSxuZXh0Um9vdENvbnRleHQsZmliZXIpO31mdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKXtwb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsZmliZXIpO3BvcChjb250ZXh0RmliZXJTdGFja0N1cnNvcixmaWJlcik7cG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLGZpYmVyKTt9ZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKXt2YXIgY29udGV4dD1yZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yJDEuY3VycmVudCk7cmV0dXJuIGNvbnRleHQ7fWZ1bmN0aW9uIHB1c2hIb3N0Q29udGV4dChmaWJlcil7dmFyIHJvb3RJbnN0YW5jZT1yZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7dmFyIGNvbnRleHQ9cmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvciQxLmN1cnJlbnQpO3ZhciBuZXh0Q29udGV4dD1nZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsZmliZXIudHlwZSk7Ly8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG5pZihjb250ZXh0PT09bmV4dENvbnRleHQpe3JldHVybjt9Ly8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxucHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvcixmaWJlcixmaWJlcik7cHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSxuZXh0Q29udGV4dCxmaWJlcik7fWZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKXsvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4vLyBwdXNoSG9zdENvbnRleHQoKSBvbmx5IHB1c2hlcyBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbmlmKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQhPT1maWJlcil7cmV0dXJuO31wb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsZmliZXIpO3BvcChjb250ZXh0RmliZXJTdGFja0N1cnNvcixmaWJlcik7fXZhciBEZWZhdWx0U3VzcGVuc2VDb250ZXh0PTA7Ly8gVGhlIFN1c3BlbnNlIENvbnRleHQgaXMgc3BsaXQgaW50byB0d28gcGFydHMuIFRoZSBsb3dlciBiaXRzIGlzXG4vLyBpbmhlcml0ZWQgZGVlcGx5IGRvd24gdGhlIHN1YnRyZWUuIFRoZSB1cHBlciBiaXRzIG9ubHkgYWZmZWN0XG4vLyB0aGlzIGltbWVkaWF0ZSBzdXNwZW5zZSBib3VuZGFyeSBhbmQgZ2V0cyByZXNldCBlYWNoIG5ld1xuLy8gYm91bmRhcnkgb3Igc3VzcGVuc2UgbGlzdC5cbnZhciBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaz0xOy8vIFN1YnRyZWUgRmxhZ3M6XG4vLyBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQgaW5kaWNhdGVzIHRoYXQgb25lIG9mIG91ciBwYXJlbnQgU3VzcGVuc2Vcbi8vIGJvdW5kYXJpZXMgaXMgbm90IGN1cnJlbnRseSBzaG93aW5nIHZpc2libGUgbWFpbiBjb250ZW50LlxuLy8gRWl0aGVyIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2sgb3IgaXMgbm90IG1vdW50ZWQgYXQgYWxsLlxuLy8gV2UgY2FuIHVzZSB0aGlzIHRvIGRldGVybWluZSBpZiBpdCBpcyBkZXNpcmFibGUgdG8gdHJpZ2dlciBhIGZhbGxiYWNrIGF0XG4vLyB0aGUgcGFyZW50LiBJZiBub3QsIHRoZW4gd2UgbWlnaHQgbmVlZCB0byB0cmlnZ2VyIHVuZGVzaXJhYmxlIGJvdW5kYXJpZXNcbi8vIGFuZC9vciBzdXNwZW5kIHRoZSBjb21taXQgdG8gYXZvaWQgaGlkaW5nIHRoZSBwYXJlbnQgY29udGVudC5cbnZhciBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQ9MTsvLyBTaGFsbG93IEZsYWdzOlxuLy8gRm9yY2VTdXNwZW5zZUZhbGxiYWNrIGNhbiBiZSB1c2VkIGJ5IFN1c3BlbnNlTGlzdCB0byBmb3JjZSBuZXdseSBhZGRlZFxuLy8gaXRlbXMgaW50byB0aGVpciBmYWxsYmFjayBzdGF0ZSBkdXJpbmcgb25lIG9mIHRoZSByZW5kZXIgcGFzc2VzLlxudmFyIEZvcmNlU3VzcGVuc2VGYWxsYmFjaz0yO3ZhciBzdXNwZW5zZVN0YWNrQ3Vyc29yPWNyZWF0ZUN1cnNvcihEZWZhdWx0U3VzcGVuc2VDb250ZXh0KTtmdW5jdGlvbiBoYXNTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCxmbGFnKXtyZXR1cm4ocGFyZW50Q29udGV4dCZmbGFnKSE9PTA7fWZ1bmN0aW9uIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQpe3JldHVybiBwYXJlbnRDb250ZXh0JlN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrO31mdW5jdGlvbiBzZXRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQsc2hhbGxvd0NvbnRleHQpe3JldHVybiBwYXJlbnRDb250ZXh0JlN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrfHNoYWxsb3dDb250ZXh0O31mdW5jdGlvbiBhZGRTdWJ0cmVlU3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQsc3VidHJlZUNvbnRleHQpe3JldHVybiBwYXJlbnRDb250ZXh0fHN1YnRyZWVDb250ZXh0O31mdW5jdGlvbiBwdXNoU3VzcGVuc2VDb250ZXh0KGZpYmVyLG5ld0NvbnRleHQpe3B1c2goc3VzcGVuc2VTdGFja0N1cnNvcixuZXdDb250ZXh0LGZpYmVyKTt9ZnVuY3Rpb24gcG9wU3VzcGVuc2VDb250ZXh0KGZpYmVyKXtwb3Aoc3VzcGVuc2VTdGFja0N1cnNvcixmaWJlcik7fWZ1bmN0aW9uIHNob3VsZENhcHR1cmVTdXNwZW5zZSh3b3JrSW5Qcm9ncmVzcyxoYXNJbnZpc2libGVQYXJlbnQpey8vIElmIGl0IHdhcyB0aGUgcHJpbWFyeSBjaGlsZHJlbiB0aGF0IGp1c3Qgc3VzcGVuZGVkLCBjYXB0dXJlIGFuZCByZW5kZXIgdGhlXG4vLyBmYWxsYmFjay4gT3RoZXJ3aXNlLCBkb24ndCBjYXB0dXJlIGFuZCBidWJibGUgdG8gdGhlIG5leHQgYm91bmRhcnkuXG52YXIgbmV4dFN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7aWYobmV4dFN0YXRlIT09bnVsbCl7aWYobmV4dFN0YXRlLmRlaHlkcmF0ZWQhPT1udWxsKXsvLyBBIGRlaHlkcmF0ZWQgYm91bmRhcnkgYWx3YXlzIGNhcHR1cmVzLlxucmV0dXJuIHRydWU7fXJldHVybiBmYWxzZTt9dmFyIHByb3BzPXdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7Ly8gUmVndWxhciBib3VuZGFyaWVzIGFsd2F5cyBjYXB0dXJlLlxue3JldHVybiB0cnVlO30vLyBJZiBpdCdzIGEgYm91bmRhcnkgd2Ugc2hvdWxkIGF2b2lkLCB0aGVuIHdlIHByZWZlciB0byBidWJibGUgdXAgdG8gdGhlXG59ZnVuY3Rpb24gZmluZEZpcnN0U3VzcGVuZGVkKHJvdyl7dmFyIG5vZGU9cm93O3doaWxlKG5vZGUhPT1udWxsKXtpZihub2RlLnRhZz09PVN1c3BlbnNlQ29tcG9uZW50KXt2YXIgc3RhdGU9bm9kZS5tZW1vaXplZFN0YXRlO2lmKHN0YXRlIT09bnVsbCl7dmFyIGRlaHlkcmF0ZWQ9c3RhdGUuZGVoeWRyYXRlZDtpZihkZWh5ZHJhdGVkPT09bnVsbHx8aXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhkZWh5ZHJhdGVkKXx8aXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soZGVoeWRyYXRlZCkpe3JldHVybiBub2RlO319fWVsc2UgaWYobm9kZS50YWc9PT1TdXNwZW5zZUxpc3RDb21wb25lbnQmJi8vIHJldmVhbE9yZGVyIHVuZGVmaW5lZCBjYW4ndCBiZSB0cnVzdGVkIGJlY2F1c2UgaXQgZG9uJ3Rcbi8vIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBpdCBzdXNwZW5kZWQgb3Igbm90Llxubm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyIT09dW5kZWZpbmVkKXt2YXIgZGlkU3VzcGVuZD0obm9kZS5mbGFncyZEaWRDYXB0dXJlKSE9PU5vRmxhZ3M7aWYoZGlkU3VzcGVuZCl7cmV0dXJuIG5vZGU7fX1lbHNlIGlmKG5vZGUuY2hpbGQhPT1udWxsKXtub2RlLmNoaWxkLnJldHVybj1ub2RlO25vZGU9bm9kZS5jaGlsZDtjb250aW51ZTt9aWYobm9kZT09PXJvdyl7cmV0dXJuIG51bGw7fXdoaWxlKG5vZGUuc2libGluZz09PW51bGwpe2lmKG5vZGUucmV0dXJuPT09bnVsbHx8bm9kZS5yZXR1cm49PT1yb3cpe3JldHVybiBudWxsO31ub2RlPW5vZGUucmV0dXJuO31ub2RlLnNpYmxpbmcucmV0dXJuPW5vZGUucmV0dXJuO25vZGU9bm9kZS5zaWJsaW5nO31yZXR1cm4gbnVsbDt9dmFyIE5vRmxhZ3MkMT0vKiAgICovMDsvLyBSZXByZXNlbnRzIHdoZXRoZXIgZWZmZWN0IHNob3VsZCBmaXJlLlxudmFyIEhhc0VmZmVjdD0vKiAqLzE7Ly8gUmVwcmVzZW50cyB0aGUgcGhhc2UgaW4gd2hpY2ggdGhlIGVmZmVjdCAobm90IHRoZSBjbGVhbi11cCkgZmlyZXMuXG52YXIgSW5zZXJ0aW9uPS8qICAqLzI7dmFyIExheW91dD0vKiAgICAqLzQ7dmFyIFBhc3NpdmUkMT0vKiAgICovODsvLyBhbmQgc2hvdWxkIGJlIHJlc2V0IGJlZm9yZSBzdGFydGluZyBhIG5ldyByZW5kZXIuXG4vLyBUaGlzIHRyYWNrcyB3aGljaCBtdXRhYmxlIHNvdXJjZXMgbmVlZCB0byBiZSByZXNldCBhZnRlciBhIHJlbmRlci5cbnZhciB3b3JrSW5Qcm9ncmVzc1NvdXJjZXM9W107ZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCl7Zm9yKHZhciBpPTA7aTx3b3JrSW5Qcm9ncmVzc1NvdXJjZXMubGVuZ3RoO2krKyl7dmFyIG11dGFibGVTb3VyY2U9d29ya0luUHJvZ3Jlc3NTb3VyY2VzW2ldO3ttdXRhYmxlU291cmNlLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5PW51bGw7fX13b3JrSW5Qcm9ncmVzc1NvdXJjZXMubGVuZ3RoPTA7fS8vIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSB2ZXJzaW9uIHVzZWQgZm9yIHNlcnZlciByZW5kZXJpbmcgbWF0Y2hlcyB0aGUgb25lXG4vLyB0aGF0IGlzIGV2ZW50dWFsbHkgcmVhZCBkdXJpbmcgaHlkcmF0aW9uLlxuLy8gSWYgdGhleSBkb24ndCBtYXRjaCB0aGVyZSdzIGEgcG90ZW50aWFsIHRlYXIgYW5kIGEgZnVsbCBkZW9wdCByZW5kZXIgaXMgcmVxdWlyZWQuXG5mdW5jdGlvbiByZWdpc3Rlck11dGFibGVTb3VyY2VGb3JIeWRyYXRpb24ocm9vdCxtdXRhYmxlU291cmNlKXt2YXIgZ2V0VmVyc2lvbj1tdXRhYmxlU291cmNlLl9nZXRWZXJzaW9uO3ZhciB2ZXJzaW9uPWdldFZlcnNpb24obXV0YWJsZVNvdXJjZS5fc291cmNlKTsvLyBUT0RPIENsZWFyIHRoaXMgZGF0YSBvbmNlIGFsbCBwZW5kaW5nIGh5ZHJhdGlvbiB3b3JrIGlzIGZpbmlzaGVkLlxuLy8gUmV0YWluaW5nIGl0IGZvcmV2ZXIgbWF5IGludGVyZmVyZSB3aXRoIEdDLlxuaWYocm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhPT1udWxsKXtyb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE9W211dGFibGVTb3VyY2UsdmVyc2lvbl07fWVsc2V7cm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhLnB1c2gobXV0YWJsZVNvdXJjZSx2ZXJzaW9uKTt9fXZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDE9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO3ZhciBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQ7dmFyIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90O3tkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQ9bmV3IFNldCgpO30vLyBUaGVzZSBhcmUgc2V0IHJpZ2h0IGJlZm9yZSBjYWxsaW5nIHRoZSBjb21wb25lbnQuXG52YXIgcmVuZGVyTGFuZXM9Tm9MYW5lczsvLyBUaGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci4gSSd2ZSBuYW1lZCBpdCBkaWZmZXJlbnRseSB0byBkaXN0aW5ndWlzaCBpdCBmcm9tXG4vLyB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE9bnVsbDsvLyBIb29rcyBhcmUgc3RvcmVkIGFzIGEgbGlua2VkIGxpc3Qgb24gdGhlIGZpYmVyJ3MgbWVtb2l6ZWRTdGF0ZSBmaWVsZC4gVGhlXG4vLyBjdXJyZW50IGhvb2sgbGlzdCBpcyB0aGUgbGlzdCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGN1cnJlbnQgZmliZXIuIFRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBob29rIGxpc3QgaXMgYSBuZXcgbGlzdCB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxudmFyIGN1cnJlbnRIb29rPW51bGw7dmFyIHdvcmtJblByb2dyZXNzSG9vaz1udWxsOy8vIFdoZXRoZXIgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgYXQgYW55IHBvaW50IGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGlzXG4vLyBkb2VzIG5vdCBnZXQgcmVzZXQgaWYgd2UgZG8gYW5vdGhlciByZW5kZXIgcGFzczsgb25seSB3aGVuIHdlJ3JlIGNvbXBsZXRlbHlcbi8vIGZpbmlzaGVkIGV2YWx1YXRpbmcgdGhpcyBjb21wb25lbnQuIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHNvIHdlIGtub3dcbi8vIHdoZXRoZXIgd2UgbmVlZCB0byBjbGVhciByZW5kZXIgcGhhc2UgdXBkYXRlcyBhZnRlciBhIHRocm93LlxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGU9ZmFsc2U7Ly8gV2hlcmUgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgb25seSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIHBhc3MuIFRoaXNcbi8vIGdldHMgcmVzZXQgYWZ0ZXIgZWFjaCBhdHRlbXB0LlxuLy8gVE9ETzogTWF5YmUgdGhlcmUncyBzb21lIHdheSB0byBjb25zb2xpZGF0ZSB0aGlzIHdpdGhcbi8vIGBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlYC4gT3Igd2l0aCBgbnVtYmVyT2ZSZVJlbmRlcnNgLlxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcz1mYWxzZTsvLyBDb3VudHMgdGhlIG51bWJlciBvZiB1c2VJZCBob29rcyBpbiB0aGlzIGNvbXBvbmVudC5cbnZhciBsb2NhbElkQ291bnRlcj0wOy8vIFVzZWQgZm9yIGlkcyB0aGF0IGFyZSBnZW5lcmF0ZWQgY29tcGxldGVseSBjbGllbnQtc2lkZSAoaS5lLiBub3QgZHVyaW5nXG4vLyBoeWRyYXRpb24pLiBUaGlzIGNvdW50ZXIgaXMgZ2xvYmFsLCBzbyBjbGllbnQgaWRzIGFyZSBub3Qgc3RhYmxlIGFjcm9zc1xuLy8gcmVuZGVyIGF0dGVtcHRzLlxudmFyIGdsb2JhbENsaWVudElkQ291bnRlcj0wO3ZhciBSRV9SRU5ERVJfTElNSVQ9MjU7Ly8gSW4gREVWLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHByaW1pdGl2ZSBob29rXG52YXIgY3VycmVudEhvb2tOYW1lSW5EZXY9bnVsbDsvLyBJbiBERVYsIHRoaXMgbGlzdCBlbnN1cmVzIHRoYXQgaG9va3MgYXJlIGNhbGxlZCBpbiB0aGUgc2FtZSBvcmRlciBiZXR3ZWVuIHJlbmRlcnMuXG4vLyBUaGUgbGlzdCBzdG9yZXMgdGhlIG9yZGVyIG9mIGhvb2tzIHVzZWQgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlciAobW91bnQpLlxuLy8gU3Vic2VxdWVudCByZW5kZXJzICh1cGRhdGVzKSByZWZlcmVuY2UgdGhpcyBsaXN0LlxudmFyIGhvb2tUeXBlc0Rldj1udWxsO3ZhciBob29rVHlwZXNVcGRhdGVJbmRleERldj0tMTsvLyBJbiBERVYsIHRoaXMgdHJhY2tzIHdoZXRoZXIgY3VycmVudGx5IHJlbmRlcmluZyBjb21wb25lbnQgbmVlZHMgdG8gaWdub3JlXG4vLyB0aGUgZGVwZW5kZW5jaWVzIGZvciBIb29rcyB0aGF0IG5lZWQgdGhlbSAoZS5nLiB1c2VFZmZlY3Qgb3IgdXNlTWVtbykuXG4vLyBXaGVuIHRydWUsIHN1Y2ggSG9va3Mgd2lsbCBhbHdheXMgYmUgXCJyZW1vdW50ZWRcIi4gT25seSB1c2VkIGR1cmluZyBob3QgcmVsb2FkLlxudmFyIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzPWZhbHNlO2Z1bmN0aW9uIG1vdW50SG9va1R5cGVzRGV2KCl7e3ZhciBob29rTmFtZT1jdXJyZW50SG9va05hbWVJbkRldjtpZihob29rVHlwZXNEZXY9PT1udWxsKXtob29rVHlwZXNEZXY9W2hvb2tOYW1lXTt9ZWxzZXtob29rVHlwZXNEZXYucHVzaChob29rTmFtZSk7fX19ZnVuY3Rpb24gdXBkYXRlSG9va1R5cGVzRGV2KCl7e3ZhciBob29rTmFtZT1jdXJyZW50SG9va05hbWVJbkRldjtpZihob29rVHlwZXNEZXYhPT1udWxsKXtob29rVHlwZXNVcGRhdGVJbmRleERldisrO2lmKGhvb2tUeXBlc0Rldltob29rVHlwZXNVcGRhdGVJbmRleERldl0hPT1ob29rTmFtZSl7d2Fybk9uSG9va01pc21hdGNoSW5EZXYoaG9va05hbWUpO319fX1mdW5jdGlvbiBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKXt7aWYoZGVwcyE9PXVuZGVmaW5lZCYmZGVwcyE9PW51bGwmJiFpc0FycmF5KGRlcHMpKXsvLyBWZXJpZnkgZGVwcywgYnV0IG9ubHkgb24gbW91bnQgdG8gYXZvaWQgZXh0cmEgY2hlY2tzLlxuLy8gSXQncyB1bmxpa2VseSB0aGVpciB0eXBlIHdvdWxkIGNoYW5nZSBhcyB1c3VhbGx5IHlvdSBkZWZpbmUgdGhlbSBpbmxpbmUuXG5lcnJvcignJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCB0aGF0IGlzIG5vdCBhbiBhcnJheSAoaW5zdGVhZCwgcmVjZWl2ZWQgYCVzYCkuIFdoZW4gJysnc3BlY2lmaWVkLCB0aGUgZmluYWwgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheS4nLGN1cnJlbnRIb29rTmFtZUluRGV2LHR5cGVvZiBkZXBzKTt9fX1mdW5jdGlvbiB3YXJuT25Ib29rTWlzbWF0Y2hJbkRldihjdXJyZW50SG9va05hbWUpe3t2YXIgY29tcG9uZW50TmFtZT1nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO2lmKCFkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKXtkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO2lmKGhvb2tUeXBlc0RldiE9PW51bGwpe3ZhciB0YWJsZT0nJzt2YXIgc2Vjb25kQ29sdW1uU3RhcnQ9MzA7Zm9yKHZhciBpPTA7aTw9aG9va1R5cGVzVXBkYXRlSW5kZXhEZXY7aSsrKXt2YXIgb2xkSG9va05hbWU9aG9va1R5cGVzRGV2W2ldO3ZhciBuZXdIb29rTmFtZT1pPT09aG9va1R5cGVzVXBkYXRlSW5kZXhEZXY/Y3VycmVudEhvb2tOYW1lOm9sZEhvb2tOYW1lO3ZhciByb3c9aSsxK1wiLiBcIitvbGRIb29rTmFtZTsvLyBFeHRyYSBzcGFjZSBzbyBzZWNvbmQgY29sdW1uIGxpbmVzIHVwXG4vLyBsb2wgQCBJRSBub3Qgc3VwcG9ydGluZyBTdHJpbmcjcmVwZWF0XG53aGlsZShyb3cubGVuZ3RoPHNlY29uZENvbHVtblN0YXJ0KXtyb3crPScgJzt9cm93Kz1uZXdIb29rTmFtZSsnXFxuJzt0YWJsZSs9cm93O31lcnJvcignUmVhY3QgaGFzIGRldGVjdGVkIGEgY2hhbmdlIGluIHRoZSBvcmRlciBvZiBIb29rcyBjYWxsZWQgYnkgJXMuICcrJ1RoaXMgd2lsbCBsZWFkIHRvIGJ1Z3MgYW5kIGVycm9ycyBpZiBub3QgZml4ZWQuICcrJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCByZWFkIHRoZSBSdWxlcyBvZiBIb29rczogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzXFxuXFxuJysnICAgUHJldmlvdXMgcmVuZGVyICAgICAgICAgICAgTmV4dCByZW5kZXJcXG4nKycgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4nKyclcycrJyAgIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxcbicsY29tcG9uZW50TmFtZSx0YWJsZSk7fX19fWZ1bmN0aW9uIHRocm93SW52YWxpZEhvb2tFcnJvcigpe3Rocm93IG5ldyBFcnJvcignSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvcicrJyBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbicrJzEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbicrJzIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4nKyczLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuJysnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uJyk7fWZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcyxwcmV2RGVwcyl7e2lmKGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzKXsvLyBPbmx5IHRydWUgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBiZWluZyBob3QgcmVsb2FkZWQuXG5yZXR1cm4gZmFsc2U7fX1pZihwcmV2RGVwcz09PW51bGwpe3tlcnJvcignJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCBub3QgZHVyaW5nICcrJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJysnaXRzIHR5cGUgY2Fubm90IGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMuJyxjdXJyZW50SG9va05hbWVJbkRldik7fXJldHVybiBmYWxzZTt9ey8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuLy8gcGFzc2VkIGlubGluZS5cbmlmKG5leHREZXBzLmxlbmd0aCE9PXByZXZEZXBzLmxlbmd0aCl7ZXJyb3IoJ1RoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlICcrJ29yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuJysnUHJldmlvdXM6ICVzXFxuJysnSW5jb21pbmc6ICVzJyxjdXJyZW50SG9va05hbWVJbkRldixcIltcIitwcmV2RGVwcy5qb2luKCcsICcpK1wiXVwiLFwiW1wiK25leHREZXBzLmpvaW4oJywgJykrXCJdXCIpO319Zm9yKHZhciBpPTA7aTxwcmV2RGVwcy5sZW5ndGgmJmk8bmV4dERlcHMubGVuZ3RoO2krKyl7aWYob2JqZWN0SXMobmV4dERlcHNbaV0scHJldkRlcHNbaV0pKXtjb250aW51ZTt9cmV0dXJuIGZhbHNlO31yZXR1cm4gdHJ1ZTt9ZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHByb3BzLHNlY29uZEFyZyxuZXh0UmVuZGVyTGFuZXMpe3JlbmRlckxhbmVzPW5leHRSZW5kZXJMYW5lcztjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxPXdvcmtJblByb2dyZXNzO3tob29rVHlwZXNEZXY9Y3VycmVudCE9PW51bGw/Y3VycmVudC5fZGVidWdIb29rVHlwZXM6bnVsbDtob29rVHlwZXNVcGRhdGVJbmRleERldj0tMTsvLyBVc2VkIGZvciBob3QgcmVsb2FkaW5nOlxuaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXM9Y3VycmVudCE9PW51bGwmJmN1cnJlbnQudHlwZSE9PXdvcmtJblByb2dyZXNzLnR5cGU7fXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9bnVsbDt3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT1udWxsO3dvcmtJblByb2dyZXNzLmxhbmVzPU5vTGFuZXM7Ly8gVGhlIGZvbGxvd2luZyBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVzZXRcbi8vIGN1cnJlbnRIb29rID0gbnVsbDtcbi8vIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4vLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4vLyBsb2NhbElkQ291bnRlciA9IDA7XG4vLyBUT0RPIFdhcm4gaWYgbm8gaG9va3MgYXJlIHVzZWQgYXQgYWxsIGR1cmluZyBtb3VudCwgdGhlbiBzb21lIGFyZSB1c2VkIGR1cmluZyB1cGRhdGUuXG4vLyBDdXJyZW50bHkgd2Ugd2lsbCBpZGVudGlmeSB0aGUgdXBkYXRlIHJlbmRlciBhcyBhIG1vdW50IGJlY2F1c2UgbWVtb2l6ZWRTdGF0ZSA9PT0gbnVsbC5cbi8vIFRoaXMgaXMgdHJpY2t5IGJlY2F1c2UgaXQncyB2YWxpZCBmb3IgY2VydGFpbiB0eXBlcyBvZiBjb21wb25lbnRzIChlLmcuIFJlYWN0LmxhenkpXG4vLyBVc2luZyBtZW1vaXplZFN0YXRlIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBtb3VudC91cGRhdGUgb25seSB3b3JrcyBpZiBhdCBsZWFzdCBvbmUgc3RhdGVmdWwgaG9vayBpcyB1c2VkLlxuLy8gTm9uLXN0YXRlZnVsIGhvb2tzIChlLmcuIGNvbnRleHQpIGRvbid0IGdldCBhZGRlZCB0byBtZW1vaXplZFN0YXRlLFxuLy8gc28gbWVtb2l6ZWRTdGF0ZSB3b3VsZCBiZSBudWxsIGR1cmluZyB1cGRhdGVzIGFuZCBtb3VudHMuXG57aWYoY3VycmVudCE9PW51bGwmJmN1cnJlbnQubWVtb2l6ZWRTdGF0ZSE9PW51bGwpe1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7fWVsc2UgaWYoaG9va1R5cGVzRGV2IT09bnVsbCl7Ly8gVGhpcyBkaXNwYXRjaGVyIGhhbmRsZXMgYW4gZWRnZSBjYXNlIHdoZXJlIGEgY29tcG9uZW50IGlzIHVwZGF0aW5nLFxuLy8gYnV0IG5vIHN0YXRlZnVsIGhvb2tzIGhhdmUgYmVlbiB1c2VkLlxuLy8gV2Ugd2FudCB0byBtYXRjaCB0aGUgcHJvZHVjdGlvbiBjb2RlIGJlaGF2aW9yICh3aGljaCB3aWxsIHVzZSBIb29rc0Rpc3BhdGNoZXJPbk1vdW50KSxcbi8vIGJ1dCB3aXRoIHRoZSBleHRyYSBERVYgdmFsaWRhdGlvbiB0byBlbnN1cmUgaG9va3Mgb3JkZXJpbmcgaGFzbid0IGNoYW5nZWQuXG4vLyBUaGlzIGRpc3BhdGNoZXIgZG9lcyB0aGF0LlxuUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVjt9ZWxzZXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1Ib29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7fX12YXIgY2hpbGRyZW49Q29tcG9uZW50KHByb3BzLHNlY29uZEFyZyk7Ly8gQ2hlY2sgaWYgdGhlcmUgd2FzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZVxuaWYoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzKXsvLyBLZWVwIHJlbmRlcmluZyBpbiBhIGxvb3AgZm9yIGFzIGxvbmcgYXMgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgY29udGludWUgdG9cbi8vIGJlIHNjaGVkdWxlZC4gVXNlIGEgY291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxudmFyIG51bWJlck9mUmVSZW5kZXJzPTA7ZG97ZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzPWZhbHNlO2xvY2FsSWRDb3VudGVyPTA7aWYobnVtYmVyT2ZSZVJlbmRlcnM+PVJFX1JFTkRFUl9MSU1JVCl7dGhyb3cgbmV3IEVycm9yKCdUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgJysnYW4gaW5maW5pdGUgbG9vcC4nKTt9bnVtYmVyT2ZSZVJlbmRlcnMrPTE7ey8vIEV2ZW4gd2hlbiBob3QgcmVsb2FkaW5nLCBhbGxvdyBkZXBlbmRlbmNpZXMgdG8gc3RhYmlsaXplXG4vLyBhZnRlciBmaXJzdCByZW5kZXIgdG8gcHJldmVudCBpbmZpbml0ZSByZW5kZXIgcGhhc2UgdXBkYXRlcy5cbmlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzPWZhbHNlO30vLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuY3VycmVudEhvb2s9bnVsbDt3b3JrSW5Qcm9ncmVzc0hvb2s9bnVsbDt3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT1udWxsO3svLyBBbHNvIHZhbGlkYXRlIGhvb2sgb3JkZXIgZm9yIGNhc2NhZGluZyB1cGRhdGVzLlxuaG9va1R5cGVzVXBkYXRlSW5kZXhEZXY9LTE7fVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtjaGlsZHJlbj1Db21wb25lbnQocHJvcHMsc2Vjb25kQXJnKTt9d2hpbGUoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzKTt9Ly8gV2UgY2FuIGFzc3VtZSB0aGUgcHJldmlvdXMgZGlzcGF0Y2hlciBpcyBhbHdheXMgdGhpcyBvbmUsIHNpbmNlIHdlIHNldCBpdFxuLy8gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVuZGVyIHBoYXNlIGFuZCB0aGVyZSdzIG5vIHJlLWVudHJhbmNlLlxuUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9Q29udGV4dE9ubHlEaXNwYXRjaGVyO3t3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXM9aG9va1R5cGVzRGV2O30vLyBUaGlzIGNoZWNrIHVzZXMgY3VycmVudEhvb2sgc28gdGhhdCBpdCB3b3JrcyB0aGUgc2FtZSBpbiBERVYgYW5kIHByb2QgYnVuZGxlcy5cbi8vIGhvb2tUeXBlc0RldiBjb3VsZCBjYXRjaCBtb3JlIGNhc2VzIChlLmcuIGNvbnRleHQpIGJ1dCBvbmx5IGluIERFViBidW5kbGVzLlxudmFyIGRpZFJlbmRlclRvb0Zld0hvb2tzPWN1cnJlbnRIb29rIT09bnVsbCYmY3VycmVudEhvb2submV4dCE9PW51bGw7cmVuZGVyTGFuZXM9Tm9MYW5lcztjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxPW51bGw7Y3VycmVudEhvb2s9bnVsbDt3b3JrSW5Qcm9ncmVzc0hvb2s9bnVsbDt7Y3VycmVudEhvb2tOYW1lSW5EZXY9bnVsbDtob29rVHlwZXNEZXY9bnVsbDtob29rVHlwZXNVcGRhdGVJbmRleERldj0tMTsvLyBDb25maXJtIHRoYXQgYSBzdGF0aWMgZmxhZyB3YXMgbm90IGFkZGVkIG9yIHJlbW92ZWQgc2luY2UgdGhlIGxhc3Rcbi8vIHJlbmRlci4gSWYgdGhpcyBmaXJlcywgaXQgc3VnZ2VzdHMgdGhhdCB3ZSBpbmNvcnJlY3RseSByZXNldCB0aGUgc3RhdGljXG4vLyBmbGFncyBpbiBzb21lIG90aGVyIHBhcnQgb2YgdGhlIGNvZGViYXNlLiBUaGlzIGhhcyBoYXBwZW5lZCBiZWZvcmUsIGZvclxuLy8gZXhhbXBsZSwgaW4gdGhlIFN1c3BlbnNlTGlzdCBpbXBsZW1lbnRhdGlvbi5cbmlmKGN1cnJlbnQhPT1udWxsJiYoY3VycmVudC5mbGFncyZTdGF0aWNNYXNrKSE9PSh3b3JrSW5Qcm9ncmVzcy5mbGFncyZTdGF0aWNNYXNrKSYmLy8gRGlzYWJsZSB0aGlzIHdhcm5pbmcgaW4gbGVnYWN5IG1vZGUsIGJlY2F1c2UgbGVnYWN5IFN1c3BlbnNlIGlzIHdlaXJkXG4vLyBhbmQgY3JlYXRlcyBmYWxzZSBwb3NpdGl2ZXMuIFRvIG1ha2UgdGhpcyB3b3JrIGluIGxlZ2FjeSBtb2RlLCB3ZSdkXG4vLyBuZWVkIHRvIG1hcmsgZmliZXJzIHRoYXQgY29tbWl0IGluIGFuIGluY29tcGxldGUgc3RhdGUsIHNvbWVob3cuIEZvclxuLy8gbm93IEknbGwgZGlzYWJsZSB0aGUgd2FybmluZyB0aGF0IG1vc3Qgb2YgdGhlIGJ1Z3MgdGhhdCB3b3VsZCB0cmlnZ2VyXG4vLyBpdCBhcmUgZWl0aGVyIGV4Y2x1c2l2ZSB0byBjb25jdXJyZW50IG1vZGUgb3IgZXhpc3QgaW4gYm90aC5cbihjdXJyZW50Lm1vZGUmQ29uY3VycmVudE1vZGUpIT09Tm9Nb2RlKXtlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEV4cGVjdGVkIHN0YXRpYyBmbGFnIHdhcyBtaXNzaW5nLiBQbGVhc2UgJysnbm90aWZ5IHRoZSBSZWFjdCB0ZWFtLicpO319ZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZT1mYWxzZTsvLyBUaGlzIGlzIHJlc2V0IGJ5IGNoZWNrRGlkUmVuZGVySWRIb29rXG4vLyBsb2NhbElkQ291bnRlciA9IDA7XG5pZihkaWRSZW5kZXJUb29GZXdIb29rcyl7dGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlZCBmZXdlciBob29rcyB0aGFuIGV4cGVjdGVkLiBUaGlzIG1heSBiZSBjYXVzZWQgYnkgYW4gYWNjaWRlbnRhbCAnKydlYXJseSByZXR1cm4gc3RhdGVtZW50LicpO31yZXR1cm4gY2hpbGRyZW47fWZ1bmN0aW9uIGNoZWNrRGlkUmVuZGVySWRIb29rKCl7Ly8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIGV2ZXJ5IHJlbmRlcldpdGhIb29rcyBjYWxsLlxuLy8gQ29uY2VwdHVhbGx5LCBpdCdzIHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiByZW5kZXJXaXRoSG9va3M7IGl0J3Mgb25seSBhXG4vLyBzZXBhcmF0ZSBmdW5jdGlvbiB0byBhdm9pZCB1c2luZyBhbiBhcnJheSB0dXBsZS5cbnZhciBkaWRSZW5kZXJJZEhvb2s9bG9jYWxJZENvdW50ZXIhPT0wO2xvY2FsSWRDb3VudGVyPTA7cmV0dXJuIGRpZFJlbmRlcklkSG9vazt9ZnVuY3Rpb24gYmFpbG91dEhvb2tzKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbGFuZXMpe3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlPWN1cnJlbnQudXBkYXRlUXVldWU7Ly8gVE9ETzogRG9uJ3QgbmVlZCB0byByZXNldCB0aGUgZmxhZ3MgaGVyZSwgYmVjYXVzZSB0aGV5J3JlIHJlc2V0IGluIHRoZVxuLy8gY29tcGxldGUgcGhhc2UgKGJ1YmJsZVByb3BlcnRpZXMpLlxuaWYoKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0RWZmZWN0c01vZGUpIT09Tm9Nb2RlKXt3b3JrSW5Qcm9ncmVzcy5mbGFncyY9fihNb3VudFBhc3NpdmVEZXZ8TW91bnRMYXlvdXREZXZ8UGFzc2l2ZXxVcGRhdGUpO31lbHNle3dvcmtJblByb2dyZXNzLmZsYWdzJj1+KFBhc3NpdmV8VXBkYXRlKTt9Y3VycmVudC5sYW5lcz1yZW1vdmVMYW5lcyhjdXJyZW50LmxhbmVzLGxhbmVzKTt9ZnVuY3Rpb24gcmVzZXRIb29rc0FmdGVyVGhyb3coKXsvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4vLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZW5kZXIgcGhhc2UgYW5kIHRoZXJlJ3Mgbm8gcmUtZW50cmFuY2UuXG5SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1Db250ZXh0T25seURpc3BhdGNoZXI7aWYoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSl7Ly8gVGhlcmUgd2VyZSByZW5kZXIgcGhhc2UgdXBkYXRlcy4gVGhlc2UgYXJlIG9ubHkgdmFsaWQgZm9yIHRoaXMgcmVuZGVyXG4vLyBwaGFzZSwgd2hpY2ggd2UgYXJlIG5vdyBhYm9ydGluZy4gUmVtb3ZlIHRoZSB1cGRhdGVzIGZyb20gdGhlIHF1ZXVlcyBzb1xuLy8gdGhleSBkbyBub3QgcGVyc2lzdCB0byB0aGUgbmV4dCByZW5kZXIuIERvIG5vdCByZW1vdmUgdXBkYXRlcyBmcm9tIGhvb2tzXG4vLyB0aGF0IHdlcmVuJ3QgcHJvY2Vzc2VkLlxuLy9cbi8vIE9ubHkgcmVzZXQgdGhlIHVwZGF0ZXMgZnJvbSB0aGUgcXVldWUgaWYgaXQgaGFzIGEgY2xvbmUuIElmIGl0IGRvZXNcbi8vIG5vdCBoYXZlIGEgY2xvbmUsIHRoYXQgbWVhbnMgaXQgd2Fzbid0IHByb2Nlc3NlZCwgYW5kIHRoZSB1cGRhdGVzIHdlcmVcbi8vIHNjaGVkdWxlZCBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgcmVuZGVyIHBoYXNlLlxudmFyIGhvb2s9Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlO3doaWxlKGhvb2shPT1udWxsKXt2YXIgcXVldWU9aG9vay5xdWV1ZTtpZihxdWV1ZSE9PW51bGwpe3F1ZXVlLnBlbmRpbmc9bnVsbDt9aG9vaz1ob29rLm5leHQ7fWRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGU9ZmFsc2U7fXJlbmRlckxhbmVzPU5vTGFuZXM7Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMT1udWxsO2N1cnJlbnRIb29rPW51bGw7d29ya0luUHJvZ3Jlc3NIb29rPW51bGw7e2hvb2tUeXBlc0Rldj1udWxsO2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2PS0xO2N1cnJlbnRIb29rTmFtZUluRGV2PW51bGw7aXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZT1mYWxzZTt9ZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzPWZhbHNlO2xvY2FsSWRDb3VudGVyPTA7fWZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCl7dmFyIGhvb2s9e21lbW9pemVkU3RhdGU6bnVsbCxiYXNlU3RhdGU6bnVsbCxiYXNlUXVldWU6bnVsbCxxdWV1ZTpudWxsLG5leHQ6bnVsbH07aWYod29ya0luUHJvZ3Jlc3NIb29rPT09bnVsbCl7Ly8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdFxuY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlPXdvcmtJblByb2dyZXNzSG9vaz1ob29rO31lbHNley8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG53b3JrSW5Qcm9ncmVzc0hvb2s9d29ya0luUHJvZ3Jlc3NIb29rLm5leHQ9aG9vazt9cmV0dXJuIHdvcmtJblByb2dyZXNzSG9vazt9ZnVuY3Rpb24gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCl7Ly8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJvdGggZm9yIHVwZGF0ZXMgYW5kIGZvciByZS1yZW5kZXJzIHRyaWdnZXJlZCBieSBhXG4vLyByZW5kZXIgcGhhc2UgdXBkYXRlLiBJdCBhc3N1bWVzIHRoZXJlIGlzIGVpdGhlciBhIGN1cnJlbnQgaG9vayB3ZSBjYW5cbi8vIGNsb25lLCBvciBhIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBmcm9tIGEgcHJldmlvdXMgcmVuZGVyIHBhc3MgdGhhdCB3ZSBjYW5cbi8vIHVzZSBhcyBhIGJhc2UuIFdoZW4gd2UgcmVhY2ggdGhlIGVuZCBvZiB0aGUgYmFzZSBsaXN0LCB3ZSBtdXN0IHN3aXRjaCB0b1xuLy8gdGhlIGRpc3BhdGNoZXIgdXNlZCBmb3IgbW91bnRzLlxudmFyIG5leHRDdXJyZW50SG9vaztpZihjdXJyZW50SG9vaz09PW51bGwpe3ZhciBjdXJyZW50PWN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlO2lmKGN1cnJlbnQhPT1udWxsKXtuZXh0Q3VycmVudEhvb2s9Y3VycmVudC5tZW1vaXplZFN0YXRlO31lbHNle25leHRDdXJyZW50SG9vaz1udWxsO319ZWxzZXtuZXh0Q3VycmVudEhvb2s9Y3VycmVudEhvb2submV4dDt9dmFyIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2s7aWYod29ya0luUHJvZ3Jlc3NIb29rPT09bnVsbCl7bmV4dFdvcmtJblByb2dyZXNzSG9vaz1jdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGU7fWVsc2V7bmV4dFdvcmtJblByb2dyZXNzSG9vaz13b3JrSW5Qcm9ncmVzc0hvb2submV4dDt9aWYobmV4dFdvcmtJblByb2dyZXNzSG9vayE9PW51bGwpey8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0Llxud29ya0luUHJvZ3Jlc3NIb29rPW5leHRXb3JrSW5Qcm9ncmVzc0hvb2s7bmV4dFdvcmtJblByb2dyZXNzSG9vaz13b3JrSW5Qcm9ncmVzc0hvb2submV4dDtjdXJyZW50SG9vaz1uZXh0Q3VycmVudEhvb2s7fWVsc2V7Ly8gQ2xvbmUgZnJvbSB0aGUgY3VycmVudCBob29rLlxuaWYobmV4dEN1cnJlbnRIb29rPT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXIuJyk7fWN1cnJlbnRIb29rPW5leHRDdXJyZW50SG9vazt2YXIgbmV3SG9vaz17bWVtb2l6ZWRTdGF0ZTpjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLGJhc2VTdGF0ZTpjdXJyZW50SG9vay5iYXNlU3RhdGUsYmFzZVF1ZXVlOmN1cnJlbnRIb29rLmJhc2VRdWV1ZSxxdWV1ZTpjdXJyZW50SG9vay5xdWV1ZSxuZXh0Om51bGx9O2lmKHdvcmtJblByb2dyZXNzSG9vaz09PW51bGwpey8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3QuXG5jdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGU9d29ya0luUHJvZ3Jlc3NIb29rPW5ld0hvb2s7fWVsc2V7Ly8gQXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG53b3JrSW5Qcm9ncmVzc0hvb2s9d29ya0luUHJvZ3Jlc3NIb29rLm5leHQ9bmV3SG9vazt9fXJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7fWZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKXtyZXR1cm57bGFzdEVmZmVjdDpudWxsLHN0b3JlczpudWxsfTt9ZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsYWN0aW9uKXsvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xucmV0dXJuIHR5cGVvZiBhY3Rpb249PT0nZnVuY3Rpb24nP2FjdGlvbihzdGF0ZSk6YWN0aW9uO31mdW5jdGlvbiBtb3VudFJlZHVjZXIocmVkdWNlcixpbml0aWFsQXJnLGluaXQpe3ZhciBob29rPW1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7dmFyIGluaXRpYWxTdGF0ZTtpZihpbml0IT09dW5kZWZpbmVkKXtpbml0aWFsU3RhdGU9aW5pdChpbml0aWFsQXJnKTt9ZWxzZXtpbml0aWFsU3RhdGU9aW5pdGlhbEFyZzt9aG9vay5tZW1vaXplZFN0YXRlPWhvb2suYmFzZVN0YXRlPWluaXRpYWxTdGF0ZTt2YXIgcXVldWU9e3BlbmRpbmc6bnVsbCxpbnRlcmxlYXZlZDpudWxsLGxhbmVzOk5vTGFuZXMsZGlzcGF0Y2g6bnVsbCxsYXN0UmVuZGVyZWRSZWR1Y2VyOnJlZHVjZXIsbGFzdFJlbmRlcmVkU3RhdGU6aW5pdGlhbFN0YXRlfTtob29rLnF1ZXVlPXF1ZXVlO3ZhciBkaXNwYXRjaD1xdWV1ZS5kaXNwYXRjaD1kaXNwYXRjaFJlZHVjZXJBY3Rpb24uYmluZChudWxsLGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEscXVldWUpO3JldHVybltob29rLm1lbW9pemVkU3RhdGUsZGlzcGF0Y2hdO31mdW5jdGlvbiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KXt2YXIgaG9vaz11cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTt2YXIgcXVldWU9aG9vay5xdWV1ZTtpZihxdWV1ZT09PW51bGwpe3Rocm93IG5ldyBFcnJvcignU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31xdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyPXJlZHVjZXI7dmFyIGN1cnJlbnQ9Y3VycmVudEhvb2s7Ly8gVGhlIGxhc3QgcmViYXNlIHVwZGF0ZSB0aGF0IGlzIE5PVCBwYXJ0IG9mIHRoZSBiYXNlIHN0YXRlLlxudmFyIGJhc2VRdWV1ZT1jdXJyZW50LmJhc2VRdWV1ZTsvLyBUaGUgbGFzdCBwZW5kaW5nIHVwZGF0ZSB0aGF0IGhhc24ndCBiZWVuIHByb2Nlc3NlZCB5ZXQuXG52YXIgcGVuZGluZ1F1ZXVlPXF1ZXVlLnBlbmRpbmc7aWYocGVuZGluZ1F1ZXVlIT09bnVsbCl7Ly8gV2UgaGF2ZSBuZXcgdXBkYXRlcyB0aGF0IGhhdmVuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxuLy8gV2UnbGwgYWRkIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG5pZihiYXNlUXVldWUhPT1udWxsKXsvLyBNZXJnZSB0aGUgcGVuZGluZyBxdWV1ZSBhbmQgdGhlIGJhc2UgcXVldWUuXG52YXIgYmFzZUZpcnN0PWJhc2VRdWV1ZS5uZXh0O3ZhciBwZW5kaW5nRmlyc3Q9cGVuZGluZ1F1ZXVlLm5leHQ7YmFzZVF1ZXVlLm5leHQ9cGVuZGluZ0ZpcnN0O3BlbmRpbmdRdWV1ZS5uZXh0PWJhc2VGaXJzdDt9e2lmKGN1cnJlbnQuYmFzZVF1ZXVlIT09YmFzZVF1ZXVlKXsvLyBJbnRlcm5hbCBpbnZhcmlhbnQgdGhhdCBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgZmVhc2libHkgY291bGQgaW5cbi8vIHRoZSBmdXR1cmUgaWYgd2UgaW1wbGVtZW50IHJlc3VtaW5nLCBvciBzb21lIGZvcm0gb2YgdGhhdC5cbmVycm9yKCdJbnRlcm5hbCBlcnJvcjogRXhwZWN0ZWQgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSB0byBiZSBhIGNsb25lLiAnKydUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO319Y3VycmVudC5iYXNlUXVldWU9YmFzZVF1ZXVlPXBlbmRpbmdRdWV1ZTtxdWV1ZS5wZW5kaW5nPW51bGw7fWlmKGJhc2VRdWV1ZSE9PW51bGwpey8vIFdlIGhhdmUgYSBxdWV1ZSB0byBwcm9jZXNzLlxudmFyIGZpcnN0PWJhc2VRdWV1ZS5uZXh0O3ZhciBuZXdTdGF0ZT1jdXJyZW50LmJhc2VTdGF0ZTt2YXIgbmV3QmFzZVN0YXRlPW51bGw7dmFyIG5ld0Jhc2VRdWV1ZUZpcnN0PW51bGw7dmFyIG5ld0Jhc2VRdWV1ZUxhc3Q9bnVsbDt2YXIgdXBkYXRlPWZpcnN0O2Rve3ZhciB1cGRhdGVMYW5lPXVwZGF0ZS5sYW5lO2lmKCFpc1N1YnNldE9mTGFuZXMocmVuZGVyTGFuZXMsdXBkYXRlTGFuZSkpey8vIFByaW9yaXR5IGlzIGluc3VmZmljaWVudC4gU2tpcCB0aGlzIHVwZGF0ZS4gSWYgdGhpcyBpcyB0aGUgZmlyc3Rcbi8vIHNraXBwZWQgdXBkYXRlLCB0aGUgcHJldmlvdXMgdXBkYXRlL3N0YXRlIGlzIHRoZSBuZXcgYmFzZVxuLy8gdXBkYXRlL3N0YXRlLlxudmFyIGNsb25lPXtsYW5lOnVwZGF0ZUxhbmUsYWN0aW9uOnVwZGF0ZS5hY3Rpb24saGFzRWFnZXJTdGF0ZTp1cGRhdGUuaGFzRWFnZXJTdGF0ZSxlYWdlclN0YXRlOnVwZGF0ZS5lYWdlclN0YXRlLG5leHQ6bnVsbH07aWYobmV3QmFzZVF1ZXVlTGFzdD09PW51bGwpe25ld0Jhc2VRdWV1ZUZpcnN0PW5ld0Jhc2VRdWV1ZUxhc3Q9Y2xvbmU7bmV3QmFzZVN0YXRlPW5ld1N0YXRlO31lbHNle25ld0Jhc2VRdWV1ZUxhc3Q9bmV3QmFzZVF1ZXVlTGFzdC5uZXh0PWNsb25lO30vLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG4vLyBUT0RPOiBEb24ndCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhpcy4gSW5zdGVhZCwgd2UgY2FuIHJlbW92ZVxuLy8gcmVuZGVyTGFuZXMgZnJvbSB0aGUgb3JpZ2luYWwgbGFuZXMuXG5jdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzPW1lcmdlTGFuZXMoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyx1cGRhdGVMYW5lKTttYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHVwZGF0ZUxhbmUpO31lbHNley8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuaWYobmV3QmFzZVF1ZXVlTGFzdCE9PW51bGwpe3ZhciBfY2xvbmU9ey8vIFRoaXMgdXBkYXRlIGlzIGdvaW5nIHRvIGJlIGNvbW1pdHRlZCBzbyB3ZSBuZXZlciB3YW50IHVuY29tbWl0XG4vLyBpdC4gVXNpbmcgTm9MYW5lIHdvcmtzIGJlY2F1c2UgMCBpcyBhIHN1YnNldCBvZiBhbGwgYml0bWFza3MsIHNvXG4vLyB0aGlzIHdpbGwgbmV2ZXIgYmUgc2tpcHBlZCBieSB0aGUgY2hlY2sgYWJvdmUuXG5sYW5lOk5vTGFuZSxhY3Rpb246dXBkYXRlLmFjdGlvbixoYXNFYWdlclN0YXRlOnVwZGF0ZS5oYXNFYWdlclN0YXRlLGVhZ2VyU3RhdGU6dXBkYXRlLmVhZ2VyU3RhdGUsbmV4dDpudWxsfTtuZXdCYXNlUXVldWVMYXN0PW5ld0Jhc2VRdWV1ZUxhc3QubmV4dD1fY2xvbmU7fS8vIFByb2Nlc3MgdGhpcyB1cGRhdGUuXG5pZih1cGRhdGUuaGFzRWFnZXJTdGF0ZSl7Ly8gSWYgdGhpcyB1cGRhdGUgaXMgYSBzdGF0ZSB1cGRhdGUgKG5vdCBhIHJlZHVjZXIpIGFuZCB3YXMgcHJvY2Vzc2VkIGVhZ2VybHksXG4vLyB3ZSBjYW4gdXNlIHRoZSBlYWdlcmx5IGNvbXB1dGVkIHN0YXRlXG5uZXdTdGF0ZT11cGRhdGUuZWFnZXJTdGF0ZTt9ZWxzZXt2YXIgYWN0aW9uPXVwZGF0ZS5hY3Rpb247bmV3U3RhdGU9cmVkdWNlcihuZXdTdGF0ZSxhY3Rpb24pO319dXBkYXRlPXVwZGF0ZS5uZXh0O313aGlsZSh1cGRhdGUhPT1udWxsJiZ1cGRhdGUhPT1maXJzdCk7aWYobmV3QmFzZVF1ZXVlTGFzdD09PW51bGwpe25ld0Jhc2VTdGF0ZT1uZXdTdGF0ZTt9ZWxzZXtuZXdCYXNlUXVldWVMYXN0Lm5leHQ9bmV3QmFzZVF1ZXVlRmlyc3Q7fS8vIE1hcmsgdGhhdCB0aGUgZmliZXIgcGVyZm9ybWVkIHdvcmssIGJ1dCBvbmx5IGlmIHRoZSBuZXcgc3RhdGUgaXNcbi8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuaWYoIW9iamVjdElzKG5ld1N0YXRlLGhvb2subWVtb2l6ZWRTdGF0ZSkpe21hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7fWhvb2subWVtb2l6ZWRTdGF0ZT1uZXdTdGF0ZTtob29rLmJhc2VTdGF0ZT1uZXdCYXNlU3RhdGU7aG9vay5iYXNlUXVldWU9bmV3QmFzZVF1ZXVlTGFzdDtxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZT1uZXdTdGF0ZTt9Ly8gSW50ZXJsZWF2ZWQgdXBkYXRlcyBhcmUgc3RvcmVkIG9uIGEgc2VwYXJhdGUgcXVldWUuIFdlIGFyZW4ndCBnb2luZyB0b1xuLy8gcHJvY2VzcyB0aGVtIGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IHdlIGRvIG5lZWQgdG8gdHJhY2sgd2hpY2ggbGFuZXNcbi8vIGFyZSByZW1haW5pbmcuXG52YXIgbGFzdEludGVybGVhdmVkPXF1ZXVlLmludGVybGVhdmVkO2lmKGxhc3RJbnRlcmxlYXZlZCE9PW51bGwpe3ZhciBpbnRlcmxlYXZlZD1sYXN0SW50ZXJsZWF2ZWQ7ZG97dmFyIGludGVybGVhdmVkTGFuZT1pbnRlcmxlYXZlZC5sYW5lO2N1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXM9bWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLGludGVybGVhdmVkTGFuZSk7bWFya1NraXBwZWRVcGRhdGVMYW5lcyhpbnRlcmxlYXZlZExhbmUpO2ludGVybGVhdmVkPWludGVybGVhdmVkLm5leHQ7fXdoaWxlKGludGVybGVhdmVkIT09bGFzdEludGVybGVhdmVkKTt9ZWxzZSBpZihiYXNlUXVldWU9PT1udWxsKXsvLyBgcXVldWUubGFuZXNgIGlzIHVzZWQgZm9yIGVudGFuZ2xpbmcgdHJhbnNpdGlvbnMuIFdlIGNhbiBzZXQgaXQgYmFjayB0b1xuLy8gemVybyBvbmNlIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbnF1ZXVlLmxhbmVzPU5vTGFuZXM7fXZhciBkaXNwYXRjaD1xdWV1ZS5kaXNwYXRjaDtyZXR1cm5baG9vay5tZW1vaXplZFN0YXRlLGRpc3BhdGNoXTt9ZnVuY3Rpb24gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KXt2YXIgaG9vaz11cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTt2YXIgcXVldWU9aG9vay5xdWV1ZTtpZihxdWV1ZT09PW51bGwpe3Rocm93IG5ldyBFcnJvcignU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31xdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyPXJlZHVjZXI7Ly8gVGhpcyBpcyBhIHJlLXJlbmRlci4gQXBwbHkgdGhlIG5ldyByZW5kZXIgcGhhc2UgdXBkYXRlcyB0byB0aGUgcHJldmlvdXNcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cbnZhciBkaXNwYXRjaD1xdWV1ZS5kaXNwYXRjaDt2YXIgbGFzdFJlbmRlclBoYXNlVXBkYXRlPXF1ZXVlLnBlbmRpbmc7dmFyIG5ld1N0YXRlPWhvb2subWVtb2l6ZWRTdGF0ZTtpZihsYXN0UmVuZGVyUGhhc2VVcGRhdGUhPT1udWxsKXsvLyBUaGUgcXVldWUgZG9lc24ndCBwZXJzaXN0IHBhc3QgdGhpcyByZW5kZXIgcGFzcy5cbnF1ZXVlLnBlbmRpbmc9bnVsbDt2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZT1sYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dDt2YXIgdXBkYXRlPWZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7ZG97Ly8gUHJvY2VzcyB0aGlzIHJlbmRlciBwaGFzZSB1cGRhdGUuIFdlIGRvbid0IGhhdmUgdG8gY2hlY2sgdGhlXG4vLyBwcmlvcml0eSBiZWNhdXNlIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XG4vLyByZW5kZXIncy5cbnZhciBhY3Rpb249dXBkYXRlLmFjdGlvbjtuZXdTdGF0ZT1yZWR1Y2VyKG5ld1N0YXRlLGFjdGlvbik7dXBkYXRlPXVwZGF0ZS5uZXh0O313aGlsZSh1cGRhdGUhPT1maXJzdFJlbmRlclBoYXNlVXBkYXRlKTsvLyBNYXJrIHRoYXQgdGhlIGZpYmVyIHBlcmZvcm1lZCB3b3JrLCBidXQgb25seSBpZiB0aGUgbmV3IHN0YXRlIGlzXG4vLyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBzdGF0ZS5cbmlmKCFvYmplY3RJcyhuZXdTdGF0ZSxob29rLm1lbW9pemVkU3RhdGUpKXttYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO31ob29rLm1lbW9pemVkU3RhdGU9bmV3U3RhdGU7Ly8gRG9uJ3QgcGVyc2lzdCB0aGUgc3RhdGUgYWNjdW11bGF0ZWQgZnJvbSB0aGUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG9cbi8vIHRoZSBiYXNlIHN0YXRlIHVubGVzcyB0aGUgcXVldWUgaXMgZW1wdHkuXG4vLyBUT0RPOiBOb3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBkZXNpcmVkIHNlbWFudGljcywgYnV0IGl0J3Mgd2hhdCB3ZVxuLy8gZG8gZm9yIGdEU0ZQLiBJIGNhbid0IHJlbWVtYmVyIHdoeS5cbmlmKGhvb2suYmFzZVF1ZXVlPT09bnVsbCl7aG9vay5iYXNlU3RhdGU9bmV3U3RhdGU7fXF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlPW5ld1N0YXRlO31yZXR1cm5bbmV3U3RhdGUsZGlzcGF0Y2hdO31mdW5jdGlvbiBtb3VudE11dGFibGVTb3VyY2Uoc291cmNlLGdldFNuYXBzaG90LHN1YnNjcmliZSl7e3JldHVybiB1bmRlZmluZWQ7fX1mdW5jdGlvbiB1cGRhdGVNdXRhYmxlU291cmNlKHNvdXJjZSxnZXRTbmFwc2hvdCxzdWJzY3JpYmUpe3tyZXR1cm4gdW5kZWZpbmVkO319ZnVuY3Rpb24gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsZ2V0U25hcHNob3QsZ2V0U2VydmVyU25hcHNob3Qpe3ZhciBmaWJlcj1jdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO3ZhciBob29rPW1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7dmFyIG5leHRTbmFwc2hvdDt2YXIgaXNIeWRyYXRpbmc9Z2V0SXNIeWRyYXRpbmcoKTtpZihpc0h5ZHJhdGluZyl7aWYoZ2V0U2VydmVyU25hcHNob3Q9PT11bmRlZmluZWQpe3Rocm93IG5ldyBFcnJvcignTWlzc2luZyBnZXRTZXJ2ZXJTbmFwc2hvdCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yICcrJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLicpO31uZXh0U25hcHNob3Q9Z2V0U2VydmVyU25hcHNob3QoKTt7aWYoIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KXtpZihuZXh0U25hcHNob3QhPT1nZXRTZXJ2ZXJTbmFwc2hvdCgpKXtlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTZXJ2ZXJTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdD10cnVlO319fX1lbHNle25leHRTbmFwc2hvdD1nZXRTbmFwc2hvdCgpO3tpZighZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3Qpe3ZhciBjYWNoZWRTbmFwc2hvdD1nZXRTbmFwc2hvdCgpO2lmKCFvYmplY3RJcyhuZXh0U25hcHNob3QsY2FjaGVkU25hcHNob3QpKXtlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdD10cnVlO319fS8vIFVubGVzcyB3ZSdyZSByZW5kZXJpbmcgYSBibG9ja2luZyBsYW5lLCBzY2hlZHVsZSBhIGNvbnNpc3RlbmN5IGNoZWNrLlxuLy8gUmlnaHQgYmVmb3JlIGNvbW1pdHRpbmcsIHdlIHdpbGwgd2FsayB0aGUgdHJlZSBhbmQgY2hlY2sgaWYgYW55IG9mIHRoZVxuLy8gc3RvcmVzIHdlcmUgbXV0YXRlZC5cbi8vXG4vLyBXZSB3b24ndCBkbyB0aGlzIGlmIHdlJ3JlIGh5ZHJhdGluZyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCwgYmVjYXVzZSBpZlxuLy8gdGhlIGNvbnRlbnQgaXMgc3RhbGUsIGl0J3MgYWxyZWFkeSB2aXNpYmxlIGFueXdheS4gSW5zdGVhZCB3ZSdsbCBwYXRjaFxuLy8gaXQgdXAgaW4gYSBwYXNzaXZlIGVmZmVjdC5cbnZhciByb290PWdldFdvcmtJblByb2dyZXNzUm9vdCgpO2lmKHJvb3Q9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9aWYoIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QscmVuZGVyTGFuZXMpKXtwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLGdldFNuYXBzaG90LG5leHRTbmFwc2hvdCk7fX0vLyBSZWFkIHRoZSBjdXJyZW50IHNuYXBzaG90IGZyb20gdGhlIHN0b3JlIG9uIGV2ZXJ5IHJlbmRlci4gVGhpcyBicmVha3MgdGhlXG4vLyBub3JtYWwgcnVsZXMgb2YgUmVhY3QsIGFuZCBvbmx5IHdvcmtzIGJlY2F1c2Ugc3RvcmUgdXBkYXRlcyBhcmVcbi8vIGFsd2F5cyBzeW5jaHJvbm91cy5cbmhvb2subWVtb2l6ZWRTdGF0ZT1uZXh0U25hcHNob3Q7dmFyIGluc3Q9e3ZhbHVlOm5leHRTbmFwc2hvdCxnZXRTbmFwc2hvdDpnZXRTbmFwc2hvdH07aG9vay5xdWV1ZT1pbnN0Oy8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBzdWJzY3JpYmUgdG8gdGhlIHN0b3JlLlxubW91bnRFZmZlY3Qoc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsZmliZXIsaW5zdCxzdWJzY3JpYmUpLFtzdWJzY3JpYmVdKTsvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gdXBkYXRlIHRoZSBtdXRhYmxlIGluc3RhbmNlIGZpZWxkcy4gV2Ugd2lsbCB1cGRhdGVcbi8vIHRoaXMgd2hlbmV2ZXIgc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgb3IgdmFsdWUgY2hhbmdlcy4gQmVjYXVzZSB0aGVyZSdzIG5vXG4vLyBjbGVhbi11cCBmdW5jdGlvbiwgYW5kIHdlIHRyYWNrIHRoZSBkZXBzIGNvcnJlY3RseSwgd2UgY2FuIGNhbGwgcHVzaEVmZmVjdFxuLy8gZGlyZWN0bHksIHdpdGhvdXQgc3RvcmluZyBhbnkgYWRkaXRpb25hbCBzdGF0ZS4gRm9yIHRoZSBzYW1lIHJlYXNvbiwgd2Vcbi8vIGRvbid0IG5lZWQgdG8gc2V0IGEgc3RhdGljIGZsYWcsIGVpdGhlci5cbi8vIFRPRE86IFdlIGNhbiBtb3ZlIHRoaXMgdG8gdGhlIHBhc3NpdmUgcGhhc2Ugb25jZSB3ZSBhZGQgYSBwcmUtY29tbWl0XG4vLyBjb25zaXN0ZW5jeSBjaGVjay4gU2VlIHRoZSBuZXh0IGNvbW1lbnQuXG5maWJlci5mbGFnc3w9UGFzc2l2ZTtwdXNoRWZmZWN0KEhhc0VmZmVjdHxQYXNzaXZlJDEsdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKG51bGwsZmliZXIsaW5zdCxuZXh0U25hcHNob3QsZ2V0U25hcHNob3QpLHVuZGVmaW5lZCxudWxsKTtyZXR1cm4gbmV4dFNuYXBzaG90O31mdW5jdGlvbiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsZ2V0U25hcHNob3QsZ2V0U2VydmVyU25hcHNob3Qpe3ZhciBmaWJlcj1jdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO3ZhciBob29rPXVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpOy8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBUaGlzIGJyZWFrcyB0aGVcbi8vIG5vcm1hbCBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3MgYmVjYXVzZSBzdG9yZSB1cGRhdGVzIGFyZVxuLy8gYWx3YXlzIHN5bmNocm9ub3VzLlxudmFyIG5leHRTbmFwc2hvdD1nZXRTbmFwc2hvdCgpO3tpZighZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3Qpe3ZhciBjYWNoZWRTbmFwc2hvdD1nZXRTbmFwc2hvdCgpO2lmKCFvYmplY3RJcyhuZXh0U25hcHNob3QsY2FjaGVkU25hcHNob3QpKXtlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdD10cnVlO319fXZhciBwcmV2U25hcHNob3Q9aG9vay5tZW1vaXplZFN0YXRlO3ZhciBzbmFwc2hvdENoYW5nZWQ9IW9iamVjdElzKHByZXZTbmFwc2hvdCxuZXh0U25hcHNob3QpO2lmKHNuYXBzaG90Q2hhbmdlZCl7aG9vay5tZW1vaXplZFN0YXRlPW5leHRTbmFwc2hvdDttYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO312YXIgaW5zdD1ob29rLnF1ZXVlO3VwZGF0ZUVmZmVjdChzdWJzY3JpYmVUb1N0b3JlLmJpbmQobnVsbCxmaWJlcixpbnN0LHN1YnNjcmliZSksW3N1YnNjcmliZV0pOy8vIFdoZW5ldmVyIGdldFNuYXBzaG90IG9yIHN1YnNjcmliZSBjaGFuZ2VzLCB3ZSBuZWVkIHRvIGNoZWNrIGluIHRoZVxuLy8gY29tbWl0IHBoYXNlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcmxlYXZlZCBtdXRhdGlvbi4gSW4gY29uY3VycmVudCBtb2RlXG4vLyB0aGlzIGNhbiBoYXBwZW4gYWxsIHRoZSB0aW1lLCBidXQgZXZlbiBpbiBzeW5jaHJvbm91cyBtb2RlLCBhbiBlYXJsaWVyXG4vLyBlZmZlY3QgbWF5IGhhdmUgbXV0YXRlZCB0aGUgc3RvcmUuXG5pZihpbnN0LmdldFNuYXBzaG90IT09Z2V0U25hcHNob3R8fHNuYXBzaG90Q2hhbmdlZHx8Ly8gQ2hlY2sgaWYgdGhlIHN1c2JjcmliZSBmdW5jdGlvbiBjaGFuZ2VkLiBXZSBjYW4gc2F2ZSBzb21lIG1lbW9yeSBieVxuLy8gY2hlY2tpbmcgd2hldGhlciB3ZSBzY2hlZHVsZWQgYSBzdWJzY3JpcHRpb24gZWZmZWN0IGFib3ZlLlxud29ya0luUHJvZ3Jlc3NIb29rIT09bnVsbCYmd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUudGFnJkhhc0VmZmVjdCl7ZmliZXIuZmxhZ3N8PVBhc3NpdmU7cHVzaEVmZmVjdChIYXNFZmZlY3R8UGFzc2l2ZSQxLHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChudWxsLGZpYmVyLGluc3QsbmV4dFNuYXBzaG90LGdldFNuYXBzaG90KSx1bmRlZmluZWQsbnVsbCk7Ly8gVW5sZXNzIHdlJ3JlIHJlbmRlcmluZyBhIGJsb2NraW5nIGxhbmUsIHNjaGVkdWxlIGEgY29uc2lzdGVuY3kgY2hlY2suXG4vLyBSaWdodCBiZWZvcmUgY29tbWl0dGluZywgd2Ugd2lsbCB3YWxrIHRoZSB0cmVlIGFuZCBjaGVjayBpZiBhbnkgb2YgdGhlXG4vLyBzdG9yZXMgd2VyZSBtdXRhdGVkLlxudmFyIHJvb3Q9Z2V0V29ya0luUHJvZ3Jlc3NSb290KCk7aWYocm9vdD09PW51bGwpe3Rocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31pZighaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCxyZW5kZXJMYW5lcykpe3B1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsZ2V0U25hcHNob3QsbmV4dFNuYXBzaG90KTt9fXJldHVybiBuZXh0U25hcHNob3Q7fWZ1bmN0aW9uIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsZ2V0U25hcHNob3QscmVuZGVyZWRTbmFwc2hvdCl7ZmliZXIuZmxhZ3N8PVN0b3JlQ29uc2lzdGVuY3k7dmFyIGNoZWNrPXtnZXRTbmFwc2hvdDpnZXRTbmFwc2hvdCx2YWx1ZTpyZW5kZXJlZFNuYXBzaG90fTt2YXIgY29tcG9uZW50VXBkYXRlUXVldWU9Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtpZihjb21wb25lbnRVcGRhdGVRdWV1ZT09PW51bGwpe2NvbXBvbmVudFVwZGF0ZVF1ZXVlPWNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKTtjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlPWNvbXBvbmVudFVwZGF0ZVF1ZXVlO2NvbXBvbmVudFVwZGF0ZVF1ZXVlLnN0b3Jlcz1bY2hlY2tdO31lbHNle3ZhciBzdG9yZXM9Y29tcG9uZW50VXBkYXRlUXVldWUuc3RvcmVzO2lmKHN0b3Jlcz09PW51bGwpe2NvbXBvbmVudFVwZGF0ZVF1ZXVlLnN0b3Jlcz1bY2hlY2tdO31lbHNle3N0b3Jlcy5wdXNoKGNoZWNrKTt9fX1mdW5jdGlvbiB1cGRhdGVTdG9yZUluc3RhbmNlKGZpYmVyLGluc3QsbmV4dFNuYXBzaG90LGdldFNuYXBzaG90KXsvLyBUaGVzZSBhcmUgdXBkYXRlZCBpbiB0aGUgcGFzc2l2ZSBwaGFzZVxuaW5zdC52YWx1ZT1uZXh0U25hcHNob3Q7aW5zdC5nZXRTbmFwc2hvdD1nZXRTbmFwc2hvdDsvLyBTb21ldGhpbmcgbWF5IGhhdmUgYmVlbiBtdXRhdGVkIGluIGJldHdlZW4gcmVuZGVyIGFuZCBjb21taXQuIFRoaXMgY291bGRcbi8vIGhhdmUgYmVlbiBpbiBhbiBldmVudCB0aGF0IGZpcmVkIGJlZm9yZSB0aGUgcGFzc2l2ZSBlZmZlY3RzLCBvciBpdCBjb3VsZFxuLy8gaGF2ZSBiZWVuIGluIGEgbGF5b3V0IGVmZmVjdC4gSW4gdGhhdCBjYXNlLCB3ZSB3b3VsZCBoYXZlIHVzZWQgdGhlIG9sZFxuLy8gc25hcHNobyBhbmQgZ2V0U25hcHNob3QgdmFsdWVzIHRvIGJhaWwgb3V0LiBXZSBuZWVkIHRvIGNoZWNrIG9uZSBtb3JlIHRpbWUuXG5pZihjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKXsvLyBGb3JjZSBhIHJlLXJlbmRlci5cbmZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7fX1mdW5jdGlvbiBzdWJzY3JpYmVUb1N0b3JlKGZpYmVyLGluc3Qsc3Vic2NyaWJlKXt2YXIgaGFuZGxlU3RvcmVDaGFuZ2U9ZnVuY3Rpb24oKXsvLyBUaGUgc3RvcmUgY2hhbmdlZC4gQ2hlY2sgaWYgdGhlIHNuYXBzaG90IGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZVxuLy8gcmVhZCBmcm9tIHRoZSBzdG9yZS5cbmlmKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpey8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTt9fTsvLyBTdWJzY3JpYmUgdG8gdGhlIHN0b3JlIGFuZCByZXR1cm4gYSBjbGVhbi11cCBmdW5jdGlvbi5cbnJldHVybiBzdWJzY3JpYmUoaGFuZGxlU3RvcmVDaGFuZ2UpO31mdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3Qpe3ZhciBsYXRlc3RHZXRTbmFwc2hvdD1pbnN0LmdldFNuYXBzaG90O3ZhciBwcmV2VmFsdWU9aW5zdC52YWx1ZTt0cnl7dmFyIG5leHRWYWx1ZT1sYXRlc3RHZXRTbmFwc2hvdCgpO3JldHVybiFvYmplY3RJcyhwcmV2VmFsdWUsbmV4dFZhbHVlKTt9Y2F0Y2goZXJyb3Ipe3JldHVybiB0cnVlO319ZnVuY3Rpb24gZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKXt2YXIgcm9vdD1lbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsU3luY0xhbmUpO2lmKHJvb3QhPT1udWxsKXtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxmaWJlcixTeW5jTGFuZSxOb1RpbWVzdGFtcCk7fX1mdW5jdGlvbiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSl7dmFyIGhvb2s9bW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtpZih0eXBlb2YgaW5pdGlhbFN0YXRlPT09J2Z1bmN0aW9uJyl7Ly8gJEZsb3dGaXhNZTogRmxvdyBkb2Vzbid0IGxpa2UgbWl4ZWQgdHlwZXNcbmluaXRpYWxTdGF0ZT1pbml0aWFsU3RhdGUoKTt9aG9vay5tZW1vaXplZFN0YXRlPWhvb2suYmFzZVN0YXRlPWluaXRpYWxTdGF0ZTt2YXIgcXVldWU9e3BlbmRpbmc6bnVsbCxpbnRlcmxlYXZlZDpudWxsLGxhbmVzOk5vTGFuZXMsZGlzcGF0Y2g6bnVsbCxsYXN0UmVuZGVyZWRSZWR1Y2VyOmJhc2ljU3RhdGVSZWR1Y2VyLGxhc3RSZW5kZXJlZFN0YXRlOmluaXRpYWxTdGF0ZX07aG9vay5xdWV1ZT1xdWV1ZTt2YXIgZGlzcGF0Y2g9cXVldWUuZGlzcGF0Y2g9ZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKG51bGwsY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxxdWV1ZSk7cmV0dXJuW2hvb2subWVtb2l6ZWRTdGF0ZSxkaXNwYXRjaF07fWZ1bmN0aW9uIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSl7cmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO31mdW5jdGlvbiByZXJlbmRlclN0YXRlKGluaXRpYWxTdGF0ZSl7cmV0dXJuIHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7fWZ1bmN0aW9uIHB1c2hFZmZlY3QodGFnLGNyZWF0ZSxkZXN0cm95LGRlcHMpe3ZhciBlZmZlY3Q9e3RhZzp0YWcsY3JlYXRlOmNyZWF0ZSxkZXN0cm95OmRlc3Ryb3ksZGVwczpkZXBzLC8vIENpcmN1bGFyXG5uZXh0Om51bGx9O3ZhciBjb21wb25lbnRVcGRhdGVRdWV1ZT1jdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO2lmKGNvbXBvbmVudFVwZGF0ZVF1ZXVlPT09bnVsbCl7Y29tcG9uZW50VXBkYXRlUXVldWU9Y3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpO2N1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU9Y29tcG9uZW50VXBkYXRlUXVldWU7Y29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdD1lZmZlY3QubmV4dD1lZmZlY3Q7fWVsc2V7dmFyIGxhc3RFZmZlY3Q9Y29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdDtpZihsYXN0RWZmZWN0PT09bnVsbCl7Y29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdD1lZmZlY3QubmV4dD1lZmZlY3Q7fWVsc2V7dmFyIGZpcnN0RWZmZWN0PWxhc3RFZmZlY3QubmV4dDtsYXN0RWZmZWN0Lm5leHQ9ZWZmZWN0O2VmZmVjdC5uZXh0PWZpcnN0RWZmZWN0O2NvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q9ZWZmZWN0O319cmV0dXJuIGVmZmVjdDt9ZnVuY3Rpb24gbW91bnRSZWYoaW5pdGlhbFZhbHVlKXt2YXIgaG9vaz1tb3VudFdvcmtJblByb2dyZXNzSG9vaygpO3t2YXIgX3JlZjI9e2N1cnJlbnQ6aW5pdGlhbFZhbHVlfTtob29rLm1lbW9pemVkU3RhdGU9X3JlZjI7cmV0dXJuIF9yZWYyO319ZnVuY3Rpb24gdXBkYXRlUmVmKGluaXRpYWxWYWx1ZSl7dmFyIGhvb2s9dXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7cmV0dXJuIGhvb2subWVtb2l6ZWRTdGF0ZTt9ZnVuY3Rpb24gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsaG9va0ZsYWdzLGNyZWF0ZSxkZXBzKXt2YXIgaG9vaz1tb3VudFdvcmtJblByb2dyZXNzSG9vaygpO3ZhciBuZXh0RGVwcz1kZXBzPT09dW5kZWZpbmVkP251bGw6ZGVwcztjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzfD1maWJlckZsYWdzO2hvb2subWVtb2l6ZWRTdGF0ZT1wdXNoRWZmZWN0KEhhc0VmZmVjdHxob29rRmxhZ3MsY3JlYXRlLHVuZGVmaW5lZCxuZXh0RGVwcyk7fWZ1bmN0aW9uIHVwZGF0ZUVmZmVjdEltcGwoZmliZXJGbGFncyxob29rRmxhZ3MsY3JlYXRlLGRlcHMpe3ZhciBob29rPXVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO3ZhciBuZXh0RGVwcz1kZXBzPT09dW5kZWZpbmVkP251bGw6ZGVwczt2YXIgZGVzdHJveT11bmRlZmluZWQ7aWYoY3VycmVudEhvb2shPT1udWxsKXt2YXIgcHJldkVmZmVjdD1jdXJyZW50SG9vay5tZW1vaXplZFN0YXRlO2Rlc3Ryb3k9cHJldkVmZmVjdC5kZXN0cm95O2lmKG5leHREZXBzIT09bnVsbCl7dmFyIHByZXZEZXBzPXByZXZFZmZlY3QuZGVwcztpZihhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMscHJldkRlcHMpKXtob29rLm1lbW9pemVkU3RhdGU9cHVzaEVmZmVjdChob29rRmxhZ3MsY3JlYXRlLGRlc3Ryb3ksbmV4dERlcHMpO3JldHVybjt9fX1jdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzfD1maWJlckZsYWdzO2hvb2subWVtb2l6ZWRTdGF0ZT1wdXNoRWZmZWN0KEhhc0VmZmVjdHxob29rRmxhZ3MsY3JlYXRlLGRlc3Ryb3ksbmV4dERlcHMpO31mdW5jdGlvbiBtb3VudEVmZmVjdChjcmVhdGUsZGVwcyl7aWYoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSZTdHJpY3RFZmZlY3RzTW9kZSkhPT1Ob01vZGUpe3JldHVybiBtb3VudEVmZmVjdEltcGwoTW91bnRQYXNzaXZlRGV2fFBhc3NpdmV8UGFzc2l2ZVN0YXRpYyxQYXNzaXZlJDEsY3JlYXRlLGRlcHMpO31lbHNle3JldHVybiBtb3VudEVmZmVjdEltcGwoUGFzc2l2ZXxQYXNzaXZlU3RhdGljLFBhc3NpdmUkMSxjcmVhdGUsZGVwcyk7fX1mdW5jdGlvbiB1cGRhdGVFZmZlY3QoY3JlYXRlLGRlcHMpe3JldHVybiB1cGRhdGVFZmZlY3RJbXBsKFBhc3NpdmUsUGFzc2l2ZSQxLGNyZWF0ZSxkZXBzKTt9ZnVuY3Rpb24gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLGRlcHMpe3JldHVybiBtb3VudEVmZmVjdEltcGwoVXBkYXRlLEluc2VydGlvbixjcmVhdGUsZGVwcyk7fWZ1bmN0aW9uIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsZGVwcyl7cmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoVXBkYXRlLEluc2VydGlvbixjcmVhdGUsZGVwcyk7fWZ1bmN0aW9uIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSxkZXBzKXt2YXIgZmliZXJGbGFncz1VcGRhdGU7e2ZpYmVyRmxhZ3N8PUxheW91dFN0YXRpYzt9aWYoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSZTdHJpY3RFZmZlY3RzTW9kZSkhPT1Ob01vZGUpe2ZpYmVyRmxhZ3N8PU1vdW50TGF5b3V0RGV2O31yZXR1cm4gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsTGF5b3V0LGNyZWF0ZSxkZXBzKTt9ZnVuY3Rpb24gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSxkZXBzKXtyZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsTGF5b3V0LGNyZWF0ZSxkZXBzKTt9ZnVuY3Rpb24gaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdChjcmVhdGUscmVmKXtpZih0eXBlb2YgcmVmPT09J2Z1bmN0aW9uJyl7dmFyIHJlZkNhbGxiYWNrPXJlZjt2YXIgX2luc3Q9Y3JlYXRlKCk7cmVmQ2FsbGJhY2soX2luc3QpO3JldHVybiBmdW5jdGlvbigpe3JlZkNhbGxiYWNrKG51bGwpO307fWVsc2UgaWYocmVmIT09bnVsbCYmcmVmIT09dW5kZWZpbmVkKXt2YXIgcmVmT2JqZWN0PXJlZjt7aWYoIXJlZk9iamVjdC5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKXtlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIGZpcnN0IGFyZ3VtZW50IHRvIGVpdGhlciBiZSBhICcrJ3JlZiBjYWxsYmFjayBvciBSZWFjdC5jcmVhdGVSZWYoKSBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsJ2FuIG9iamVjdCB3aXRoIGtleXMgeycrT2JqZWN0LmtleXMocmVmT2JqZWN0KS5qb2luKCcsICcpKyd9Jyk7fX12YXIgX2luc3QyPWNyZWF0ZSgpO3JlZk9iamVjdC5jdXJyZW50PV9pbnN0MjtyZXR1cm4gZnVuY3Rpb24oKXtyZWZPYmplY3QuY3VycmVudD1udWxsO307fX1mdW5jdGlvbiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLGNyZWF0ZSxkZXBzKXt7aWYodHlwZW9mIGNyZWF0ZSE9PSdmdW5jdGlvbicpe2Vycm9yKCdFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24gJysndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLGNyZWF0ZSE9PW51bGw/dHlwZW9mIGNyZWF0ZTonbnVsbCcpO319Ly8gVE9ETzogSWYgZGVwcyBhcmUgcHJvdmlkZWQsIHNob3VsZCB3ZSBza2lwIGNvbXBhcmluZyB0aGUgcmVmIGl0c2VsZj9cbnZhciBlZmZlY3REZXBzPWRlcHMhPT1udWxsJiZkZXBzIT09dW5kZWZpbmVkP2RlcHMuY29uY2F0KFtyZWZdKTpudWxsO3ZhciBmaWJlckZsYWdzPVVwZGF0ZTt7ZmliZXJGbGFnc3w9TGF5b3V0U3RhdGljO31pZigoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlJlN0cmljdEVmZmVjdHNNb2RlKSE9PU5vTW9kZSl7ZmliZXJGbGFnc3w9TW91bnRMYXlvdXREZXY7fXJldHVybiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncyxMYXlvdXQsaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsY3JlYXRlLHJlZiksZWZmZWN0RGVwcyk7fWZ1bmN0aW9uIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLGNyZWF0ZSxkZXBzKXt7aWYodHlwZW9mIGNyZWF0ZSE9PSdmdW5jdGlvbicpe2Vycm9yKCdFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24gJysndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLGNyZWF0ZSE9PW51bGw/dHlwZW9mIGNyZWF0ZTonbnVsbCcpO319Ly8gVE9ETzogSWYgZGVwcyBhcmUgcHJvdmlkZWQsIHNob3VsZCB3ZSBza2lwIGNvbXBhcmluZyB0aGUgcmVmIGl0c2VsZj9cbnZhciBlZmZlY3REZXBzPWRlcHMhPT1udWxsJiZkZXBzIT09dW5kZWZpbmVkP2RlcHMuY29uY2F0KFtyZWZdKTpudWxsO3JldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSxMYXlvdXQsaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsY3JlYXRlLHJlZiksZWZmZWN0RGVwcyk7fWZ1bmN0aW9uIG1vdW50RGVidWdWYWx1ZSh2YWx1ZSxmb3JtYXR0ZXJGbil7Ly8gVGhpcyBob29rIGlzIG5vcm1hbGx5IGEgbm8tb3AuXG4vLyBUaGUgcmVhY3QtZGVidWctaG9va3MgcGFja2FnZSBpbmplY3RzIGl0cyBvd24gaW1wbGVtZW50YXRpb25cbi8vIHNvIHRoYXQgZS5nLiBEZXZUb29scyBjYW4gZGlzcGxheSBjdXN0b20gaG9vayB2YWx1ZXMuXG59dmFyIHVwZGF0ZURlYnVnVmFsdWU9bW91bnREZWJ1Z1ZhbHVlO2Z1bmN0aW9uIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssZGVwcyl7dmFyIGhvb2s9bW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTt2YXIgbmV4dERlcHM9ZGVwcz09PXVuZGVmaW5lZD9udWxsOmRlcHM7aG9vay5tZW1vaXplZFN0YXRlPVtjYWxsYmFjayxuZXh0RGVwc107cmV0dXJuIGNhbGxiYWNrO31mdW5jdGlvbiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjayxkZXBzKXt2YXIgaG9vaz11cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTt2YXIgbmV4dERlcHM9ZGVwcz09PXVuZGVmaW5lZD9udWxsOmRlcHM7dmFyIHByZXZTdGF0ZT1ob29rLm1lbW9pemVkU3RhdGU7aWYocHJldlN0YXRlIT09bnVsbCl7aWYobmV4dERlcHMhPT1udWxsKXt2YXIgcHJldkRlcHM9cHJldlN0YXRlWzFdO2lmKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcyxwcmV2RGVwcykpe3JldHVybiBwcmV2U3RhdGVbMF07fX19aG9vay5tZW1vaXplZFN0YXRlPVtjYWxsYmFjayxuZXh0RGVwc107cmV0dXJuIGNhbGxiYWNrO31mdW5jdGlvbiBtb3VudE1lbW8obmV4dENyZWF0ZSxkZXBzKXt2YXIgaG9vaz1tb3VudFdvcmtJblByb2dyZXNzSG9vaygpO3ZhciBuZXh0RGVwcz1kZXBzPT09dW5kZWZpbmVkP251bGw6ZGVwczt2YXIgbmV4dFZhbHVlPW5leHRDcmVhdGUoKTtob29rLm1lbW9pemVkU3RhdGU9W25leHRWYWx1ZSxuZXh0RGVwc107cmV0dXJuIG5leHRWYWx1ZTt9ZnVuY3Rpb24gdXBkYXRlTWVtbyhuZXh0Q3JlYXRlLGRlcHMpe3ZhciBob29rPXVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO3ZhciBuZXh0RGVwcz1kZXBzPT09dW5kZWZpbmVkP251bGw6ZGVwczt2YXIgcHJldlN0YXRlPWhvb2subWVtb2l6ZWRTdGF0ZTtpZihwcmV2U3RhdGUhPT1udWxsKXsvLyBBc3N1bWUgdGhlc2UgYXJlIGRlZmluZWQuIElmIHRoZXkncmUgbm90LCBhcmVIb29rSW5wdXRzRXF1YWwgd2lsbCB3YXJuLlxuaWYobmV4dERlcHMhPT1udWxsKXt2YXIgcHJldkRlcHM9cHJldlN0YXRlWzFdO2lmKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcyxwcmV2RGVwcykpe3JldHVybiBwcmV2U3RhdGVbMF07fX19dmFyIG5leHRWYWx1ZT1uZXh0Q3JlYXRlKCk7aG9vay5tZW1vaXplZFN0YXRlPVtuZXh0VmFsdWUsbmV4dERlcHNdO3JldHVybiBuZXh0VmFsdWU7fWZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSl7dmFyIGhvb2s9bW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtob29rLm1lbW9pemVkU3RhdGU9dmFsdWU7cmV0dXJuIHZhbHVlO31mdW5jdGlvbiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlKXt2YXIgaG9vaz11cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTt2YXIgcmVzb2x2ZWRDdXJyZW50SG9vaz1jdXJyZW50SG9vazt2YXIgcHJldlZhbHVlPXJlc29sdmVkQ3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZTtyZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoaG9vayxwcmV2VmFsdWUsdmFsdWUpO31mdW5jdGlvbiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUpe3ZhciBob29rPXVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO2lmKGN1cnJlbnRIb29rPT09bnVsbCl7Ly8gVGhpcyBpcyBhIHJlcmVuZGVyIGR1cmluZyBhIG1vdW50LlxuaG9vay5tZW1vaXplZFN0YXRlPXZhbHVlO3JldHVybiB2YWx1ZTt9ZWxzZXsvLyBUaGlzIGlzIGEgcmVyZW5kZXIgZHVyaW5nIGFuIHVwZGF0ZS5cbnZhciBwcmV2VmFsdWU9Y3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZTtyZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoaG9vayxwcmV2VmFsdWUsdmFsdWUpO319ZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoaG9vayxwcmV2VmFsdWUsdmFsdWUpe3ZhciBzaG91bGREZWZlclZhbHVlPSFpbmNsdWRlc09ubHlOb25VcmdlbnRMYW5lcyhyZW5kZXJMYW5lcyk7aWYoc2hvdWxkRGVmZXJWYWx1ZSl7Ly8gVGhpcyBpcyBhbiB1cmdlbnQgdXBkYXRlLiBJZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIGtlZXAgdXNpbmcgdGhlXG4vLyBwcmV2aW91cyB2YWx1ZSBhbmQgc3Bhd24gYSBkZWZlcnJlZCByZW5kZXIgdG8gdXBkYXRlIGl0IGxhdGVyLlxuaWYoIW9iamVjdElzKHZhbHVlLHByZXZWYWx1ZSkpey8vIFNjaGVkdWxlIGEgZGVmZXJyZWQgcmVuZGVyXG52YXIgZGVmZXJyZWRMYW5lPWNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCk7Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcz1tZXJnZUxhbmVzKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMsZGVmZXJyZWRMYW5lKTttYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKGRlZmVycmVkTGFuZSk7Ly8gU2V0IHRoaXMgdG8gdHJ1ZSB0byBpbmRpY2F0ZSB0aGF0IHRoZSByZW5kZXJlZCB2YWx1ZSBpcyBpbmNvbnNpc3RlbnRcbi8vIGZyb20gdGhlIGxhdGVzdCB2YWx1ZS4gVGhlIG5hbWUgXCJiYXNlU3RhdGVcIiBkb2Vzbid0IHJlYWxseSBtYXRjaCBob3cgd2Vcbi8vIHVzZSBpdCBiZWNhdXNlIHdlJ3JlIHJldXNpbmcgYSBzdGF0ZSBob29rIGZpZWxkIGluc3RlYWQgb2YgY3JlYXRpbmcgYVxuLy8gbmV3IG9uZS5cbmhvb2suYmFzZVN0YXRlPXRydWU7fS8vIFJldXNlIHRoZSBwcmV2aW91cyB2YWx1ZVxucmV0dXJuIHByZXZWYWx1ZTt9ZWxzZXsvLyBUaGlzIGlzIG5vdCBhbiB1cmdlbnQgdXBkYXRlLCBzbyB3ZSBjYW4gdXNlIHRoZSBsYXRlc3QgdmFsdWUgcmVnYXJkbGVzc1xuLy8gb2Ygd2hhdCBpdCBpcy4gTm8gbmVlZCB0byBkZWZlciBpdC5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBzcGF3bmVkIHJlbmRlciwgdGhlbiB3ZSBuZWVkIHRvIG1hcmtcbi8vIHRoaXMgYXMgYW4gdXBkYXRlIHRvIHByZXZlbnQgdGhlIGZpYmVyIGZyb20gYmFpbGluZyBvdXQuXG4vL1xuLy8gYGJhc2VTdGF0ZWAgaXMgdHJ1ZSB3aGVuIHRoZSBjdXJyZW50IHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tIHRoZSByZW5kZXJlZFxuLy8gdmFsdWUuIFRoZSBuYW1lIGRvZXNuJ3QgcmVhbGx5IG1hdGNoIGhvdyB3ZSB1c2UgaXQgYmVjYXVzZSB3ZSdyZSByZXVzaW5nXG4vLyBhIHN0YXRlIGhvb2sgZmllbGQgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvbmUuXG5pZihob29rLmJhc2VTdGF0ZSl7Ly8gRmxpcCB0aGlzIGJhY2sgdG8gZmFsc2UuXG5ob29rLmJhc2VTdGF0ZT1mYWxzZTttYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO31ob29rLm1lbW9pemVkU3RhdGU9dmFsdWU7cmV0dXJuIHZhbHVlO319ZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKHNldFBlbmRpbmcsY2FsbGJhY2ssb3B0aW9ucyl7dmFyIHByZXZpb3VzUHJpb3JpdHk9Z2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KGhpZ2hlckV2ZW50UHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSxDb250aW51b3VzRXZlbnRQcmlvcml0eSkpO3NldFBlbmRpbmcodHJ1ZSk7dmFyIHByZXZUcmFuc2l0aW9uPVJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbjtSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb249e307dmFyIGN1cnJlbnRUcmFuc2l0aW9uPVJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbjt7UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzPW5ldyBTZXQoKTt9dHJ5e3NldFBlbmRpbmcoZmFsc2UpO2NhbGxiYWNrKCk7fWZpbmFsbHl7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbj1wcmV2VHJhbnNpdGlvbjt7aWYocHJldlRyYW5zaXRpb249PT1udWxsJiZjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyl7dmFyIHVwZGF0ZWRGaWJlcnNDb3VudD1jdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5zaXplO2lmKHVwZGF0ZWRGaWJlcnNDb3VudD4xMCl7d2FybignRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiAnKydJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiAnKydPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuJyk7fWN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCk7fX19fWZ1bmN0aW9uIG1vdW50VHJhbnNpdGlvbigpe3ZhciBfbW91bnRTdGF0ZT1tb3VudFN0YXRlKGZhbHNlKSxpc1BlbmRpbmc9X21vdW50U3RhdGVbMF0sc2V0UGVuZGluZz1fbW91bnRTdGF0ZVsxXTsvLyBUaGUgYHN0YXJ0YCBtZXRob2QgbmV2ZXIgY2hhbmdlcy5cbnZhciBzdGFydD1zdGFydFRyYW5zaXRpb24uYmluZChudWxsLHNldFBlbmRpbmcpO3ZhciBob29rPW1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7aG9vay5tZW1vaXplZFN0YXRlPXN0YXJ0O3JldHVybltpc1BlbmRpbmcsc3RhcnRdO31mdW5jdGlvbiB1cGRhdGVUcmFuc2l0aW9uKCl7dmFyIF91cGRhdGVTdGF0ZT11cGRhdGVTdGF0ZSgpLGlzUGVuZGluZz1fdXBkYXRlU3RhdGVbMF07dmFyIGhvb2s9dXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7dmFyIHN0YXJ0PWhvb2subWVtb2l6ZWRTdGF0ZTtyZXR1cm5baXNQZW5kaW5nLHN0YXJ0XTt9ZnVuY3Rpb24gcmVyZW5kZXJUcmFuc2l0aW9uKCl7dmFyIF9yZXJlbmRlclN0YXRlPXJlcmVuZGVyU3RhdGUoKSxpc1BlbmRpbmc9X3JlcmVuZGVyU3RhdGVbMF07dmFyIGhvb2s9dXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7dmFyIHN0YXJ0PWhvb2subWVtb2l6ZWRTdGF0ZTtyZXR1cm5baXNQZW5kaW5nLHN0YXJ0XTt9dmFyIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2U9ZmFsc2U7ZnVuY3Rpb24gZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWKCl7e3JldHVybiBpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlO319ZnVuY3Rpb24gbW91bnRJZCgpe3ZhciBob29rPW1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7dmFyIHJvb3Q9Z2V0V29ya0luUHJvZ3Jlc3NSb290KCk7Ly8gVE9ETzogSW4gRml6eiwgaWQgZ2VuZXJhdGlvbiBpcyBzcGVjaWZpYyB0byBlYWNoIHNlcnZlciBjb25maWcuIE1heWJlIHdlXG4vLyBzaG91bGQgZG8gdGhpcyBpbiBGaWJlciwgdG9vPyBEZWZlcnJpbmcgdGhpcyBkZWNpc2lvbiBmb3Igbm93IGJlY2F1c2Vcbi8vIHRoZXJlJ3Mgbm8gb3RoZXIgcGxhY2UgdG8gc3RvcmUgdGhlIHByZWZpeCBleGNlcHQgZm9yIGFuIGludGVybmFsIGZpZWxkIG9uXG4vLyB0aGUgcHVibGljIGNyZWF0ZVJvb3Qgb2JqZWN0LCB3aGljaCB0aGUgZmliZXIgdHJlZSBkb2VzIG5vdCBjdXJyZW50bHkgaGF2ZVxuLy8gYSByZWZlcmVuY2UgdG8uXG52YXIgaWRlbnRpZmllclByZWZpeD1yb290LmlkZW50aWZpZXJQcmVmaXg7dmFyIGlkO2lmKGdldElzSHlkcmF0aW5nKCkpe3ZhciB0cmVlSWQ9Z2V0VHJlZUlkKCk7Ly8gVXNlIGEgY2FwdGlhbCBSIHByZWZpeCBmb3Igc2VydmVyLWdlbmVyYXRlZCBpZHMuXG5pZD0nOicraWRlbnRpZmllclByZWZpeCsnUicrdHJlZUlkOy8vIFVubGVzcyB0aGlzIGlzIHRoZSBmaXJzdCBpZCBhdCB0aGlzIGxldmVsLCBhcHBlbmQgYSBudW1iZXIgYXQgdGhlIGVuZFxuLy8gdGhhdCByZXByZXNlbnRzIHRoZSBwb3NpdGlvbiBvZiB0aGlzIHVzZUlkIGhvb2sgYW1vbmcgYWxsIHRoZSB1c2VJZFxuLy8gaG9va3MgZm9yIHRoaXMgZmliZXIuXG52YXIgbG9jYWxJZD1sb2NhbElkQ291bnRlcisrO2lmKGxvY2FsSWQ+MCl7aWQrPSdIJytsb2NhbElkLnRvU3RyaW5nKDMyKTt9aWQrPSc6Jzt9ZWxzZXsvLyBVc2UgYSBsb3dlcmNhc2UgciBwcmVmaXggZm9yIGNsaWVudC1nZW5lcmF0ZWQgaWRzLlxudmFyIGdsb2JhbENsaWVudElkPWdsb2JhbENsaWVudElkQ291bnRlcisrO2lkPSc6JytpZGVudGlmaWVyUHJlZml4KydyJytnbG9iYWxDbGllbnRJZC50b1N0cmluZygzMikrJzonO31ob29rLm1lbW9pemVkU3RhdGU9aWQ7cmV0dXJuIGlkO31mdW5jdGlvbiB1cGRhdGVJZCgpe3ZhciBob29rPXVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO3ZhciBpZD1ob29rLm1lbW9pemVkU3RhdGU7cmV0dXJuIGlkO31mdW5jdGlvbiBkaXNwYXRjaFJlZHVjZXJBY3Rpb24oZmliZXIscXVldWUsYWN0aW9uKXt7aWYodHlwZW9mIGFyZ3VtZW50c1szXT09PSdmdW5jdGlvbicpe2Vycm9yKFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgXCIrJ3NlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyICcrJ3JlbmRlcmluZywgZGVjbGFyZSBpdCBpbiB0aGUgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTt9fXZhciBsYW5lPXJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTt2YXIgdXBkYXRlPXtsYW5lOmxhbmUsYWN0aW9uOmFjdGlvbixoYXNFYWdlclN0YXRlOmZhbHNlLGVhZ2VyU3RhdGU6bnVsbCxuZXh0Om51bGx9O2lmKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKXtlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsdXBkYXRlKTt9ZWxzZXt2YXIgcm9vdD1lbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIscXVldWUsdXBkYXRlLGxhbmUpO2lmKHJvb3QhPT1udWxsKXt2YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxmaWJlcixsYW5lLGV2ZW50VGltZSk7ZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QscXVldWUsbGFuZSk7fX1tYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlcixsYW5lKTt9ZnVuY3Rpb24gZGlzcGF0Y2hTZXRTdGF0ZShmaWJlcixxdWV1ZSxhY3Rpb24pe3tpZih0eXBlb2YgYXJndW1lbnRzWzNdPT09J2Z1bmN0aW9uJyl7ZXJyb3IoXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBcIisnc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgJysncmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO319dmFyIGxhbmU9cmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO3ZhciB1cGRhdGU9e2xhbmU6bGFuZSxhY3Rpb246YWN0aW9uLGhhc0VhZ2VyU3RhdGU6ZmFsc2UsZWFnZXJTdGF0ZTpudWxsLG5leHQ6bnVsbH07aWYoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpe2VucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSx1cGRhdGUpO31lbHNle3ZhciBhbHRlcm5hdGU9ZmliZXIuYWx0ZXJuYXRlO2lmKGZpYmVyLmxhbmVzPT09Tm9MYW5lcyYmKGFsdGVybmF0ZT09PW51bGx8fGFsdGVybmF0ZS5sYW5lcz09PU5vTGFuZXMpKXsvLyBUaGUgcXVldWUgaXMgY3VycmVudGx5IGVtcHR5LCB3aGljaCBtZWFucyB3ZSBjYW4gZWFnZXJseSBjb21wdXRlIHRoZVxuLy8gbmV4dCBzdGF0ZSBiZWZvcmUgZW50ZXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gSWYgdGhlIG5ldyBzdGF0ZSBpcyB0aGVcbi8vIHNhbWUgYXMgdGhlIGN1cnJlbnQgc3RhdGUsIHdlIG1heSBiZSBhYmxlIHRvIGJhaWwgb3V0IGVudGlyZWx5LlxudmFyIGxhc3RSZW5kZXJlZFJlZHVjZXI9cXVldWUubGFzdFJlbmRlcmVkUmVkdWNlcjtpZihsYXN0UmVuZGVyZWRSZWR1Y2VyIT09bnVsbCl7dmFyIHByZXZEaXNwYXRjaGVyO3twcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjt9dHJ5e3ZhciBjdXJyZW50U3RhdGU9cXVldWUubGFzdFJlbmRlcmVkU3RhdGU7dmFyIGVhZ2VyU3RhdGU9bGFzdFJlbmRlcmVkUmVkdWNlcihjdXJyZW50U3RhdGUsYWN0aW9uKTsvLyBTdGFzaCB0aGUgZWFnZXJseSBjb21wdXRlZCBzdGF0ZSwgYW5kIHRoZSByZWR1Y2VyIHVzZWQgdG8gY29tcHV0ZVxuLy8gaXQsIG9uIHRoZSB1cGRhdGUgb2JqZWN0LiBJZiB0aGUgcmVkdWNlciBoYXNuJ3QgY2hhbmdlZCBieSB0aGVcbi8vIHRpbWUgd2UgZW50ZXIgdGhlIHJlbmRlciBwaGFzZSwgdGhlbiB0aGUgZWFnZXIgc3RhdGUgY2FuIGJlIHVzZWRcbi8vIHdpdGhvdXQgY2FsbGluZyB0aGUgcmVkdWNlciBhZ2Fpbi5cbnVwZGF0ZS5oYXNFYWdlclN0YXRlPXRydWU7dXBkYXRlLmVhZ2VyU3RhdGU9ZWFnZXJTdGF0ZTtpZihvYmplY3RJcyhlYWdlclN0YXRlLGN1cnJlbnRTdGF0ZSkpey8vIEZhc3QgcGF0aC4gV2UgY2FuIGJhaWwgb3V0IHdpdGhvdXQgc2NoZWR1bGluZyBSZWFjdCB0byByZS1yZW5kZXIuXG4vLyBJdCdzIHN0aWxsIHBvc3NpYmxlIHRoYXQgd2UnbGwgbmVlZCB0byByZWJhc2UgdGhpcyB1cGRhdGUgbGF0ZXIsXG4vLyBpZiB0aGUgY29tcG9uZW50IHJlLXJlbmRlcnMgZm9yIGEgZGlmZmVyZW50IHJlYXNvbiBhbmQgYnkgdGhhdFxuLy8gdGltZSB0aGUgcmVkdWNlciBoYXMgY2hhbmdlZC5cbi8vIFRPRE86IERvIHdlIHN0aWxsIG5lZWQgdG8gZW50YW5nbGUgdHJhbnNpdGlvbnMgaW4gdGhpcyBjYXNlP1xuZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlQW5kRWFnZXJseUJhaWxvdXQoZmliZXIscXVldWUsdXBkYXRlLGxhbmUpO3JldHVybjt9fWNhdGNoKGVycm9yKXsvLyBTdXBwcmVzcyB0aGUgZXJyb3IuIEl0IHdpbGwgdGhyb3cgYWdhaW4gaW4gdGhlIHJlbmRlciBwaGFzZS5cbn1maW5hbGx5e3tSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fX19dmFyIHJvb3Q9ZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLHF1ZXVlLHVwZGF0ZSxsYW5lKTtpZihyb290IT09bnVsbCl7dmFyIGV2ZW50VGltZT1yZXF1ZXN0RXZlbnRUaW1lKCk7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsbGFuZSxldmVudFRpbWUpO2VudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LHF1ZXVlLGxhbmUpO319bWFya1VwZGF0ZUluRGV2VG9vbHMoZmliZXIsbGFuZSk7fWZ1bmN0aW9uIGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpe3ZhciBhbHRlcm5hdGU9ZmliZXIuYWx0ZXJuYXRlO3JldHVybiBmaWJlcj09PWN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDF8fGFsdGVybmF0ZSE9PW51bGwmJmFsdGVybmF0ZT09PWN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7fWZ1bmN0aW9uIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSx1cGRhdGUpey8vIFRoaXMgaXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlLiBTdGFzaCBpdCBpbiBhIGxhemlseS1jcmVhdGVkIG1hcCBvZlxuLy8gcXVldWUgLT4gbGlua2VkIGxpc3Qgb2YgdXBkYXRlcy4gQWZ0ZXIgdGhpcyByZW5kZXIgcGFzcywgd2UnbGwgcmVzdGFydFxuLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG5kaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3M9ZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZT10cnVlO3ZhciBwZW5kaW5nPXF1ZXVlLnBlbmRpbmc7aWYocGVuZGluZz09PW51bGwpey8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbnVwZGF0ZS5uZXh0PXVwZGF0ZTt9ZWxzZXt1cGRhdGUubmV4dD1wZW5kaW5nLm5leHQ7cGVuZGluZy5uZXh0PXVwZGF0ZTt9cXVldWUucGVuZGluZz11cGRhdGU7fS8vIFRPRE86IE1vdmUgdG8gUmVhY3RGaWJlckNvbmN1cnJlbnRVcGRhdGVzP1xuZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QscXVldWUsbGFuZSl7aWYoaXNUcmFuc2l0aW9uTGFuZShsYW5lKSl7dmFyIHF1ZXVlTGFuZXM9cXVldWUubGFuZXM7Ly8gSWYgYW55IGVudGFuZ2xlZCBsYW5lcyBhcmUgbm8gbG9uZ2VyIHBlbmRpbmcgb24gdGhlIHJvb3QsIHRoZW4gdGhleVxuLy8gbXVzdCBoYXZlIGZpbmlzaGVkLiBXZSBjYW4gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc2hhcmVkIHF1ZXVlLCB3aGljaFxuLy8gcmVwcmVzZW50cyBhIHN1cGVyc2V0IG9mIHRoZSBhY3R1YWxseSBwZW5kaW5nIGxhbmVzLiBJbiBzb21lIGNhc2VzIHdlXG4vLyBtYXkgZW50YW5nbGUgbW9yZSB0aGFuIHdlIG5lZWQgdG8sIGJ1dCB0aGF0J3MgT0suIEluIGZhY3QgaXQncyB3b3JzZSBpZlxuLy8gd2UgKmRvbid0KiBlbnRhbmdsZSB3aGVuIHdlIHNob3VsZC5cbnF1ZXVlTGFuZXM9aW50ZXJzZWN0TGFuZXMocXVldWVMYW5lcyxyb290LnBlbmRpbmdMYW5lcyk7Ly8gRW50YW5nbGUgdGhlIG5ldyB0cmFuc2l0aW9uIGxhbmUgd2l0aCB0aGUgb3RoZXIgdHJhbnNpdGlvbiBsYW5lcy5cbnZhciBuZXdRdWV1ZUxhbmVzPW1lcmdlTGFuZXMocXVldWVMYW5lcyxsYW5lKTtxdWV1ZS5sYW5lcz1uZXdRdWV1ZUxhbmVzOy8vIEV2ZW4gaWYgcXVldWUubGFuZXMgYWxyZWFkeSBpbmNsdWRlIGxhbmUsIHdlIGRvbid0IGtub3cgZm9yIGNlcnRhaW4gaWZcbi8vIHRoZSBsYW5lIGZpbmlzaGVkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2UgZW50YW5nbGVkIGl0LiBTbyB3ZSBuZWVkIHRvXG4vLyBlbnRhbmdsZSBpdCBhZ2FpbiwganVzdCB0byBiZSBzdXJlLlxubWFya1Jvb3RFbnRhbmdsZWQocm9vdCxuZXdRdWV1ZUxhbmVzKTt9fWZ1bmN0aW9uIG1hcmtVcGRhdGVJbkRldlRvb2xzKGZpYmVyLGxhbmUsYWN0aW9uKXt7bWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLGxhbmUpO319dmFyIENvbnRleHRPbmx5RGlzcGF0Y2hlcj17cmVhZENvbnRleHQ6cmVhZENvbnRleHQsdXNlQ2FsbGJhY2s6dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVzZUNvbnRleHQ6dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVzZUVmZmVjdDp0aHJvd0ludmFsaWRIb29rRXJyb3IsdXNlSW1wZXJhdGl2ZUhhbmRsZTp0aHJvd0ludmFsaWRIb29rRXJyb3IsdXNlSW5zZXJ0aW9uRWZmZWN0OnRocm93SW52YWxpZEhvb2tFcnJvcix1c2VMYXlvdXRFZmZlY3Q6dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVzZU1lbW86dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVzZVJlZHVjZXI6dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVzZVJlZjp0aHJvd0ludmFsaWRIb29rRXJyb3IsdXNlU3RhdGU6dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVzZURlYnVnVmFsdWU6dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVzZURlZmVycmVkVmFsdWU6dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVzZVRyYW5zaXRpb246dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVzZU11dGFibGVTb3VyY2U6dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVzZVN5bmNFeHRlcm5hbFN0b3JlOnRocm93SW52YWxpZEhvb2tFcnJvcix1c2VJZDp0aHJvd0ludmFsaWRIb29rRXJyb3IsdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOmVuYWJsZU5ld1JlY29uY2lsZXJ9O3ZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY9bnVsbDt2YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVj1udWxsO3ZhciBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWPW51bGw7dmFyIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVj1udWxsO3ZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWPW51bGw7dmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWPW51bGw7dmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY9bnVsbDt7dmFyIHdhcm5JbnZhbGlkQ29udGV4dEFjY2Vzcz1mdW5jdGlvbigpe2Vycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnKydJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnKydJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJysnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTt9O3ZhciB3YXJuSW52YWxpZEhvb2tBY2Nlc3M9ZnVuY3Rpb24oKXtlcnJvcignRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiAnKydZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uICcrJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgJysnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyk7fTtIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY9e3JlYWRDb250ZXh0OmZ1bmN0aW9uKGNvbnRleHQpe3JldHVybiByZWFkQ29udGV4dChjb250ZXh0KTt9LHVzZUNhbGxiYWNrOmZ1bmN0aW9uKGNhbGxiYWNrLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VDYWxsYmFjayc7bW91bnRIb29rVHlwZXNEZXYoKTtjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtyZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjayxkZXBzKTt9LHVzZUNvbnRleHQ6ZnVuY3Rpb24oY29udGV4dCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUNvbnRleHQnO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO30sdXNlRWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRWZmZWN0Jzttb3VudEhvb2tUeXBlc0RldigpO2NoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO3JldHVybiBtb3VudEVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VJbXBlcmF0aXZlSGFuZGxlOmZ1bmN0aW9uKHJlZixjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUltcGVyYXRpdmVIYW5kbGUnO21vdW50SG9va1R5cGVzRGV2KCk7Y2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7cmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsY3JlYXRlLGRlcHMpO30sdXNlSW5zZXJ0aW9uRWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSW5zZXJ0aW9uRWZmZWN0Jzttb3VudEhvb2tUeXBlc0RldigpO2NoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO3JldHVybiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VMYXlvdXRFZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VMYXlvdXRFZmZlY3QnO21vdW50SG9va1R5cGVzRGV2KCk7Y2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7cmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZU1lbW86ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VNZW1vJzttb3VudEhvb2tUeXBlc0RldigpO2NoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO3RyeXtyZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSxkZXBzKTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VSZWR1Y2VyOmZ1bmN0aW9uKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlUmVkdWNlcic7bW91bnRIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjt0cnl7cmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlUmVmOmZ1bmN0aW9uKGluaXRpYWxWYWx1ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVJlZic7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTt9LHVzZVN0YXRlOmZ1bmN0aW9uKGluaXRpYWxTdGF0ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVN0YXRlJzttb3VudEhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO3RyeXtyZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZURlYnVnVmFsdWU6ZnVuY3Rpb24odmFsdWUsZm9ybWF0dGVyRm4pe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VEZWJ1Z1ZhbHVlJzttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudERlYnVnVmFsdWUoKTt9LHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24odmFsdWUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VEZWZlcnJlZFZhbHVlJzttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpO30sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VUcmFuc2l0aW9uJzttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudFRyYW5zaXRpb24oKTt9LHVzZU11dGFibGVTb3VyY2U6ZnVuY3Rpb24oc291cmNlLGdldFNuYXBzaG90LHN1YnNjcmliZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZU11dGFibGVTb3VyY2UnO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50TXV0YWJsZVNvdXJjZSgpO30sdXNlU3luY0V4dGVybmFsU3RvcmU6ZnVuY3Rpb24oc3Vic2NyaWJlLGdldFNuYXBzaG90LGdldFNlcnZlclNuYXBzaG90KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlU3luY0V4dGVybmFsU3RvcmUnO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLGdldFNuYXBzaG90LGdldFNlcnZlclNuYXBzaG90KTt9LHVzZUlkOmZ1bmN0aW9uKCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUlkJzttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudElkKCk7fSx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ZW5hYmxlTmV3UmVjb25jaWxlcn07SG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVj17cmVhZENvbnRleHQ6ZnVuY3Rpb24oY29udGV4dCl7cmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO30sdXNlQ2FsbGJhY2s6ZnVuY3Rpb24oY2FsbGJhY2ssZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUNhbGxiYWNrJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjayxkZXBzKTt9LHVzZUNvbnRleHQ6ZnVuY3Rpb24oY29udGV4dCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUNvbnRleHQnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiByZWFkQ29udGV4dChjb250ZXh0KTt9LHVzZUVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUVmZmVjdCc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZUltcGVyYXRpdmVIYW5kbGU6ZnVuY3Rpb24ocmVmLGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSW1wZXJhdGl2ZUhhbmRsZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsY3JlYXRlLGRlcHMpO30sdXNlSW5zZXJ0aW9uRWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSW5zZXJ0aW9uRWZmZWN0Jzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlTGF5b3V0RWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTGF5b3V0RWZmZWN0Jzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlTWVtbzpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZU1lbW8nO3VwZGF0ZUhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO3RyeXtyZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSxkZXBzKTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VSZWR1Y2VyOmZ1bmN0aW9uKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlUmVkdWNlcic7dXBkYXRlSG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7dHJ5e3JldHVybiBtb3VudFJlZHVjZXIocmVkdWNlcixpbml0aWFsQXJnLGluaXQpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZVJlZjpmdW5jdGlvbihpbml0aWFsVmFsdWUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VSZWYnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO30sdXNlU3RhdGU6ZnVuY3Rpb24oaW5pdGlhbFN0YXRlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlU3RhdGUnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO3RyeXtyZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZURlYnVnVmFsdWU6ZnVuY3Rpb24odmFsdWUsZm9ybWF0dGVyRm4pe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VEZWJ1Z1ZhbHVlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7fSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKHZhbHVlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRGVmZXJyZWRWYWx1ZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7fSx1c2VUcmFuc2l0aW9uOmZ1bmN0aW9uKCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVRyYW5zaXRpb24nO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudFRyYW5zaXRpb24oKTt9LHVzZU11dGFibGVTb3VyY2U6ZnVuY3Rpb24oc291cmNlLGdldFNuYXBzaG90LHN1YnNjcmliZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZU11dGFibGVTb3VyY2UnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudE11dGFibGVTb3VyY2UoKTt9LHVzZVN5bmNFeHRlcm5hbFN0b3JlOmZ1bmN0aW9uKHN1YnNjcmliZSxnZXRTbmFwc2hvdCxnZXRTZXJ2ZXJTbmFwc2hvdCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVN5bmNFeHRlcm5hbFN0b3JlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsZ2V0U25hcHNob3QsZ2V0U2VydmVyU25hcHNob3QpO30sdXNlSWQ6ZnVuY3Rpb24oKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSWQnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudElkKCk7fSx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ZW5hYmxlTmV3UmVjb25jaWxlcn07SG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVj17cmVhZENvbnRleHQ6ZnVuY3Rpb24oY29udGV4dCl7cmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO30sdXNlQ2FsbGJhY2s6ZnVuY3Rpb24oY2FsbGJhY2ssZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUNhbGxiYWNrJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssZGVwcyk7fSx1c2VDb250ZXh0OmZ1bmN0aW9uKGNvbnRleHQpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VDb250ZXh0Jzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7fSx1c2VFZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VFZmZlY3QnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlSW1wZXJhdGl2ZUhhbmRsZTpmdW5jdGlvbihyZWYsY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJbXBlcmF0aXZlSGFuZGxlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsY3JlYXRlLGRlcHMpO30sdXNlSW5zZXJ0aW9uRWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSW5zZXJ0aW9uRWZmZWN0Jzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZUxheW91dEVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUxheW91dEVmZmVjdCc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VNZW1vOmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTWVtbyc7dXBkYXRlSG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO3RyeXtyZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsZGVwcyk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlUmVkdWNlcjpmdW5jdGlvbihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVJlZHVjZXInO3VwZGF0ZUhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjt0cnl7cmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlcixpbml0aWFsQXJnLGluaXQpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZVJlZjpmdW5jdGlvbihpbml0aWFsVmFsdWUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VSZWYnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVSZWYoKTt9LHVzZVN0YXRlOmZ1bmN0aW9uKGluaXRpYWxTdGF0ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVN0YXRlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7dHJ5e3JldHVybiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZURlYnVnVmFsdWU6ZnVuY3Rpb24odmFsdWUsZm9ybWF0dGVyRm4pe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VEZWJ1Z1ZhbHVlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO30sdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbih2YWx1ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZURlZmVycmVkVmFsdWUnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlKTt9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlVHJhbnNpdGlvbic7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTt9LHVzZU11dGFibGVTb3VyY2U6ZnVuY3Rpb24oc291cmNlLGdldFNuYXBzaG90LHN1YnNjcmliZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZU11dGFibGVTb3VyY2UnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7fSx1c2VTeW5jRXh0ZXJuYWxTdG9yZTpmdW5jdGlvbihzdWJzY3JpYmUsZ2V0U25hcHNob3QsZ2V0U2VydmVyU25hcHNob3Qpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSxnZXRTbmFwc2hvdCk7fSx1c2VJZDpmdW5jdGlvbigpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJZCc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUlkKCk7fSx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ZW5hYmxlTmV3UmVjb25jaWxlcn07SG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWPXtyZWFkQ29udGV4dDpmdW5jdGlvbihjb250ZXh0KXtyZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7fSx1c2VDYWxsYmFjazpmdW5jdGlvbihjYWxsYmFjayxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlQ2FsbGJhY2snO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjayxkZXBzKTt9LHVzZUNvbnRleHQ6ZnVuY3Rpb24oY29udGV4dCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUNvbnRleHQnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiByZWFkQ29udGV4dChjb250ZXh0KTt9LHVzZUVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUVmZmVjdCc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VJbXBlcmF0aXZlSGFuZGxlOmZ1bmN0aW9uKHJlZixjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUltcGVyYXRpdmVIYW5kbGUnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZixjcmVhdGUsZGVwcyk7fSx1c2VJbnNlcnRpb25FZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJbnNlcnRpb25FZmZlY3QnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlTGF5b3V0RWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTGF5b3V0RWZmZWN0Jzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZU1lbW86ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VNZW1vJzt1cGRhdGVIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjt0cnl7cmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLGRlcHMpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZVJlZHVjZXI6ZnVuY3Rpb24ocmVkdWNlcixpbml0aWFsQXJnLGluaXQpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VSZWR1Y2VyJzt1cGRhdGVIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjt0cnl7cmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlUmVmOmZ1bmN0aW9uKGluaXRpYWxWYWx1ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVJlZic7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZVJlZigpO30sdXNlU3RhdGU6ZnVuY3Rpb24oaW5pdGlhbFN0YXRlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlU3RhdGUnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO3RyeXtyZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZURlYnVnVmFsdWU6ZnVuY3Rpb24odmFsdWUsZm9ybWF0dGVyRm4pe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VEZWJ1Z1ZhbHVlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO30sdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbih2YWx1ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZURlZmVycmVkVmFsdWUnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUpO30sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VUcmFuc2l0aW9uJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gcmVyZW5kZXJUcmFuc2l0aW9uKCk7fSx1c2VNdXRhYmxlU291cmNlOmZ1bmN0aW9uKHNvdXJjZSxnZXRTbmFwc2hvdCxzdWJzY3JpYmUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VNdXRhYmxlU291cmNlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZSgpO30sdXNlU3luY0V4dGVybmFsU3RvcmU6ZnVuY3Rpb24oc3Vic2NyaWJlLGdldFNuYXBzaG90LGdldFNlcnZlclNuYXBzaG90KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlU3luY0V4dGVybmFsU3RvcmUnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsZ2V0U25hcHNob3QpO30sdXNlSWQ6ZnVuY3Rpb24oKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSWQnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVJZCgpO30sdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOmVuYWJsZU5ld1JlY29uY2lsZXJ9O0ludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY9e3JlYWRDb250ZXh0OmZ1bmN0aW9uKGNvbnRleHQpe3dhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO3JldHVybiByZWFkQ29udGV4dChjb250ZXh0KTt9LHVzZUNhbGxiYWNrOmZ1bmN0aW9uKGNhbGxiYWNrLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VDYWxsYmFjayc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjayxkZXBzKTt9LHVzZUNvbnRleHQ6ZnVuY3Rpb24oY29udGV4dCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUNvbnRleHQnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO30sdXNlRWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRWZmZWN0Jzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudEVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VJbXBlcmF0aXZlSGFuZGxlOmZ1bmN0aW9uKHJlZixjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUltcGVyYXRpdmVIYW5kbGUnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsY3JlYXRlLGRlcHMpO30sdXNlSW5zZXJ0aW9uRWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSW5zZXJ0aW9uRWZmZWN0Jzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VMYXlvdXRFZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VMYXlvdXRFZmZlY3QnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZU1lbW86ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VNZW1vJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO3RyeXtyZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSxkZXBzKTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VSZWR1Y2VyOmZ1bmN0aW9uKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlUmVkdWNlcic7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjt0cnl7cmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlUmVmOmZ1bmN0aW9uKGluaXRpYWxWYWx1ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVJlZic7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTt9LHVzZVN0YXRlOmZ1bmN0aW9uKGluaXRpYWxTdGF0ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVN0YXRlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO3RyeXtyZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZURlYnVnVmFsdWU6ZnVuY3Rpb24odmFsdWUsZm9ybWF0dGVyRm4pe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VEZWJ1Z1ZhbHVlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudERlYnVnVmFsdWUoKTt9LHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24odmFsdWUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VEZWZlcnJlZFZhbHVlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpO30sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VUcmFuc2l0aW9uJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudFRyYW5zaXRpb24oKTt9LHVzZU11dGFibGVTb3VyY2U6ZnVuY3Rpb24oc291cmNlLGdldFNuYXBzaG90LHN1YnNjcmliZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZU11dGFibGVTb3VyY2UnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50TXV0YWJsZVNvdXJjZSgpO30sdXNlU3luY0V4dGVybmFsU3RvcmU6ZnVuY3Rpb24oc3Vic2NyaWJlLGdldFNuYXBzaG90LGdldFNlcnZlclNuYXBzaG90KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlU3luY0V4dGVybmFsU3RvcmUnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLGdldFNuYXBzaG90LGdldFNlcnZlclNuYXBzaG90KTt9LHVzZUlkOmZ1bmN0aW9uKCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUlkJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudElkKCk7fSx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ZW5hYmxlTmV3UmVjb25jaWxlcn07SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY9e3JlYWRDb250ZXh0OmZ1bmN0aW9uKGNvbnRleHQpe3dhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO3JldHVybiByZWFkQ29udGV4dChjb250ZXh0KTt9LHVzZUNhbGxiYWNrOmZ1bmN0aW9uKGNhbGxiYWNrLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VDYWxsYmFjayc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLGRlcHMpO30sdXNlQ29udGV4dDpmdW5jdGlvbihjb250ZXh0KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlQ29udGV4dCc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO30sdXNlRWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRWZmZWN0Jzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZUltcGVyYXRpdmVIYW5kbGU6ZnVuY3Rpb24ocmVmLGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSW1wZXJhdGl2ZUhhbmRsZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLGNyZWF0ZSxkZXBzKTt9LHVzZUluc2VydGlvbkVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUluc2VydGlvbkVmZmVjdCc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VMYXlvdXRFZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VMYXlvdXRFZmZlY3QnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlTWVtbzpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZU1lbW8nO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjt0cnl7cmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLGRlcHMpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZVJlZHVjZXI6ZnVuY3Rpb24ocmVkdWNlcixpbml0aWFsQXJnLGluaXQpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VSZWR1Y2VyJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7dHJ5e3JldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VSZWY6ZnVuY3Rpb24oaW5pdGlhbFZhbHVlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlUmVmJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlUmVmKCk7fSx1c2VTdGF0ZTpmdW5jdGlvbihpbml0aWFsU3RhdGUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VTdGF0ZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO3RyeXtyZXR1cm4gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VEZWJ1Z1ZhbHVlOmZ1bmN0aW9uKHZhbHVlLGZvcm1hdHRlckZuKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRGVidWdWYWx1ZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTt9LHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24odmFsdWUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VEZWZlcnJlZFZhbHVlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7fSx1c2VUcmFuc2l0aW9uOmZ1bmN0aW9uKCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVRyYW5zaXRpb24nO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7fSx1c2VNdXRhYmxlU291cmNlOmZ1bmN0aW9uKHNvdXJjZSxnZXRTbmFwc2hvdCxzdWJzY3JpYmUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VNdXRhYmxlU291cmNlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZSgpO30sdXNlU3luY0V4dGVybmFsU3RvcmU6ZnVuY3Rpb24oc3Vic2NyaWJlLGdldFNuYXBzaG90LGdldFNlcnZlclNuYXBzaG90KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlU3luY0V4dGVybmFsU3RvcmUnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsZ2V0U25hcHNob3QpO30sdXNlSWQ6ZnVuY3Rpb24oKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSWQnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVJZCgpO30sdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOmVuYWJsZU5ld1JlY29uY2lsZXJ9O0ludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY9e3JlYWRDb250ZXh0OmZ1bmN0aW9uKGNvbnRleHQpe3dhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO3JldHVybiByZWFkQ29udGV4dChjb250ZXh0KTt9LHVzZUNhbGxiYWNrOmZ1bmN0aW9uKGNhbGxiYWNrLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VDYWxsYmFjayc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLGRlcHMpO30sdXNlQ29udGV4dDpmdW5jdGlvbihjb250ZXh0KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlQ29udGV4dCc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO30sdXNlRWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRWZmZWN0Jzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZUltcGVyYXRpdmVIYW5kbGU6ZnVuY3Rpb24ocmVmLGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSW1wZXJhdGl2ZUhhbmRsZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLGNyZWF0ZSxkZXBzKTt9LHVzZUluc2VydGlvbkVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUluc2VydGlvbkVmZmVjdCc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VMYXlvdXRFZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VMYXlvdXRFZmZlY3QnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlTWVtbzpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZU1lbW8nO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjt0cnl7cmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLGRlcHMpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZVJlZHVjZXI6ZnVuY3Rpb24ocmVkdWNlcixpbml0aWFsQXJnLGluaXQpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VSZWR1Y2VyJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7dHJ5e3JldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlcixpbml0aWFsQXJnLGluaXQpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZVJlZjpmdW5jdGlvbihpbml0aWFsVmFsdWUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VSZWYnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVSZWYoKTt9LHVzZVN0YXRlOmZ1bmN0aW9uKGluaXRpYWxTdGF0ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVN0YXRlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7dHJ5e3JldHVybiByZXJlbmRlclN0YXRlKGluaXRpYWxTdGF0ZSk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlRGVidWdWYWx1ZTpmdW5jdGlvbih2YWx1ZSxmb3JtYXR0ZXJGbil7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZURlYnVnVmFsdWUnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7fSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKHZhbHVlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRGVmZXJyZWRWYWx1ZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7fSx1c2VUcmFuc2l0aW9uOmZ1bmN0aW9uKCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVRyYW5zaXRpb24nO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTt9LHVzZU11dGFibGVTb3VyY2U6ZnVuY3Rpb24oc291cmNlLGdldFNuYXBzaG90LHN1YnNjcmliZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZU11dGFibGVTb3VyY2UnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7fSx1c2VTeW5jRXh0ZXJuYWxTdG9yZTpmdW5jdGlvbihzdWJzY3JpYmUsZ2V0U25hcHNob3QsZ2V0U2VydmVyU25hcHNob3Qpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSxnZXRTbmFwc2hvdCk7fSx1c2VJZDpmdW5jdGlvbigpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJZCc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUlkKCk7fSx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ZW5hYmxlTmV3UmVjb25jaWxlcn07fXZhciBub3ckMT1TY2hlZHVsZXIudW5zdGFibGVfbm93O3ZhciBjb21taXRUaW1lPTA7dmFyIGxheW91dEVmZmVjdFN0YXJ0VGltZT0tMTt2YXIgcHJvZmlsZXJTdGFydFRpbWU9LTE7dmFyIHBhc3NpdmVFZmZlY3RTdGFydFRpbWU9LTE7LyoqXG4gKiBUcmFja3Mgd2hldGhlciB0aGUgY3VycmVudCB1cGRhdGUgd2FzIGEgbmVzdGVkL2Nhc2NhZGluZyB1cGRhdGUgKHNjaGVkdWxlZCBmcm9tIGEgbGF5b3V0IGVmZmVjdCkuXG4gKlxuICogVGhlIG92ZXJhbGwgc2VxdWVuY2UgaXM6XG4gKiAgIDEuIHJlbmRlclxuICogICAyLiBjb21taXQgKGFuZCBjYWxsIGBvblJlbmRlcmAsIGBvbkNvbW1pdGApXG4gKiAgIDMuIGNoZWNrIGZvciBuZXN0ZWQgdXBkYXRlc1xuICogICA0LiBmbHVzaCBwYXNzaXZlIGVmZmVjdHMgKGFuZCBjYWxsIGBvblBvc3RDb21taXRgKVxuICpcbiAqIE5lc3RlZCB1cGRhdGVzIGFyZSBpZGVudGlmaWVkIGluIHN0ZXAgMyBhYm92ZSxcbiAqIGJ1dCBzdGVwIDQgc3RpbGwgYXBwbGllcyB0byB0aGUgd29yayB0aGF0IHdhcyBqdXN0IGNvbW1pdHRlZC5cbiAqIFdlIHVzZSB0d28gZmxhZ3MgdG8gdHJhY2sgbmVzdGVkIHVwZGF0ZXMgdGhlbjpcbiAqIG9uZSB0cmFja3Mgd2hldGhlciB0aGUgdXBjb21pbmcgdXBkYXRlIGlzIGEgbmVzdGVkIHVwZGF0ZSxcbiAqIGFuZCB0aGUgb3RoZXIgdHJhY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgdXBkYXRlIHdhcyBhIG5lc3RlZCB1cGRhdGUuXG4gKiBUaGUgZmlyc3QgdmFsdWUgZ2V0cyBzeW5jZWQgdG8gdGhlIHNlY29uZCBhdCB0aGUgc3RhcnQgb2YgdGhlIHJlbmRlciBwaGFzZS5cbiAqL3ZhciBjdXJyZW50VXBkYXRlSXNOZXN0ZWQ9ZmFsc2U7dmFyIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZD1mYWxzZTtmdW5jdGlvbiBpc0N1cnJlbnRVcGRhdGVOZXN0ZWQoKXtyZXR1cm4gY3VycmVudFVwZGF0ZUlzTmVzdGVkO31mdW5jdGlvbiBtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkKCl7e25lc3RlZFVwZGF0ZVNjaGVkdWxlZD10cnVlO319ZnVuY3Rpb24gcmVzZXROZXN0ZWRVcGRhdGVGbGFnKCl7e2N1cnJlbnRVcGRhdGVJc05lc3RlZD1mYWxzZTtuZXN0ZWRVcGRhdGVTY2hlZHVsZWQ9ZmFsc2U7fX1mdW5jdGlvbiBzeW5jTmVzdGVkVXBkYXRlRmxhZygpe3tjdXJyZW50VXBkYXRlSXNOZXN0ZWQ9bmVzdGVkVXBkYXRlU2NoZWR1bGVkO25lc3RlZFVwZGF0ZVNjaGVkdWxlZD1mYWxzZTt9fWZ1bmN0aW9uIGdldENvbW1pdFRpbWUoKXtyZXR1cm4gY29tbWl0VGltZTt9ZnVuY3Rpb24gcmVjb3JkQ29tbWl0VGltZSgpe2NvbW1pdFRpbWU9bm93JDEoKTt9ZnVuY3Rpb24gc3RhcnRQcm9maWxlclRpbWVyKGZpYmVyKXtwcm9maWxlclN0YXJ0VGltZT1ub3ckMSgpO2lmKGZpYmVyLmFjdHVhbFN0YXJ0VGltZTwwKXtmaWJlci5hY3R1YWxTdGFydFRpbWU9bm93JDEoKTt9fWZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKGZpYmVyKXtwcm9maWxlclN0YXJ0VGltZT0tMTt9ZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShmaWJlcixvdmVycmlkZUJhc2VUaW1lKXtpZihwcm9maWxlclN0YXJ0VGltZT49MCl7dmFyIGVsYXBzZWRUaW1lPW5vdyQxKCktcHJvZmlsZXJTdGFydFRpbWU7ZmliZXIuYWN0dWFsRHVyYXRpb24rPWVsYXBzZWRUaW1lO2lmKG92ZXJyaWRlQmFzZVRpbWUpe2ZpYmVyLnNlbGZCYXNlRHVyYXRpb249ZWxhcHNlZFRpbWU7fXByb2ZpbGVyU3RhcnRUaW1lPS0xO319ZnVuY3Rpb24gcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmliZXIpe2lmKGxheW91dEVmZmVjdFN0YXJ0VGltZT49MCl7dmFyIGVsYXBzZWRUaW1lPW5vdyQxKCktbGF5b3V0RWZmZWN0U3RhcnRUaW1lO2xheW91dEVmZmVjdFN0YXJ0VGltZT0tMTsvLyBTdG9yZSBkdXJhdGlvbiBvbiB0aGUgbmV4dCBuZWFyZXN0IFByb2ZpbGVyIGFuY2VzdG9yXG4vLyBPciB0aGUgcm9vdCAoZm9yIHRoZSBEZXZUb29scyBQcm9maWxlciB0byByZWFkKVxudmFyIHBhcmVudEZpYmVyPWZpYmVyLnJldHVybjt3aGlsZShwYXJlbnRGaWJlciE9PW51bGwpe3N3aXRjaChwYXJlbnRGaWJlci50YWcpe2Nhc2UgSG9zdFJvb3Q6dmFyIHJvb3Q9cGFyZW50RmliZXIuc3RhdGVOb2RlO3Jvb3QuZWZmZWN0RHVyYXRpb24rPWVsYXBzZWRUaW1lO3JldHVybjtjYXNlIFByb2ZpbGVyOnZhciBwYXJlbnRTdGF0ZU5vZGU9cGFyZW50RmliZXIuc3RhdGVOb2RlO3BhcmVudFN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbis9ZWxhcHNlZFRpbWU7cmV0dXJuO31wYXJlbnRGaWJlcj1wYXJlbnRGaWJlci5yZXR1cm47fX19ZnVuY3Rpb24gcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGZpYmVyKXtpZihwYXNzaXZlRWZmZWN0U3RhcnRUaW1lPj0wKXt2YXIgZWxhcHNlZFRpbWU9bm93JDEoKS1wYXNzaXZlRWZmZWN0U3RhcnRUaW1lO3Bhc3NpdmVFZmZlY3RTdGFydFRpbWU9LTE7Ly8gU3RvcmUgZHVyYXRpb24gb24gdGhlIG5leHQgbmVhcmVzdCBQcm9maWxlciBhbmNlc3RvclxuLy8gT3IgdGhlIHJvb3QgKGZvciB0aGUgRGV2VG9vbHMgUHJvZmlsZXIgdG8gcmVhZClcbnZhciBwYXJlbnRGaWJlcj1maWJlci5yZXR1cm47d2hpbGUocGFyZW50RmliZXIhPT1udWxsKXtzd2l0Y2gocGFyZW50RmliZXIudGFnKXtjYXNlIEhvc3RSb290OnZhciByb290PXBhcmVudEZpYmVyLnN0YXRlTm9kZTtpZihyb290IT09bnVsbCl7cm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24rPWVsYXBzZWRUaW1lO31yZXR1cm47Y2FzZSBQcm9maWxlcjp2YXIgcGFyZW50U3RhdGVOb2RlPXBhcmVudEZpYmVyLnN0YXRlTm9kZTtpZihwYXJlbnRTdGF0ZU5vZGUhPT1udWxsKXsvLyBEZXRhY2hlZCBmaWJlcnMgaGF2ZSB0aGVpciBzdGF0ZSBub2RlIGNsZWFyZWQgb3V0LlxuLy8gSW4gdGhpcyBjYXNlLCB0aGUgcmV0dXJuIHBvaW50ZXIgaXMgYWxzbyBjbGVhcmVkIG91dCxcbi8vIHNvIHdlIHdvbid0IGJlIGFibGUgdG8gcmVwb3J0IHRoZSB0aW1lIHNwZW50IGluIHRoaXMgUHJvZmlsZXIncyBzdWJ0cmVlLlxucGFyZW50U3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbis9ZWxhcHNlZFRpbWU7fXJldHVybjt9cGFyZW50RmliZXI9cGFyZW50RmliZXIucmV0dXJuO319fWZ1bmN0aW9uIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKXtsYXlvdXRFZmZlY3RTdGFydFRpbWU9bm93JDEoKTt9ZnVuY3Rpb24gc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKXtwYXNzaXZlRWZmZWN0U3RhcnRUaW1lPW5vdyQxKCk7fWZ1bmN0aW9uIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24oZmliZXIpey8vIFRyYW5zZmVyIHRpbWUgc3BlbnQgcmVuZGVyaW5nIHRoZXNlIGNoaWxkcmVuIHNvIHdlIGRvbid0IGxvc2UgaXRcbi8vIGFmdGVyIHdlIHJlcmVuZGVyLiBUaGlzIGlzIHVzZWQgYXMgYSBoZWxwZXIgaW4gc3BlY2lhbCBjYXNlc1xuLy8gd2hlcmUgd2Ugc2hvdWxkIGNvdW50IHRoZSB3b3JrIG9mIG11bHRpcGxlIHBhc3Nlcy5cbnZhciBjaGlsZD1maWJlci5jaGlsZDt3aGlsZShjaGlsZCl7ZmliZXIuYWN0dWFsRHVyYXRpb24rPWNoaWxkLmFjdHVhbER1cmF0aW9uO2NoaWxkPWNoaWxkLnNpYmxpbmc7fX1mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCxiYXNlUHJvcHMpe2lmKENvbXBvbmVudCYmQ29tcG9uZW50LmRlZmF1bHRQcm9wcyl7Ly8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzLiBUYWtlbiBmcm9tIFJlYWN0RWxlbWVudFxudmFyIHByb3BzPWFzc2lnbih7fSxiYXNlUHJvcHMpO3ZhciBkZWZhdWx0UHJvcHM9Q29tcG9uZW50LmRlZmF1bHRQcm9wcztmb3IodmFyIHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcyl7aWYocHJvcHNbcHJvcE5hbWVdPT09dW5kZWZpbmVkKXtwcm9wc1twcm9wTmFtZV09ZGVmYXVsdFByb3BzW3Byb3BOYW1lXTt9fXJldHVybiBwcm9wczt9cmV0dXJuIGJhc2VQcm9wczt9dmFyIGZha2VJbnRlcm5hbEluc3RhbmNlPXt9O3ZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQ7dmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZTt2YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlO3ZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlO3ZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGU7dmFyIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZTt2YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrO3ZhciBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZTt2YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXM7dmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTt2YXIgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCQxO3tkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQ9bmV3IFNldCgpO2RpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZT1uZXcgU2V0KCk7ZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlPW5ldyBTZXQoKTtkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlPW5ldyBTZXQoKTtkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZT1uZXcgU2V0KCk7ZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlPW5ldyBTZXQoKTtkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcz1uZXcgU2V0KCk7ZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlPW5ldyBTZXQoKTtkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0JDE9bmV3IFNldCgpO3ZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2s9bmV3IFNldCgpO3dhcm5PbkludmFsaWRDYWxsYmFjaz1mdW5jdGlvbihjYWxsYmFjayxjYWxsZXJOYW1lKXtpZihjYWxsYmFjaz09PW51bGx8fHR5cGVvZiBjYWxsYmFjaz09PSdmdW5jdGlvbicpe3JldHVybjt9dmFyIGtleT1jYWxsZXJOYW1lKydfJytjYWxsYmFjaztpZighZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmhhcyhrZXkpKXtkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSk7ZXJyb3IoJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnKydmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJyxjYWxsZXJOYW1lLGNhbGxiYWNrKTt9fTt3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGU9ZnVuY3Rpb24odHlwZSxwYXJ0aWFsU3RhdGUpe2lmKHBhcnRpYWxTdGF0ZT09PXVuZGVmaW5lZCl7dmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpfHwnQ29tcG9uZW50JztpZighZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSl7ZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnKydZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJyxjb21wb25lbnROYW1lKTt9fX07Ly8gVGhpcyBpcyBzbyBncm9zcyBidXQgaXQncyBhdCBsZWFzdCBub24tY3JpdGljYWwgYW5kIGNhbiBiZSByZW1vdmVkIGlmXG4vLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4vLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4vLyAuLi4pKSB3aGljaCBvdGhlcndpc2UgdGhyb3dzIGEgXCJfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYSBmdW5jdGlvblwiXG4vLyBleGNlcHRpb24uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsJ19wcm9jZXNzQ2hpbGRDb250ZXh0Jyx7ZW51bWVyYWJsZTpmYWxzZSx2YWx1ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcignX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5ICcrJ21lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCAnKydhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyAnK1widW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIsIHdoaWNoIGlzbid0IHN1cHBvcnRlZC4gVHJ5IFwiKyd0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCAnKyd0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO319KTtPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTt9ZnVuY3Rpb24gYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsY3RvcixnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsbmV4dFByb3BzKXt2YXIgcHJldlN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7dmFyIHBhcnRpYWxTdGF0ZT1nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLHByZXZTdGF0ZSk7e2lmKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7dHJ5ey8vIEludm9rZSB0aGUgZnVuY3Rpb24gYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG5wYXJ0aWFsU3RhdGU9Z2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcyxwcmV2U3RhdGUpO31maW5hbGx5e3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTt9fXdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZShjdG9yLHBhcnRpYWxTdGF0ZSk7fS8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG52YXIgbWVtb2l6ZWRTdGF0ZT1wYXJ0aWFsU3RhdGU9PT1udWxsfHxwYXJ0aWFsU3RhdGU9PT11bmRlZmluZWQ/cHJldlN0YXRlOmFzc2lnbih7fSxwcmV2U3RhdGUscGFydGlhbFN0YXRlKTt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW1lbW9pemVkU3RhdGU7Ly8gT25jZSB0aGUgdXBkYXRlIHF1ZXVlIGlzIGVtcHR5LCBwZXJzaXN0IHRoZSBkZXJpdmVkIHN0YXRlIG9udG8gdGhlXG4vLyBiYXNlIHN0YXRlLlxuaWYod29ya0luUHJvZ3Jlc3MubGFuZXM9PT1Ob0xhbmVzKXsvLyBRdWV1ZSBpcyBhbHdheXMgbm9uLW51bGwgZm9yIGNsYXNzZXNcbnZhciB1cGRhdGVRdWV1ZT13b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTt1cGRhdGVRdWV1ZS5iYXNlU3RhdGU9bWVtb2l6ZWRTdGF0ZTt9fXZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXI9e2lzTW91bnRlZDppc01vdW50ZWQsZW5xdWV1ZVNldFN0YXRlOmZ1bmN0aW9uKGluc3QscGF5bG9hZCxjYWxsYmFjayl7dmFyIGZpYmVyPWdldChpbnN0KTt2YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTt2YXIgbGFuZT1yZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7dmFyIHVwZGF0ZT1jcmVhdGVVcGRhdGUoZXZlbnRUaW1lLGxhbmUpO3VwZGF0ZS5wYXlsb2FkPXBheWxvYWQ7aWYoY2FsbGJhY2shPT11bmRlZmluZWQmJmNhbGxiYWNrIT09bnVsbCl7e3dhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywnc2V0U3RhdGUnKTt9dXBkYXRlLmNhbGxiYWNrPWNhbGxiYWNrO312YXIgcm9vdD1lbnF1ZXVlVXBkYXRlKGZpYmVyLHVwZGF0ZSxsYW5lKTtpZihyb290IT09bnVsbCl7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsbGFuZSxldmVudFRpbWUpO2VudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCxmaWJlcixsYW5lKTt9e21hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlcixsYW5lKTt9fSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKGluc3QscGF5bG9hZCxjYWxsYmFjayl7dmFyIGZpYmVyPWdldChpbnN0KTt2YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTt2YXIgbGFuZT1yZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7dmFyIHVwZGF0ZT1jcmVhdGVVcGRhdGUoZXZlbnRUaW1lLGxhbmUpO3VwZGF0ZS50YWc9UmVwbGFjZVN0YXRlO3VwZGF0ZS5wYXlsb2FkPXBheWxvYWQ7aWYoY2FsbGJhY2shPT11bmRlZmluZWQmJmNhbGxiYWNrIT09bnVsbCl7e3dhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywncmVwbGFjZVN0YXRlJyk7fXVwZGF0ZS5jYWxsYmFjaz1jYWxsYmFjazt9dmFyIHJvb3Q9ZW5xdWV1ZVVwZGF0ZShmaWJlcix1cGRhdGUsbGFuZSk7aWYocm9vdCE9PW51bGwpe3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLGxhbmUsZXZlbnRUaW1lKTtlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsZmliZXIsbGFuZSk7fXttYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsbGFuZSk7fX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKGluc3QsY2FsbGJhY2spe3ZhciBmaWJlcj1nZXQoaW5zdCk7dmFyIGV2ZW50VGltZT1yZXF1ZXN0RXZlbnRUaW1lKCk7dmFyIGxhbmU9cmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO3ZhciB1cGRhdGU9Y3JlYXRlVXBkYXRlKGV2ZW50VGltZSxsYW5lKTt1cGRhdGUudGFnPUZvcmNlVXBkYXRlO2lmKGNhbGxiYWNrIT09dW5kZWZpbmVkJiZjYWxsYmFjayE9PW51bGwpe3t3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssJ2ZvcmNlVXBkYXRlJyk7fXVwZGF0ZS5jYWxsYmFjaz1jYWxsYmFjazt9dmFyIHJvb3Q9ZW5xdWV1ZVVwZGF0ZShmaWJlcix1cGRhdGUsbGFuZSk7aWYocm9vdCE9PW51bGwpe3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLGxhbmUsZXZlbnRUaW1lKTtlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsZmliZXIsbGFuZSk7fXttYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQoZmliZXIsbGFuZSk7fX19O2Z1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLGN0b3Isb2xkUHJvcHMsbmV3UHJvcHMsb2xkU3RhdGUsbmV3U3RhdGUsbmV4dENvbnRleHQpe3ZhciBpbnN0YW5jZT13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7aWYodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZT09PSdmdW5jdGlvbicpe3ZhciBzaG91bGRVcGRhdGU9aW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLG5ld1N0YXRlLG5leHRDb250ZXh0KTt7aWYod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RMZWdhY3lNb2RlKXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTt0cnl7Ly8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbnNob3VsZFVwZGF0ZT1pbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsbmV3U3RhdGUsbmV4dENvbnRleHQpO31maW5hbGx5e3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTt9fWlmKHNob3VsZFVwZGF0ZT09PXVuZGVmaW5lZCl7ZXJyb3IoJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcrJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKXx8J0NvbXBvbmVudCcpO319cmV0dXJuIHNob3VsZFVwZGF0ZTt9aWYoY3Rvci5wcm90b3R5cGUmJmN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KXtyZXR1cm4hc2hhbGxvd0VxdWFsKG9sZFByb3BzLG5ld1Byb3BzKXx8IXNoYWxsb3dFcXVhbChvbGRTdGF0ZSxuZXdTdGF0ZSk7fXJldHVybiB0cnVlO31mdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsY3RvcixuZXdQcm9wcyl7dmFyIGluc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTt7dmFyIG5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpfHwnQ29tcG9uZW50Jzt2YXIgcmVuZGVyUHJlc2VudD1pbnN0YW5jZS5yZW5kZXI7aWYoIXJlbmRlclByZXNlbnQpe2lmKGN0b3IucHJvdG90eXBlJiZ0eXBlb2YgY3Rvci5wcm90b3R5cGUucmVuZGVyPT09J2Z1bmN0aW9uJyl7ZXJyb3IoJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcrJ2luc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yPycsbmFtZSk7fWVsc2V7ZXJyb3IoJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcrJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLG5hbWUpO319aWYoaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlJiYhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkJiYhaW5zdGFuY2Uuc3RhdGUpe2Vycm9yKCdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJysnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnKydEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLG5hbWUpO31pZihpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMmJiFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpe2Vycm9yKCdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJysnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnKydVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsbmFtZSk7fWlmKGluc3RhbmNlLnByb3BUeXBlcyl7ZXJyb3IoJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcrJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLG5hbWUpO31pZihpbnN0YW5jZS5jb250ZXh0VHlwZSl7ZXJyb3IoJ2NvbnRleHRUeXBlIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJysncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuJyxuYW1lKTt9e2lmKGN0b3IuY2hpbGRDb250ZXh0VHlwZXMmJiFkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0JDEuaGFzKGN0b3IpJiYvLyBTdHJpY3QgTW9kZSBoYXMgaXRzIG93biB3YXJuaW5nIGZvciBsZWdhY3kgY29udGV4dCwgc28gd2UgY2FuIHNraXBcbi8vIHRoaXMgb25lLlxuKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSk9PT1Ob01vZGUpe2RpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQkMS5hZGQoY3Rvcik7ZXJyb3IoJyVzIHVzZXMgdGhlIGxlZ2FjeSBjaGlsZENvbnRleHRUeXBlcyBBUEkgd2hpY2ggaXMgbm8gbG9uZ2VyICcrJ3N1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuIFVzZSAnKydSZWFjdC5jcmVhdGVDb250ZXh0KCkgaW5zdGVhZFxcblxcbi4nKydMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvbGVnYWN5LWNvbnRleHQnLG5hbWUpO31pZihjdG9yLmNvbnRleHRUeXBlcyYmIWRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQkMS5oYXMoY3RvcikmJi8vIFN0cmljdCBNb2RlIGhhcyBpdHMgb3duIHdhcm5pbmcgZm9yIGxlZ2FjeSBjb250ZXh0LCBzbyB3ZSBjYW4gc2tpcFxuLy8gdGhpcyBvbmUuXG4od29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RMZWdhY3lNb2RlKT09PU5vTW9kZSl7ZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCQxLmFkZChjdG9yKTtlcnJvcignJXMgdXNlcyB0aGUgbGVnYWN5IGNvbnRleHRUeXBlcyBBUEkgd2hpY2ggaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCAnKydhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuIFVzZSAnKydSZWFjdC5jcmVhdGVDb250ZXh0KCkgd2l0aCBzdGF0aWMgY29udGV4dFR5cGUgaW5zdGVhZC5cXG5cXG4nKydMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvbGVnYWN5LWNvbnRleHQnLG5hbWUpO31pZihpbnN0YW5jZS5jb250ZXh0VHlwZXMpe2Vycm9yKCdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnKydwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJyxuYW1lKTt9aWYoY3Rvci5jb250ZXh0VHlwZSYmY3Rvci5jb250ZXh0VHlwZXMmJiFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcy5oYXMoY3Rvcikpe2RpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmFkZChjdG9yKTtlcnJvcignJXMgZGVjbGFyZXMgYm90aCBjb250ZXh0VHlwZXMgYW5kIGNvbnRleHRUeXBlIHN0YXRpYyBwcm9wZXJ0aWVzLiAnKydUaGUgbGVnYWN5IGNvbnRleHRUeXBlcyBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuJyxuYW1lKTt9fWlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGU9PT0nZnVuY3Rpb24nKXtlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnKydjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnKydUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJysnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJyxuYW1lKTt9aWYoY3Rvci5wcm90b3R5cGUmJmN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50JiZ0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlIT09J3VuZGVmaW5lZCcpe2Vycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiAnKydzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcrJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpfHwnQSBwdXJlIGNvbXBvbmVudCcpO31pZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudD09PSdmdW5jdGlvbicpe2Vycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcrJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJysnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JyxuYW1lKTt9aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcz09PSdmdW5jdGlvbicpe2Vycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcrJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnKydJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgJysndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJysncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJyxuYW1lKTt9aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHM9PT0nZnVuY3Rpb24nKXtlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnKydjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JyxuYW1lKTt9aWYodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzPT09J2Z1bmN0aW9uJyl7ZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJysnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JyxuYW1lKTt9dmFyIGhhc011dGF0ZWRQcm9wcz1pbnN0YW5jZS5wcm9wcyE9PW5ld1Byb3BzO2lmKGluc3RhbmNlLnByb3BzIT09dW5kZWZpbmVkJiZoYXNNdXRhdGVkUHJvcHMpe2Vycm9yKCclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnK1widXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsbmFtZSxuYW1lKTt9aWYoaW5zdGFuY2UuZGVmYXVsdFByb3BzKXtlcnJvcignU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicrJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsbmFtZSxuYW1lKTt9aWYodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlPT09J2Z1bmN0aW9uJyYmdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSE9PSdmdW5jdGlvbicmJiFkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKGN0b3IpKXtkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKGN0b3IpO2Vycm9yKCclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBzaG91bGQgYmUgdXNlZCB3aXRoIGNvbXBvbmVudERpZFVwZGF0ZSgpLiAnKydUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS4nLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSk7fWlmKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9PT0nZnVuY3Rpb24nKXtlcnJvcignJXM6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcrJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsbmFtZSk7fWlmKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I9PT0nZnVuY3Rpb24nKXtlcnJvcignJXM6IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcrJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsbmFtZSk7fWlmKHR5cGVvZiBjdG9yLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlPT09J2Z1bmN0aW9uJyl7ZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kICcrJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kLicsbmFtZSk7fXZhciBfc3RhdGU9aW5zdGFuY2Uuc3RhdGU7aWYoX3N0YXRlJiYodHlwZW9mIF9zdGF0ZSE9PSdvYmplY3QnfHxpc0FycmF5KF9zdGF0ZSkpKXtlcnJvcignJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJyxuYW1lKTt9aWYodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dD09PSdmdW5jdGlvbicmJnR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzIT09J29iamVjdCcpe2Vycm9yKCclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcrJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLG5hbWUpO319fWZ1bmN0aW9uIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxpbnN0YW5jZSl7aW5zdGFuY2UudXBkYXRlcj1jbGFzc0NvbXBvbmVudFVwZGF0ZXI7d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlPWluc3RhbmNlOy8vIFRoZSBpbnN0YW5jZSBuZWVkcyBhY2Nlc3MgdG8gdGhlIGZpYmVyIHNvIHRoYXQgaXQgY2FuIHNjaGVkdWxlIHVwZGF0ZXNcbnNldChpbnN0YW5jZSx3b3JrSW5Qcm9ncmVzcyk7e2luc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2U9ZmFrZUludGVybmFsSW5zdGFuY2U7fX1mdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLGN0b3IscHJvcHMpe3ZhciBpc0xlZ2FjeUNvbnRleHRDb25zdW1lcj1mYWxzZTt2YXIgdW5tYXNrZWRDb250ZXh0PWVtcHR5Q29udGV4dE9iamVjdDt2YXIgY29udGV4dD1lbXB0eUNvbnRleHRPYmplY3Q7dmFyIGNvbnRleHRUeXBlPWN0b3IuY29udGV4dFR5cGU7e2lmKCdjb250ZXh0VHlwZSdpbiBjdG9yKXt2YXIgaXNWYWxpZD0vLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuY29udGV4dFR5cGU9PT1udWxsfHxjb250ZXh0VHlwZSE9PXVuZGVmaW5lZCYmY29udGV4dFR5cGUuJCR0eXBlb2Y9PT1SRUFDVF9DT05URVhUX1RZUEUmJmNvbnRleHRUeXBlLl9jb250ZXh0PT09dW5kZWZpbmVkOy8vIE5vdCBhIDxDb250ZXh0LkNvbnN1bWVyPlxuaWYoIWlzVmFsaWQmJiFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKGN0b3IpKXtkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKGN0b3IpO3ZhciBhZGRlbmR1bT0nJztpZihjb250ZXh0VHlwZT09PXVuZGVmaW5lZCl7YWRkZW5kdW09JyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiAnKydUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnKydUaGlzIGNhbiBhbHNvIGhhcHBlbiBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBzbyAnKyd0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuJzt9ZWxzZSBpZih0eXBlb2YgY29udGV4dFR5cGUhPT0nb2JqZWN0Jyl7YWRkZW5kdW09JyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnK3R5cGVvZiBjb250ZXh0VHlwZSsnLic7fWVsc2UgaWYoY29udGV4dFR5cGUuJCR0eXBlb2Y9PT1SRUFDVF9QUk9WSURFUl9UWVBFKXthZGRlbmR1bT0nIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuUHJvdmlkZXIgaW5zdGVhZD8nO31lbHNlIGlmKGNvbnRleHRUeXBlLl9jb250ZXh0IT09dW5kZWZpbmVkKXsvLyA8Q29udGV4dC5Db25zdW1lcj5cbmFkZGVuZHVtPScgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkPyc7fWVsc2V7YWRkZW5kdW09JyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYW4gb2JqZWN0IHdpdGgga2V5cyB7JytPYmplY3Qua2V5cyhjb250ZXh0VHlwZSkuam9pbignLCAnKSsnfS4nO31lcnJvcignJXMgZGVmaW5lcyBhbiBpbnZhbGlkIGNvbnRleHRUeXBlLiAnKydjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpfHwnQ29tcG9uZW50JyxhZGRlbmR1bSk7fX19aWYodHlwZW9mIGNvbnRleHRUeXBlPT09J29iamVjdCcmJmNvbnRleHRUeXBlIT09bnVsbCl7Y29udGV4dD1yZWFkQ29udGV4dChjb250ZXh0VHlwZSk7fWVsc2V7dW5tYXNrZWRDb250ZXh0PWdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxjdG9yLHRydWUpO3ZhciBjb250ZXh0VHlwZXM9Y3Rvci5jb250ZXh0VHlwZXM7aXNMZWdhY3lDb250ZXh0Q29uc3VtZXI9Y29udGV4dFR5cGVzIT09bnVsbCYmY29udGV4dFR5cGVzIT09dW5kZWZpbmVkO2NvbnRleHQ9aXNMZWdhY3lDb250ZXh0Q29uc3VtZXI/Z2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyx1bm1hc2tlZENvbnRleHQpOmVtcHR5Q29udGV4dE9iamVjdDt9dmFyIGluc3RhbmNlPW5ldyBjdG9yKHByb3BzLGNvbnRleHQpOy8vIEluc3RhbnRpYXRlIHR3aWNlIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbntpZih3b3JrSW5Qcm9ncmVzcy5tb2RlJlN0cmljdExlZ2FjeU1vZGUpe3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO3RyeXtpbnN0YW5jZT1uZXcgY3Rvcihwcm9wcyxjb250ZXh0KTsvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xufWZpbmFsbHl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO319fXZhciBzdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPWluc3RhbmNlLnN0YXRlIT09bnVsbCYmaW5zdGFuY2Uuc3RhdGUhPT11bmRlZmluZWQ/aW5zdGFuY2Uuc3RhdGU6bnVsbDthZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsaW5zdGFuY2UpO3tpZih0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9PT0nZnVuY3Rpb24nJiZzdGF0ZT09PW51bGwpe3ZhciBjb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKXx8J0NvbXBvbmVudCc7aWYoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpe2RpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7ZXJyb3IoJ2Alc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJysnJXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLiBJbnN0ZWFkLCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgYnkgJysnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcrJ1RoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS4nLGNvbXBvbmVudE5hbWUsaW5zdGFuY2Uuc3RhdGU9PT1udWxsPydudWxsJzondW5kZWZpbmVkJyxjb21wb25lbnROYW1lKTt9fS8vIElmIG5ldyBjb21wb25lbnQgQVBJcyBhcmUgZGVmaW5lZCwgXCJ1bnNhZmVcIiBsaWZlY3ljbGVzIHdvbid0IGJlIGNhbGxlZC5cbi8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIG1ldGhvZHMgdGhvdWdoLlxuaWYodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzPT09J2Z1bmN0aW9uJ3x8dHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlPT09J2Z1bmN0aW9uJyl7dmFyIGZvdW5kV2lsbE1vdW50TmFtZT1udWxsO3ZhciBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lPW51bGw7dmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWU9bnVsbDtpZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50PT09J2Z1bmN0aW9uJyYmaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmchPT10cnVlKXtmb3VuZFdpbGxNb3VudE5hbWU9J2NvbXBvbmVudFdpbGxNb3VudCc7fWVsc2UgaWYodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nKXtmb3VuZFdpbGxNb3VudE5hbWU9J1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO31pZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcz09PSdmdW5jdGlvbicmJmluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyE9PXRydWUpe2ZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWU9J2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO31lbHNlIGlmKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcz09PSdmdW5jdGlvbicpe2ZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWU9J1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJzt9aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGU9PT0nZnVuY3Rpb24nJiZpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmchPT10cnVlKXtmb3VuZFdpbGxVcGRhdGVOYW1lPSdjb21wb25lbnRXaWxsVXBkYXRlJzt9ZWxzZSBpZih0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGU9PT0nZnVuY3Rpb24nKXtmb3VuZFdpbGxVcGRhdGVOYW1lPSdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSc7fWlmKGZvdW5kV2lsbE1vdW50TmFtZSE9PW51bGx8fGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUhPT1udWxsfHxmb3VuZFdpbGxVcGRhdGVOYW1lIT09bnVsbCl7dmFyIF9jb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKXx8J0NvbXBvbmVudCc7dmFyIG5ld0FwaU5hbWU9dHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzPT09J2Z1bmN0aW9uJz8nZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCknOidnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpJztpZighZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2NvbXBvbmVudE5hbWUpKXtkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfY29tcG9uZW50TmFtZSk7ZXJyb3IoJ1Vuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbicrJyVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG4nKydUaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG4nKydodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzJyxfY29tcG9uZW50TmFtZSxuZXdBcGlOYW1lLGZvdW5kV2lsbE1vdW50TmFtZSE9PW51bGw/XCJcXG4gIFwiK2ZvdW5kV2lsbE1vdW50TmFtZTonJyxmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIT09bnVsbD9cIlxcbiAgXCIrZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZTonJyxmb3VuZFdpbGxVcGRhdGVOYW1lIT09bnVsbD9cIlxcbiAgXCIrZm91bmRXaWxsVXBkYXRlTmFtZTonJyk7fX19fS8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbi8vIFJlYWN0RmliZXJDb250ZXh0IHVzdWFsbHkgdXBkYXRlcyB0aGlzIGNhY2hlIGJ1dCBjYW4ndCBmb3IgbmV3bHktY3JlYXRlZCBpbnN0YW5jZXMuXG5pZihpc0xlZ2FjeUNvbnRleHRDb25zdW1lcil7Y2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLHVubWFza2VkQ29udGV4dCxjb250ZXh0KTt9cmV0dXJuIGluc3RhbmNlO31mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLGluc3RhbmNlKXt2YXIgb2xkU3RhdGU9aW5zdGFuY2Uuc3RhdGU7aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudD09PSdmdW5jdGlvbicpe2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO31pZih0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudD09PSdmdW5jdGlvbicpe2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTt9aWYob2xkU3RhdGUhPT1pbnN0YW5jZS5zdGF0ZSl7e2Vycm9yKCclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJytcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIisnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpfHwnQ29tcG9uZW50Jyk7fWNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLGluc3RhbmNlLnN0YXRlLG51bGwpO319ZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsaW5zdGFuY2UsbmV3UHJvcHMsbmV4dENvbnRleHQpe3ZhciBvbGRTdGF0ZT1pbnN0YW5jZS5zdGF0ZTtpZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcz09PSdmdW5jdGlvbicpe2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsbmV4dENvbnRleHQpO31pZih0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM9PT0nZnVuY3Rpb24nKXtpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcyxuZXh0Q29udGV4dCk7fWlmKGluc3RhbmNlLnN0YXRlIT09b2xkU3RhdGUpe3t2YXIgY29tcG9uZW50TmFtZT1nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKXx8J0NvbXBvbmVudCc7aWYoIWRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpe2RpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7ZXJyb3IoJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcrXCJ0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIisnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLGNvbXBvbmVudE5hbWUpO319Y2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsaW5zdGFuY2Uuc3RhdGUsbnVsbCk7fX0vLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG5mdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsY3RvcixuZXdQcm9wcyxyZW5kZXJMYW5lcyl7e2NoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxjdG9yLG5ld1Byb3BzKTt9dmFyIGluc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtpbnN0YW5jZS5wcm9wcz1uZXdQcm9wcztpbnN0YW5jZS5zdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO2luc3RhbmNlLnJlZnM9e307aW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTt2YXIgY29udGV4dFR5cGU9Y3Rvci5jb250ZXh0VHlwZTtpZih0eXBlb2YgY29udGV4dFR5cGU9PT0nb2JqZWN0JyYmY29udGV4dFR5cGUhPT1udWxsKXtpbnN0YW5jZS5jb250ZXh0PXJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTt9ZWxzZXt2YXIgdW5tYXNrZWRDb250ZXh0PWdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxjdG9yLHRydWUpO2luc3RhbmNlLmNvbnRleHQ9Z2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyx1bm1hc2tlZENvbnRleHQpO317aWYoaW5zdGFuY2Uuc3RhdGU9PT1uZXdQcm9wcyl7dmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpfHwnQ29tcG9uZW50JztpZighZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKXtkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7ZXJyb3IoJyVzOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gYXNzaWduIHByb3BzIGRpcmVjdGx5IHRvIHN0YXRlICcrXCJiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBcIisnSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS4nLGNvbXBvbmVudE5hbWUpO319aWYod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RMZWdhY3lNb2RlKXtSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyh3b3JrSW5Qcm9ncmVzcyxpbnN0YW5jZSk7fXtSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyh3b3JrSW5Qcm9ncmVzcyxpbnN0YW5jZSk7fX1pbnN0YW5jZS5zdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO3ZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9Y3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7aWYodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcz09PSdmdW5jdGlvbicpe2FwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLGN0b3IsZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLG5ld1Byb3BzKTtpbnN0YW5jZS5zdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO30vLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbi8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5pZih0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMhPT0nZnVuY3Rpb24nJiZ0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUhPT0nZnVuY3Rpb24nJiYodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nfHx0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50PT09J2Z1bmN0aW9uJykpe2NhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsaW5zdGFuY2UpOy8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3Ncbi8vIHByb2Nlc3MgdGhlbSBub3cuXG5wcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsbmV3UHJvcHMsaW5zdGFuY2UscmVuZGVyTGFuZXMpO2luc3RhbmNlLnN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7fWlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudD09PSdmdW5jdGlvbicpe3ZhciBmaWJlckZsYWdzPVVwZGF0ZTt7ZmliZXJGbGFnc3w9TGF5b3V0U3RhdGljO31pZigod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RFZmZlY3RzTW9kZSkhPT1Ob01vZGUpe2ZpYmVyRmxhZ3N8PU1vdW50TGF5b3V0RGV2O313b3JrSW5Qcm9ncmVzcy5mbGFnc3w9ZmliZXJGbGFnczt9fWZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxjdG9yLG5ld1Byb3BzLHJlbmRlckxhbmVzKXt2YXIgaW5zdGFuY2U9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO3ZhciBvbGRQcm9wcz13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO2luc3RhbmNlLnByb3BzPW9sZFByb3BzO3ZhciBvbGRDb250ZXh0PWluc3RhbmNlLmNvbnRleHQ7dmFyIGNvbnRleHRUeXBlPWN0b3IuY29udGV4dFR5cGU7dmFyIG5leHRDb250ZXh0PWVtcHR5Q29udGV4dE9iamVjdDtpZih0eXBlb2YgY29udGV4dFR5cGU9PT0nb2JqZWN0JyYmY29udGV4dFR5cGUhPT1udWxsKXtuZXh0Q29udGV4dD1yZWFkQ29udGV4dChjb250ZXh0VHlwZSk7fWVsc2V7dmFyIG5leHRMZWdhY3lVbm1hc2tlZENvbnRleHQ9Z2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLGN0b3IsdHJ1ZSk7bmV4dENvbnRleHQ9Z2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0KTt9dmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcz1jdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczt2YXIgaGFzTmV3TGlmZWN5Y2xlcz10eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzPT09J2Z1bmN0aW9uJ3x8dHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlPT09J2Z1bmN0aW9uJzsvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4vLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbi8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbmlmKCFoYXNOZXdMaWZlY3ljbGVzJiYodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzPT09J2Z1bmN0aW9uJ3x8dHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM9PT0nZnVuY3Rpb24nKSl7aWYob2xkUHJvcHMhPT1uZXdQcm9wc3x8b2xkQ29udGV4dCE9PW5leHRDb250ZXh0KXtjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcyxpbnN0YW5jZSxuZXdQcm9wcyxuZXh0Q29udGV4dCk7fX1yZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpO3ZhciBvbGRTdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO3ZhciBuZXdTdGF0ZT1pbnN0YW5jZS5zdGF0ZT1vbGRTdGF0ZTtwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsbmV3UHJvcHMsaW5zdGFuY2UscmVuZGVyTGFuZXMpO25ld1N0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7aWYob2xkUHJvcHM9PT1uZXdQcm9wcyYmb2xkU3RhdGU9PT1uZXdTdGF0ZSYmIWhhc0NvbnRleHRDaGFuZ2VkKCkmJiFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpey8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbmlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudD09PSdmdW5jdGlvbicpe3ZhciBmaWJlckZsYWdzPVVwZGF0ZTt7ZmliZXJGbGFnc3w9TGF5b3V0U3RhdGljO31pZigod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RFZmZlY3RzTW9kZSkhPT1Ob01vZGUpe2ZpYmVyRmxhZ3N8PU1vdW50TGF5b3V0RGV2O313b3JrSW5Qcm9ncmVzcy5mbGFnc3w9ZmliZXJGbGFnczt9cmV0dXJuIGZhbHNlO31pZih0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzPT09J2Z1bmN0aW9uJyl7YXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsY3RvcixnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsbmV3UHJvcHMpO25ld1N0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7fXZhciBzaG91bGRVcGRhdGU9Y2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpfHxjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcyxjdG9yLG9sZFByb3BzLG5ld1Byb3BzLG9sZFN0YXRlLG5ld1N0YXRlLG5leHRDb250ZXh0KTtpZihzaG91bGRVcGRhdGUpey8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbmlmKCFoYXNOZXdMaWZlY3ljbGVzJiYodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nfHx0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50PT09J2Z1bmN0aW9uJykpe2lmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nKXtpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTt9aWYodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nKXtpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7fX1pZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQ9PT0nZnVuY3Rpb24nKXt2YXIgX2ZpYmVyRmxhZ3M9VXBkYXRlO3tfZmliZXJGbGFnc3w9TGF5b3V0U3RhdGljO31pZigod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RFZmZlY3RzTW9kZSkhPT1Ob01vZGUpe19maWJlckZsYWdzfD1Nb3VudExheW91dERldjt9d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PV9maWJlckZsYWdzO319ZWxzZXsvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbi8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG5pZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQ9PT0nZnVuY3Rpb24nKXt2YXIgX2ZpYmVyRmxhZ3MyPVVwZGF0ZTt7X2ZpYmVyRmxhZ3MyfD1MYXlvdXRTdGF0aWM7fWlmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJlN0cmljdEVmZmVjdHNNb2RlKSE9PU5vTW9kZSl7X2ZpYmVyRmxhZ3MyfD1Nb3VudExheW91dERldjt9d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PV9maWJlckZsYWdzMjt9Ly8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuLy8gbWVtb2l6ZWQgc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cbndvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM9bmV3UHJvcHM7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1uZXdTdGF0ZTt9Ly8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG5pbnN0YW5jZS5wcm9wcz1uZXdQcm9wcztpbnN0YW5jZS5zdGF0ZT1uZXdTdGF0ZTtpbnN0YW5jZS5jb250ZXh0PW5leHRDb250ZXh0O3JldHVybiBzaG91bGRVcGRhdGU7fS8vIEludm9rZXMgdGhlIHVwZGF0ZSBsaWZlLWN5Y2xlcyBhbmQgcmV0dXJucyBmYWxzZSBpZiBpdCBzaG91bGRuJ3QgcmVyZW5kZXIuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsY3RvcixuZXdQcm9wcyxyZW5kZXJMYW5lcyl7dmFyIGluc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MpO3ZhciB1bnJlc29sdmVkT2xkUHJvcHM9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wczt2YXIgb2xkUHJvcHM9d29ya0luUHJvZ3Jlc3MudHlwZT09PXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlP3VucmVzb2x2ZWRPbGRQcm9wczpyZXNvbHZlRGVmYXVsdFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsdW5yZXNvbHZlZE9sZFByb3BzKTtpbnN0YW5jZS5wcm9wcz1vbGRQcm9wczt2YXIgdW5yZXNvbHZlZE5ld1Byb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgb2xkQ29udGV4dD1pbnN0YW5jZS5jb250ZXh0O3ZhciBjb250ZXh0VHlwZT1jdG9yLmNvbnRleHRUeXBlO3ZhciBuZXh0Q29udGV4dD1lbXB0eUNvbnRleHRPYmplY3Q7aWYodHlwZW9mIGNvbnRleHRUeXBlPT09J29iamVjdCcmJmNvbnRleHRUeXBlIT09bnVsbCl7bmV4dENvbnRleHQ9cmVhZENvbnRleHQoY29udGV4dFR5cGUpO31lbHNle3ZhciBuZXh0VW5tYXNrZWRDb250ZXh0PWdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxjdG9yLHRydWUpO25leHRDb250ZXh0PWdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsbmV4dFVubWFza2VkQ29udGV4dCk7fXZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9Y3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7dmFyIGhhc05ld0xpZmVjeWNsZXM9dHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcz09PSdmdW5jdGlvbid8fHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZT09PSdmdW5jdGlvbic7Ly8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbi8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG4vLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbi8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5pZighaGFzTmV3TGlmZWN5Y2xlcyYmKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcz09PSdmdW5jdGlvbid8fHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzPT09J2Z1bmN0aW9uJykpe2lmKHVucmVzb2x2ZWRPbGRQcm9wcyE9PXVucmVzb2x2ZWROZXdQcm9wc3x8b2xkQ29udGV4dCE9PW5leHRDb250ZXh0KXtjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcyxpbnN0YW5jZSxuZXdQcm9wcyxuZXh0Q29udGV4dCk7fX1yZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpO3ZhciBvbGRTdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO3ZhciBuZXdTdGF0ZT1pbnN0YW5jZS5zdGF0ZT1vbGRTdGF0ZTtwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsbmV3UHJvcHMsaW5zdGFuY2UscmVuZGVyTGFuZXMpO25ld1N0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7aWYodW5yZXNvbHZlZE9sZFByb3BzPT09dW5yZXNvbHZlZE5ld1Byb3BzJiZvbGRTdGF0ZT09PW5ld1N0YXRlJiYhaGFzQ29udGV4dENoYW5nZWQoKSYmIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSYmIWVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb24pey8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbmlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGU9PT0nZnVuY3Rpb24nKXtpZih1bnJlc29sdmVkT2xkUHJvcHMhPT1jdXJyZW50Lm1lbW9pemVkUHJvcHN8fG9sZFN0YXRlIT09Y3VycmVudC5tZW1vaXplZFN0YXRlKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VXBkYXRlO319aWYodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlPT09J2Z1bmN0aW9uJyl7aWYodW5yZXNvbHZlZE9sZFByb3BzIT09Y3VycmVudC5tZW1vaXplZFByb3BzfHxvbGRTdGF0ZSE9PWN1cnJlbnQubWVtb2l6ZWRTdGF0ZSl7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVNuYXBzaG90O319cmV0dXJuIGZhbHNlO31pZih0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzPT09J2Z1bmN0aW9uJyl7YXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsY3RvcixnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsbmV3UHJvcHMpO25ld1N0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7fXZhciBzaG91bGRVcGRhdGU9Y2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpfHxjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcyxjdG9yLG9sZFByb3BzLG5ld1Byb3BzLG9sZFN0YXRlLG5ld1N0YXRlLG5leHRDb250ZXh0KXx8Ly8gVE9ETzogSW4gc29tZSBjYXNlcywgd2UnbGwgZW5kIHVwIGNoZWNraW5nIGlmIGNvbnRleHQgaGFzIGNoYW5nZWQgdHdpY2UsXG4vLyBib3RoIGJlZm9yZSBhbmQgYWZ0ZXIgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAgaGFzIGJlZW4gY2FsbGVkLiBOb3QgaWRlYWwsXG4vLyBidXQgSSdtIGxvYXRoIHRvIHJlZmFjdG9yIHRoaXMgZnVuY3Rpb24uIFRoaXMgb25seSBoYXBwZW5zIGZvciBtZW1vaXplZFxuLy8gY29tcG9uZW50cyBzbyBpdCdzIG5vdCB0aGF0IGNvbW1vbi5cbmVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb247aWYoc2hvdWxkVXBkYXRlKXsvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbi8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5pZighaGFzTmV3TGlmZWN5Y2xlcyYmKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZT09PSdmdW5jdGlvbid8fHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlPT09J2Z1bmN0aW9uJykpe2lmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlPT09J2Z1bmN0aW9uJyl7aW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcyxuZXdTdGF0ZSxuZXh0Q29udGV4dCk7fWlmKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZT09PSdmdW5jdGlvbicpe2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLG5ld1N0YXRlLG5leHRDb250ZXh0KTt9fWlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGU9PT0nZnVuY3Rpb24nKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VXBkYXRlO31pZih0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU9PT0nZnVuY3Rpb24nKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9U25hcHNob3Q7fX1lbHNley8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbmlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGU9PT0nZnVuY3Rpb24nKXtpZih1bnJlc29sdmVkT2xkUHJvcHMhPT1jdXJyZW50Lm1lbW9pemVkUHJvcHN8fG9sZFN0YXRlIT09Y3VycmVudC5tZW1vaXplZFN0YXRlKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VXBkYXRlO319aWYodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlPT09J2Z1bmN0aW9uJyl7aWYodW5yZXNvbHZlZE9sZFByb3BzIT09Y3VycmVudC5tZW1vaXplZFByb3BzfHxvbGRTdGF0ZSE9PWN1cnJlbnQubWVtb2l6ZWRTdGF0ZSl7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVNuYXBzaG90O319Ly8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuLy8gbWVtb2l6ZWQgcHJvcHMvc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cbndvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM9bmV3UHJvcHM7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1uZXdTdGF0ZTt9Ly8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG5pbnN0YW5jZS5wcm9wcz1uZXdQcm9wcztpbnN0YW5jZS5zdGF0ZT1uZXdTdGF0ZTtpbnN0YW5jZS5jb250ZXh0PW5leHRDb250ZXh0O3JldHVybiBzaG91bGRVcGRhdGU7fWZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLHNvdXJjZSl7Ly8gSWYgdGhlIHZhbHVlIGlzIGFuIGVycm9yLCBjYWxsIHRoaXMgZnVuY3Rpb24gaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgdGhyb3duXG4vLyBzbyB0aGUgc3RhY2sgaXMgYWNjdXJhdGUuXG5yZXR1cm57dmFsdWU6dmFsdWUsc291cmNlOnNvdXJjZSxzdGFjazpnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKSxkaWdlc3Q6bnVsbH07fWZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsZGlnZXN0LHN0YWNrKXtyZXR1cm57dmFsdWU6dmFsdWUsc291cmNlOm51bGwsc3RhY2s6c3RhY2shPW51bGw/c3RhY2s6bnVsbCxkaWdlc3Q6ZGlnZXN0IT1udWxsP2RpZ2VzdDpudWxsfTt9Ly8gVGhpcyBtb2R1bGUgaXMgZm9ya2VkIGluIGRpZmZlcmVudCBlbnZpcm9ubWVudHMuXG4vLyBCeSBkZWZhdWx0LCByZXR1cm4gYHRydWVgIHRvIGxvZyBlcnJvcnMgdG8gdGhlIGNvbnNvbGUuXG4vLyBGb3JrcyBjYW4gcmV0dXJuIGBmYWxzZWAgaWYgdGhpcyBpc24ndCBkZXNpcmFibGUuXG5mdW5jdGlvbiBzaG93RXJyb3JEaWFsb2coYm91bmRhcnksZXJyb3JJbmZvKXtyZXR1cm4gdHJ1ZTt9ZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihib3VuZGFyeSxlcnJvckluZm8pe3RyeXt2YXIgbG9nRXJyb3I9c2hvd0Vycm9yRGlhbG9nKGJvdW5kYXJ5LGVycm9ySW5mbyk7Ly8gQWxsb3cgaW5qZWN0ZWQgc2hvd0Vycm9yRGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cbi8vIFRoaXMgZW5hYmxlcyByZW5kZXJlcnMgbGlrZSBSZWFjdE5hdGl2ZSB0byBiZXR0ZXIgbWFuYWdlIHJlZGJveCBiZWhhdmlvci5cbmlmKGxvZ0Vycm9yPT09ZmFsc2Upe3JldHVybjt9dmFyIGVycm9yPWVycm9ySW5mby52YWx1ZTtpZih0cnVlKXt2YXIgc291cmNlPWVycm9ySW5mby5zb3VyY2U7dmFyIHN0YWNrPWVycm9ySW5mby5zdGFjazt2YXIgY29tcG9uZW50U3RhY2s9c3RhY2shPT1udWxsP3N0YWNrOicnOy8vIEJyb3dzZXJzIHN1cHBvcnQgc2lsZW5jaW5nIHVuY2F1Z2h0IGVycm9ycyBieSBjYWxsaW5nXG4vLyBgcHJldmVudERlZmF1bHQoKWAgaW4gd2luZG93IGBlcnJvcmAgaGFuZGxlci5cbi8vIFdlIHJlY29yZCB0aGlzIGluZm9ybWF0aW9uIGFzIGFuIGV4cGFuZG8gb24gdGhlIGVycm9yLlxuaWYoZXJyb3IhPW51bGwmJmVycm9yLl9zdXBwcmVzc0xvZ2dpbmcpe2lmKGJvdW5kYXJ5LnRhZz09PUNsYXNzQ29tcG9uZW50KXsvLyBUaGUgZXJyb3IgaXMgcmVjb3ZlcmFibGUgYW5kIHdhcyBzaWxlbmNlZC5cbi8vIElnbm9yZSBpdCBhbmQgZG9uJ3QgcHJpbnQgdGhlIHN0YWNrIGFkZGVuZHVtLlxuLy8gVGhpcyBpcyBoYW5keSBmb3IgdGVzdGluZyBlcnJvciBib3VuZGFyaWVzIHdpdGhvdXQgbm9pc2UuXG5yZXR1cm47fS8vIFRoZSBlcnJvciBpcyBmYXRhbC4gU2luY2UgdGhlIHNpbGVuY2luZyBtaWdodCBoYXZlXG4vLyBiZWVuIGFjY2lkZW50YWwsIHdlJ2xsIHN1cmZhY2UgaXQgYW55d2F5LlxuLy8gSG93ZXZlciwgdGhlIGJyb3dzZXIgd291bGQgaGF2ZSBzaWxlbmNlZCB0aGUgb3JpZ2luYWwgZXJyb3Jcbi8vIHNvIHdlJ2xsIHByaW50IGl0IGZpcnN0LCBhbmQgdGhlbiBwcmludCB0aGUgc3RhY2sgYWRkZW5kdW0uXG5jb25zb2xlWydlcnJvciddKGVycm9yKTsvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcbi8vIEZvciBhIG1vcmUgZGV0YWlsZWQgZGVzY3JpcHRpb24gb2YgdGhpcyBibG9jaywgc2VlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTMzODRcbn12YXIgY29tcG9uZW50TmFtZT1zb3VyY2U/Z2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihzb3VyY2UpOm51bGw7dmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlPWNvbXBvbmVudE5hbWU/XCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDxcIitjb21wb25lbnROYW1lK1wiPiBjb21wb25lbnQ6XCI6J1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzOic7dmFyIGVycm9yQm91bmRhcnlNZXNzYWdlO2lmKGJvdW5kYXJ5LnRhZz09PUhvc3RSb290KXtlcnJvckJvdW5kYXJ5TWVzc2FnZT0nQ29uc2lkZXIgYWRkaW5nIGFuIGVycm9yIGJvdW5kYXJ5IHRvIHlvdXIgdHJlZSB0byBjdXN0b21pemUgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3IuXFxuJysnVmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Vycm9yLWJvdW5kYXJpZXMgdG8gbGVhcm4gbW9yZSBhYm91dCBlcnJvciBib3VuZGFyaWVzLic7fWVsc2V7dmFyIGVycm9yQm91bmRhcnlOYW1lPWdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoYm91bmRhcnkpfHwnQW5vbnltb3VzJztlcnJvckJvdW5kYXJ5TWVzc2FnZT1cIlJlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoIFwiKyhcInVzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsIFwiK2Vycm9yQm91bmRhcnlOYW1lK1wiLlwiKTt9dmFyIGNvbWJpbmVkTWVzc2FnZT1jb21wb25lbnROYW1lTWVzc2FnZStcIlxcblwiK2NvbXBvbmVudFN0YWNrK1wiXFxuXFxuXCIrKFwiXCIrZXJyb3JCb3VuZGFyeU1lc3NhZ2UpOy8vIEluIGRldmVsb3BtZW50LCB3ZSBwcm92aWRlIG91ciBvd24gbWVzc2FnZSB3aXRoIGp1c3QgdGhlIGNvbXBvbmVudCBzdGFjay5cbi8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbi8vIGhhcyBhbHJlYWR5IHByaW50ZWQgaXQuIEV2ZW4gaWYgdGhlIGFwcGxpY2F0aW9uIHN3YWxsb3dzIHRoZSBlcnJvciwgaXQgaXMgc3RpbGxcbi8vIGRpc3BsYXllZCBieSB0aGUgYnJvd3NlciB0aGFua3MgdG8gdGhlIERFVi1vbmx5IGZha2UgZXZlbnQgdHJpY2sgaW4gUmVhY3RFcnJvclV0aWxzLlxuY29uc29sZVsnZXJyb3InXShjb21iaW5lZE1lc3NhZ2UpOy8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxufWVsc2V7Ly8gSW4gcHJvZHVjdGlvbiwgd2UgcHJpbnQgdGhlIGVycm9yIGRpcmVjdGx5LlxuLy8gVGhpcyB3aWxsIGluY2x1ZGUgdGhlIG1lc3NhZ2UsIHRoZSBKUyBzdGFjaywgYW5kIGFueXRoaW5nIHRoZSBicm93c2VyIHdhbnRzIHRvIHNob3cuXG4vLyBXZSBwYXNzIHRoZSBlcnJvciBvYmplY3QgaW5zdGVhZCBvZiBjdXN0b20gbWVzc2FnZSBzbyB0aGF0IHRoZSBicm93c2VyIGRpc3BsYXlzIHRoZSBlcnJvciBuYXRpdmVseS5cbmNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpOy8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxufX1jYXRjaChlKXsvLyBUaGlzIG1ldGhvZCBtdXN0IG5vdCB0aHJvdywgb3IgUmVhY3QgaW50ZXJuYWwgc3RhdGUgd2lsbCBnZXQgbWVzc2VkIHVwLlxuLy8gSWYgY29uc29sZS5lcnJvciBpcyBvdmVycmlkZGVuLCBvciBsb2dDYXB0dXJlZEVycm9yKCkgc2hvd3MgYSBkaWFsb2cgdGhhdCB0aHJvd3MsXG4vLyB3ZSB3YW50IHRvIHJlcG9ydCB0aGlzIGVycm9yIG91dHNpZGUgb2YgdGhlIG5vcm1hbCBzdGFjayBhcyBhIGxhc3QgcmVzb3J0LlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzE4OFxuc2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGU7fSk7fX12YXIgUG9zc2libHlXZWFrTWFwJDE9dHlwZW9mIFdlYWtNYXA9PT0nZnVuY3Rpb24nP1dlYWtNYXA6TWFwO2Z1bmN0aW9uIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShmaWJlcixlcnJvckluZm8sbGFuZSl7dmFyIHVwZGF0ZT1jcmVhdGVVcGRhdGUoTm9UaW1lc3RhbXAsbGFuZSk7Ly8gVW5tb3VudCB0aGUgcm9vdCBieSByZW5kZXJpbmcgbnVsbC5cbnVwZGF0ZS50YWc9Q2FwdHVyZVVwZGF0ZTsvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4vLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG51cGRhdGUucGF5bG9hZD17ZWxlbWVudDpudWxsfTt2YXIgZXJyb3I9ZXJyb3JJbmZvLnZhbHVlO3VwZGF0ZS5jYWxsYmFjaz1mdW5jdGlvbigpe29uVW5jYXVnaHRFcnJvcihlcnJvcik7bG9nQ2FwdHVyZWRFcnJvcihmaWJlcixlcnJvckluZm8pO307cmV0dXJuIHVwZGF0ZTt9ZnVuY3Rpb24gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlcixlcnJvckluZm8sbGFuZSl7dmFyIHVwZGF0ZT1jcmVhdGVVcGRhdGUoTm9UaW1lc3RhbXAsbGFuZSk7dXBkYXRlLnRhZz1DYXB0dXJlVXBkYXRlO3ZhciBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I9ZmliZXIudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I7aWYodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcj09PSdmdW5jdGlvbicpe3ZhciBlcnJvciQxPWVycm9ySW5mby52YWx1ZTt1cGRhdGUucGF5bG9hZD1mdW5jdGlvbigpe3JldHVybiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IkMSk7fTt1cGRhdGUuY2FsbGJhY2s9ZnVuY3Rpb24oKXt7bWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO31sb2dDYXB0dXJlZEVycm9yKGZpYmVyLGVycm9ySW5mbyk7fTt9dmFyIGluc3Q9ZmliZXIuc3RhdGVOb2RlO2lmKGluc3QhPT1udWxsJiZ0eXBlb2YgaW5zdC5jb21wb25lbnREaWRDYXRjaD09PSdmdW5jdGlvbicpe3VwZGF0ZS5jYWxsYmFjaz1mdW5jdGlvbiBjYWxsYmFjaygpe3ttYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7fWxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsZXJyb3JJbmZvKTtpZih0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIT09J2Z1bmN0aW9uJyl7Ly8gVG8gcHJlc2VydmUgdGhlIHByZWV4aXN0aW5nIHJldHJ5IGJlaGF2aW9yIG9mIGVycm9yIGJvdW5kYXJpZXMsXG4vLyB3ZSBrZWVwIHRyYWNrIG9mIHdoaWNoIG9uZXMgYWxyZWFkeSBmYWlsZWQgZHVyaW5nIHRoaXMgYmF0Y2guXG4vLyBUaGlzIGdldHMgcmVzZXQgYmVmb3JlIHdlIHlpZWxkIGJhY2sgdG8gdGhlIGJyb3dzZXIuXG4vLyBUT0RPOiBXYXJuIGluIHN0cmljdCBtb2RlIGlmIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpc1xuLy8gbm90IGRlZmluZWQuXG5tYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKHRoaXMpO312YXIgZXJyb3IkMT1lcnJvckluZm8udmFsdWU7dmFyIHN0YWNrPWVycm9ySW5mby5zdGFjazt0aGlzLmNvbXBvbmVudERpZENhdGNoKGVycm9yJDEse2NvbXBvbmVudFN0YWNrOnN0YWNrIT09bnVsbD9zdGFjazonJ30pO3tpZih0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIT09J2Z1bmN0aW9uJyl7Ly8gSWYgY29tcG9uZW50RGlkQ2F0Y2ggaXMgdGhlIG9ubHkgZXJyb3IgYm91bmRhcnkgbWV0aG9kIGRlZmluZWQsXG4vLyB0aGVuIGl0IG5lZWRzIHRvIGNhbGwgc2V0U3RhdGUgdG8gcmVjb3ZlciBmcm9tIGVycm9ycy5cbi8vIElmIG5vIHN0YXRlIHVwZGF0ZSBpcyBzY2hlZHVsZWQgdGhlbiB0aGUgYm91bmRhcnkgd2lsbCBzd2FsbG93IHRoZSBlcnJvci5cbmlmKCFpbmNsdWRlc1NvbWVMYW5lKGZpYmVyLmxhbmVzLFN5bmNMYW5lKSl7ZXJyb3IoJyVzOiBFcnJvciBib3VuZGFyaWVzIHNob3VsZCBpbXBsZW1lbnQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkuICcrJ0luIHRoYXQgbWV0aG9kLCByZXR1cm4gYSBzdGF0ZSB1cGRhdGUgdG8gZGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIG9yIGZhbGxiYWNrIFVJLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcil8fCdVbmtub3duJyk7fX19fTt9cmV0dXJuIHVwZGF0ZTt9ZnVuY3Rpb24gYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3Qsd2FrZWFibGUsbGFuZXMpey8vIEF0dGFjaCBhIHBpbmcgbGlzdGVuZXJcbi8vXG4vLyBUaGUgZGF0YSBtaWdodCByZXNvbHZlIGJlZm9yZSB3ZSBoYXZlIGEgY2hhbmNlIHRvIGNvbW1pdCB0aGUgZmFsbGJhY2suIE9yLFxuLy8gaW4gdGhlIGNhc2Ugb2YgYSByZWZyZXNoLCB3ZSdsbCBuZXZlciBjb21taXQgYSBmYWxsYmFjay4gU28gd2UgbmVlZCB0b1xuLy8gYXR0YWNoIGEgbGlzdGVuZXIgbm93LiBXaGVuIGl0IHJlc29sdmVzIChcInBpbmdzXCIpLCB3ZSBjYW4gZGVjaWRlIHdoZXRoZXIgdG9cbi8vIHRyeSByZW5kZXJpbmcgdGhlIHRyZWUgYWdhaW4uXG4vL1xuLy8gT25seSBhdHRhY2ggYSBsaXN0ZW5lciBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdCBmb3IgdGhlIGxhbmVzXG4vLyB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nICh3aGljaCBhY3RzIGxpa2UgYSBcInRocmVhZCBJRFwiIGhlcmUpLlxuLy9cbi8vIFdlIG9ubHkgbmVlZCB0byBkbyB0aGlzIGluIGNvbmN1cnJlbnQgbW9kZS4gTGVnYWN5IFN1c3BlbnNlIGFsd2F5c1xuLy8gY29tbWl0cyBmYWxsYmFja3Mgc3luY2hyb25vdXNseSwgc28gdGhlcmUgYXJlIG5vIHBpbmdzLlxudmFyIHBpbmdDYWNoZT1yb290LnBpbmdDYWNoZTt2YXIgdGhyZWFkSURzO2lmKHBpbmdDYWNoZT09PW51bGwpe3BpbmdDYWNoZT1yb290LnBpbmdDYWNoZT1uZXcgUG9zc2libHlXZWFrTWFwJDEoKTt0aHJlYWRJRHM9bmV3IFNldCgpO3BpbmdDYWNoZS5zZXQod2FrZWFibGUsdGhyZWFkSURzKTt9ZWxzZXt0aHJlYWRJRHM9cGluZ0NhY2hlLmdldCh3YWtlYWJsZSk7aWYodGhyZWFkSURzPT09dW5kZWZpbmVkKXt0aHJlYWRJRHM9bmV3IFNldCgpO3BpbmdDYWNoZS5zZXQod2FrZWFibGUsdGhyZWFkSURzKTt9fWlmKCF0aHJlYWRJRHMuaGFzKGxhbmVzKSl7Ly8gTWVtb2l6ZSB1c2luZyB0aGUgdGhyZWFkIElEIHRvIHByZXZlbnQgcmVkdW5kYW50IGxpc3RlbmVycy5cbnRocmVhZElEcy5hZGQobGFuZXMpO3ZhciBwaW5nPXBpbmdTdXNwZW5kZWRSb290LmJpbmQobnVsbCxyb290LHdha2VhYmxlLGxhbmVzKTt7aWYoaXNEZXZUb29sc1ByZXNlbnQpey8vIElmIHdlIGhhdmUgcGVuZGluZyB3b3JrIHN0aWxsLCByZXN0b3JlIHRoZSBvcmlnaW5hbCB1cGRhdGVyc1xucmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LGxhbmVzKTt9fXdha2VhYmxlLnRoZW4ocGluZyxwaW5nKTt9fWZ1bmN0aW9uIGF0dGFjaFJldHJ5TGlzdGVuZXIoc3VzcGVuc2VCb3VuZGFyeSxyb290LHdha2VhYmxlLGxhbmVzKXsvLyBSZXRyeSBsaXN0ZW5lclxuLy9cbi8vIElmIHRoZSBmYWxsYmFjayBkb2VzIGNvbW1pdCwgd2UgbmVlZCB0byBhdHRhY2ggYSBkaWZmZXJlbnQgdHlwZSBvZlxuLy8gbGlzdGVuZXIuIFRoaXMgb25lIHNjaGVkdWxlcyBhbiB1cGRhdGUgb24gdGhlIFN1c3BlbnNlIGJvdW5kYXJ5IHRvIHR1cm5cbi8vIHRoZSBmYWxsYmFjayBzdGF0ZSBvZmYuXG4vL1xuLy8gU3Rhc2ggdGhlIHdha2VhYmxlIG9uIHRoZSBib3VuZGFyeSBmaWJlciBzbyB3ZSBjYW4gYWNjZXNzIGl0IGluIHRoZVxuLy8gY29tbWl0IHBoYXNlLlxuLy9cbi8vIFdoZW4gdGhlIHdha2VhYmxlIHJlc29sdmVzLCB3ZSdsbCBhdHRlbXB0IHRvIHJlbmRlciB0aGUgYm91bmRhcnlcbi8vIGFnYWluIChcInJldHJ5XCIpLlxudmFyIHdha2VhYmxlcz1zdXNwZW5zZUJvdW5kYXJ5LnVwZGF0ZVF1ZXVlO2lmKHdha2VhYmxlcz09PW51bGwpe3ZhciB1cGRhdGVRdWV1ZT1uZXcgU2V0KCk7dXBkYXRlUXVldWUuYWRkKHdha2VhYmxlKTtzdXNwZW5zZUJvdW5kYXJ5LnVwZGF0ZVF1ZXVlPXVwZGF0ZVF1ZXVlO31lbHNle3dha2VhYmxlcy5hZGQod2FrZWFibGUpO319ZnVuY3Rpb24gcmVzZXRTdXNwZW5kZWRDb21wb25lbnQoc291cmNlRmliZXIscm9vdFJlbmRlckxhbmVzKXsvLyBBIGxlZ2FjeSBtb2RlIFN1c3BlbnNlIHF1aXJrLCBvbmx5IHJlbGV2YW50IHRvIGhvb2sgY29tcG9uZW50cy5cbnZhciB0YWc9c291cmNlRmliZXIudGFnO2lmKChzb3VyY2VGaWJlci5tb2RlJkNvbmN1cnJlbnRNb2RlKT09PU5vTW9kZSYmKHRhZz09PUZ1bmN0aW9uQ29tcG9uZW50fHx0YWc9PT1Gb3J3YXJkUmVmfHx0YWc9PT1TaW1wbGVNZW1vQ29tcG9uZW50KSl7dmFyIGN1cnJlbnRTb3VyY2U9c291cmNlRmliZXIuYWx0ZXJuYXRlO2lmKGN1cnJlbnRTb3VyY2Upe3NvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlPWN1cnJlbnRTb3VyY2UudXBkYXRlUXVldWU7c291cmNlRmliZXIubWVtb2l6ZWRTdGF0ZT1jdXJyZW50U291cmNlLm1lbW9pemVkU3RhdGU7c291cmNlRmliZXIubGFuZXM9Y3VycmVudFNvdXJjZS5sYW5lczt9ZWxzZXtzb3VyY2VGaWJlci51cGRhdGVRdWV1ZT1udWxsO3NvdXJjZUZpYmVyLm1lbW9pemVkU3RhdGU9bnVsbDt9fX1mdW5jdGlvbiBnZXROZWFyZXN0U3VzcGVuc2VCb3VuZGFyeVRvQ2FwdHVyZShyZXR1cm5GaWJlcil7dmFyIG5vZGU9cmV0dXJuRmliZXI7ZG97aWYobm9kZS50YWc9PT1TdXNwZW5zZUNvbXBvbmVudCYmc2hvdWxkQ2FwdHVyZVN1c3BlbnNlKG5vZGUpKXtyZXR1cm4gbm9kZTt9Ly8gVGhpcyBib3VuZGFyeSBhbHJlYWR5IGNhcHR1cmVkIGR1cmluZyB0aGlzIHJlbmRlci4gQ29udGludWUgdG8gdGhlIG5leHRcbi8vIGJvdW5kYXJ5Llxubm9kZT1ub2RlLnJldHVybjt9d2hpbGUobm9kZSE9PW51bGwpO3JldHVybiBudWxsO31mdW5jdGlvbiBtYXJrU3VzcGVuc2VCb3VuZGFyeVNob3VsZENhcHR1cmUoc3VzcGVuc2VCb3VuZGFyeSxyZXR1cm5GaWJlcixzb3VyY2VGaWJlcixyb290LHJvb3RSZW5kZXJMYW5lcyl7Ly8gVGhpcyBtYXJrcyBhIFN1c3BlbnNlIGJvdW5kYXJ5IHNvIHRoYXQgd2hlbiB3ZSdyZSB1bndpbmRpbmcgdGhlIHN0YWNrLFxuLy8gaXQgY2FwdHVyZXMgdGhlIHN1c3BlbmRlZCBcImV4Y2VwdGlvblwiIGFuZCBkb2VzIGEgc2Vjb25kIChmYWxsYmFjaykgcGFzcy5cbmlmKChzdXNwZW5zZUJvdW5kYXJ5Lm1vZGUmQ29uY3VycmVudE1vZGUpPT09Tm9Nb2RlKXsvLyBMZWdhY3kgTW9kZSBTdXNwZW5zZVxuLy9cbi8vIElmIHRoZSBib3VuZGFyeSBpcyBpbiBsZWdhY3kgbW9kZSwgd2Ugc2hvdWxkICpub3QqXG4vLyBzdXNwZW5kIHRoZSBjb21taXQuIFByZXRlbmQgYXMgaWYgdGhlIHN1c3BlbmRlZCBjb21wb25lbnQgcmVuZGVyZWRcbi8vIG51bGwgYW5kIGtlZXAgcmVuZGVyaW5nLiBXaGVuIHRoZSBTdXNwZW5zZSBib3VuZGFyeSBjb21wbGV0ZXMsXG4vLyB3ZSdsbCBkbyBhIHNlY29uZCBwYXNzIHRvIHJlbmRlciB0aGUgZmFsbGJhY2suXG5pZihzdXNwZW5zZUJvdW5kYXJ5PT09cmV0dXJuRmliZXIpey8vIFNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBzdXNwZW5kZWQgd2hpbGUgcmVjb25jaWxpbmcgdGhlIGNoaWxkcmVuIG9mXG4vLyBhIFN1c3BlbnNlIGJvdW5kYXJ5J3MgaW5uZXIgT2Zmc2NyZWVuIHdyYXBwZXIgZmliZXIuIFRoaXMgaGFwcGVuc1xuLy8gd2hlbiBhIFJlYWN0LmxhenkgY29tcG9uZW50IGlzIGEgZGlyZWN0IGNoaWxkIG9mIGFcbi8vIFN1c3BlbnNlIGJvdW5kYXJ5LlxuLy9cbi8vIFN1c3BlbnNlIGJvdW5kYXJpZXMgYXJlIGltcGxlbWVudGVkIGFzIG11bHRpcGxlIGZpYmVycywgYnV0IHRoZXlcbi8vIGFyZSBhIHNpbmdsZSBjb25jZXB0dWFsIHVuaXQuIFRoZSBsZWdhY3kgbW9kZSBiZWhhdmlvciB3aGVyZSB3ZVxuLy8gcHJldGVuZCB0aGUgc3VzcGVuZGVkIGZpYmVyIGNvbW1pdHRlZCBhcyBgbnVsbGAgd29uJ3Qgd29yayxcbi8vIGJlY2F1c2UgaW4gdGhpcyBjYXNlIHRoZSBcInN1c3BlbmRlZFwiIGZpYmVyIGlzIHRoZSBpbm5lclxuLy8gT2Zmc2NyZWVuIHdyYXBwZXIuXG4vL1xuLy8gQmVjYXVzZSB0aGUgY29udGVudHMgb2YgdGhlIGJvdW5kYXJ5IGhhdmVuJ3Qgc3RhcnRlZCByZW5kZXJpbmdcbi8vIHlldCAoaS5lLiBub3RoaW5nIGluIHRoZSB0cmVlIGhhcyBwYXJ0aWFsbHkgcmVuZGVyZWQpIHdlIGNhblxuLy8gc3dpdGNoIHRvIHRoZSByZWd1bGFyLCBjb25jdXJyZW50IG1vZGUgYmVoYXZpb3I6IG1hcmsgdGhlXG4vLyBib3VuZGFyeSB3aXRoIFNob3VsZENhcHR1cmUgYW5kIGVudGVyIHRoZSB1bndpbmQgcGhhc2UuXG5zdXNwZW5zZUJvdW5kYXJ5LmZsYWdzfD1TaG91bGRDYXB0dXJlO31lbHNle3N1c3BlbnNlQm91bmRhcnkuZmxhZ3N8PURpZENhcHR1cmU7c291cmNlRmliZXIuZmxhZ3N8PUZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2U7Ly8gV2UncmUgZ29pbmcgdG8gY29tbWl0IHRoaXMgZmliZXIgZXZlbiB0aG91Z2ggaXQgZGlkbid0IGNvbXBsZXRlLlxuLy8gQnV0IHdlIHNob3VsZG4ndCBjYWxsIGFueSBsaWZlY3ljbGUgbWV0aG9kcyBvciBjYWxsYmFja3MuIFJlbW92ZVxuLy8gYWxsIGxpZmVjeWNsZSBlZmZlY3QgdGFncy5cbnNvdXJjZUZpYmVyLmZsYWdzJj1+KExpZmVjeWNsZUVmZmVjdE1hc2t8SW5jb21wbGV0ZSk7aWYoc291cmNlRmliZXIudGFnPT09Q2xhc3NDb21wb25lbnQpe3ZhciBjdXJyZW50U291cmNlRmliZXI9c291cmNlRmliZXIuYWx0ZXJuYXRlO2lmKGN1cnJlbnRTb3VyY2VGaWJlcj09PW51bGwpey8vIFRoaXMgaXMgYSBuZXcgbW91bnQuIENoYW5nZSB0aGUgdGFnIHNvIGl0J3Mgbm90IG1pc3Rha2VuIGZvciBhXG4vLyBjb21wbGV0ZWQgY2xhc3MgY29tcG9uZW50LiBGb3IgZXhhbXBsZSwgd2Ugc2hvdWxkIG5vdCBjYWxsXG4vLyBjb21wb25lbnRXaWxsVW5tb3VudCBpZiBpdCBpcyBkZWxldGVkLlxuc291cmNlRmliZXIudGFnPUluY29tcGxldGVDbGFzc0NvbXBvbmVudDt9ZWxzZXsvLyBXaGVuIHdlIHRyeSByZW5kZXJpbmcgYWdhaW4sIHdlIHNob3VsZCBub3QgcmV1c2UgdGhlIGN1cnJlbnQgZmliZXIsXG4vLyBzaW5jZSBpdCdzIGtub3duIHRvIGJlIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gVXNlIGEgZm9yY2UgdXBkYXRlIHRvXG4vLyBwcmV2ZW50IGEgYmFpbCBvdXQuXG52YXIgdXBkYXRlPWNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCxTeW5jTGFuZSk7dXBkYXRlLnRhZz1Gb3JjZVVwZGF0ZTtlbnF1ZXVlVXBkYXRlKHNvdXJjZUZpYmVyLHVwZGF0ZSxTeW5jTGFuZSk7fX0vLyBUaGUgc291cmNlIGZpYmVyIGRpZCBub3QgY29tcGxldGUuIE1hcmsgaXQgd2l0aCBTeW5jIHByaW9yaXR5IHRvXG4vLyBpbmRpY2F0ZSB0aGF0IGl0IHN0aWxsIGhhcyBwZW5kaW5nIHdvcmsuXG5zb3VyY2VGaWJlci5sYW5lcz1tZXJnZUxhbmVzKHNvdXJjZUZpYmVyLmxhbmVzLFN5bmNMYW5lKTt9cmV0dXJuIHN1c3BlbnNlQm91bmRhcnk7fS8vIENvbmZpcm1lZCB0aGF0IHRoZSBib3VuZGFyeSBpcyBpbiBhIGNvbmN1cnJlbnQgbW9kZSB0cmVlLiBDb250aW51ZVxuLy8gd2l0aCB0aGUgbm9ybWFsIHN1c3BlbmQgcGF0aC5cbi8vXG4vLyBBZnRlciB0aGlzIHdlJ2xsIHVzZSBhIHNldCBvZiBoZXVyaXN0aWNzIHRvIGRldGVybWluZSB3aGV0aGVyIHRoaXNcbi8vIHJlbmRlciBwYXNzIHdpbGwgcnVuIHRvIGNvbXBsZXRpb24gb3IgcmVzdGFydCBvciBcInN1c3BlbmRcIiB0aGUgY29tbWl0LlxuLy8gVGhlIGFjdHVhbCBsb2dpYyBmb3IgdGhpcyBpcyBzcHJlYWQgb3V0IGluIGRpZmZlcmVudCBwbGFjZXMuXG4vL1xuLy8gVGhpcyBmaXJzdCBwcmluY2lwbGUgaXMgdGhhdCBpZiB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdoZW4gd2UgY29tcGxldGVcbi8vIGEgcm9vdCwgdGhlbiB3ZSBzaG91bGQgYWxzbyByZXN0YXJ0IGlmIHdlIGdldCBhbiB1cGRhdGUgb3IgcGluZyB0aGF0XG4vLyBtaWdodCB1bnN1c3BlbmQgaXQsIGFuZCB2aWNlIHZlcnNhLiBUaGUgb25seSByZWFzb24gdG8gc3VzcGVuZCBpc1xuLy8gYmVjYXVzZSB5b3UgdGhpbmsgeW91IG1pZ2h0IHdhbnQgdG8gcmVzdGFydCBiZWZvcmUgY29tbWl0dGluZy4gSG93ZXZlcixcbi8vIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byByZXN0YXJ0IG9ubHkgd2hpbGUgaW4gdGhlIHBlcmlvZCB3ZSdyZSBzdXNwZW5kZWQuXG4vL1xuLy8gUmVzdGFydGluZyB0b28gYWdncmVzc2l2ZWx5IGlzIGFsc28gbm90IGdvb2QgYmVjYXVzZSBpdCBzdGFydmVzIG91dCBhbnlcbi8vIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBTbyB3ZSB1c2UgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hlbi5cbi8vIFN1c3BlbnNlIEhldXJpc3RpY3Ncbi8vXG4vLyBJZiBub3RoaW5nIHRocmV3IGEgUHJvbWlzZSBvciBhbGwgdGhlIHNhbWUgZmFsbGJhY2tzIGFyZSBhbHJlYWR5IHNob3dpbmcsXG4vLyB0aGVuIGRvbid0IHN1c3BlbmQvcmVzdGFydC5cbi8vXG4vLyBJZiB0aGlzIGlzIGFuIGluaXRpYWwgcmVuZGVyIG9mIGEgbmV3IHRyZWUgb2YgU3VzcGVuc2UgYm91bmRhcmllcyBhbmRcbi8vIHRob3NlIHRyaWdnZXIgYSBmYWxsYmFjaywgdGhlbiBkb24ndCBzdXNwZW5kL3Jlc3RhcnQuIFdlIHdhbnQgdG8gZW5zdXJlXG4vLyB0aGF0IHdlIGNhbiBzaG93IHRoZSBpbml0aWFsIGxvYWRpbmcgc3RhdGUgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS5cbi8vXG4vLyBJZiB3ZSBoaXQgYSBcIkRlbGF5ZWRcIiBjYXNlLCBzdWNoIGFzIHdoZW4gd2UnZCBzd2l0Y2ggZnJvbSBjb250ZW50IGJhY2sgaW50b1xuLy8gYSBmYWxsYmFjaywgdGhlbiB3ZSBzaG91bGQgYWx3YXlzIHN1c3BlbmQvcmVzdGFydC4gVHJhbnNpdGlvbnMgYXBwbHlcbi8vIHRvIHRoaXMgY2FzZS4gSWYgbm9uZSBpcyBkZWZpbmVkLCBKTkQgaXMgdXNlZCBpbnN0ZWFkLlxuLy9cbi8vIElmIHdlJ3JlIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIGFuZCBpdCBnZXRzIFwicmV0cmllZFwiLCBhbGxvd2luZyB1cyB0byBzaG93XG4vLyBhbm90aGVyIGxldmVsLCBidXQgdGhlcmUncyBzdGlsbCBhbiBpbm5lciBib3VuZGFyeSB0aGF0IHdvdWxkIHNob3cgYSBmYWxsYmFjayxcbi8vIHRoZW4gd2Ugc3VzcGVuZC9yZXN0YXJ0IGZvciA1MDBtcyBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlIHNob3dlZCBhIGZhbGxiYWNrXG4vLyBhbnl3aGVyZSBpbiB0aGUgdHJlZS4gVGhpcyBlZmZlY3RpdmVseSB0aHJvdHRsZXMgcHJvZ3Jlc3NpdmUgbG9hZGluZyBpbnRvIGFcbi8vIGNvbnNpc3RlbnQgdHJhaW4gb2YgY29tbWl0cy4gVGhpcyBhbHNvIGdpdmVzIHVzIGFuIG9wcG9ydHVuaXR5IHRvIHJlc3RhcnQgdG9cbi8vIGdldCB0byB0aGUgY29tcGxldGVkIHN0YXRlIHNsaWdodGx5IGVhcmxpZXIuXG4vL1xuLy8gSWYgdGhlcmUncyBhbWJpZ3VpdHkgZHVlIHRvIGJhdGNoaW5nIGl0J3MgcmVzb2x2ZWQgaW4gcHJlZmVyZW5jZSBvZjpcbi8vIDEpIFwiZGVsYXllZFwiLCAyKSBcImluaXRpYWwgcmVuZGVyXCIsIDMpIFwicmV0cnlcIi5cbi8vXG4vLyBXZSB3YW50IHRvIGVuc3VyZSB0aGF0IGEgXCJidXN5XCIgc3RhdGUgZG9lc24ndCBnZXQgZm9yY2UgY29tbWl0dGVkLiBXZSB3YW50IHRvXG4vLyBlbnN1cmUgdGhhdCBuZXcgaW5pdGlhbCBsb2FkaW5nIHN0YXRlcyBjYW4gY29tbWl0IGFzIHNvb24gYXMgcG9zc2libGUuXG5zdXNwZW5zZUJvdW5kYXJ5LmZsYWdzfD1TaG91bGRDYXB0dXJlOy8vIFRPRE86IEkgdGhpbmsgd2UgY2FuIHJlbW92ZSB0aGlzLCBzaW5jZSB3ZSBub3cgdXNlIGBEaWRDYXB0dXJlYCBpblxuLy8gdGhlIGJlZ2luIHBoYXNlIHRvIHByZXZlbnQgYW4gZWFybHkgYmFpbG91dC5cbnN1c3BlbnNlQm91bmRhcnkubGFuZXM9cm9vdFJlbmRlckxhbmVzO3JldHVybiBzdXNwZW5zZUJvdW5kYXJ5O31mdW5jdGlvbiB0aHJvd0V4Y2VwdGlvbihyb290LHJldHVybkZpYmVyLHNvdXJjZUZpYmVyLHZhbHVlLHJvb3RSZW5kZXJMYW5lcyl7Ly8gVGhlIHNvdXJjZSBmaWJlciBkaWQgbm90IGNvbXBsZXRlLlxuc291cmNlRmliZXIuZmxhZ3N8PUluY29tcGxldGU7e2lmKGlzRGV2VG9vbHNQcmVzZW50KXsvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnNcbnJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCxyb290UmVuZGVyTGFuZXMpO319aWYodmFsdWUhPT1udWxsJiZ0eXBlb2YgdmFsdWU9PT0nb2JqZWN0JyYmdHlwZW9mIHZhbHVlLnRoZW49PT0nZnVuY3Rpb24nKXsvLyBUaGlzIGlzIGEgd2FrZWFibGUuIFRoZSBjb21wb25lbnQgc3VzcGVuZGVkLlxudmFyIHdha2VhYmxlPXZhbHVlO3Jlc2V0U3VzcGVuZGVkQ29tcG9uZW50KHNvdXJjZUZpYmVyKTt7aWYoZ2V0SXNIeWRyYXRpbmcoKSYmc291cmNlRmliZXIubW9kZSZDb25jdXJyZW50TW9kZSl7bWFya0RpZFRocm93V2hpbGVIeWRyYXRpbmdERVYoKTt9fXZhciBzdXNwZW5zZUJvdW5kYXJ5PWdldE5lYXJlc3RTdXNwZW5zZUJvdW5kYXJ5VG9DYXB0dXJlKHJldHVybkZpYmVyKTtpZihzdXNwZW5zZUJvdW5kYXJ5IT09bnVsbCl7c3VzcGVuc2VCb3VuZGFyeS5mbGFncyY9fkZvcmNlQ2xpZW50UmVuZGVyO21hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShzdXNwZW5zZUJvdW5kYXJ5LHJldHVybkZpYmVyLHNvdXJjZUZpYmVyLHJvb3Qscm9vdFJlbmRlckxhbmVzKTsvLyBXZSBvbmx5IGF0dGFjaCBwaW5nIGxpc3RlbmVycyBpbiBjb25jdXJyZW50IG1vZGUuIExlZ2FjeSBTdXNwZW5zZSBhbHdheXNcbi8vIGNvbW1pdHMgZmFsbGJhY2tzIHN5bmNocm9ub3VzbHksIHNvIHRoZXJlIGFyZSBubyBwaW5ncy5cbmlmKHN1c3BlbnNlQm91bmRhcnkubW9kZSZDb25jdXJyZW50TW9kZSl7YXR0YWNoUGluZ0xpc3RlbmVyKHJvb3Qsd2FrZWFibGUscm9vdFJlbmRlckxhbmVzKTt9YXR0YWNoUmV0cnlMaXN0ZW5lcihzdXNwZW5zZUJvdW5kYXJ5LHJvb3Qsd2FrZWFibGUpO3JldHVybjt9ZWxzZXsvLyBObyBib3VuZGFyeSB3YXMgZm91bmQuIFVubGVzcyB0aGlzIGlzIGEgc3luYyB1cGRhdGUsIHRoaXMgaXMgT0suXG4vLyBXZSBjYW4gc3VzcGVuZCBhbmQgd2FpdCBmb3IgbW9yZSBkYXRhIHRvIGFycml2ZS5cbmlmKCFpbmNsdWRlc1N5bmNMYW5lKHJvb3RSZW5kZXJMYW5lcykpey8vIFRoaXMgaXMgbm90IGEgc3luYyB1cGRhdGUuIFN1c3BlbmQuIFNpbmNlIHdlJ3JlIG5vdCBhY3RpdmF0aW5nIGFcbi8vIFN1c3BlbnNlIGJvdW5kYXJ5LCB0aGlzIHdpbGwgdW53aW5kIGFsbCB0aGUgd2F5IHRvIHRoZSByb290IHdpdGhvdXRcbi8vIHBlcmZvcm1pbmcgYSBzZWNvbmQgcGFzcyB0byByZW5kZXIgYSBmYWxsYmFjay4gKFRoaXMgaXMgYXJndWFibHkgaG93XG4vLyByZWZyZXNoIHRyYW5zaXRpb25zIHNob3VsZCB3b3JrLCB0b28sIHNpbmNlIHdlJ3JlIG5vdCBnb2luZyB0byBjb21taXRcbi8vIHRoZSBmYWxsYmFja3MgYW55d2F5Lilcbi8vXG4vLyBUaGlzIGNhc2UgYWxzbyBhcHBsaWVzIHRvIGluaXRpYWwgaHlkcmF0aW9uLlxuYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3Qsd2FrZWFibGUscm9vdFJlbmRlckxhbmVzKTtyZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7cmV0dXJuO30vLyBUaGlzIGlzIGEgc3luYy9kaXNjcmV0ZSB1cGRhdGUuIFdlIHRyZWF0IHRoaXMgY2FzZSBsaWtlIGFuIGVycm9yXG4vLyBiZWNhdXNlIGRpc2NyZXRlIHJlbmRlcnMgYXJlIGV4cGVjdGVkIHRvIHByb2R1Y2UgYSBjb21wbGV0ZSB0cmVlXG4vLyBzeW5jaHJvbm91c2x5IHRvIG1haW50YWluIGNvbnNpc3RlbmN5IHdpdGggZXh0ZXJuYWwgc3RhdGUuXG52YXIgdW5jYXVnaHRTdXNwZW5zZUVycm9yPW5ldyBFcnJvcignQSBjb21wb25lbnQgc3VzcGVuZGVkIHdoaWxlIHJlc3BvbmRpbmcgdG8gc3luY2hyb25vdXMgaW5wdXQuIFRoaXMgJysnd2lsbCBjYXVzZSB0aGUgVUkgdG8gYmUgcmVwbGFjZWQgd2l0aCBhIGxvYWRpbmcgaW5kaWNhdG9yLiBUbyAnKydmaXgsIHVwZGF0ZXMgdGhhdCBzdXNwZW5kIHNob3VsZCBiZSB3cmFwcGVkICcrJ3dpdGggc3RhcnRUcmFuc2l0aW9uLicpOy8vIElmIHdlJ3JlIG91dHNpZGUgYSB0cmFuc2l0aW9uLCBmYWxsIHRocm91Z2ggdG8gdGhlIHJlZ3VsYXIgZXJyb3IgcGF0aC5cbi8vIFRoZSBlcnJvciB3aWxsIGJlIGNhdWdodCBieSB0aGUgbmVhcmVzdCBzdXNwZW5zZSBib3VuZGFyeS5cbnZhbHVlPXVuY2F1Z2h0U3VzcGVuc2VFcnJvcjt9fWVsc2V7Ly8gVGhpcyBpcyBhIHJlZ3VsYXIgZXJyb3IsIG5vdCBhIFN1c3BlbnNlIHdha2VhYmxlLlxuaWYoZ2V0SXNIeWRyYXRpbmcoKSYmc291cmNlRmliZXIubW9kZSZDb25jdXJyZW50TW9kZSl7bWFya0RpZFRocm93V2hpbGVIeWRyYXRpbmdERVYoKTt2YXIgX3N1c3BlbnNlQm91bmRhcnk9Z2V0TmVhcmVzdFN1c3BlbnNlQm91bmRhcnlUb0NhcHR1cmUocmV0dXJuRmliZXIpOy8vIElmIHRoZSBlcnJvciB3YXMgdGhyb3duIGR1cmluZyBoeWRyYXRpb24sIHdlIG1heSBiZSBhYmxlIHRvIHJlY292ZXIgYnlcbi8vIGRpc2NhcmRpbmcgdGhlIGRlaHlkcmF0ZWQgY29udGVudCBhbmQgc3dpdGNoaW5nIHRvIGEgY2xpZW50IHJlbmRlci5cbi8vIEluc3RlYWQgb2Ygc3VyZmFjaW5nIHRoZSBlcnJvciwgZmluZCB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeVxuLy8gYW5kIHJlbmRlciBpdCBhZ2FpbiB3aXRob3V0IGh5ZHJhdGlvbi5cbmlmKF9zdXNwZW5zZUJvdW5kYXJ5IT09bnVsbCl7aWYoKF9zdXNwZW5zZUJvdW5kYXJ5LmZsYWdzJlNob3VsZENhcHR1cmUpPT09Tm9GbGFncyl7Ly8gU2V0IGEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IHdlIHNob3VsZCB0cnkgcmVuZGVyaW5nIHRoZSBub3JtYWxcbi8vIGNoaWxkcmVuIGFnYWluLCBub3QgdGhlIGZhbGxiYWNrLlxuX3N1c3BlbnNlQm91bmRhcnkuZmxhZ3N8PUZvcmNlQ2xpZW50UmVuZGVyO31tYXJrU3VzcGVuc2VCb3VuZGFyeVNob3VsZENhcHR1cmUoX3N1c3BlbnNlQm91bmRhcnkscmV0dXJuRmliZXIsc291cmNlRmliZXIscm9vdCxyb290UmVuZGVyTGFuZXMpOy8vIEV2ZW4gdGhvdWdoIHRoZSB1c2VyIG1heSBub3QgYmUgYWZmZWN0ZWQgYnkgdGhpcyBlcnJvciwgd2Ugc2hvdWxkXG4vLyBzdGlsbCBsb2cgaXQgc28gaXQgY2FuIGJlIGZpeGVkLlxucXVldWVIeWRyYXRpb25FcnJvcihjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSxzb3VyY2VGaWJlcikpO3JldHVybjt9fX12YWx1ZT1jcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSxzb3VyY2VGaWJlcik7cmVuZGVyRGlkRXJyb3IodmFsdWUpOy8vIFdlIGRpZG4ndCBmaW5kIGEgYm91bmRhcnkgdGhhdCBjb3VsZCBoYW5kbGUgdGhpcyB0eXBlIG9mIGV4Y2VwdGlvbi4gU3RhcnRcbi8vIG92ZXIgYW5kIHRyYXZlcnNlIHBhcmVudCBwYXRoIGFnYWluLCB0aGlzIHRpbWUgdHJlYXRpbmcgdGhlIGV4Y2VwdGlvblxuLy8gYXMgYW4gZXJyb3IuXG52YXIgd29ya0luUHJvZ3Jlc3M9cmV0dXJuRmliZXI7ZG97c3dpdGNoKHdvcmtJblByb2dyZXNzLnRhZyl7Y2FzZSBIb3N0Um9vdDp7dmFyIF9lcnJvckluZm89dmFsdWU7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVNob3VsZENhcHR1cmU7dmFyIGxhbmU9cGlja0FyYml0cmFyeUxhbmUocm9vdFJlbmRlckxhbmVzKTt3b3JrSW5Qcm9ncmVzcy5sYW5lcz1tZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLGxhbmUpO3ZhciB1cGRhdGU9Y3JlYXRlUm9vdEVycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLF9lcnJvckluZm8sbGFuZSk7ZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLHVwZGF0ZSk7cmV0dXJuO31jYXNlIENsYXNzQ29tcG9uZW50Oi8vIENhcHR1cmUgYW5kIHJldHJ5XG52YXIgZXJyb3JJbmZvPXZhbHVlO3ZhciBjdG9yPXdvcmtJblByb2dyZXNzLnR5cGU7dmFyIGluc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtpZigod29ya0luUHJvZ3Jlc3MuZmxhZ3MmRGlkQ2FwdHVyZSk9PT1Ob0ZsYWdzJiYodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yPT09J2Z1bmN0aW9uJ3x8aW5zdGFuY2UhPT1udWxsJiZ0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2g9PT0nZnVuY3Rpb24nJiYhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9U2hvdWxkQ2FwdHVyZTt2YXIgX2xhbmU9cGlja0FyYml0cmFyeUxhbmUocm9vdFJlbmRlckxhbmVzKTt3b3JrSW5Qcm9ncmVzcy5sYW5lcz1tZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLF9sYW5lKTsvLyBTY2hlZHVsZSB0aGUgZXJyb3IgYm91bmRhcnkgdG8gcmUtcmVuZGVyIHVzaW5nIHVwZGF0ZWQgc3RhdGVcbnZhciBfdXBkYXRlPWNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUod29ya0luUHJvZ3Jlc3MsZXJyb3JJbmZvLF9sYW5lKTtlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsX3VwZGF0ZSk7cmV0dXJuO31icmVhazt9d29ya0luUHJvZ3Jlc3M9d29ya0luUHJvZ3Jlc3MucmV0dXJuO313aGlsZSh3b3JrSW5Qcm9ncmVzcyE9PW51bGwpO31mdW5jdGlvbiBnZXRTdXNwZW5kZWRDYWNoZSgpe3tyZXR1cm4gbnVsbDt9Ly8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhIFN1c3BlbnNlIGJvdW5kYXJ5IHN1c3BlbmRzLiBJdCByZXR1cm5zIHRoZVxufXZhciBSZWFjdEN1cnJlbnRPd25lciQxPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO3ZhciBkaWRSZWNlaXZlVXBkYXRlPWZhbHNlO3ZhciBkaWRXYXJuQWJvdXRCYWRDbGFzczt2YXIgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudDt2YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50O3ZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50O3ZhciBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnM7dmFyIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHM7dmFyIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyO3ZhciBkaWRXYXJuQWJvdXRUYWlsT3B0aW9uczt2YXIgZGlkV2FybkFib3V0RGVmYXVsdFByb3BzT25GdW5jdGlvbkNvbXBvbmVudDt7ZGlkV2FybkFib3V0QmFkQ2xhc3M9e307ZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudD17fTtkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQ9e307ZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudD17fTtkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnM9e307ZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcz1mYWxzZTtkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcj17fTtkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucz17fTtkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50PXt9O31mdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyl7aWYoY3VycmVudD09PW51bGwpey8vIElmIHRoaXMgaXMgYSBmcmVzaCBuZXcgY29tcG9uZW50IHRoYXQgaGFzbid0IGJlZW4gcmVuZGVyZWQgeWV0LCB3ZVxuLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4vLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbi8vIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIHJlY29uY2lsaWF0aW9uIHBhc3MgYnkgbm90IHRyYWNraW5nIHNpZGUtZWZmZWN0cy5cbndvcmtJblByb2dyZXNzLmNoaWxkPW1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsbnVsbCxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpO31lbHNley8vIElmIHRoZSBjdXJyZW50IGNoaWxkIGlzIHRoZSBzYW1lIGFzIHRoZSB3b3JrIGluIHByb2dyZXNzLCBpdCBtZWFucyB0aGF0XG4vLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cbi8vIElmIHdlIGhhZCBhbnkgcHJvZ3Jlc3NlZCB3b3JrIGFscmVhZHksIHRoYXQgaXMgaW52YWxpZCBhdCB0aGlzIHBvaW50IHNvXG4vLyBsZXQncyB0aHJvdyBpdCBvdXQuXG53b3JrSW5Qcm9ncmVzcy5jaGlsZD1yZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcyxjdXJyZW50LmNoaWxkLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7fX1mdW5jdGlvbiBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKXsvLyBUaGlzIGZ1bmN0aW9uIGlzIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW4uIEl0J3MgdXNlZCBpbiBjYXNlcyB3aGVyZSB3ZVxuLy8gd2FudCB0byByZWNvbmNpbGUgd2l0aG91dCBtYXRjaGluZyBhZ2FpbnN0IHRoZSBleGlzdGluZyBzZXQuIFRoaXMgaGFzIHRoZVxuLy8gZWZmZWN0IG9mIGFsbCBjdXJyZW50IGNoaWxkcmVuIGJlaW5nIHVubW91bnRlZDsgZXZlbiBpZiB0aGUgdHlwZSBhbmQga2V5XG4vLyBhcmUgdGhlIHNhbWUsIHRoZSBvbGQgY2hpbGQgaXMgdW5tb3VudGVkIGFuZCBhIG5ldyBjaGlsZCBpcyBjcmVhdGVkLlxuLy9cbi8vIFRvIGRvIHRoaXMsIHdlJ3JlIGdvaW5nIHRvIGdvIHRocm91Z2ggdGhlIHJlY29uY2lsZSBhbGdvcml0aG0gdHdpY2UuIEluXG4vLyB0aGUgZmlyc3QgcGFzcywgd2Ugc2NoZWR1bGUgYSBkZWxldGlvbiBmb3IgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuIGJ5XG4vLyBwYXNzaW5nIG51bGwuXG53b3JrSW5Qcm9ncmVzcy5jaGlsZD1yZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcyxjdXJyZW50LmNoaWxkLG51bGwscmVuZGVyTGFuZXMpOy8vIEluIHRoZSBzZWNvbmQgcGFzcywgd2UgbW91bnQgdGhlIG5ldyBjaGlsZHJlbi4gVGhlIHRyaWNrIGhlcmUgaXMgdGhhdCB3ZVxuLy8gcGFzcyBudWxsIGluIHBsYWNlIG9mIHdoZXJlIHdlIHVzdWFsbHkgcGFzcyB0aGUgY3VycmVudCBjaGlsZCBzZXQuIFRoaXMgaGFzXG4vLyB0aGUgZWZmZWN0IG9mIHJlbW91bnRpbmcgYWxsIGNoaWxkcmVuIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGVpclxuLy8gaWRlbnRpdGllcyBtYXRjaC5cbndvcmtJblByb2dyZXNzLmNoaWxkPXJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLG51bGwsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTt9ZnVuY3Rpb24gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50LHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxuZXh0UHJvcHMscmVuZGVyTGFuZXMpey8vIFRPRE86IGN1cnJlbnQgY2FuIGJlIG5vbi1udWxsIGhlcmUgZXZlbiBpZiB0aGUgY29tcG9uZW50XG4vLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgZmlyc3QgcmVuZGVyIHN1c3BlbmRzLlxuLy8gV2UnbGwgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoaXMgaXMgZmluZSBvciBjYW4gY2F1c2UgaXNzdWVzLlxue2lmKHdvcmtJblByb2dyZXNzLnR5cGUhPT13b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSl7Ly8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbi8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbnZhciBpbm5lclByb3BUeXBlcz1Db21wb25lbnQucHJvcFR5cGVzO2lmKGlubmVyUHJvcFR5cGVzKXtjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcyxuZXh0UHJvcHMsLy8gUmVzb2x2ZWQgcHJvcHNcbidwcm9wJyxnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSk7fX19dmFyIHJlbmRlcj1Db21wb25lbnQucmVuZGVyO3ZhciByZWY9d29ya0luUHJvZ3Jlc3MucmVmOy8vIFRoZSByZXN0IGlzIGEgZm9yayBvZiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudFxudmFyIG5leHRDaGlsZHJlbjt2YXIgaGFzSWQ7cHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO3ttYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7fXtSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQ9d29ya0luUHJvZ3Jlc3M7c2V0SXNSZW5kZXJpbmcodHJ1ZSk7bmV4dENoaWxkcmVuPXJlbmRlcldpdGhIb29rcyhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlcixuZXh0UHJvcHMscmVmLHJlbmRlckxhbmVzKTtoYXNJZD1jaGVja0RpZFJlbmRlcklkSG9vaygpO2lmKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7dHJ5e25leHRDaGlsZHJlbj1yZW5kZXJXaXRoSG9va3MoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXIsbmV4dFByb3BzLHJlZixyZW5kZXJMYW5lcyk7aGFzSWQ9Y2hlY2tEaWRSZW5kZXJJZEhvb2soKTt9ZmluYWxseXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7fX1zZXRJc1JlbmRlcmluZyhmYWxzZSk7fXttYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO31pZihjdXJyZW50IT09bnVsbCYmIWRpZFJlY2VpdmVVcGRhdGUpe2JhaWxvdXRIb29rcyhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTtyZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt9aWYoZ2V0SXNIeWRyYXRpbmcoKSYmaGFzSWQpe3B1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO30vLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9UGVyZm9ybWVkV29yaztyZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO31mdW5jdGlvbiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyxyZW5kZXJMYW5lcyl7aWYoY3VycmVudD09PW51bGwpe3ZhciB0eXBlPUNvbXBvbmVudC50eXBlO2lmKGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSkmJkNvbXBvbmVudC5jb21wYXJlPT09bnVsbCYmLy8gU2ltcGxlTWVtb0NvbXBvbmVudCBjb2RlcGF0aCBkb2Vzbid0IHJlc29sdmUgb3V0ZXIgcHJvcHMgZWl0aGVyLlxuQ29tcG9uZW50LmRlZmF1bHRQcm9wcz09PXVuZGVmaW5lZCl7dmFyIHJlc29sdmVkVHlwZT10eXBlO3tyZXNvbHZlZFR5cGU9cmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpO30vLyBJZiB0aGlzIGlzIGEgcGxhaW4gZnVuY3Rpb24gY29tcG9uZW50IHdpdGhvdXQgZGVmYXVsdCBwcm9wcyxcbi8vIGFuZCB3aXRoIG9ubHkgdGhlIGRlZmF1bHQgc2hhbGxvdyBjb21wYXJpc29uLCB3ZSB1cGdyYWRlIGl0XG4vLyB0byBhIFNpbXBsZU1lbW9Db21wb25lbnQgdG8gYWxsb3cgZmFzdCBwYXRoIHVwZGF0ZXMuXG53b3JrSW5Qcm9ncmVzcy50YWc9U2ltcGxlTWVtb0NvbXBvbmVudDt3b3JrSW5Qcm9ncmVzcy50eXBlPXJlc29sdmVkVHlwZTt7dmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLHR5cGUpO31yZXR1cm4gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlc29sdmVkVHlwZSxuZXh0UHJvcHMscmVuZGVyTGFuZXMpO317dmFyIGlubmVyUHJvcFR5cGVzPXR5cGUucHJvcFR5cGVzO2lmKGlubmVyUHJvcFR5cGVzKXsvLyBJbm5lciBtZW1vIGNvbXBvbmVudCBwcm9wcyBhcmVuJ3QgY3VycmVudGx5IHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50LlxuLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cbmNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLG5leHRQcm9wcywvLyBSZXNvbHZlZCBwcm9wc1xuJ3Byb3AnLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSk7fWlmKENvbXBvbmVudC5kZWZhdWx0UHJvcHMhPT11bmRlZmluZWQpe3ZhciBjb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKXx8J1Vua25vd24nO2lmKCFkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKXtlcnJvcignJXM6IFN1cHBvcnQgZm9yIGRlZmF1bHRQcm9wcyB3aWxsIGJlIHJlbW92ZWQgZnJvbSBtZW1vIGNvbXBvbmVudHMgJysnaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVXNlIEphdmFTY3JpcHQgZGVmYXVsdCBwYXJhbWV0ZXJzIGluc3RlYWQuJyxjb21wb25lbnROYW1lKTtkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdPXRydWU7fX19dmFyIGNoaWxkPWNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhDb21wb25lbnQudHlwZSxudWxsLG5leHRQcm9wcyx3b3JrSW5Qcm9ncmVzcyx3b3JrSW5Qcm9ncmVzcy5tb2RlLHJlbmRlckxhbmVzKTtjaGlsZC5yZWY9d29ya0luUHJvZ3Jlc3MucmVmO2NoaWxkLnJldHVybj13b3JrSW5Qcm9ncmVzczt3b3JrSW5Qcm9ncmVzcy5jaGlsZD1jaGlsZDtyZXR1cm4gY2hpbGQ7fXt2YXIgX3R5cGU9Q29tcG9uZW50LnR5cGU7dmFyIF9pbm5lclByb3BUeXBlcz1fdHlwZS5wcm9wVHlwZXM7aWYoX2lubmVyUHJvcFR5cGVzKXsvLyBJbm5lciBtZW1vIGNvbXBvbmVudCBwcm9wcyBhcmVuJ3QgY3VycmVudGx5IHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50LlxuLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cbmNoZWNrUHJvcFR5cGVzKF9pbm5lclByb3BUeXBlcyxuZXh0UHJvcHMsLy8gUmVzb2x2ZWQgcHJvcHNcbidwcm9wJyxnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoX3R5cGUpKTt9fXZhciBjdXJyZW50Q2hpbGQ9Y3VycmVudC5jaGlsZDsvLyBUaGlzIGlzIGFsd2F5cyBleGFjdGx5IG9uZSBjaGlsZFxudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dD1jaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LHJlbmRlckxhbmVzKTtpZighaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KXsvLyBUaGlzIHdpbGwgYmUgdGhlIHByb3BzIHdpdGggcmVzb2x2ZWQgZGVmYXVsdFByb3BzLFxuLy8gdW5saWtlIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB3aGljaCB3aWxsIGJlIHRoZSB1bnJlc29sdmVkIG9uZXMuXG52YXIgcHJldlByb3BzPWN1cnJlbnRDaGlsZC5tZW1vaXplZFByb3BzOy8vIERlZmF1bHQgdG8gc2hhbGxvdyBjb21wYXJpc29uXG52YXIgY29tcGFyZT1Db21wb25lbnQuY29tcGFyZTtjb21wYXJlPWNvbXBhcmUhPT1udWxsP2NvbXBhcmU6c2hhbGxvd0VxdWFsO2lmKGNvbXBhcmUocHJldlByb3BzLG5leHRQcm9wcykmJmN1cnJlbnQucmVmPT09d29ya0luUHJvZ3Jlc3MucmVmKXtyZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt9fS8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbndvcmtJblByb2dyZXNzLmZsYWdzfD1QZXJmb3JtZWRXb3JrO3ZhciBuZXdDaGlsZD1jcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsbmV4dFByb3BzKTtuZXdDaGlsZC5yZWY9d29ya0luUHJvZ3Jlc3MucmVmO25ld0NoaWxkLnJldHVybj13b3JrSW5Qcm9ncmVzczt3b3JrSW5Qcm9ncmVzcy5jaGlsZD1uZXdDaGlsZDtyZXR1cm4gbmV3Q2hpbGQ7fWZ1bmN0aW9uIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLHJlbmRlckxhbmVzKXsvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuLy8gaGFzbid0IHlldCBtb3VudGVkLiBUaGlzIGhhcHBlbnMgd2hlbiB0aGUgaW5uZXIgcmVuZGVyIHN1c3BlbmRzLlxuLy8gV2UnbGwgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoaXMgaXMgZmluZSBvciBjYW4gY2F1c2UgaXNzdWVzLlxue2lmKHdvcmtJblByb2dyZXNzLnR5cGUhPT13b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSl7Ly8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbi8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbnZhciBvdXRlck1lbW9UeXBlPXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlO2lmKG91dGVyTWVtb1R5cGUuJCR0eXBlb2Y9PT1SRUFDVF9MQVpZX1RZUEUpey8vIFdlIHdhcm4gd2hlbiB5b3UgZGVmaW5lIHByb3BUeXBlcyBvbiBsYXp5KClcbi8vIHNvIGxldCdzIGp1c3Qgc2tpcCBvdmVyIGl0IHRvIGZpbmQgbWVtbygpIG91dGVyIHdyYXBwZXIuXG4vLyBJbm5lciBwcm9wcyBmb3IgbWVtbyBhcmUgdmFsaWRhdGVkIGxhdGVyLlxudmFyIGxhenlDb21wb25lbnQ9b3V0ZXJNZW1vVHlwZTt2YXIgcGF5bG9hZD1sYXp5Q29tcG9uZW50Ll9wYXlsb2FkO3ZhciBpbml0PWxhenlDb21wb25lbnQuX2luaXQ7dHJ5e291dGVyTWVtb1R5cGU9aW5pdChwYXlsb2FkKTt9Y2F0Y2goeCl7b3V0ZXJNZW1vVHlwZT1udWxsO30vLyBJbm5lciBwcm9wVHlwZXMgd2lsbCBiZSB2YWxpZGF0ZWQgaW4gdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCBwYXRoLlxudmFyIG91dGVyUHJvcFR5cGVzPW91dGVyTWVtb1R5cGUmJm91dGVyTWVtb1R5cGUucHJvcFR5cGVzO2lmKG91dGVyUHJvcFR5cGVzKXtjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcyxuZXh0UHJvcHMsLy8gUmVzb2x2ZWQgKFNpbXBsZU1lbW9Db21wb25lbnQgaGFzIG5vIGRlZmF1bHRQcm9wcylcbidwcm9wJyxnZXRDb21wb25lbnROYW1lRnJvbVR5cGUob3V0ZXJNZW1vVHlwZSkpO319fX1pZihjdXJyZW50IT09bnVsbCl7dmFyIHByZXZQcm9wcz1jdXJyZW50Lm1lbW9pemVkUHJvcHM7aWYoc2hhbGxvd0VxdWFsKHByZXZQcm9wcyxuZXh0UHJvcHMpJiZjdXJyZW50LnJlZj09PXdvcmtJblByb2dyZXNzLnJlZiYmLy8gUHJldmVudCBiYWlsb3V0IGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIGR1ZSB0byBob3QgcmVsb2FkLlxud29ya0luUHJvZ3Jlc3MudHlwZT09PWN1cnJlbnQudHlwZSl7ZGlkUmVjZWl2ZVVwZGF0ZT1mYWxzZTsvLyBUaGUgcHJvcHMgYXJlIHNoYWxsb3dseSBlcXVhbC4gUmV1c2UgdGhlIHByZXZpb3VzIHByb3BzIG9iamVjdCwgbGlrZSB3ZVxuLy8gd291bGQgZHVyaW5nIGEgbm9ybWFsIGZpYmVyIGJhaWxvdXQuXG4vL1xuLy8gV2UgZG9uJ3QgaGF2ZSBzdHJvbmcgZ3VhcmFudGVlcyB0aGF0IHRoZSBwcm9wcyBvYmplY3QgaXMgcmVmZXJlbnRpYWxseVxuLy8gZXF1YWwgZHVyaW5nIHVwZGF0ZXMgd2hlcmUgd2UgY2FuJ3QgYmFpbCBvdXQgYW55d2F5IOKAlCBsaWtlIGlmIHRoZSBwcm9wc1xuLy8gYXJlIHNoYWxsb3dseSBlcXVhbCwgYnV0IHRoZXJlJ3MgYSBsb2NhbCBzdGF0ZSBvciBjb250ZXh0IHVwZGF0ZSBpbiB0aGVcbi8vIHNhbWUgYmF0Y2guXG4vL1xuLy8gSG93ZXZlciwgYXMgYSBwcmluY2lwbGUsIHdlIHNob3VsZCBhaW0gdG8gbWFrZSB0aGUgYmVoYXZpb3IgY29uc2lzdGVudFxuLy8gYWNyb3NzIGRpZmZlcmVudCB3YXlzIG9mIG1lbW9pemluZyBhIGNvbXBvbmVudC4gRm9yIGV4YW1wbGUsIFJlYWN0Lm1lbW9cbi8vIGhhcyBhIGRpZmZlcmVudCBpbnRlcm5hbCBGaWJlciBsYXlvdXQgaWYgeW91IHBhc3MgYSBub3JtYWwgZnVuY3Rpb25cbi8vIGNvbXBvbmVudCAoU2ltcGxlTWVtb0NvbXBvbmVudCkgdmVyc3VzIGlmIHlvdSBwYXNzIGEgZGlmZmVyZW50IHR5cGVcbi8vIGxpa2UgZm9yd2FyZFJlZiAoTWVtb0NvbXBvbmVudCkuIEJ1dCB0aGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbC5cbi8vIFdyYXBwaW5nIGEgY29tcG9uZW50IGluIGZvcndhcmRSZWYgKG9yIFJlYWN0LmxhenksIGV0Yykgc2hvdWxkbid0XG4vLyBhZmZlY3Qgd2hldGhlciB0aGUgcHJvcHMgb2JqZWN0IGlzIHJldXNlZCBkdXJpbmcgYSBiYWlsb3V0Llxud29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzPW5leHRQcm9wcz1wcmV2UHJvcHM7aWYoIWNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQscmVuZGVyTGFuZXMpKXsvLyBUaGUgcGVuZGluZyBsYW5lcyB3ZXJlIGNsZWFyZWQgYXQgdGhlIGJlZ2lubmluZyBvZiBiZWdpbldvcmsuIFdlJ3JlXG4vLyBhYm91dCB0byBiYWlsIG91dCwgYnV0IHRoZXJlIG1pZ2h0IGJlIG90aGVyIGxhbmVzIHRoYXQgd2VyZW4ndFxuLy8gaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgcmVuZGVyLiBVc3VhbGx5LCB0aGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlXG4vLyByZW1haW5pbmcgdXBkYXRlcyBpcyBhY2N1bXVsYXRlZCBkdXJpbmcgdGhlIGV2YWx1YXRpb24gb2YgdGhlXG4vLyBjb21wb25lbnQgKGkuZS4gd2hlbiBwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUpLiBCdXQgc2luY2Ugc2luY2Vcbi8vIHdlJ3JlIGJhaWxpbmcgb3V0IGVhcmx5ICp3aXRob3V0KiBldmFsdWF0aW5nIHRoZSBjb21wb25lbnQsIHdlIG5lZWRcbi8vIHRvIGFjY291bnQgZm9yIGl0IGhlcmUsIHRvby4gUmVzZXQgdG8gdGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IGZpYmVyLlxuLy8gTk9URTogVGhpcyBvbmx5IGFwcGxpZXMgdG8gU2ltcGxlTWVtb0NvbXBvbmVudCwgbm90IE1lbW9Db21wb25lbnQsXG4vLyBiZWNhdXNlIGEgTWVtb0NvbXBvbmVudCBmaWJlciBkb2VzIG5vdCBoYXZlIGhvb2tzIG9yIGFuIHVwZGF0ZSBxdWV1ZTtcbi8vIHJhdGhlciwgaXQgd3JhcHMgYXJvdW5kIGFuIGlubmVyIGNvbXBvbmVudCwgd2hpY2ggbWF5IG9yIG1heSBub3Rcbi8vIGNvbnRhaW5zIGhvb2tzLlxuLy8gVE9ETzogTW92ZSB0aGUgcmVzZXQgYXQgaW4gYmVnaW5Xb3JrIG91dCBvZiB0aGUgY29tbW9uIHBhdGggc28gdGhhdFxuLy8gdGhpcyBpcyBubyBsb25nZXIgbmVjZXNzYXJ5Llxud29ya0luUHJvZ3Jlc3MubGFuZXM9Y3VycmVudC5sYW5lcztyZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt9ZWxzZSBpZigoY3VycmVudC5mbGFncyZGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlKSE9PU5vRmxhZ3Mpey8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGV4aXN0cyBmb3IgbGVnYWN5IG1vZGUuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTkyMTYuXG5kaWRSZWNlaXZlVXBkYXRlPXRydWU7fX19cmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyxyZW5kZXJMYW5lcyk7fWZ1bmN0aW9uIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXt2YXIgbmV4dFByb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgbmV4dENoaWxkcmVuPW5leHRQcm9wcy5jaGlsZHJlbjt2YXIgcHJldlN0YXRlPWN1cnJlbnQhPT1udWxsP2N1cnJlbnQubWVtb2l6ZWRTdGF0ZTpudWxsO2lmKG5leHRQcm9wcy5tb2RlPT09J2hpZGRlbid8fGVuYWJsZUxlZ2FjeUhpZGRlbil7Ly8gUmVuZGVyaW5nIGEgaGlkZGVuIHRyZWUuXG5pZigod29ya0luUHJvZ3Jlc3MubW9kZSZDb25jdXJyZW50TW9kZSk9PT1Ob01vZGUpey8vIEluIGxlZ2FjeSBzeW5jIG1vZGUsIGRvbid0IGRlZmVyIHRoZSBzdWJ0cmVlLiBSZW5kZXIgaXQgbm93LlxuLy8gVE9ETzogQ29uc2lkZXIgaG93IE9mZnNjcmVlbiBzaG91bGQgd29yayB3aXRoIHRyYW5zaXRpb25zIGluIHRoZSBmdXR1cmVcbnZhciBuZXh0U3RhdGU9e2Jhc2VMYW5lczpOb0xhbmVzLGNhY2hlUG9vbDpudWxsLHRyYW5zaXRpb25zOm51bGx9O3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9bmV4dFN0YXRlO3B1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7fWVsc2UgaWYoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsT2Zmc2NyZWVuTGFuZSkpe3ZhciBzcGF3bmVkQ2FjaGVQb29sPW51bGw7Ly8gV2UncmUgaGlkZGVuLCBhbmQgd2UncmUgbm90IHJlbmRlcmluZyBhdCBPZmZzY3JlZW4uIFdlIHdpbGwgYmFpbCBvdXRcbi8vIGFuZCByZXN1bWUgdGhpcyB0cmVlIGxhdGVyLlxudmFyIG5leHRCYXNlTGFuZXM7aWYocHJldlN0YXRlIT09bnVsbCl7dmFyIHByZXZCYXNlTGFuZXM9cHJldlN0YXRlLmJhc2VMYW5lcztuZXh0QmFzZUxhbmVzPW1lcmdlTGFuZXMocHJldkJhc2VMYW5lcyxyZW5kZXJMYW5lcyk7fWVsc2V7bmV4dEJhc2VMYW5lcz1yZW5kZXJMYW5lczt9Ly8gU2NoZWR1bGUgdGhpcyBmaWJlciB0byByZS1yZW5kZXIgYXQgb2Zmc2NyZWVuIHByaW9yaXR5LiBUaGVuIGJhaWxvdXQuXG53b3JrSW5Qcm9ncmVzcy5sYW5lcz13b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzPWxhbmVUb0xhbmVzKE9mZnNjcmVlbkxhbmUpO3ZhciBfbmV4dFN0YXRlPXtiYXNlTGFuZXM6bmV4dEJhc2VMYW5lcyxjYWNoZVBvb2w6c3Bhd25lZENhY2hlUG9vbCx0cmFuc2l0aW9uczpudWxsfTt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPV9uZXh0U3RhdGU7d29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU9bnVsbDsvLyB0byBhdm9pZCBhIHB1c2gvcG9wIG1pc2FsaWdubWVudC5cbnB1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyxuZXh0QmFzZUxhbmVzKTtyZXR1cm4gbnVsbDt9ZWxzZXsvLyBUaGlzIGlzIHRoZSBzZWNvbmQgcmVuZGVyLiBUaGUgc3Vycm91bmRpbmcgdmlzaWJsZSBjb250ZW50IGhhcyBhbHJlYWR5XG4vLyBjb21taXR0ZWQuIE5vdyB3ZSByZXN1bWUgcmVuZGVyaW5nIHRoZSBoaWRkZW4gdHJlZS5cbi8vIFJlbmRlcmluZyBhdCBvZmZzY3JlZW4sIHNvIHdlIGNhbiBjbGVhciB0aGUgYmFzZSBsYW5lcy5cbnZhciBfbmV4dFN0YXRlMj17YmFzZUxhbmVzOk5vTGFuZXMsY2FjaGVQb29sOm51bGwsdHJhbnNpdGlvbnM6bnVsbH07d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1fbmV4dFN0YXRlMjsvLyBQdXNoIHRoZSBsYW5lcyB0aGF0IHdlcmUgc2tpcHBlZCB3aGVuIHdlIGJhaWxlZCBvdXQuXG52YXIgc3VidHJlZVJlbmRlckxhbmVzPXByZXZTdGF0ZSE9PW51bGw/cHJldlN0YXRlLmJhc2VMYW5lczpyZW5kZXJMYW5lcztwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3Msc3VidHJlZVJlbmRlckxhbmVzKTt9fWVsc2V7Ly8gUmVuZGVyaW5nIGEgdmlzaWJsZSB0cmVlLlxudmFyIF9zdWJ0cmVlUmVuZGVyTGFuZXM7aWYocHJldlN0YXRlIT09bnVsbCl7Ly8gV2UncmUgZ29pbmcgZnJvbSBoaWRkZW4gLT4gdmlzaWJsZS5cbl9zdWJ0cmVlUmVuZGVyTGFuZXM9bWVyZ2VMYW5lcyhwcmV2U3RhdGUuYmFzZUxhbmVzLHJlbmRlckxhbmVzKTt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW51bGw7fWVsc2V7Ly8gV2Ugd2VyZW4ndCBwcmV2aW91c2x5IGhpZGRlbiwgYW5kIHdlIHN0aWxsIGFyZW4ndCwgc28gdGhlcmUncyBub3RoaW5nXG4vLyBzcGVjaWFsIHRvIGRvLiBOZWVkIHRvIHB1c2ggdG8gdGhlIHN0YWNrIHJlZ2FyZGxlc3MsIHRob3VnaCwgdG8gYXZvaWRcbi8vIGEgcHVzaC9wb3AgbWlzYWxpZ25tZW50LlxuX3N1YnRyZWVSZW5kZXJMYW5lcz1yZW5kZXJMYW5lczt9cHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLF9zdWJ0cmVlUmVuZGVyTGFuZXMpO31yZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO30vLyBOb3RlOiBUaGVzZSBoYXBwZW4gdG8gaGF2ZSBpZGVudGljYWwgYmVnaW4gcGhhc2VzLCBmb3Igbm93LiBXZSBzaG91bGRuJ3QgaG9sZFxuZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7dmFyIG5leHRDaGlsZHJlbj13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7cmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpO3JldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDt9ZnVuY3Rpb24gdXBkYXRlTW9kZShjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXt2YXIgbmV4dENoaWxkcmVuPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbjtyZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO31mdW5jdGlvbiB1cGRhdGVQcm9maWxlcihjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXt7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVVwZGF0ZTt7Ly8gUmVzZXQgZWZmZWN0IGR1cmF0aW9ucyBmb3IgdGhlIG5leHQgZXZlbnR1YWwgZWZmZWN0IHBoYXNlLlxuLy8gVGhlc2UgYXJlIHJlc2V0IGR1cmluZyByZW5kZXIgdG8gYWxsb3cgdGhlIERldlRvb2xzIGNvbW1pdCBob29rIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSxcbnZhciBzdGF0ZU5vZGU9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO3N0YXRlTm9kZS5lZmZlY3REdXJhdGlvbj0wO3N0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb249MDt9fXZhciBuZXh0UHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciBuZXh0Q2hpbGRyZW49bmV4dFByb3BzLmNoaWxkcmVuO3JlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTtyZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fWZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyl7dmFyIHJlZj13b3JrSW5Qcm9ncmVzcy5yZWY7aWYoY3VycmVudD09PW51bGwmJnJlZiE9PW51bGx8fGN1cnJlbnQhPT1udWxsJiZjdXJyZW50LnJlZiE9PXJlZil7Ly8gU2NoZWR1bGUgYSBSZWYgZWZmZWN0XG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9UmVmO3t3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9UmVmU3RhdGljO319fWZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyxyZW5kZXJMYW5lcyl7e2lmKHdvcmtJblByb2dyZXNzLnR5cGUhPT13b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSl7Ly8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbi8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbnZhciBpbm5lclByb3BUeXBlcz1Db21wb25lbnQucHJvcFR5cGVzO2lmKGlubmVyUHJvcFR5cGVzKXtjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcyxuZXh0UHJvcHMsLy8gUmVzb2x2ZWQgcHJvcHNcbidwcm9wJyxnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSk7fX19dmFyIGNvbnRleHQ7e3ZhciB1bm1hc2tlZENvbnRleHQ9Z2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLENvbXBvbmVudCx0cnVlKTtjb250ZXh0PWdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsdW5tYXNrZWRDb250ZXh0KTt9dmFyIG5leHRDaGlsZHJlbjt2YXIgaGFzSWQ7cHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO3ttYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7fXtSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQ9d29ya0luUHJvZ3Jlc3M7c2V0SXNSZW5kZXJpbmcodHJ1ZSk7bmV4dENoaWxkcmVuPXJlbmRlcldpdGhIb29rcyhjdXJyZW50LHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxuZXh0UHJvcHMsY29udGV4dCxyZW5kZXJMYW5lcyk7aGFzSWQ9Y2hlY2tEaWRSZW5kZXJJZEhvb2soKTtpZih3b3JrSW5Qcm9ncmVzcy5tb2RlJlN0cmljdExlZ2FjeU1vZGUpe3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO3RyeXtuZXh0Q2hpbGRyZW49cmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyxjb250ZXh0LHJlbmRlckxhbmVzKTtoYXNJZD1jaGVja0RpZFJlbmRlcklkSG9vaygpO31maW5hbGx5e3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTt9fXNldElzUmVuZGVyaW5nKGZhbHNlKTt9e21hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7fWlmKGN1cnJlbnQhPT1udWxsJiYhZGlkUmVjZWl2ZVVwZGF0ZSl7YmFpbG91dEhvb2tzKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO3JldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO31pZihnZXRJc0h5ZHJhdGluZygpJiZoYXNJZCl7cHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7fS8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbndvcmtJblByb2dyZXNzLmZsYWdzfD1QZXJmb3JtZWRXb3JrO3JlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTtyZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fWZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyxyZW5kZXJMYW5lcyl7ey8vIFRoaXMgaXMgdXNlZCBieSBEZXZUb29scyB0byBmb3JjZSBhIGJvdW5kYXJ5IHRvIGVycm9yLlxuc3dpdGNoKHNob3VsZEVycm9yKHdvcmtJblByb2dyZXNzKSl7Y2FzZSBmYWxzZTp7dmFyIF9pbnN0YW5jZT13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7dmFyIGN0b3I9d29ya0luUHJvZ3Jlc3MudHlwZTsvLyBUT0RPIFRoaXMgd2F5IG9mIHJlc2V0dGluZyB0aGUgZXJyb3IgYm91bmRhcnkgc3RhdGUgaXMgYSBoYWNrLlxuLy8gSXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXM/XG52YXIgdGVtcEluc3RhbmNlPW5ldyBjdG9yKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsX2luc3RhbmNlLmNvbnRleHQpO3ZhciBzdGF0ZT10ZW1wSW5zdGFuY2Uuc3RhdGU7X2luc3RhbmNlLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKF9pbnN0YW5jZSxzdGF0ZSxudWxsKTticmVhazt9Y2FzZSB0cnVlOnt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9RGlkQ2FwdHVyZTt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9U2hvdWxkQ2FwdHVyZTsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xudmFyIGVycm9yJDE9bmV3IEVycm9yKCdTaW11bGF0ZWQgZXJyb3IgY29taW5nIGZyb20gRGV2VG9vbHMnKTt2YXIgbGFuZT1waWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcyk7d29ya0luUHJvZ3Jlc3MubGFuZXM9bWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcyxsYW5lKTsvLyBTY2hlZHVsZSB0aGUgZXJyb3IgYm91bmRhcnkgdG8gcmUtcmVuZGVyIHVzaW5nIHVwZGF0ZWQgc3RhdGVcbnZhciB1cGRhdGU9Y3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcyxjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciQxLHdvcmtJblByb2dyZXNzKSxsYW5lKTtlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsdXBkYXRlKTticmVhazt9fWlmKHdvcmtJblByb2dyZXNzLnR5cGUhPT13b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSl7Ly8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbi8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbnZhciBpbm5lclByb3BUeXBlcz1Db21wb25lbnQucHJvcFR5cGVzO2lmKGlubmVyUHJvcFR5cGVzKXtjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcyxuZXh0UHJvcHMsLy8gUmVzb2x2ZWQgcHJvcHNcbidwcm9wJyxnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSk7fX19Ly8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbi8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbi8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cbnZhciBoYXNDb250ZXh0O2lmKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpe2hhc0NvbnRleHQ9dHJ1ZTtwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTt9ZWxzZXtoYXNDb250ZXh0PWZhbHNlO31wcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7dmFyIGluc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTt2YXIgc2hvdWxkVXBkYXRlO2lmKGluc3RhbmNlPT09bnVsbCl7cmVzZXRTdXNwZW5kZWRDdXJyZW50T25Nb3VudEluTGVnYWN5TW9kZShjdXJyZW50LHdvcmtJblByb2dyZXNzKTsvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbmNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyk7bW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxuZXh0UHJvcHMscmVuZGVyTGFuZXMpO3Nob3VsZFVwZGF0ZT10cnVlO31lbHNlIGlmKGN1cnJlbnQ9PT1udWxsKXsvLyBJbiBhIHJlc3VtZSwgd2UnbGwgYWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIHdlIGNhbiByZXVzZS5cbnNob3VsZFVwZGF0ZT1yZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyxyZW5kZXJMYW5lcyk7fWVsc2V7c2hvdWxkVXBkYXRlPXVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLHJlbmRlckxhbmVzKTt9dmFyIG5leHRVbml0T2ZXb3JrPWZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHNob3VsZFVwZGF0ZSxoYXNDb250ZXh0LHJlbmRlckxhbmVzKTt7dmFyIGluc3Q9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO2lmKHNob3VsZFVwZGF0ZSYmaW5zdC5wcm9wcyE9PW5leHRQcm9wcyl7aWYoIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpe2Vycm9yKCdJdCBsb29rcyBsaWtlICVzIGlzIHJlYXNzaWduaW5nIGl0cyBvd24gYHRoaXMucHJvcHNgIHdoaWxlIHJlbmRlcmluZy4gJysnVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBjYW4gbGVhZCB0byBjb25mdXNpbmcgYnVncy4nLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpfHwnYSBjb21wb25lbnQnKTt9ZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcz10cnVlO319cmV0dXJuIG5leHRVbml0T2ZXb3JrO31mdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxzaG91bGRVcGRhdGUsaGFzQ29udGV4dCxyZW5kZXJMYW5lcyl7Ly8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2Vcbm1hcmtSZWYoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyk7dmFyIGRpZENhcHR1cmVFcnJvcj0od29ya0luUHJvZ3Jlc3MuZmxhZ3MmRGlkQ2FwdHVyZSkhPT1Ob0ZsYWdzO2lmKCFzaG91bGRVcGRhdGUmJiFkaWRDYXB0dXJlRXJyb3Ipey8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuaWYoaGFzQ29udGV4dCl7aW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsZmFsc2UpO31yZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt9dmFyIGluc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTsvLyBSZXJlbmRlclxuUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50PXdvcmtJblByb2dyZXNzO3ZhciBuZXh0Q2hpbGRyZW47aWYoZGlkQ2FwdHVyZUVycm9yJiZ0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciE9PSdmdW5jdGlvbicpey8vIElmIHdlIGNhcHR1cmVkIGFuIGVycm9yLCBidXQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIGlzIG5vdCBkZWZpbmVkLFxuLy8gdW5tb3VudCBhbGwgdGhlIGNoaWxkcmVuLiBjb21wb25lbnREaWRDYXRjaCB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSB0b1xuLy8gcmUtcmVuZGVyIGEgZmFsbGJhY2suIFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIG1pZ3JhdGUgZXZlcnlvbmUgdG9cbi8vIHRoZSBuZXcgQVBJLlxuLy8gVE9ETzogV2FybiBpbiBhIGZ1dHVyZSByZWxlYXNlLlxubmV4dENoaWxkcmVuPW51bGw7e3N0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7fX1lbHNle3ttYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7fXtzZXRJc1JlbmRlcmluZyh0cnVlKTtuZXh0Q2hpbGRyZW49aW5zdGFuY2UucmVuZGVyKCk7aWYod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RMZWdhY3lNb2RlKXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTt0cnl7aW5zdGFuY2UucmVuZGVyKCk7fWZpbmFsbHl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO319c2V0SXNSZW5kZXJpbmcoZmFsc2UpO317bWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTt9fS8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbndvcmtJblByb2dyZXNzLmZsYWdzfD1QZXJmb3JtZWRXb3JrO2lmKGN1cnJlbnQhPT1udWxsJiZkaWRDYXB0dXJlRXJyb3Ipey8vIElmIHdlJ3JlIHJlY292ZXJpbmcgZnJvbSBhbiBlcnJvciwgcmVjb25jaWxlIHdpdGhvdXQgcmV1c2luZyBhbnkgb2Zcbi8vIHRoZSBleGlzdGluZyBjaGlsZHJlbi4gQ29uY2VwdHVhbGx5LCB0aGUgbm9ybWFsIGNoaWxkcmVuIGFuZCB0aGUgY2hpbGRyZW5cbi8vIHRoYXQgYXJlIHNob3duIG9uIGVycm9yIGFyZSB0d28gZGlmZmVyZW50IHNldHMsIHNvIHdlIHNob3VsZG4ndCByZXVzZVxuLy8gbm9ybWFsIGNoaWxkcmVuIGV2ZW4gaWYgdGhlaXIgaWRlbnRpdGllcyBtYXRjaC5cbmZvcmNlVW5tb3VudEN1cnJlbnRBbmRSZWNvbmNpbGUoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpO31lbHNle3JlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTt9Ly8gTWVtb2l6ZSBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4vLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cbndvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9aW5zdGFuY2Uuc3RhdGU7Ly8gVGhlIGNvbnRleHQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgaXQuXG5pZihoYXNDb250ZXh0KXtpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLENvbXBvbmVudCx0cnVlKTt9cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO31mdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKXt2YXIgcm9vdD13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7aWYocm9vdC5wZW5kaW5nQ29udGV4dCl7cHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyxyb290LnBlbmRpbmdDb250ZXh0LHJvb3QucGVuZGluZ0NvbnRleHQhPT1yb290LmNvbnRleHQpO31lbHNlIGlmKHJvb3QuY29udGV4dCl7Ly8gU2hvdWxkIGFsd2F5cyBiZSBzZXRcbnB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3Mscm9vdC5jb250ZXh0LGZhbHNlKTt9cHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3Mscm9vdC5jb250YWluZXJJbmZvKTt9ZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7cHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7aWYoY3VycmVudD09PW51bGwpe3Rocm93IG5ldyBFcnJvcignU2hvdWxkIGhhdmUgYSBjdXJyZW50IGZpYmVyLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO312YXIgbmV4dFByb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgcHJldlN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7dmFyIHByZXZDaGlsZHJlbj1wcmV2U3RhdGUuZWxlbWVudDtjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MpO3Byb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyxuZXh0UHJvcHMsbnVsbCxyZW5kZXJMYW5lcyk7dmFyIG5leHRTdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO3ZhciByb290PXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTsvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG52YXIgbmV4dENoaWxkcmVuPW5leHRTdGF0ZS5lbGVtZW50O2lmKHByZXZTdGF0ZS5pc0RlaHlkcmF0ZWQpey8vIFRoaXMgaXMgYSBoeWRyYXRpb24gcm9vdCB3aG9zZSBzaGVsbCBoYXMgbm90IHlldCBoeWRyYXRlZC4gV2Ugc2hvdWxkXG4vLyBhdHRlbXB0IHRvIGh5ZHJhdGUuXG4vLyBGbGlwIGlzRGVoeWRyYXRlZCB0byBmYWxzZSB0byBpbmRpY2F0ZSB0aGF0IHdoZW4gdGhpcyByZW5kZXJcbi8vIGZpbmlzaGVzLCB0aGUgcm9vdCB3aWxsIG5vIGxvbmdlciBiZSBkZWh5ZHJhdGVkLlxudmFyIG92ZXJyaWRlU3RhdGU9e2VsZW1lbnQ6bmV4dENoaWxkcmVuLGlzRGVoeWRyYXRlZDpmYWxzZSxjYWNoZTpuZXh0U3RhdGUuY2FjaGUscGVuZGluZ1N1c3BlbnNlQm91bmRhcmllczpuZXh0U3RhdGUucGVuZGluZ1N1c3BlbnNlQm91bmRhcmllcyx0cmFuc2l0aW9uczpuZXh0U3RhdGUudHJhbnNpdGlvbnN9O3ZhciB1cGRhdGVRdWV1ZT13b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTsvLyBgYmFzZVN0YXRlYCBjYW4gYWx3YXlzIGJlIHRoZSBsYXN0IHN0YXRlIGJlY2F1c2UgdGhlIHJvb3QgZG9lc24ndFxuLy8gaGF2ZSByZWR1Y2VyIGZ1bmN0aW9ucyBzbyBpdCBkb2Vzbid0IG5lZWQgcmViYXNpbmcuXG51cGRhdGVRdWV1ZS5iYXNlU3RhdGU9b3ZlcnJpZGVTdGF0ZTt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW92ZXJyaWRlU3RhdGU7aWYod29ya0luUHJvZ3Jlc3MuZmxhZ3MmRm9yY2VDbGllbnRSZW5kZXIpey8vIFNvbWV0aGluZyBlcnJvcmVkIGR1cmluZyBhIHByZXZpb3VzIGF0dGVtcHQgdG8gaHlkcmF0ZSB0aGUgc2hlbGwsIHNvIHdlXG4vLyBmb3JjZWQgYSBjbGllbnQgcmVuZGVyLlxudmFyIHJlY292ZXJhYmxlRXJyb3I9Y3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIobmV3IEVycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nLiBCZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5lZCBvdXRzaWRlICcrJ29mIGEgU3VzcGVuc2UgYm91bmRhcnksIHRoZSBlbnRpcmUgcm9vdCB3aWxsIHN3aXRjaCB0byAnKydjbGllbnQgcmVuZGVyaW5nLicpLHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMscmVjb3ZlcmFibGVFcnJvcik7fWVsc2UgaWYobmV4dENoaWxkcmVuIT09cHJldkNoaWxkcmVuKXt2YXIgX3JlY292ZXJhYmxlRXJyb3I9Y3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIobmV3IEVycm9yKCdUaGlzIHJvb3QgcmVjZWl2ZWQgYW4gZWFybHkgdXBkYXRlLCBiZWZvcmUgYW55dGhpbmcgd2FzIGFibGUgJysnaHlkcmF0ZS4gU3dpdGNoZWQgdGhlIGVudGlyZSByb290IHRvIGNsaWVudCByZW5kZXJpbmcuJyksd29ya0luUHJvZ3Jlc3MpO3JldHVybiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyxfcmVjb3ZlcmFibGVFcnJvcik7fWVsc2V7Ly8gVGhlIG91dGVybW9zdCBzaGVsbCBoYXMgbm90IGh5ZHJhdGVkIHlldC4gU3RhcnQgaHlkcmF0aW5nLlxuZW50ZXJIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7dmFyIGNoaWxkPW1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsbnVsbCxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpO3dvcmtJblByb2dyZXNzLmNoaWxkPWNoaWxkO3ZhciBub2RlPWNoaWxkO3doaWxlKG5vZGUpey8vIE1hcmsgZWFjaCBjaGlsZCBhcyBoeWRyYXRpbmcuIFRoaXMgaXMgYSBmYXN0IHBhdGggdG8ga25vdyB3aGV0aGVyIHRoaXNcbi8vIHRyZWUgaXMgcGFydCBvZiBhIGh5ZHJhdGluZyB0cmVlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgY2hpbGRcbi8vIG5vZGUgaGFzIGZ1bGx5IG1vdW50ZWQgeWV0LCBhbmQgZm9yIHNjaGVkdWxpbmcgZXZlbnQgcmVwbGF5aW5nLlxuLy8gQ29uY2VwdHVhbGx5IHRoaXMgaXMgc2ltaWxhciB0byBQbGFjZW1lbnQgaW4gdGhhdCBhIG5ldyBzdWJ0cmVlIGlzXG4vLyBpbnNlcnRlZCBpbnRvIHRoZSBSZWFjdCB0cmVlIGhlcmUuIEl0IGp1c3QgaGFwcGVucyB0byBub3QgbmVlZCBET01cbi8vIG11dGF0aW9ucyBiZWNhdXNlIGl0IGFscmVhZHkgZXhpc3RzLlxubm9kZS5mbGFncz1ub2RlLmZsYWdzJn5QbGFjZW1lbnR8SHlkcmF0aW5nO25vZGU9bm9kZS5zaWJsaW5nO319fWVsc2V7Ly8gUm9vdCBpcyBub3QgZGVoeWRyYXRlZC4gRWl0aGVyIHRoaXMgaXMgYSBjbGllbnQtb25seSByb290LCBvciBpdFxuLy8gYWxyZWFkeSBoeWRyYXRlZC5cbnJlc2V0SHlkcmF0aW9uU3RhdGUoKTtpZihuZXh0Q2hpbGRyZW49PT1wcmV2Q2hpbGRyZW4pe3JldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO31yZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7fXJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDt9ZnVuY3Rpb24gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMscmVjb3ZlcmFibGVFcnJvcil7Ly8gUmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXG5yZXNldEh5ZHJhdGlvblN0YXRlKCk7cXVldWVIeWRyYXRpb25FcnJvcihyZWNvdmVyYWJsZUVycm9yKTt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9Rm9yY2VDbGllbnRSZW5kZXI7cmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpO3JldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDt9ZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXtwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO2lmKGN1cnJlbnQ9PT1udWxsKXt0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7fXZhciB0eXBlPXdvcmtJblByb2dyZXNzLnR5cGU7dmFyIG5leHRQcm9wcz13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7dmFyIHByZXZQcm9wcz1jdXJyZW50IT09bnVsbD9jdXJyZW50Lm1lbW9pemVkUHJvcHM6bnVsbDt2YXIgbmV4dENoaWxkcmVuPW5leHRQcm9wcy5jaGlsZHJlbjt2YXIgaXNEaXJlY3RUZXh0Q2hpbGQ9c2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSxuZXh0UHJvcHMpO2lmKGlzRGlyZWN0VGV4dENoaWxkKXsvLyBXZSBzcGVjaWFsIGNhc2UgYSBkaXJlY3QgdGV4dCBjaGlsZCBvZiBhIGhvc3Qgbm9kZS4gVGhpcyBpcyBhIGNvbW1vblxuLy8gY2FzZS4gV2Ugd29uJ3QgaGFuZGxlIGl0IGFzIGEgcmVpZmllZCBjaGlsZC4gV2Ugd2lsbCBpbnN0ZWFkIGhhbmRsZVxuLy8gdGhpcyBpbiB0aGUgaG9zdCBlbnZpcm9ubWVudCB0aGF0IGFsc28gaGFzIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbi8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG5uZXh0Q2hpbGRyZW49bnVsbDt9ZWxzZSBpZihwcmV2UHJvcHMhPT1udWxsJiZzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLHByZXZQcm9wcykpey8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4vLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0Llxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PUNvbnRlbnRSZXNldDt9bWFya1JlZihjdXJyZW50LHdvcmtJblByb2dyZXNzKTtyZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO31mdW5jdGlvbiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LHdvcmtJblByb2dyZXNzKXtpZihjdXJyZW50PT09bnVsbCl7dHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO30vLyBOb3RoaW5nIHRvIGRvIGhlcmUuIFRoaXMgaXMgdGVybWluYWwuIFdlJ2xsIGRvIHRoZSBjb21wbGV0aW9uIHN0ZXBcbi8vIGltbWVkaWF0ZWx5IGFmdGVyLlxucmV0dXJuIG51bGw7fWZ1bmN0aW9uIG1vdW50TGF6eUNvbXBvbmVudChfY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxlbGVtZW50VHlwZSxyZW5kZXJMYW5lcyl7cmVzZXRTdXNwZW5kZWRDdXJyZW50T25Nb3VudEluTGVnYWN5TW9kZShfY3VycmVudCx3b3JrSW5Qcm9ncmVzcyk7dmFyIHByb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgbGF6eUNvbXBvbmVudD1lbGVtZW50VHlwZTt2YXIgcGF5bG9hZD1sYXp5Q29tcG9uZW50Ll9wYXlsb2FkO3ZhciBpbml0PWxhenlDb21wb25lbnQuX2luaXQ7dmFyIENvbXBvbmVudD1pbml0KHBheWxvYWQpOy8vIFN0b3JlIHRoZSB1bndyYXBwZWQgY29tcG9uZW50IGluIHRoZSB0eXBlLlxud29ya0luUHJvZ3Jlc3MudHlwZT1Db21wb25lbnQ7dmFyIHJlc29sdmVkVGFnPXdvcmtJblByb2dyZXNzLnRhZz1yZXNvbHZlTGF6eUNvbXBvbmVudFRhZyhDb21wb25lbnQpO3ZhciByZXNvbHZlZFByb3BzPXJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LHByb3BzKTt2YXIgY2hpbGQ7c3dpdGNoKHJlc29sdmVkVGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50Ont7dmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLENvbXBvbmVudCk7d29ya0luUHJvZ3Jlc3MudHlwZT1Db21wb25lbnQ9cmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7fWNoaWxkPXVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KG51bGwsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHJlc29sdmVkUHJvcHMscmVuZGVyTGFuZXMpO3JldHVybiBjaGlsZDt9Y2FzZSBDbGFzc0NvbXBvbmVudDp7e3dvcmtJblByb2dyZXNzLnR5cGU9Q29tcG9uZW50PXJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO31jaGlsZD11cGRhdGVDbGFzc0NvbXBvbmVudChudWxsLHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxyZXNvbHZlZFByb3BzLHJlbmRlckxhbmVzKTtyZXR1cm4gY2hpbGQ7fWNhc2UgRm9yd2FyZFJlZjp7e3dvcmtJblByb2dyZXNzLnR5cGU9Q29tcG9uZW50PXJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7fWNoaWxkPXVwZGF0ZUZvcndhcmRSZWYobnVsbCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQscmVzb2x2ZWRQcm9wcyxyZW5kZXJMYW5lcyk7cmV0dXJuIGNoaWxkO31jYXNlIE1lbW9Db21wb25lbnQ6e3tpZih3b3JrSW5Qcm9ncmVzcy50eXBlIT09d29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpe3ZhciBvdXRlclByb3BUeXBlcz1Db21wb25lbnQucHJvcFR5cGVzO2lmKG91dGVyUHJvcFR5cGVzKXtjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcyxyZXNvbHZlZFByb3BzLC8vIFJlc29sdmVkIGZvciBvdXRlciBvbmx5XG4ncHJvcCcsZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkpO319fWNoaWxkPXVwZGF0ZU1lbW9Db21wb25lbnQobnVsbCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQscmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQudHlwZSxyZXNvbHZlZFByb3BzKSwvLyBUaGUgaW5uZXIgdHlwZSBjYW4gaGF2ZSBkZWZhdWx0cyB0b29cbnJlbmRlckxhbmVzKTtyZXR1cm4gY2hpbGQ7fX12YXIgaGludD0nJzt7aWYoQ29tcG9uZW50IT09bnVsbCYmdHlwZW9mIENvbXBvbmVudD09PSdvYmplY3QnJiZDb21wb25lbnQuJCR0eXBlb2Y9PT1SRUFDVF9MQVpZX1RZUEUpe2hpbnQ9JyBEaWQgeW91IHdyYXAgYSBjb21wb25lbnQgaW4gUmVhY3QubGF6eSgpIG1vcmUgdGhhbiBvbmNlPyc7fX0vLyBUaGlzIG1lc3NhZ2UgaW50ZW50aW9uYWxseSBkb2Vzbid0IG1lbnRpb24gRm9yd2FyZFJlZiBvciBNZW1vQ29tcG9uZW50XG4vLyBiZWNhdXNlIHRoZSBmYWN0IHRoYXQgaXQncyBhIHNlcGFyYXRlIHR5cGUgb2Ygd29yayBpcyBhblxuLy8gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxudGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQuIFJlY2VpdmVkIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvOiBcIitDb21wb25lbnQrXCIuIFwiKyhcIkxhenkgZWxlbWVudCB0eXBlIG11c3QgcmVzb2x2ZSB0byBhIGNsYXNzIG9yIGZ1bmN0aW9uLlwiK2hpbnQpKTt9ZnVuY3Rpb24gbW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQoX2N1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyxyZW5kZXJMYW5lcyl7cmVzZXRTdXNwZW5kZWRDdXJyZW50T25Nb3VudEluTGVnYWN5TW9kZShfY3VycmVudCx3b3JrSW5Qcm9ncmVzcyk7Ly8gUHJvbW90ZSB0aGUgZmliZXIgdG8gYSBjbGFzcyBhbmQgdHJ5IHJlbmRlcmluZyBhZ2Fpbi5cbndvcmtJblByb2dyZXNzLnRhZz1DbGFzc0NvbXBvbmVudDsvLyBUaGUgcmVzdCBvZiB0aGlzIGZ1bmN0aW9uIGlzIGEgZm9yayBvZiBgdXBkYXRlQ2xhc3NDb21wb25lbnRgXG4vLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxudmFyIGhhc0NvbnRleHQ7aWYoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSl7aGFzQ29udGV4dD10cnVlO3B1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO31lbHNle2hhc0NvbnRleHQ9ZmFsc2U7fXByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTtjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxuZXh0UHJvcHMpO21vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLHJlbmRlckxhbmVzKTtyZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQobnVsbCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsdHJ1ZSxoYXNDb250ZXh0LHJlbmRlckxhbmVzKTt9ZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KF9jdXJyZW50LHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxyZW5kZXJMYW5lcyl7cmVzZXRTdXNwZW5kZWRDdXJyZW50T25Nb3VudEluTGVnYWN5TW9kZShfY3VycmVudCx3b3JrSW5Qcm9ncmVzcyk7dmFyIHByb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgY29udGV4dDt7dmFyIHVubWFza2VkQ29udGV4dD1nZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LGZhbHNlKTtjb250ZXh0PWdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsdW5tYXNrZWRDb250ZXh0KTt9cHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO3ZhciB2YWx1ZTt2YXIgaGFzSWQ7e21hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTt9e2lmKENvbXBvbmVudC5wcm90b3R5cGUmJnR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlcj09PSdmdW5jdGlvbicpe3ZhciBjb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpfHwnVW5rbm93bic7aWYoIWRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdKXtlcnJvcihcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiKydUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJyxjb21wb25lbnROYW1lLGNvbXBvbmVudE5hbWUpO2RpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdPXRydWU7fX1pZih3b3JrSW5Qcm9ncmVzcy5tb2RlJlN0cmljdExlZ2FjeU1vZGUpe1JlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLG51bGwpO31zZXRJc1JlbmRlcmluZyh0cnVlKTtSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQ9d29ya0luUHJvZ3Jlc3M7dmFsdWU9cmVuZGVyV2l0aEhvb2tzKG51bGwsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHByb3BzLGNvbnRleHQscmVuZGVyTGFuZXMpO2hhc0lkPWNoZWNrRGlkUmVuZGVySWRIb29rKCk7c2V0SXNSZW5kZXJpbmcoZmFsc2UpO317bWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTt9Ly8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVBlcmZvcm1lZFdvcms7ey8vIFN1cHBvcnQgZm9yIG1vZHVsZSBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIHJlbW92ZWQgYmVoaW5kIGEgZmxhZy5cbi8vIFdoZXRoZXIgb3Igbm90IGl0IHdvdWxkIGNyYXNoIGxhdGVyLCB3ZSB3YW50IHRvIHNob3cgYSBnb29kIG1lc3NhZ2UgaW4gREVWIGZpcnN0LlxuaWYodHlwZW9mIHZhbHVlPT09J29iamVjdCcmJnZhbHVlIT09bnVsbCYmdHlwZW9mIHZhbHVlLnJlbmRlcj09PSdmdW5jdGlvbicmJnZhbHVlLiQkdHlwZW9mPT09dW5kZWZpbmVkKXt2YXIgX2NvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCl8fCdVbmtub3duJztpZighZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0pe2Vycm9yKCdUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlLiAnKydDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcrXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiK1wiYCVzLnByb3RvdHlwZSA9IFJlYWN0LkNvbXBvbmVudC5wcm90b3R5cGVgLiBEb24ndCB1c2UgYW4gYXJyb3cgZnVuY3Rpb24gc2luY2UgaXQgXCIrJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLF9jb21wb25lbnROYW1lLF9jb21wb25lbnROYW1lLF9jb21wb25lbnROYW1lKTtkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXT10cnVlO319fWlmKC8vIFJ1biB0aGVzZSBjaGVja3MgaW4gcHJvZHVjdGlvbiBvbmx5IGlmIHRoZSBmbGFnIGlzIG9mZi5cbi8vIEV2ZW50dWFsbHkgd2UnbGwgZGVsZXRlIHRoaXMgYnJhbmNoIGFsdG9nZXRoZXIuXG50eXBlb2YgdmFsdWU9PT0nb2JqZWN0JyYmdmFsdWUhPT1udWxsJiZ0eXBlb2YgdmFsdWUucmVuZGVyPT09J2Z1bmN0aW9uJyYmdmFsdWUuJCR0eXBlb2Y9PT11bmRlZmluZWQpe3t2YXIgX2NvbXBvbmVudE5hbWUyPWdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpfHwnVW5rbm93bic7aWYoIWRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSl7ZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcrJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJytcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIrXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIisnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsX2NvbXBvbmVudE5hbWUyLF9jb21wb25lbnROYW1lMixfY29tcG9uZW50TmFtZTIpO2RpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXT10cnVlO319Ly8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBjbGFzcyBpbnN0YW5jZVxud29ya0luUHJvZ3Jlc3MudGFnPUNsYXNzQ29tcG9uZW50Oy8vIFRocm93IG91dCBhbnkgaG9va3MgdGhhdCB3ZXJlIHVzZWQuXG53b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW51bGw7d29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU9bnVsbDsvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxudmFyIGhhc0NvbnRleHQ9ZmFsc2U7aWYoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSl7aGFzQ29udGV4dD10cnVlO3B1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO31lbHNle2hhc0NvbnRleHQ9ZmFsc2U7fXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9dmFsdWUuc3RhdGUhPT1udWxsJiZ2YWx1ZS5zdGF0ZSE9PXVuZGVmaW5lZD92YWx1ZS5zdGF0ZTpudWxsO2luaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7YWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLHZhbHVlKTttb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHByb3BzLHJlbmRlckxhbmVzKTtyZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQobnVsbCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsdHJ1ZSxoYXNDb250ZXh0LHJlbmRlckxhbmVzKTt9ZWxzZXsvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGZ1bmN0aW9uIGNvbXBvbmVudFxud29ya0luUHJvZ3Jlc3MudGFnPUZ1bmN0aW9uQ29tcG9uZW50O3tpZih3b3JrSW5Qcm9ncmVzcy5tb2RlJlN0cmljdExlZ2FjeU1vZGUpe3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO3RyeXt2YWx1ZT1yZW5kZXJXaXRoSG9va3MobnVsbCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQscHJvcHMsY29udGV4dCxyZW5kZXJMYW5lcyk7aGFzSWQ9Y2hlY2tEaWRSZW5kZXJJZEhvb2soKTt9ZmluYWxseXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7fX19aWYoZ2V0SXNIeWRyYXRpbmcoKSYmaGFzSWQpe3B1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO31yZWNvbmNpbGVDaGlsZHJlbihudWxsLHdvcmtJblByb2dyZXNzLHZhbHVlLHJlbmRlckxhbmVzKTt7dmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLENvbXBvbmVudCk7fXJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDt9fWZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQpe3tpZihDb21wb25lbnQpe2lmKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyl7ZXJyb3IoJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb24gY29tcG9uZW50LicsQ29tcG9uZW50LmRpc3BsYXlOYW1lfHxDb21wb25lbnQubmFtZXx8J0NvbXBvbmVudCcpO319aWYod29ya0luUHJvZ3Jlc3MucmVmIT09bnVsbCl7dmFyIGluZm89Jyc7dmFyIG93bmVyTmFtZT1nZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpO2lmKG93bmVyTmFtZSl7aW5mbys9J1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnK293bmVyTmFtZSsnYC4nO312YXIgd2FybmluZ0tleT1vd25lck5hbWV8fCcnO3ZhciBkZWJ1Z1NvdXJjZT13b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2U7aWYoZGVidWdTb3VyY2Upe3dhcm5pbmdLZXk9ZGVidWdTb3VyY2UuZmlsZU5hbWUrJzonK2RlYnVnU291cmNlLmxpbmVOdW1iZXI7fWlmKCFkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnNbd2FybmluZ0tleV0pe2RpZFdhcm5BYm91dEZ1bmN0aW9uUmVmc1t3YXJuaW5nS2V5XT10cnVlO2Vycm9yKCdGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnKydBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLiAnKydEaWQgeW91IG1lYW4gdG8gdXNlIFJlYWN0LmZvcndhcmRSZWYoKT8lcycsaW5mbyk7fX1pZihDb21wb25lbnQuZGVmYXVsdFByb3BzIT09dW5kZWZpbmVkKXt2YXIgY29tcG9uZW50TmFtZT1nZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KXx8J1Vua25vd24nO2lmKCFkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKXtlcnJvcignJXM6IFN1cHBvcnQgZm9yIGRlZmF1bHRQcm9wcyB3aWxsIGJlIHJlbW92ZWQgZnJvbSBmdW5jdGlvbiBjb21wb25lbnRzICcrJ2luIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIFVzZSBKYXZhU2NyaXB0IGRlZmF1bHQgcGFyYW1ldGVycyBpbnN0ZWFkLicsY29tcG9uZW50TmFtZSk7ZGlkV2FybkFib3V0RGVmYXVsdFByb3BzT25GdW5jdGlvbkNvbXBvbmVudFtjb21wb25lbnROYW1lXT10cnVlO319aWYodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9PT0nZnVuY3Rpb24nKXt2YXIgX2NvbXBvbmVudE5hbWUzPWdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpfHwnVW5rbm93bic7aWYoIWRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSl7ZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4nLF9jb21wb25lbnROYW1lMyk7ZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdPXRydWU7fX1pZih0eXBlb2YgQ29tcG9uZW50LmNvbnRleHRUeXBlPT09J29iamVjdCcmJkNvbXBvbmVudC5jb250ZXh0VHlwZSE9PW51bGwpe3ZhciBfY29tcG9uZW50TmFtZTQ9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCl8fCdVbmtub3duJztpZighZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0pe2Vycm9yKCclczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBjb250ZXh0VHlwZS4nLF9jb21wb25lbnROYW1lNCk7ZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF09dHJ1ZTt9fX19dmFyIFNVU1BFTkRFRF9NQVJLRVI9e2RlaHlkcmF0ZWQ6bnVsbCx0cmVlQ29udGV4dDpudWxsLHJldHJ5TGFuZTpOb0xhbmV9O2Z1bmN0aW9uIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcyl7cmV0dXJue2Jhc2VMYW5lczpyZW5kZXJMYW5lcyxjYWNoZVBvb2w6Z2V0U3VzcGVuZGVkQ2FjaGUoKSx0cmFuc2l0aW9uczpudWxsfTt9ZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShwcmV2T2Zmc2NyZWVuU3RhdGUscmVuZGVyTGFuZXMpe3ZhciBjYWNoZVBvb2w9bnVsbDtyZXR1cm57YmFzZUxhbmVzOm1lcmdlTGFuZXMocHJldk9mZnNjcmVlblN0YXRlLmJhc2VMYW5lcyxyZW5kZXJMYW5lcyksY2FjaGVQb29sOmNhY2hlUG9vbCx0cmFuc2l0aW9uczpwcmV2T2Zmc2NyZWVuU3RhdGUudHJhbnNpdGlvbnN9O30vLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgaW5saW5lIHRoaXMgYmFja1xuZnVuY3Rpb24gc2hvdWxkUmVtYWluT25GYWxsYmFjayhzdXNwZW5zZUNvbnRleHQsY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7Ly8gSWYgd2UncmUgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2ssIHRoZXJlIGFyZSBjYXNlcyB3aGVyZSB3ZSBuZWVkIHRvXG4vLyByZW1haW4gb24gdGhhdCBmYWxsYmFjayByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIGNvbnRlbnQgaGFzIHJlc29sdmVkLlxuLy8gRm9yIGV4YW1wbGUsIFN1c3BlbnNlTGlzdCBjb29yZGluYXRlcyB3aGVuIG5lc3RlZCBjb250ZW50IGFwcGVhcnMuXG5pZihjdXJyZW50IT09bnVsbCl7dmFyIHN1c3BlbnNlU3RhdGU9Y3VycmVudC5tZW1vaXplZFN0YXRlO2lmKHN1c3BlbnNlU3RhdGU9PT1udWxsKXsvLyBDdXJyZW50bHkgc2hvd2luZyBjb250ZW50LiBEb24ndCBoaWRlIGl0LCBldmVuIGlmIEZvcmNlU3VzcGVuc2VGYWxsYmFja1xuLy8gaXMgdHJ1ZS4gTW9yZSBwcmVjaXNlIG5hbWUgbWlnaHQgYmUgXCJGb3JjZVJlbWFpblN1c3BlbnNlRmFsbGJhY2tcIi5cbi8vIE5vdGU6IFRoaXMgaXMgYSBmYWN0b3Jpbmcgc21lbGwuIENhbid0IHJlbWFpbiBvbiBhIGZhbGxiYWNrIGlmIHRoZXJlJ3Ncbi8vIG5vIGZhbGxiYWNrIHRvIHJlbWFpbiBvbi5cbnJldHVybiBmYWxzZTt9fS8vIE5vdCBjdXJyZW50bHkgc2hvd2luZyBjb250ZW50LiBDb25zdWx0IHRoZSBTdXNwZW5zZSBjb250ZXh0LlxucmV0dXJuIGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTt9ZnVuY3Rpb24gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoY3VycmVudCxyZW5kZXJMYW5lcyl7Ly8gVE9ETzogU2hvdWxkIG5vdCByZW1vdmUgcmVuZGVyIGxhbmVzIHRoYXQgd2VyZSBwaW5nZWQgZHVyaW5nIHRoaXMgcmVuZGVyXG5yZXR1cm4gcmVtb3ZlTGFuZXMoY3VycmVudC5jaGlsZExhbmVzLHJlbmRlckxhbmVzKTt9ZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7dmFyIG5leHRQcm9wcz13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7Ly8gVGhpcyBpcyB1c2VkIGJ5IERldlRvb2xzIHRvIGZvcmNlIGEgYm91bmRhcnkgdG8gc3VzcGVuZC5cbntpZihzaG91bGRTdXNwZW5kKHdvcmtJblByb2dyZXNzKSl7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PURpZENhcHR1cmU7fX12YXIgc3VzcGVuc2VDb250ZXh0PXN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDt2YXIgc2hvd0ZhbGxiYWNrPWZhbHNlO3ZhciBkaWRTdXNwZW5kPSh3b3JrSW5Qcm9ncmVzcy5mbGFncyZEaWRDYXB0dXJlKSE9PU5vRmxhZ3M7aWYoZGlkU3VzcGVuZHx8c2hvdWxkUmVtYWluT25GYWxsYmFjayhzdXNwZW5zZUNvbnRleHQsY3VycmVudCkpey8vIFNvbWV0aGluZyBpbiB0aGlzIGJvdW5kYXJ5J3Mgc3VidHJlZSBhbHJlYWR5IHN1c3BlbmRlZC4gU3dpdGNoIHRvXG4vLyByZW5kZXJpbmcgdGhlIGZhbGxiYWNrIGNoaWxkcmVuLlxuc2hvd0ZhbGxiYWNrPXRydWU7d29ya0luUHJvZ3Jlc3MuZmxhZ3MmPX5EaWRDYXB0dXJlO31lbHNley8vIEF0dGVtcHRpbmcgdGhlIG1haW4gY29udGVudFxuaWYoY3VycmVudD09PW51bGx8fGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSE9PW51bGwpey8vIFRoaXMgaXMgYSBuZXcgbW91bnQgb3IgdGhpcyBib3VuZGFyeSBpcyBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjayBzdGF0ZS5cbi8vIE1hcmsgdGhpcyBzdWJ0cmVlIGNvbnRleHQgYXMgaGF2aW5nIGF0IGxlYXN0IG9uZSBpbnZpc2libGUgcGFyZW50IHRoYXQgY291bGRcbi8vIGhhbmRsZSB0aGUgZmFsbGJhY2sgc3RhdGUuXG4vLyBBdm9pZGVkIGJvdW5kYXJpZXMgYXJlIG5vdCBjb25zaWRlcmVkIHNpbmNlIHRoZXkgY2Fubm90IGhhbmRsZSBwcmVmZXJyZWQgZmFsbGJhY2sgc3RhdGVzLlxue3N1c3BlbnNlQ29udGV4dD1hZGRTdWJ0cmVlU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCxJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQpO319fXN1c3BlbnNlQ29udGV4dD1zZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQpO3B1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3Msc3VzcGVuc2VDb250ZXh0KTsvLyBPSywgdGhlIG5leHQgcGFydCBpcyBjb25mdXNpbmcuIFdlJ3JlIGFib3V0IHRvIHJlY29uY2lsZSB0aGUgU3VzcGVuc2Vcbi8vIGJvdW5kYXJ5J3MgY2hpbGRyZW4uIFRoaXMgaW52b2x2ZXMgc29tZSBjdXN0b20gcmVjb25jaWxpYXRpb24gbG9naWMuIFR3b1xuLy8gbWFpbiByZWFzb25zIHRoaXMgaXMgc28gY29tcGxpY2F0ZWQuXG4vL1xuLy8gRmlyc3QsIExlZ2FjeSBNb2RlIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gVGhlXG4vLyBwcmltYXJ5IHRyZWUgd2lsbCBjb21taXQgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLCBzbyB3aGVuIHdlIGRvIHRoZVxuLy8gc2Vjb25kIHBhc3MgdG8gcmVuZGVyIHRoZSBmYWxsYmFjaywgd2UgZG8gc29tZSBleGNlZWRpbmdseSwgdWgsIGNsZXZlclxuLy8gaGFja3MgdG8gbWFrZSB0aGF0IG5vdCB0b3RhbGx5IGJyZWFrLiBMaWtlIHRyYW5zZmVycmluZyBlZmZlY3RzIGFuZFxuLy8gZGVsZXRpb25zIGZyb20gaGlkZGVuIHRyZWUuIEluIENvbmN1cnJlbnQgTW9kZSwgaXQncyBtdWNoIHNpbXBsZXIsXG4vLyBiZWNhdXNlIHdlIGJhaWxvdXQgb24gdGhlIHByaW1hcnkgdHJlZSBjb21wbGV0ZWx5IGFuZCBsZWF2ZSBpdCBpbiBpdHMgb2xkXG4vLyBzdGF0ZSwgbm8gZWZmZWN0cy4gU2FtZSBhcyB3aGF0IHdlIGRvIGZvciBPZmZzY3JlZW4gKGV4Y2VwdCB0aGF0XG4vLyBPZmZzY3JlZW4gZG9lc24ndCBoYXZlIHRoZSBmaXJzdCByZW5kZXIgcGFzcykuXG4vL1xuLy8gU2Vjb25kIGlzIGh5ZHJhdGlvbi4gRHVyaW5nIGh5ZHJhdGlvbiwgdGhlIFN1c3BlbnNlIGZpYmVyIGhhcyBhIHNsaWdodGx5XG4vLyBkaWZmZXJlbnQgbGF5b3V0LCB3aGVyZSB0aGUgY2hpbGQgcG9pbnRzIHRvIGEgZGVoeWRyYXRlZCBmcmFnbWVudCwgd2hpY2hcbi8vIGNvbnRhaW5zIHRoZSBET00gcmVuZGVyZWQgYnkgdGhlIHNlcnZlci5cbi8vXG4vLyBUaGlyZCwgZXZlbiBpZiB5b3Ugc2V0IGFsbCB0aGF0IGFzaWRlLCBTdXNwZW5zZSBpcyBsaWtlIGVycm9yIGJvdW5kYXJpZXMgaW5cbi8vIHRoYXQgd2UgZmlyc3Qgd2UgdHJ5IHRvIHJlbmRlciBvbmUgdHJlZSwgYW5kIGlmIHRoYXQgZmFpbHMsIHdlIHJlbmRlciBhZ2FpblxuLy8gYW5kIHN3aXRjaCB0byBhIGRpZmZlcmVudCB0cmVlLiBMaWtlIGEgdHJ5L2NhdGNoIGJsb2NrLiBTbyB3ZSBoYXZlIHRvIHRyYWNrXG4vLyB3aGljaCBicmFuY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZy4gSWRlYWxseSB3ZSB3b3VsZCBtb2RlbCB0aGlzIHVzaW5nXG4vLyBhIHN0YWNrLlxuaWYoY3VycmVudD09PW51bGwpey8vIEluaXRpYWwgbW91bnRcbi8vIFNwZWNpYWwgcGF0aCBmb3IgaHlkcmF0aW9uXG4vLyBJZiB3ZSdyZSBjdXJyZW50bHkgaHlkcmF0aW5nLCB0cnkgdG8gaHlkcmF0ZSB0aGlzIGJvdW5kYXJ5LlxudHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpOy8vIFRoaXMgY291bGQndmUgYmVlbiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50LlxudmFyIHN1c3BlbnNlU3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtpZihzdXNwZW5zZVN0YXRlIT09bnVsbCl7dmFyIGRlaHlkcmF0ZWQ9c3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkO2lmKGRlaHlkcmF0ZWQhPT1udWxsKXtyZXR1cm4gbW91bnREZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQod29ya0luUHJvZ3Jlc3MsZGVoeWRyYXRlZCk7fX12YXIgbmV4dFByaW1hcnlDaGlsZHJlbj1uZXh0UHJvcHMuY2hpbGRyZW47dmFyIG5leHRGYWxsYmFja0NoaWxkcmVuPW5leHRQcm9wcy5mYWxsYmFjaztpZihzaG93RmFsbGJhY2spe3ZhciBmYWxsYmFja0ZyYWdtZW50PW1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLG5leHRQcmltYXJ5Q2hpbGRyZW4sbmV4dEZhbGxiYWNrQ2hpbGRyZW4scmVuZGVyTGFuZXMpO3ZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudD13b3JrSW5Qcm9ncmVzcy5jaGlsZDtwcmltYXJ5Q2hpbGRGcmFnbWVudC5tZW1vaXplZFN0YXRlPW1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcyk7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1TVVNQRU5ERURfTUFSS0VSO3JldHVybiBmYWxsYmFja0ZyYWdtZW50O31lbHNle3JldHVybiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLG5leHRQcmltYXJ5Q2hpbGRyZW4pO319ZWxzZXsvLyBUaGlzIGlzIGFuIHVwZGF0ZS5cbi8vIFNwZWNpYWwgcGF0aCBmb3IgaHlkcmF0aW9uXG52YXIgcHJldlN0YXRlPWN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtpZihwcmV2U3RhdGUhPT1udWxsKXt2YXIgX2RlaHlkcmF0ZWQ9cHJldlN0YXRlLmRlaHlkcmF0ZWQ7aWYoX2RlaHlkcmF0ZWQhPT1udWxsKXtyZXR1cm4gdXBkYXRlRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsZGlkU3VzcGVuZCxuZXh0UHJvcHMsX2RlaHlkcmF0ZWQscHJldlN0YXRlLHJlbmRlckxhbmVzKTt9fWlmKHNob3dGYWxsYmFjayl7dmFyIF9uZXh0RmFsbGJhY2tDaGlsZHJlbj1uZXh0UHJvcHMuZmFsbGJhY2s7dmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuPW5leHRQcm9wcy5jaGlsZHJlbjt2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50PXVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLF9uZXh0UHJpbWFyeUNoaWxkcmVuLF9uZXh0RmFsbGJhY2tDaGlsZHJlbixyZW5kZXJMYW5lcyk7dmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDI9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7dmFyIHByZXZPZmZzY3JlZW5TdGF0ZT1jdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGU7X3ByaW1hcnlDaGlsZEZyYWdtZW50Mi5tZW1vaXplZFN0YXRlPXByZXZPZmZzY3JlZW5TdGF0ZT09PW51bGw/bW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTp1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHByZXZPZmZzY3JlZW5TdGF0ZSxyZW5kZXJMYW5lcyk7X3ByaW1hcnlDaGlsZEZyYWdtZW50Mi5jaGlsZExhbmVzPWdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQscmVuZGVyTGFuZXMpO3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9U1VTUEVOREVEX01BUktFUjtyZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O31lbHNle3ZhciBfbmV4dFByaW1hcnlDaGlsZHJlbjI9bmV4dFByb3BzLmNoaWxkcmVuO3ZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQzPXVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsX25leHRQcmltYXJ5Q2hpbGRyZW4yLHJlbmRlckxhbmVzKTt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW51bGw7cmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDM7fX19ZnVuY3Rpb24gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcyxwcmltYXJ5Q2hpbGRyZW4scmVuZGVyTGFuZXMpe3ZhciBtb2RlPXdvcmtJblByb2dyZXNzLm1vZGU7dmFyIHByaW1hcnlDaGlsZFByb3BzPXttb2RlOid2aXNpYmxlJyxjaGlsZHJlbjpwcmltYXJ5Q2hpbGRyZW59O3ZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudD1tb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIocHJpbWFyeUNoaWxkUHJvcHMsbW9kZSk7cHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuPXdvcmtJblByb2dyZXNzO3dvcmtJblByb2dyZXNzLmNoaWxkPXByaW1hcnlDaGlsZEZyYWdtZW50O3JldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDt9ZnVuY3Rpb24gbW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4od29ya0luUHJvZ3Jlc3MscHJpbWFyeUNoaWxkcmVuLGZhbGxiYWNrQ2hpbGRyZW4scmVuZGVyTGFuZXMpe3ZhciBtb2RlPXdvcmtJblByb2dyZXNzLm1vZGU7dmFyIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQ9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7dmFyIHByaW1hcnlDaGlsZFByb3BzPXttb2RlOidoaWRkZW4nLGNoaWxkcmVuOnByaW1hcnlDaGlsZHJlbn07dmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O3ZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7aWYoKG1vZGUmQ29uY3VycmVudE1vZGUpPT09Tm9Nb2RlJiZwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50IT09bnVsbCl7Ly8gSW4gbGVnYWN5IG1vZGUsIHdlIGNvbW1pdCB0aGUgcHJpbWFyeSB0cmVlIGFzIGlmIGl0IHN1Y2Nlc3NmdWxseVxuLy8gY29tcGxldGVkLCBldmVuIHRob3VnaCBpdCdzIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS5cbnByaW1hcnlDaGlsZEZyYWdtZW50PXByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQ7cHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcz1Ob0xhbmVzO3ByaW1hcnlDaGlsZEZyYWdtZW50LnBlbmRpbmdQcm9wcz1wcmltYXJ5Q2hpbGRQcm9wcztpZih3b3JrSW5Qcm9ncmVzcy5tb2RlJlByb2ZpbGVNb2RlKXsvLyBSZXNldCB0aGUgZHVyYXRpb25zIGZyb20gdGhlIGZpcnN0IHBhc3Mgc28gdGhleSBhcmVuJ3QgaW5jbHVkZWQgaW4gdGhlXG4vLyBmaW5hbCBhbW91bnRzLiBUaGlzIHNlZW1zIGNvdW50ZXJpbnR1aXRpdmUsIHNpbmNlIHdlJ3JlIGludGVudGlvbmFsbHlcbi8vIG5vdCBtZWFzdXJpbmcgcGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLCBidXQgdGhpcyBtYWtlcyBpdCBtYXRjaCB3aGF0IHdlXG4vLyBkbyBpbiBDb25jdXJyZW50IE1vZGUuXG5wcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxEdXJhdGlvbj0wO3ByaW1hcnlDaGlsZEZyYWdtZW50LmFjdHVhbFN0YXJ0VGltZT0tMTtwcmltYXJ5Q2hpbGRGcmFnbWVudC5zZWxmQmFzZUR1cmF0aW9uPTA7cHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbj0wO31mYWxsYmFja0NoaWxkRnJhZ21lbnQ9Y3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbixtb2RlLHJlbmRlckxhbmVzLG51bGwpO31lbHNle3ByaW1hcnlDaGlsZEZyYWdtZW50PW1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihwcmltYXJ5Q2hpbGRQcm9wcyxtb2RlKTtmYWxsYmFja0NoaWxkRnJhZ21lbnQ9Y3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbixtb2RlLHJlbmRlckxhbmVzLG51bGwpO31wcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm49d29ya0luUHJvZ3Jlc3M7ZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybj13b3JrSW5Qcm9ncmVzcztwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nPWZhbGxiYWNrQ2hpbGRGcmFnbWVudDt3b3JrSW5Qcm9ncmVzcy5jaGlsZD1wcmltYXJ5Q2hpbGRGcmFnbWVudDtyZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O31mdW5jdGlvbiBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIob2Zmc2NyZWVuUHJvcHMsbW9kZSxyZW5kZXJMYW5lcyl7Ly8gVGhlIHByb3BzIGFyZ3VtZW50IHRvIGBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW5gIGlzIGBhbnlgIHR5cGVkLCBzbyB3ZSB1c2Vcbi8vIHRoaXMgd3JhcHBlciBmdW5jdGlvbiB0byBjb25zdHJhaW4gaXQuXG5yZXR1cm4gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKG9mZnNjcmVlblByb3BzLG1vZGUsTm9MYW5lcyxudWxsKTt9ZnVuY3Rpb24gdXBkYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50LG9mZnNjcmVlblByb3BzKXsvLyBUaGUgcHJvcHMgYXJndW1lbnQgdG8gYGNyZWF0ZVdvcmtJblByb2dyZXNzYCBpcyBgYW55YCB0eXBlZCwgc28gd2UgdXNlIHRoaXNcbi8vIHdyYXBwZXIgZnVuY3Rpb24gdG8gY29uc3RyYWluIGl0LlxucmV0dXJuIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsb2Zmc2NyZWVuUHJvcHMpO31mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLHByaW1hcnlDaGlsZHJlbixyZW5kZXJMYW5lcyl7dmFyIGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudD1jdXJyZW50LmNoaWxkO3ZhciBjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50PWN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO3ZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudD11cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCx7bW9kZTondmlzaWJsZScsY2hpbGRyZW46cHJpbWFyeUNoaWxkcmVufSk7aWYoKHdvcmtJblByb2dyZXNzLm1vZGUmQ29uY3VycmVudE1vZGUpPT09Tm9Nb2RlKXtwcmltYXJ5Q2hpbGRGcmFnbWVudC5sYW5lcz1yZW5kZXJMYW5lczt9cHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuPXdvcmtJblByb2dyZXNzO3ByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmc9bnVsbDtpZihjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50IT09bnVsbCl7Ly8gRGVsZXRlIHRoZSBmYWxsYmFjayBjaGlsZCBmcmFnbWVudFxudmFyIGRlbGV0aW9ucz13b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnM7aWYoZGVsZXRpb25zPT09bnVsbCl7d29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zPVtjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50XTt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9Q2hpbGREZWxldGlvbjt9ZWxzZXtkZWxldGlvbnMucHVzaChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50KTt9fXdvcmtJblByb2dyZXNzLmNoaWxkPXByaW1hcnlDaGlsZEZyYWdtZW50O3JldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDt9ZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscHJpbWFyeUNoaWxkcmVuLGZhbGxiYWNrQ2hpbGRyZW4scmVuZGVyTGFuZXMpe3ZhciBtb2RlPXdvcmtJblByb2dyZXNzLm1vZGU7dmFyIGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudD1jdXJyZW50LmNoaWxkO3ZhciBjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50PWN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO3ZhciBwcmltYXJ5Q2hpbGRQcm9wcz17bW9kZTonaGlkZGVuJyxjaGlsZHJlbjpwcmltYXJ5Q2hpbGRyZW59O3ZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudDtpZigvLyBJbiBsZWdhY3kgbW9kZSwgd2UgY29tbWl0IHRoZSBwcmltYXJ5IHRyZWUgYXMgaWYgaXQgc3VjY2Vzc2Z1bGx5XG4vLyBjb21wbGV0ZWQsIGV2ZW4gdGhvdWdoIGl0J3MgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLlxuKG1vZGUmQ29uY3VycmVudE1vZGUpPT09Tm9Nb2RlJiYvLyBNYWtlIHN1cmUgd2UncmUgb24gdGhlIHNlY29uZCBwYXNzLCBpLmUuIHRoZSBwcmltYXJ5IGNoaWxkIGZyYWdtZW50IHdhc1xuLy8gYWxyZWFkeSBjbG9uZWQuIEluIGxlZ2FjeSBtb2RlLCB0aGUgb25seSBjYXNlIHdoZXJlIHRoaXMgaXNuJ3QgdHJ1ZSBpc1xuLy8gd2hlbiBEZXZUb29scyBmb3JjZXMgdXMgdG8gZGlzcGxheSBhIGZhbGxiYWNrOyB3ZSBza2lwIHRoZSBmaXJzdCByZW5kZXJcbi8vIHBhc3MgZW50aXJlbHkgYW5kIGdvIHN0cmFpZ2h0IHRvIHJlbmRlcmluZyB0aGUgZmFsbGJhY2suIChJbiBDb25jdXJyZW50XG4vLyBNb2RlLCBTdXNwZW5zZUxpc3QgY2FuIGFsc28gdHJpZ2dlciB0aGlzIHNjZW5hcmlvLCBidXQgdGhpcyBpcyBhIGxlZ2FjeS1cbi8vIG9ubHkgY29kZXBhdGguKVxud29ya0luUHJvZ3Jlc3MuY2hpbGQhPT1jdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQpe3ZhciBwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50PXdvcmtJblByb2dyZXNzLmNoaWxkO3ByaW1hcnlDaGlsZEZyYWdtZW50PXByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQ7cHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcz1Ob0xhbmVzO3ByaW1hcnlDaGlsZEZyYWdtZW50LnBlbmRpbmdQcm9wcz1wcmltYXJ5Q2hpbGRQcm9wcztpZih3b3JrSW5Qcm9ncmVzcy5tb2RlJlByb2ZpbGVNb2RlKXsvLyBSZXNldCB0aGUgZHVyYXRpb25zIGZyb20gdGhlIGZpcnN0IHBhc3Mgc28gdGhleSBhcmVuJ3QgaW5jbHVkZWQgaW4gdGhlXG4vLyBmaW5hbCBhbW91bnRzLiBUaGlzIHNlZW1zIGNvdW50ZXJpbnR1aXRpdmUsIHNpbmNlIHdlJ3JlIGludGVudGlvbmFsbHlcbi8vIG5vdCBtZWFzdXJpbmcgcGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLCBidXQgdGhpcyBtYWtlcyBpdCBtYXRjaCB3aGF0IHdlXG4vLyBkbyBpbiBDb25jdXJyZW50IE1vZGUuXG5wcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxEdXJhdGlvbj0wO3ByaW1hcnlDaGlsZEZyYWdtZW50LmFjdHVhbFN0YXJ0VGltZT0tMTtwcmltYXJ5Q2hpbGRGcmFnbWVudC5zZWxmQmFzZUR1cmF0aW9uPWN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zZWxmQmFzZUR1cmF0aW9uO3ByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb249Y3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247fS8vIFRoZSBmYWxsYmFjayBmaWJlciB3YXMgYWRkZWQgYXMgYSBkZWxldGlvbiBkdXJpbmcgdGhlIGZpcnN0IHBhc3MuXG4vLyBIb3dldmVyLCBzaW5jZSB3ZSdyZSBnb2luZyB0byByZW1haW4gb24gdGhlIGZhbGxiYWNrLCB3ZSBubyBsb25nZXIgd2FudFxuLy8gdG8gZGVsZXRlIGl0Llxud29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zPW51bGw7fWVsc2V7cHJpbWFyeUNoaWxkRnJhZ21lbnQ9dXBkYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQscHJpbWFyeUNoaWxkUHJvcHMpOy8vIFNpbmNlIHdlJ3JlIHJldXNpbmcgYSBjdXJyZW50IHRyZWUsIHdlIG5lZWQgdG8gcmV1c2UgdGhlIGZsYWdzLCB0b28uXG4vLyAoV2UgZG9uJ3QgZG8gdGhpcyBpbiBsZWdhY3kgbW9kZSwgYmVjYXVzZSBpbiBsZWdhY3kgbW9kZSB3ZSBkb24ndCByZS11c2Vcbi8vIHRoZSBjdXJyZW50IHRyZWU7IHNlZSBwcmV2aW91cyBicmFuY2guKVxucHJpbWFyeUNoaWxkRnJhZ21lbnQuc3VidHJlZUZsYWdzPWN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zdWJ0cmVlRmxhZ3MmU3RhdGljTWFzazt9dmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtpZihjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50IT09bnVsbCl7ZmFsbGJhY2tDaGlsZEZyYWdtZW50PWNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQsZmFsbGJhY2tDaGlsZHJlbik7fWVsc2V7ZmFsbGJhY2tDaGlsZEZyYWdtZW50PWNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sbW9kZSxyZW5kZXJMYW5lcyxudWxsKTsvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2UgYm91bmRhcnkpIGFscmVhZHlcbi8vIG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5mYWxsYmFja0NoaWxkRnJhZ21lbnQuZmxhZ3N8PVBsYWNlbWVudDt9ZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybj13b3JrSW5Qcm9ncmVzcztwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm49d29ya0luUHJvZ3Jlc3M7cHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZz1mYWxsYmFja0NoaWxkRnJhZ21lbnQ7d29ya0luUHJvZ3Jlc3MuY2hpbGQ9cHJpbWFyeUNoaWxkRnJhZ21lbnQ7cmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDt9ZnVuY3Rpb24gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyxyZWNvdmVyYWJsZUVycm9yKXsvLyBGYWxsaW5nIGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy4gQmVjYXVzZSB0aGlzIGhhcyBwZXJmb3JtYW5jZVxuLy8gaW1wbGljYXRpb25zLCBpdCdzIGNvbnNpZGVyZWQgYSByZWNvdmVyYWJsZSBlcnJvciwgZXZlbiB0aG91Z2ggdGhlIHVzZXJcbi8vIGxpa2VseSB3b24ndCBvYnNlcnZlIGFueXRoaW5nIHdyb25nIHdpdGggdGhlIFVJLlxuLy9cbi8vIFRoZSBlcnJvciBpcyBwYXNzZWQgaW4gYXMgYW4gYXJndW1lbnQgdG8gZW5mb3JjZSB0aGF0IGV2ZXJ5IGNhbGxlciBwcm92aWRlXG4vLyBhIGN1c3RvbSBtZXNzYWdlLCBvciBleHBsaWNpdGx5IG9wdCBvdXQgKGN1cnJlbnRseSB0aGUgb25seSBwYXRoIHRoYXQgb3B0c1xuLy8gb3V0IGlzIGxlZ2FjeSBtb2RlOyBldmVyeSBjb25jdXJyZW50IHBhdGggcHJvdmlkZXMgYW4gZXJyb3IpLlxuaWYocmVjb3ZlcmFibGVFcnJvciE9PW51bGwpe3F1ZXVlSHlkcmF0aW9uRXJyb3IocmVjb3ZlcmFibGVFcnJvcik7fS8vIFRoaXMgd2lsbCBhZGQgdGhlIG9sZCBmaWJlciB0byB0aGUgZGVsZXRpb24gbGlzdFxucmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsY3VycmVudC5jaGlsZCxudWxsLHJlbmRlckxhbmVzKTsvLyBXZSdyZSBub3cgbm90IHN1c3BlbmRlZCBub3IgZGVoeWRyYXRlZC5cbnZhciBuZXh0UHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciBwcmltYXJ5Q2hpbGRyZW49bmV4dFByb3BzLmNoaWxkcmVuO3ZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudD1tb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLHByaW1hcnlDaGlsZHJlbik7Ly8gTmVlZHMgYSBwbGFjZW1lbnQgZWZmZWN0IGJlY2F1c2UgdGhlIHBhcmVudCAodGhlIFN1c3BlbnNlIGJvdW5kYXJ5KSBhbHJlYWR5XG4vLyBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxucHJpbWFyeUNoaWxkRnJhZ21lbnQuZmxhZ3N8PVBsYWNlbWVudDt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW51bGw7cmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O31mdW5jdGlvbiBtb3VudFN1c3BlbnNlRmFsbGJhY2tBZnRlclJldHJ5V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LHdvcmtJblByb2dyZXNzLHByaW1hcnlDaGlsZHJlbixmYWxsYmFja0NoaWxkcmVuLHJlbmRlckxhbmVzKXt2YXIgZmliZXJNb2RlPXdvcmtJblByb2dyZXNzLm1vZGU7dmFyIHByaW1hcnlDaGlsZFByb3BzPXttb2RlOid2aXNpYmxlJyxjaGlsZHJlbjpwcmltYXJ5Q2hpbGRyZW59O3ZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudD1tb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIocHJpbWFyeUNoaWxkUHJvcHMsZmliZXJNb2RlKTt2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50PWNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sZmliZXJNb2RlLHJlbmRlckxhbmVzLG51bGwpOy8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZVxuLy8gYm91bmRhcnkpIGFscmVhZHkgbW91bnRlZCBidXQgdGhpcyBpcyBhIG5ldyBmaWJlci5cbmZhbGxiYWNrQ2hpbGRGcmFnbWVudC5mbGFnc3w9UGxhY2VtZW50O3ByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybj13b3JrSW5Qcm9ncmVzcztmYWxsYmFja0NoaWxkRnJhZ21lbnQucmV0dXJuPXdvcmtJblByb2dyZXNzO3ByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmc9ZmFsbGJhY2tDaGlsZEZyYWdtZW50O3dvcmtJblByb2dyZXNzLmNoaWxkPXByaW1hcnlDaGlsZEZyYWdtZW50O2lmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJkNvbmN1cnJlbnRNb2RlKSE9PU5vTW9kZSl7Ly8gV2Ugd2lsbCBoYXZlIGRyb3BwZWQgdGhlIGVmZmVjdCBsaXN0IHdoaWNoIGNvbnRhaW5zIHRoZVxuLy8gZGVsZXRpb24uIFdlIG5lZWQgdG8gcmVjb25jaWxlIHRvIGRlbGV0ZSB0aGUgY3VycmVudCBjaGlsZC5cbnJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLGN1cnJlbnQuY2hpbGQsbnVsbCxyZW5kZXJMYW5lcyk7fXJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7fWZ1bmN0aW9uIG1vdW50RGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KHdvcmtJblByb2dyZXNzLHN1c3BlbnNlSW5zdGFuY2UscmVuZGVyTGFuZXMpey8vIER1cmluZyB0aGUgZmlyc3QgcGFzcywgd2UnbGwgYmFpbCBvdXQgYW5kIG5vdCBkcmlsbCBpbnRvIHRoZSBjaGlsZHJlbi5cbi8vIEluc3RlYWQsIHdlJ2xsIGxlYXZlIHRoZSBjb250ZW50IGluIHBsYWNlIGFuZCB0cnkgdG8gaHlkcmF0ZSBpdCBsYXRlci5cbmlmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJkNvbmN1cnJlbnRNb2RlKT09PU5vTW9kZSl7e2Vycm9yKCdDYW5ub3QgaHlkcmF0ZSBTdXNwZW5zZSBpbiBsZWdhY3kgbW9kZS4gU3dpdGNoIGZyb20gJysnUmVhY3RET00uaHlkcmF0ZShlbGVtZW50LCBjb250YWluZXIpIHRvICcrJ1JlYWN0RE9NQ2xpZW50Lmh5ZHJhdGVSb290KGNvbnRhaW5lciwgPEFwcCAvPiknKycucmVuZGVyKGVsZW1lbnQpIG9yIHJlbW92ZSB0aGUgU3VzcGVuc2UgY29tcG9uZW50cyBmcm9tICcrJ3RoZSBzZXJ2ZXIgcmVuZGVyZWQgY29tcG9uZW50cy4nKTt9d29ya0luUHJvZ3Jlc3MubGFuZXM9bGFuZVRvTGFuZXMoU3luY0xhbmUpO31lbHNlIGlmKGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKHN1c3BlbnNlSW5zdGFuY2UpKXsvLyBUaGlzIGlzIGEgY2xpZW50LW9ubHkgYm91bmRhcnkuIFNpbmNlIHdlIHdvbid0IGdldCBhbnkgY29udGVudCBmcm9tIHRoZSBzZXJ2ZXJcbi8vIGZvciB0aGlzLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoYXQgYXQgYSBoaWdoZXIgcHJpb3JpdHkgYmFzZWQgb24gd2hlbiBpdCB3b3VsZFxuLy8gaGF2ZSB0aW1lZCBvdXQuIEluIHRoZW9yeSB3ZSBjb3VsZCByZW5kZXIgaXQgaW4gdGhpcyBwYXNzIGJ1dCBpdCB3b3VsZCBoYXZlIHRoZVxuLy8gd3JvbmcgcHJpb3JpdHkgYXNzb2NpYXRlZCB3aXRoIGl0IGFuZCB3aWxsIHByZXZlbnQgaHlkcmF0aW9uIG9mIHBhcmVudCBwYXRoLlxuLy8gSW5zdGVhZCwgd2UnbGwgbGVhdmUgd29yayBsZWZ0IG9uIGl0IHRvIHJlbmRlciBpdCBpbiBhIHNlcGFyYXRlIGNvbW1pdC5cbi8vIFRPRE8gVGhpcyB0aW1lIHNob3VsZCBiZSB0aGUgdGltZSBhdCB3aGljaCB0aGUgc2VydmVyIHJlbmRlcmVkIHJlc3BvbnNlIHRoYXQgaXNcbi8vIGEgcGFyZW50IHRvIHRoaXMgYm91bmRhcnkgd2FzIGRpc3BsYXllZC4gSG93ZXZlciwgc2luY2Ugd2UgY3VycmVudGx5IGRvbid0IGhhdmVcbi8vIGEgcHJvdG9jb2wgdG8gdHJhbnNmZXIgdGhhdCB0aW1lLCB3ZSdsbCBqdXN0IGVzdGltYXRlIGl0IGJ5IHVzaW5nIHRoZSBjdXJyZW50XG4vLyB0aW1lLiBUaGlzIHdpbGwgbWVhbiB0aGF0IFN1c3BlbnNlIHRpbWVvdXRzIGFyZSBzbGlnaHRseSBzaGlmdGVkIHRvIGxhdGVyIHRoYW5cbi8vIHRoZXkgc2hvdWxkIGJlLlxuLy8gU2NoZWR1bGUgYSBub3JtYWwgcHJpIHVwZGF0ZSB0byByZW5kZXIgdGhpcyBjb250ZW50Llxud29ya0luUHJvZ3Jlc3MubGFuZXM9bGFuZVRvTGFuZXMoRGVmYXVsdEh5ZHJhdGlvbkxhbmUpO31lbHNley8vIFdlJ2xsIGNvbnRpbnVlIGh5ZHJhdGluZyB0aGUgcmVzdCBhdCBvZmZzY3JlZW4gcHJpb3JpdHkgc2luY2Ugd2UnbGwgYWxyZWFkeVxuLy8gYmUgc2hvd2luZyB0aGUgcmlnaHQgY29udGVudCBjb21pbmcgZnJvbSB0aGUgc2VydmVyLCBpdCBpcyBubyBydXNoLlxud29ya0luUHJvZ3Jlc3MubGFuZXM9bGFuZVRvTGFuZXMoT2Zmc2NyZWVuTGFuZSk7fXJldHVybiBudWxsO31mdW5jdGlvbiB1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxkaWRTdXNwZW5kLG5leHRQcm9wcyxzdXNwZW5zZUluc3RhbmNlLHN1c3BlbnNlU3RhdGUscmVuZGVyTGFuZXMpe2lmKCFkaWRTdXNwZW5kKXsvLyBUaGlzIGlzIHRoZSBmaXJzdCByZW5kZXIgcGFzcy4gQXR0ZW1wdCB0byBoeWRyYXRlLlxuLy8gV2Ugc2hvdWxkIG5ldmVyIGJlIGh5ZHJhdGluZyBhdCB0aGlzIHBvaW50IGJlY2F1c2UgaXQgaXMgdGhlIGZpcnN0IHBhc3MsXG4vLyBidXQgYWZ0ZXIgd2UndmUgYWxyZWFkeSBjb21taXR0ZWQgb25jZS5cbndhcm5JZkh5ZHJhdGluZygpO2lmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJkNvbmN1cnJlbnRNb2RlKT09PU5vTW9kZSl7cmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMsLy8gVE9ETzogV2hlbiB3ZSBkZWxldGUgbGVnYWN5IG1vZGUsIHdlIHNob3VsZCBtYWtlIHRoaXMgZXJyb3IgYXJndW1lbnRcbi8vIHJlcXVpcmVkIOKAlCBldmVyeSBjb25jdXJyZW50IG1vZGUgcGF0aCB0aGF0IGNhdXNlcyBoeWRyYXRpb24gdG9cbi8vIGRlLW9wdCB0byBjbGllbnQgcmVuZGVyaW5nIHNob3VsZCBoYXZlIGFuIGVycm9yIG1lc3NhZ2UuXG5udWxsKTt9aWYoaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soc3VzcGVuc2VJbnN0YW5jZSkpey8vIFRoaXMgYm91bmRhcnkgaXMgaW4gYSBwZXJtYW5lbnQgZmFsbGJhY2sgc3RhdGUuIEluIHRoaXMgY2FzZSwgd2UnbGwgbmV2ZXJcbi8vIGdldCBhbiB1cGRhdGUgYW5kIHdlJ2xsIG5ldmVyIGJlIGFibGUgdG8gaHlkcmF0ZSB0aGUgZmluYWwgY29udGVudC4gTGV0J3MganVzdCB0cnkgdGhlXG4vLyBjbGllbnQgc2lkZSByZW5kZXIgaW5zdGVhZC5cbnZhciBkaWdlc3QsbWVzc2FnZSxzdGFjazt7dmFyIF9nZXRTdXNwZW5zZUluc3RhbmNlRj1nZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHMoc3VzcGVuc2VJbnN0YW5jZSk7ZGlnZXN0PV9nZXRTdXNwZW5zZUluc3RhbmNlRi5kaWdlc3Q7bWVzc2FnZT1fZ2V0U3VzcGVuc2VJbnN0YW5jZUYubWVzc2FnZTtzdGFjaz1fZ2V0U3VzcGVuc2VJbnN0YW5jZUYuc3RhY2s7fXZhciBlcnJvcjtpZihtZXNzYWdlKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuZXJyb3I9bmV3IEVycm9yKG1lc3NhZ2UpO31lbHNle2Vycm9yPW5ldyBFcnJvcignVGhlIHNlcnZlciBjb3VsZCBub3QgZmluaXNoIHRoaXMgU3VzcGVuc2UgYm91bmRhcnksIGxpa2VseSAnKydkdWUgdG8gYW4gZXJyb3IgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuIFN3aXRjaGVkIHRvICcrJ2NsaWVudCByZW5kZXJpbmcuJyk7fXZhciBjYXB0dXJlZFZhbHVlPWNyZWF0ZUNhcHR1cmVkVmFsdWUoZXJyb3IsZGlnZXN0LHN0YWNrKTtyZXR1cm4gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyxjYXB0dXJlZFZhbHVlKTt9Ly8gYW55IGNvbnRleHQgaGFzIGNoYW5nZWQsIHdlIG5lZWQgdG8gdHJlYXQgaXMgYXMgaWYgdGhlIGlucHV0IG1pZ2h0IGhhdmUgY2hhbmdlZC5cbnZhciBoYXNDb250ZXh0Q2hhbmdlZD1pbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLGN1cnJlbnQuY2hpbGRMYW5lcyk7aWYoZGlkUmVjZWl2ZVVwZGF0ZXx8aGFzQ29udGV4dENoYW5nZWQpey8vIFRoaXMgYm91bmRhcnkgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGZpcnN0IHJlbmRlci4gVGhpcyBtZWFucyB0aGF0IHdlIGFyZSBub3cgdW5hYmxlIHRvXG4vLyBoeWRyYXRlIGl0LiBXZSBtaWdodCBzdGlsbCBiZSBhYmxlIHRvIGh5ZHJhdGUgaXQgdXNpbmcgYSBoaWdoZXIgcHJpb3JpdHkgbGFuZS5cbnZhciByb290PWdldFdvcmtJblByb2dyZXNzUm9vdCgpO2lmKHJvb3QhPT1udWxsKXt2YXIgYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZT1nZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uKHJvb3QscmVuZGVyTGFuZXMpO2lmKGF0dGVtcHRIeWRyYXRpb25BdExhbmUhPT1Ob0xhbmUmJmF0dGVtcHRIeWRyYXRpb25BdExhbmUhPT1zdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSl7Ly8gSW50ZW50aW9uYWxseSBtdXRhdGluZyBzaW5jZSB0aGlzIHJlbmRlciB3aWxsIGdldCBpbnRlcnJ1cHRlZC4gVGhpc1xuLy8gaXMgb25lIG9mIHRoZSB2ZXJ5IHJhcmUgdGltZXMgd2hlcmUgd2UgbXV0YXRlIHRoZSBjdXJyZW50IHRyZWVcbi8vIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmU9YXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZTsvLyBUT0RPOiBJZGVhbGx5IHRoaXMgd291bGQgaW5oZXJpdCB0aGUgZXZlbnQgdGltZSBvZiB0aGUgY3VycmVudCByZW5kZXJcbnZhciBldmVudFRpbWU9Tm9UaW1lc3RhbXA7ZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGN1cnJlbnQsYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSk7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsY3VycmVudCxhdHRlbXB0SHlkcmF0aW9uQXRMYW5lLGV2ZW50VGltZSk7fX0vLyBJZiB3ZSBoYXZlIHNjaGVkdWxlZCBoaWdoZXIgcHJpIHdvcmsgYWJvdmUsIHRoaXMgd2lsbCBwcm9iYWJseSBqdXN0IGFib3J0IHRoZSByZW5kZXJcbi8vIHNpbmNlIHdlIG5vdyBoYXZlIGhpZ2hlciBwcmlvcml0eSB3b3JrLCBidXQgaW4gY2FzZSBpdCBkb2Vzbid0LCB3ZSBuZWVkIHRvIHByZXBhcmUgdG9cbi8vIHJlbmRlciBzb21ldGhpbmcsIGlmIHdlIHRpbWUgb3V0LiBFdmVuIGlmIHRoYXQgcmVxdWlyZXMgdXMgdG8gZGVsZXRlIGV2ZXJ5dGhpbmcgYW5kXG4vLyBza2lwIGh5ZHJhdGlvbi5cbi8vIERlbGF5IGhhdmluZyB0byBkbyB0aGlzIGFzIGxvbmcgYXMgdGhlIHN1c3BlbnNlIHRpbWVvdXQgYWxsb3dzIHVzLlxucmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO3ZhciBfY2FwdHVyZWRWYWx1ZT1jcmVhdGVDYXB0dXJlZFZhbHVlKG5ldyBFcnJvcignVGhpcyBTdXNwZW5zZSBib3VuZGFyeSByZWNlaXZlZCBhbiB1cGRhdGUgYmVmb3JlIGl0IGZpbmlzaGVkICcrJ2h5ZHJhdGluZy4gVGhpcyBjYXVzZWQgdGhlIGJvdW5kYXJ5IHRvIHN3aXRjaCB0byBjbGllbnQgcmVuZGVyaW5nLiAnKydUaGUgdXN1YWwgd2F5IHRvIGZpeCB0aGlzIGlzIHRvIHdyYXAgdGhlIG9yaWdpbmFsIHVwZGF0ZSAnKydpbiBzdGFydFRyYW5zaXRpb24uJykpO3JldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzLF9jYXB0dXJlZFZhbHVlKTt9ZWxzZSBpZihpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKHN1c3BlbnNlSW5zdGFuY2UpKXsvLyBUaGlzIGNvbXBvbmVudCBpcyBzdGlsbCBwZW5kaW5nIG1vcmUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIHNvIHdlIGNhbid0IGh5ZHJhdGUgaXRzXG4vLyBjb250ZW50LiBXZSB0cmVhdCBpdCBhcyBpZiB0aGlzIGNvbXBvbmVudCBzdXNwZW5kZWQgaXRzZWxmLiBJdCBtaWdodCBzZWVtIGFzIGlmXG4vLyB3ZSBjb3VsZCBqdXN0IHRyeSB0byByZW5kZXIgaXQgY2xpZW50LXNpZGUgaW5zdGVhZC4gSG93ZXZlciwgdGhpcyB3aWxsIHBlcmZvcm0gYVxuLy8gbG90IG9mIHVubmVjZXNzYXJ5IHdvcmsgYW5kIGlzIHVubGlrZWx5IHRvIGNvbXBsZXRlIHNpbmNlIGl0IG9mdGVuIHdpbGwgc3VzcGVuZFxuLy8gb24gbWlzc2luZyBkYXRhIGFueXdheS4gQWRkaXRpb25hbGx5LCB0aGUgc2VydmVyIG1pZ2h0IGJlIGFibGUgdG8gcmVuZGVyIG1vcmVcbi8vIHRoYW4gd2UgY2FuIG9uIHRoZSBjbGllbnQgeWV0LiBJbiB0aGF0IGNhc2Ugd2UnZCBlbmQgdXAgd2l0aCBtb3JlIGZhbGxiYWNrIHN0YXRlc1xuLy8gb24gdGhlIGNsaWVudCB0aGFuIGlmIHdlIGp1c3QgbGVhdmUgaXQgYWxvbmUuIElmIHRoZSBzZXJ2ZXIgdGltZXMgb3V0IG9yIGVycm9yc1xuLy8gdGhlc2Ugc2hvdWxkIHVwZGF0ZSB0aGlzIGJvdW5kYXJ5IHRvIHRoZSBwZXJtYW5lbnQgRmFsbGJhY2sgc3RhdGUgaW5zdGVhZC5cbi8vIE1hcmsgaXQgYXMgaGF2aW5nIGNhcHR1cmVkIChpLmUuIHN1c3BlbmRlZCkuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9RGlkQ2FwdHVyZTsvLyBMZWF2ZSB0aGUgY2hpbGQgaW4gcGxhY2UuIEkuZS4gdGhlIGRlaHlkcmF0ZWQgZnJhZ21lbnQuXG53b3JrSW5Qcm9ncmVzcy5jaGlsZD1jdXJyZW50LmNoaWxkOy8vIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gcmV0cnkgdGhpcyBib3VuZGFyeSBvbmNlIHRoZSBzZXJ2ZXIgaGFzIHNlbnQgdGhlIHJlc3VsdC5cbnZhciByZXRyeT1yZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5LmJpbmQobnVsbCxjdXJyZW50KTtyZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeShzdXNwZW5zZUluc3RhbmNlLHJldHJ5KTtyZXR1cm4gbnVsbDt9ZWxzZXsvLyBUaGlzIGlzIHRoZSBmaXJzdCBhdHRlbXB0LlxucmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHdvcmtJblByb2dyZXNzLHN1c3BlbnNlSW5zdGFuY2Usc3VzcGVuc2VTdGF0ZS50cmVlQ29udGV4dCk7dmFyIHByaW1hcnlDaGlsZHJlbj1uZXh0UHJvcHMuY2hpbGRyZW47dmFyIHByaW1hcnlDaGlsZEZyYWdtZW50PW1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MscHJpbWFyeUNoaWxkcmVuKTsvLyBNYXJrIHRoZSBjaGlsZHJlbiBhcyBoeWRyYXRpbmcuIFRoaXMgaXMgYSBmYXN0IHBhdGggdG8ga25vdyB3aGV0aGVyIHRoaXNcbi8vIHRyZWUgaXMgcGFydCBvZiBhIGh5ZHJhdGluZyB0cmVlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgY2hpbGRcbi8vIG5vZGUgaGFzIGZ1bGx5IG1vdW50ZWQgeWV0LCBhbmQgZm9yIHNjaGVkdWxpbmcgZXZlbnQgcmVwbGF5aW5nLlxuLy8gQ29uY2VwdHVhbGx5IHRoaXMgaXMgc2ltaWxhciB0byBQbGFjZW1lbnQgaW4gdGhhdCBhIG5ldyBzdWJ0cmVlIGlzXG4vLyBpbnNlcnRlZCBpbnRvIHRoZSBSZWFjdCB0cmVlIGhlcmUuIEl0IGp1c3QgaGFwcGVucyB0byBub3QgbmVlZCBET01cbi8vIG11dGF0aW9ucyBiZWNhdXNlIGl0IGFscmVhZHkgZXhpc3RzLlxucHJpbWFyeUNoaWxkRnJhZ21lbnQuZmxhZ3N8PUh5ZHJhdGluZztyZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7fX1lbHNley8vIFRoaXMgaXMgdGhlIHNlY29uZCByZW5kZXIgcGFzcy4gV2UgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gaHlkcmF0ZWQsIGJ1dFxuLy8gc29tZXRoaW5nIGVpdGhlciBzdXNwZW5kZWQgb3IgZXJyb3JlZC5cbmlmKHdvcmtJblByb2dyZXNzLmZsYWdzJkZvcmNlQ2xpZW50UmVuZGVyKXsvLyBTb21ldGhpbmcgZXJyb3JlZCBkdXJpbmcgaHlkcmF0aW9uLiBUcnkgYWdhaW4gd2l0aG91dCBoeWRyYXRpbmcuXG53b3JrSW5Qcm9ncmVzcy5mbGFncyY9fkZvcmNlQ2xpZW50UmVuZGVyO3ZhciBfY2FwdHVyZWRWYWx1ZTI9Y3JlYXRlQ2FwdHVyZWRWYWx1ZShuZXcgRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcgdGhpcyBTdXNwZW5zZSBib3VuZGFyeS4gJysnU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZy4nKSk7cmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMsX2NhcHR1cmVkVmFsdWUyKTt9ZWxzZSBpZih3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlIT09bnVsbCl7Ly8gU29tZXRoaW5nIHN1c3BlbmRlZCBhbmQgd2Ugc2hvdWxkIHN0aWxsIGJlIGluIGRlaHlkcmF0ZWQgbW9kZS5cbi8vIExlYXZlIHRoZSBleGlzdGluZyBjaGlsZCBpbiBwbGFjZS5cbndvcmtJblByb2dyZXNzLmNoaWxkPWN1cnJlbnQuY2hpbGQ7Ly8gVGhlIGRlaHlkcmF0ZWQgY29tcGxldGlvbiBwYXNzIGV4cGVjdHMgdGhpcyBmbGFnIHRvIGJlIHRoZXJlXG4vLyBidXQgdGhlIG5vcm1hbCBzdXNwZW5zZSBwYXNzIGRvZXNuJ3QuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9RGlkQ2FwdHVyZTtyZXR1cm4gbnVsbDt9ZWxzZXsvLyBTdXNwZW5kZWQgYnV0IHdlIHNob3VsZCBubyBsb25nZXIgYmUgaW4gZGVoeWRyYXRlZCBtb2RlLlxuLy8gVGhlcmVmb3JlIHdlIG5vdyBoYXZlIHRvIHJlbmRlciB0aGUgZmFsbGJhY2suXG52YXIgbmV4dFByaW1hcnlDaGlsZHJlbj1uZXh0UHJvcHMuY2hpbGRyZW47dmFyIG5leHRGYWxsYmFja0NoaWxkcmVuPW5leHRQcm9wcy5mYWxsYmFjazt2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50PW1vdW50U3VzcGVuc2VGYWxsYmFja0FmdGVyUmV0cnlXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dFByaW1hcnlDaGlsZHJlbixuZXh0RmFsbGJhY2tDaGlsZHJlbixyZW5kZXJMYW5lcyk7dmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDQ9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7X3ByaW1hcnlDaGlsZEZyYWdtZW50NC5tZW1vaXplZFN0YXRlPW1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcyk7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1TVVNQRU5ERURfTUFSS0VSO3JldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7fX19ZnVuY3Rpb24gc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKGZpYmVyLHJlbmRlckxhbmVzLHByb3BhZ2F0aW9uUm9vdCl7ZmliZXIubGFuZXM9bWVyZ2VMYW5lcyhmaWJlci5sYW5lcyxyZW5kZXJMYW5lcyk7dmFyIGFsdGVybmF0ZT1maWJlci5hbHRlcm5hdGU7aWYoYWx0ZXJuYXRlIT09bnVsbCl7YWx0ZXJuYXRlLmxhbmVzPW1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLHJlbmRlckxhbmVzKTt9c2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChmaWJlci5yZXR1cm4scmVuZGVyTGFuZXMscHJvcGFnYXRpb25Sb290KTt9ZnVuY3Rpb24gcHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLGZpcnN0Q2hpbGQscmVuZGVyTGFuZXMpey8vIE1hcmsgYW55IFN1c3BlbnNlIGJvdW5kYXJpZXMgd2l0aCBmYWxsYmFja3MgYXMgaGF2aW5nIHdvcmsgdG8gZG8uXG4vLyBJZiB0aGV5IHdlcmUgcHJldmlvdXNseSBmb3JjZWQgaW50byBmYWxsYmFja3MsIHRoZXkgbWF5IG5vdyBiZSBhYmxlXG4vLyB0byB1bmJsb2NrLlxudmFyIG5vZGU9Zmlyc3RDaGlsZDt3aGlsZShub2RlIT09bnVsbCl7aWYobm9kZS50YWc9PT1TdXNwZW5zZUNvbXBvbmVudCl7dmFyIHN0YXRlPW5vZGUubWVtb2l6ZWRTdGF0ZTtpZihzdGF0ZSE9PW51bGwpe3NjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihub2RlLHJlbmRlckxhbmVzLHdvcmtJblByb2dyZXNzKTt9fWVsc2UgaWYobm9kZS50YWc9PT1TdXNwZW5zZUxpc3RDb21wb25lbnQpey8vIElmIHRoZSB0YWlsIGlzIGhpZGRlbiB0aGVyZSBtaWdodCBub3QgYmUgYW4gU3VzcGVuc2UgYm91bmRhcmllc1xuLy8gdG8gc2NoZWR1bGUgd29yayBvbi4gSW4gdGhpcyBjYXNlIHdlIGhhdmUgdG8gc2NoZWR1bGUgaXQgb24gdGhlXG4vLyBsaXN0IGl0c2VsZi5cbi8vIFdlIGRvbid0IGhhdmUgdG8gdHJhdmVyc2UgdG8gdGhlIGNoaWxkcmVuIG9mIHRoZSBsaXN0IHNpbmNlXG4vLyB0aGUgbGlzdCB3aWxsIHByb3BhZ2F0ZSB0aGUgY2hhbmdlIHdoZW4gaXQgcmVyZW5kZXJzLlxuc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKG5vZGUscmVuZGVyTGFuZXMsd29ya0luUHJvZ3Jlc3MpO31lbHNlIGlmKG5vZGUuY2hpbGQhPT1udWxsKXtub2RlLmNoaWxkLnJldHVybj1ub2RlO25vZGU9bm9kZS5jaGlsZDtjb250aW51ZTt9aWYobm9kZT09PXdvcmtJblByb2dyZXNzKXtyZXR1cm47fXdoaWxlKG5vZGUuc2libGluZz09PW51bGwpe2lmKG5vZGUucmV0dXJuPT09bnVsbHx8bm9kZS5yZXR1cm49PT13b3JrSW5Qcm9ncmVzcyl7cmV0dXJuO31ub2RlPW5vZGUucmV0dXJuO31ub2RlLnNpYmxpbmcucmV0dXJuPW5vZGUucmV0dXJuO25vZGU9bm9kZS5zaWJsaW5nO319ZnVuY3Rpb24gZmluZExhc3RDb250ZW50Um93KGZpcnN0Q2hpbGQpey8vIFRoaXMgaXMgZ29pbmcgdG8gZmluZCB0aGUgbGFzdCByb3cgYW1vbmcgdGhlc2UgY2hpbGRyZW4gdGhhdCBpcyBhbHJlYWR5XG4vLyBzaG93aW5nIGNvbnRlbnQgb24gdGhlIHNjcmVlbiwgYXMgb3Bwb3NlZCB0byBiZWluZyBpbiBmYWxsYmFjayBzdGF0ZSBvclxuLy8gbmV3LiBJZiBhIHJvdyBoYXMgbXVsdGlwbGUgU3VzcGVuc2UgYm91bmRhcmllcywgYW55IG9mIHRoZW0gYmVpbmcgaW4gdGhlXG4vLyBmYWxsYmFjayBzdGF0ZSwgY291bnRzIGFzIHRoZSB3aG9sZSByb3cgYmVpbmcgaW4gYSBmYWxsYmFjayBzdGF0ZS5cbi8vIE5vdGUgdGhhdCB0aGUgXCJyb3dzXCIgd2lsbCBiZSB3b3JrSW5Qcm9ncmVzcywgYnV0IGFueSBuZXN0ZWQgY2hpbGRyZW5cbi8vIHdpbGwgc3RpbGwgYmUgY3VycmVudCBzaW5jZSB3ZSBoYXZlbid0IHJlbmRlcmVkIHRoZW0geWV0LiBUaGUgbW91bnRlZFxuLy8gb3JkZXIgbWF5IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgbmV3IG9yZGVyLiBXZSB1c2UgdGhlIG5ldyBvcmRlci5cbnZhciByb3c9Zmlyc3RDaGlsZDt2YXIgbGFzdENvbnRlbnRSb3c9bnVsbDt3aGlsZShyb3chPT1udWxsKXt2YXIgY3VycmVudFJvdz1yb3cuYWx0ZXJuYXRlOy8vIE5ldyByb3dzIGNhbid0IGJlIGNvbnRlbnQgcm93cy5cbmlmKGN1cnJlbnRSb3chPT1udWxsJiZmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudFJvdyk9PT1udWxsKXtsYXN0Q29udGVudFJvdz1yb3c7fXJvdz1yb3cuc2libGluZzt9cmV0dXJuIGxhc3RDb250ZW50Um93O31mdW5jdGlvbiB2YWxpZGF0ZVJldmVhbE9yZGVyKHJldmVhbE9yZGVyKXt7aWYocmV2ZWFsT3JkZXIhPT11bmRlZmluZWQmJnJldmVhbE9yZGVyIT09J2ZvcndhcmRzJyYmcmV2ZWFsT3JkZXIhPT0nYmFja3dhcmRzJyYmcmV2ZWFsT3JkZXIhPT0ndG9nZXRoZXInJiYhZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdKXtkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl09dHJ1ZTtpZih0eXBlb2YgcmV2ZWFsT3JkZXI9PT0nc3RyaW5nJyl7c3dpdGNoKHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpe2Nhc2UndG9nZXRoZXInOmNhc2UnZm9yd2FyZHMnOmNhc2UnYmFja3dhcmRzJzp7ZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJysnVXNlIGxvd2VyY2FzZSBcIiVzXCIgaW5zdGVhZC4nLHJldmVhbE9yZGVyLHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpO2JyZWFrO31jYXNlJ2ZvcndhcmQnOmNhc2UnYmFja3dhcmQnOntlcnJvcignXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnKydSZWFjdCB1c2VzIHRoZSAtcyBzdWZmaXggaW4gdGhlIHNwZWxsaW5nLiBVc2UgXCIlc3NcIiBpbnN0ZWFkLicscmV2ZWFsT3JkZXIscmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSk7YnJlYWs7fWRlZmF1bHQ6ZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJysnRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JyxyZXZlYWxPcmRlcik7YnJlYWs7fX1lbHNle2Vycm9yKCclcyBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcrJ0RpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycscmV2ZWFsT3JkZXIpO319fX1mdW5jdGlvbiB2YWxpZGF0ZVRhaWxPcHRpb25zKHRhaWxNb2RlLHJldmVhbE9yZGVyKXt7aWYodGFpbE1vZGUhPT11bmRlZmluZWQmJiFkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0pe2lmKHRhaWxNb2RlIT09J2NvbGxhcHNlZCcmJnRhaWxNb2RlIT09J2hpZGRlbicpe2RpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXT10cnVlO2Vycm9yKCdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHZhbHVlIGZvciB0YWlsIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcrJ0RpZCB5b3UgbWVhbiBcImNvbGxhcHNlZFwiIG9yIFwiaGlkZGVuXCI/Jyx0YWlsTW9kZSk7fWVsc2UgaWYocmV2ZWFsT3JkZXIhPT0nZm9yd2FyZHMnJiZyZXZlYWxPcmRlciE9PSdiYWNrd2FyZHMnKXtkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV09dHJ1ZTtlcnJvcignPFN1c3BlbnNlTGlzdCB0YWlsPVwiJXNcIiAvPiBpcyBvbmx5IHZhbGlkIGlmIHJldmVhbE9yZGVyIGlzICcrJ1wiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiLiAnKydEaWQgeW91IG1lYW4gdG8gc3BlY2lmeSByZXZlYWxPcmRlcj1cImZvcndhcmRzXCI/Jyx0YWlsTW9kZSk7fX19fWZ1bmN0aW9uIHZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRTbG90LGluZGV4KXt7dmFyIGlzQW5BcnJheT1pc0FycmF5KGNoaWxkU2xvdCk7dmFyIGlzSXRlcmFibGU9IWlzQW5BcnJheSYmdHlwZW9mIGdldEl0ZXJhdG9yRm4oY2hpbGRTbG90KT09PSdmdW5jdGlvbic7aWYoaXNBbkFycmF5fHxpc0l0ZXJhYmxlKXt2YXIgdHlwZT1pc0FuQXJyYXk/J2FycmF5JzonaXRlcmFibGUnO2Vycm9yKCdBIG5lc3RlZCAlcyB3YXMgcGFzc2VkIHRvIHJvdyAjJXMgaW4gPFN1c3BlbnNlTGlzdCAvPi4gV3JhcCBpdCBpbiAnKydhbiBhZGRpdGlvbmFsIFN1c3BlbnNlTGlzdCB0byBjb25maWd1cmUgaXRzIHJldmVhbE9yZGVyOiAnKyc8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj4gLi4uICcrJzxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPnslc308L1N1c3BlbnNlTGlzdD4gLi4uICcrJzwvU3VzcGVuc2VMaXN0PicsdHlwZSxpbmRleCx0eXBlKTtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9ZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihjaGlsZHJlbixyZXZlYWxPcmRlcil7e2lmKChyZXZlYWxPcmRlcj09PSdmb3J3YXJkcyd8fHJldmVhbE9yZGVyPT09J2JhY2t3YXJkcycpJiZjaGlsZHJlbiE9PXVuZGVmaW5lZCYmY2hpbGRyZW4hPT1udWxsJiZjaGlsZHJlbiE9PWZhbHNlKXtpZihpc0FycmF5KGNoaWxkcmVuKSl7Zm9yKHZhciBpPTA7aTxjaGlsZHJlbi5sZW5ndGg7aSsrKXtpZighdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChjaGlsZHJlbltpXSxpKSl7cmV0dXJuO319fWVsc2V7dmFyIGl0ZXJhdG9yRm49Z2V0SXRlcmF0b3JGbihjaGlsZHJlbik7aWYodHlwZW9mIGl0ZXJhdG9yRm49PT0nZnVuY3Rpb24nKXt2YXIgY2hpbGRyZW5JdGVyYXRvcj1pdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO2lmKGNoaWxkcmVuSXRlcmF0b3Ipe3ZhciBzdGVwPWNoaWxkcmVuSXRlcmF0b3IubmV4dCgpO3ZhciBfaT0wO2Zvcig7IXN0ZXAuZG9uZTtzdGVwPWNoaWxkcmVuSXRlcmF0b3IubmV4dCgpKXtpZighdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChzdGVwLnZhbHVlLF9pKSl7cmV0dXJuO31faSsrO319fWVsc2V7ZXJyb3IoJ0Egc2luZ2xlIHJvdyB3YXMgcGFzc2VkIHRvIGEgPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj1cIiVzXCIgLz4uICcrJ1RoaXMgaXMgbm90IHVzZWZ1bCBzaW5jZSBpdCBuZWVkcyBtdWx0aXBsZSByb3dzLiAnKydEaWQgeW91IG1lYW4gdG8gcGFzcyBtdWx0aXBsZSBjaGlsZHJlbiBvciBhbiBhcnJheT8nLHJldmVhbE9yZGVyKTt9fX19fWZ1bmN0aW9uIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcyxpc0JhY2t3YXJkcyx0YWlsLGxhc3RDb250ZW50Um93LHRhaWxNb2RlKXt2YXIgcmVuZGVyU3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtpZihyZW5kZXJTdGF0ZT09PW51bGwpe3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9e2lzQmFja3dhcmRzOmlzQmFja3dhcmRzLHJlbmRlcmluZzpudWxsLHJlbmRlcmluZ1N0YXJ0VGltZTowLGxhc3Q6bGFzdENvbnRlbnRSb3csdGFpbDp0YWlsLHRhaWxNb2RlOnRhaWxNb2RlfTt9ZWxzZXsvLyBXZSBjYW4gcmV1c2UgdGhlIGV4aXN0aW5nIG9iamVjdCBmcm9tIHByZXZpb3VzIHJlbmRlcnMuXG5yZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcz1pc0JhY2t3YXJkcztyZW5kZXJTdGF0ZS5yZW5kZXJpbmc9bnVsbDtyZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWU9MDtyZW5kZXJTdGF0ZS5sYXN0PWxhc3RDb250ZW50Um93O3JlbmRlclN0YXRlLnRhaWw9dGFpbDtyZW5kZXJTdGF0ZS50YWlsTW9kZT10YWlsTW9kZTt9fS8vIFRoaXMgY2FuIGVuZCB1cCByZW5kZXJpbmcgdGhpcyBjb21wb25lbnQgbXVsdGlwbGUgcGFzc2VzLlxuLy8gVGhlIGZpcnN0IHBhc3Mgc3BsaXRzIHRoZSBjaGlsZHJlbiBmaWJlcnMgaW50byB0d28gc2V0cy4gQSBoZWFkIGFuZCB0YWlsLlxuLy8gV2UgZmlyc3QgcmVuZGVyIHRoZSBoZWFkLiBJZiBhbnl0aGluZyBpcyBpbiBmYWxsYmFjayBzdGF0ZSwgd2UgZG8gYW5vdGhlclxuLy8gcGFzcyB0aHJvdWdoIGJlZ2luV29yayB0byByZXJlbmRlciBhbGwgY2hpbGRyZW4gKGluY2x1ZGluZyB0aGUgdGFpbCkgd2l0aFxuLy8gdGhlIGZvcmNlIHN1c3BlbmQgY29udGV4dC4gSWYgdGhlIGZpcnN0IHJlbmRlciBkaWRuJ3QgaGF2ZSBhbnl0aGluZyBpblxuLy8gaW4gZmFsbGJhY2sgc3RhdGUuIFRoZW4gd2UgcmVuZGVyIGVhY2ggcm93IGluIHRoZSB0YWlsIG9uZS1ieS1vbmUuXG4vLyBUaGF0IGhhcHBlbnMgaW4gdGhlIGNvbXBsZXRlV29yayBwaGFzZSB3aXRob3V0IGdvaW5nIGJhY2sgdG8gYmVnaW5Xb3JrLlxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe3ZhciBuZXh0UHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciByZXZlYWxPcmRlcj1uZXh0UHJvcHMucmV2ZWFsT3JkZXI7dmFyIHRhaWxNb2RlPW5leHRQcm9wcy50YWlsO3ZhciBuZXdDaGlsZHJlbj1uZXh0UHJvcHMuY2hpbGRyZW47dmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcik7dmFsaWRhdGVUYWlsT3B0aW9ucyh0YWlsTW9kZSxyZXZlYWxPcmRlcik7dmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihuZXdDaGlsZHJlbixyZXZlYWxPcmRlcik7cmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXdDaGlsZHJlbixyZW5kZXJMYW5lcyk7dmFyIHN1c3BlbnNlQ29udGV4dD1zdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7dmFyIHNob3VsZEZvcmNlRmFsbGJhY2s9aGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCxGb3JjZVN1c3BlbnNlRmFsbGJhY2spO2lmKHNob3VsZEZvcmNlRmFsbGJhY2spe3N1c3BlbnNlQ29udGV4dD1zZXRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCxGb3JjZVN1c3BlbnNlRmFsbGJhY2spO3dvcmtJblByb2dyZXNzLmZsYWdzfD1EaWRDYXB0dXJlO31lbHNle3ZhciBkaWRTdXNwZW5kQmVmb3JlPWN1cnJlbnQhPT1udWxsJiYoY3VycmVudC5mbGFncyZEaWRDYXB0dXJlKSE9PU5vRmxhZ3M7aWYoZGlkU3VzcGVuZEJlZm9yZSl7Ly8gSWYgd2UgcHJldmlvdXNseSBmb3JjZWQgYSBmYWxsYmFjaywgd2UgbmVlZCB0byBzY2hlZHVsZSB3b3JrXG4vLyBvbiBhbnkgbmVzdGVkIGJvdW5kYXJpZXMgdG8gbGV0IHRoZW0ga25vdyB0byB0cnkgdG8gcmVuZGVyXG4vLyBhZ2Fpbi4gVGhpcyBpcyB0aGUgc2FtZSBhcyBjb250ZXh0IHVwZGF0aW5nLlxucHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLHdvcmtJblByb2dyZXNzLmNoaWxkLHJlbmRlckxhbmVzKTt9c3VzcGVuc2VDb250ZXh0PXNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7fXB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3Msc3VzcGVuc2VDb250ZXh0KTtpZigod29ya0luUHJvZ3Jlc3MubW9kZSZDb25jdXJyZW50TW9kZSk9PT1Ob01vZGUpey8vIEluIGxlZ2FjeSBtb2RlLCBTdXNwZW5zZUxpc3QgZG9lc24ndCB3b3JrIHNvIHdlIGp1c3Rcbi8vIHVzZSBtYWtlIGl0IGEgbm9vcCBieSB0cmVhdGluZyBpdCBhcyB0aGUgZGVmYXVsdCByZXZlYWxPcmRlci5cbndvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9bnVsbDt9ZWxzZXtzd2l0Y2gocmV2ZWFsT3JkZXIpe2Nhc2UnZm9yd2FyZHMnOnt2YXIgbGFzdENvbnRlbnRSb3c9ZmluZExhc3RDb250ZW50Um93KHdvcmtJblByb2dyZXNzLmNoaWxkKTt2YXIgdGFpbDtpZihsYXN0Q29udGVudFJvdz09PW51bGwpey8vIFRoZSB3aG9sZSBsaXN0IGlzIHBhcnQgb2YgdGhlIHRhaWwuXG4vLyBUT0RPOiBXZSBjb3VsZCBmYXN0IHBhdGggYnkganVzdCByZW5kZXJpbmcgdGhlIHRhaWwgbm93LlxudGFpbD13b3JrSW5Qcm9ncmVzcy5jaGlsZDt3b3JrSW5Qcm9ncmVzcy5jaGlsZD1udWxsO31lbHNley8vIERpc2Nvbm5lY3QgdGhlIHRhaWwgcm93cyBhZnRlciB0aGUgY29udGVudCByb3cuXG4vLyBXZSdyZSBnb2luZyB0byByZW5kZXIgdGhlbSBzZXBhcmF0ZWx5IGxhdGVyLlxudGFpbD1sYXN0Q29udGVudFJvdy5zaWJsaW5nO2xhc3RDb250ZW50Um93LnNpYmxpbmc9bnVsbDt9aW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLGZhbHNlLC8vIGlzQmFja3dhcmRzXG50YWlsLGxhc3RDb250ZW50Um93LHRhaWxNb2RlKTticmVhazt9Y2FzZSdiYWNrd2FyZHMnOnsvLyBXZSdyZSBnb2luZyB0byBmaW5kIHRoZSBmaXJzdCByb3cgdGhhdCBoYXMgZXhpc3RpbmcgY29udGVudC5cbi8vIEF0IHRoZSBzYW1lIHRpbWUgd2UncmUgZ29pbmcgdG8gcmV2ZXJzZSB0aGUgbGlzdCBvZiBldmVyeXRoaW5nXG4vLyB3ZSBwYXNzIGluIHRoZSBtZWFudGltZS4gVGhhdCdzIGdvaW5nIHRvIGJlIG91ciB0YWlsIGluIHJldmVyc2Vcbi8vIG9yZGVyLlxudmFyIF90YWlsPW51bGw7dmFyIHJvdz13b3JrSW5Qcm9ncmVzcy5jaGlsZDt3b3JrSW5Qcm9ncmVzcy5jaGlsZD1udWxsO3doaWxlKHJvdyE9PW51bGwpe3ZhciBjdXJyZW50Um93PXJvdy5hbHRlcm5hdGU7Ly8gTmV3IHJvd3MgY2FuJ3QgYmUgY29udGVudCByb3dzLlxuaWYoY3VycmVudFJvdyE9PW51bGwmJmZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50Um93KT09PW51bGwpey8vIFRoaXMgaXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgbWFpbiBjb250ZW50Llxud29ya0luUHJvZ3Jlc3MuY2hpbGQ9cm93O2JyZWFrO312YXIgbmV4dFJvdz1yb3cuc2libGluZztyb3cuc2libGluZz1fdGFpbDtfdGFpbD1yb3c7cm93PW5leHRSb3c7fS8vIFRPRE86IElmIHdvcmtJblByb2dyZXNzLmNoaWxkIGlzIG51bGwsIHdlIGNhbiBjb250aW51ZSBvbiB0aGUgdGFpbCBpbW1lZGlhdGVseS5cbmluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcyx0cnVlLC8vIGlzQmFja3dhcmRzXG5fdGFpbCxudWxsLC8vIGxhc3RcbnRhaWxNb2RlKTticmVhazt9Y2FzZSd0b2dldGhlcic6e2luaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcyxmYWxzZSwvLyBpc0JhY2t3YXJkc1xubnVsbCwvLyB0YWlsXG5udWxsLC8vIGxhc3RcbnVuZGVmaW5lZCk7YnJlYWs7fWRlZmF1bHQ6ey8vIFRoZSBkZWZhdWx0IHJldmVhbCBvcmRlciBpcyB0aGUgc2FtZSBhcyBub3QgaGF2aW5nXG4vLyBhIGJvdW5kYXJ5Llxud29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1udWxsO319fXJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDt9ZnVuY3Rpb24gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe3B1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTt2YXIgbmV4dENoaWxkcmVuPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztpZihjdXJyZW50PT09bnVsbCl7Ly8gUG9ydGFscyBhcmUgc3BlY2lhbCBiZWNhdXNlIHdlIGRvbid0IGFwcGVuZCB0aGUgY2hpbGRyZW4gZHVyaW5nIG1vdW50XG4vLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbi8vIGZsb3cgZG9lc24ndCBkbyBkdXJpbmcgbW91bnQuIFRoaXMgZG9lc24ndCBoYXBwZW4gYXQgdGhlIHJvb3QgYmVjYXVzZVxuLy8gdGhlIHJvb3QgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgXCJjdXJyZW50XCIgd2l0aCBhIG51bGwgY2hpbGQuXG4vLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxud29ya0luUHJvZ3Jlc3MuY2hpbGQ9cmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsbnVsbCxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpO31lbHNle3JlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTt9cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO312YXIgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXI9ZmFsc2U7ZnVuY3Rpb24gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe3ZhciBwcm92aWRlclR5cGU9d29ya0luUHJvZ3Jlc3MudHlwZTt2YXIgY29udGV4dD1wcm92aWRlclR5cGUuX2NvbnRleHQ7dmFyIG5ld1Byb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgb2xkUHJvcHM9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wczt2YXIgbmV3VmFsdWU9bmV3UHJvcHMudmFsdWU7e2lmKCEoJ3ZhbHVlJ2luIG5ld1Byb3BzKSl7aWYoIWhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyKXtoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlcj10cnVlO2Vycm9yKCdUaGUgYHZhbHVlYCBwcm9wIGlzIHJlcXVpcmVkIGZvciB0aGUgYDxDb250ZXh0LlByb3ZpZGVyPmAuIERpZCB5b3UgbWlzc3BlbGwgaXQgb3IgZm9yZ2V0IHRvIHBhc3MgaXQ/Jyk7fX12YXIgcHJvdmlkZXJQcm9wVHlwZXM9d29ya0luUHJvZ3Jlc3MudHlwZS5wcm9wVHlwZXM7aWYocHJvdmlkZXJQcm9wVHlwZXMpe2NoZWNrUHJvcFR5cGVzKHByb3ZpZGVyUHJvcFR5cGVzLG5ld1Byb3BzLCdwcm9wJywnQ29udGV4dC5Qcm92aWRlcicpO319cHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLGNvbnRleHQsbmV3VmFsdWUpO3tpZihvbGRQcm9wcyE9PW51bGwpe3ZhciBvbGRWYWx1ZT1vbGRQcm9wcy52YWx1ZTtpZihvYmplY3RJcyhvbGRWYWx1ZSxuZXdWYWx1ZSkpey8vIE5vIGNoYW5nZS4gQmFpbG91dCBlYXJseSBpZiBjaGlsZHJlbiBhcmUgdGhlIHNhbWUuXG5pZihvbGRQcm9wcy5jaGlsZHJlbj09PW5ld1Byb3BzLmNoaWxkcmVuJiYhaGFzQ29udGV4dENoYW5nZWQoKSl7cmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7fX1lbHNley8vIFRoZSBjb250ZXh0IHZhbHVlIGNoYW5nZWQuIFNlYXJjaCBmb3IgbWF0Y2hpbmcgY29uc3VtZXJzIGFuZCBzY2hlZHVsZVxuLy8gdGhlbSB0byB1cGRhdGUuXG5wcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLGNvbnRleHQscmVuZGVyTGFuZXMpO319fXZhciBuZXdDaGlsZHJlbj1uZXdQcm9wcy5jaGlsZHJlbjtyZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5ld0NoaWxkcmVuLHJlbmRlckxhbmVzKTtyZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fXZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXI9ZmFsc2U7ZnVuY3Rpb24gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe3ZhciBjb250ZXh0PXdvcmtJblByb2dyZXNzLnR5cGU7Ly8gVGhlIGxvZ2ljIGJlbG93IGZvciBDb250ZXh0IGRpZmZlcnMgZGVwZW5kaW5nIG9uIFBST0Qgb3IgREVWIG1vZGUuIEluXG4vLyBERVYgbW9kZSwgd2UgY3JlYXRlIGEgc2VwYXJhdGUgb2JqZWN0IGZvciBDb250ZXh0LkNvbnN1bWVyIHRoYXQgYWN0c1xuLy8gbGlrZSBhIHByb3h5IHRvIENvbnRleHQuIFRoaXMgcHJveHkgb2JqZWN0IGFkZHMgdW5uZWNlc3NhcnkgY29kZSBpbiBQUk9EXG4vLyBzbyB3ZSB1c2UgdGhlIG9sZCBiZWhhdmlvdXIgKENvbnRleHQuQ29uc3VtZXIgcmVmZXJlbmNlcyBDb250ZXh0KSB0b1xuLy8gcmVkdWNlIHNpemUgYW5kIG92ZXJoZWFkLiBUaGUgc2VwYXJhdGUgb2JqZWN0IHJlZmVyZW5jZXMgY29udGV4dCB2aWFcbi8vIGEgcHJvcGVydHkgY2FsbGVkIFwiX2NvbnRleHRcIiwgd2hpY2ggYWxzbyBnaXZlcyB1cyB0aGUgYWJpbGl0eSB0byBjaGVja1xuLy8gaW4gREVWIG1vZGUgaWYgdGhpcyBwcm9wZXJ0eSBleGlzdHMgb3Igbm90IGFuZCB3YXJuIGlmIGl0IGRvZXMgbm90Llxue2lmKGNvbnRleHQuX2NvbnRleHQ9PT11bmRlZmluZWQpey8vIFRoaXMgbWF5IGJlIGJlY2F1c2UgaXQncyBhIENvbnRleHQgKHJhdGhlciB0aGFuIGEgQ29uc3VtZXIpLlxuLy8gT3IgaXQgbWF5IGJlIGJlY2F1c2UgaXQncyBvbGRlciBSZWFjdCB3aGVyZSB0aGV5J3JlIHRoZSBzYW1lIHRoaW5nLlxuLy8gV2Ugb25seSB3YW50IHRvIHdhcm4gaWYgd2UncmUgc3VyZSBpdCdzIGEgbmV3IFJlYWN0LlxuaWYoY29udGV4dCE9PWNvbnRleHQuQ29uc3VtZXIpe2lmKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIpe2hhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lcj10cnVlO2Vycm9yKCdSZW5kZXJpbmcgPENvbnRleHQ+IGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnKydhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO319fWVsc2V7Y29udGV4dD1jb250ZXh0Ll9jb250ZXh0O319dmFyIG5ld1Byb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgcmVuZGVyPW5ld1Byb3BzLmNoaWxkcmVuO3tpZih0eXBlb2YgcmVuZGVyIT09J2Z1bmN0aW9uJyl7ZXJyb3IoJ0EgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCAnK1widGhhdCBpc24ndCBhIGZ1bmN0aW9uLiBBIGNvbnRleHQgY29uc3VtZXIgZXhwZWN0cyBhIHNpbmdsZSBjaGlsZCBcIisndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcrJ2lzIG5vIHRyYWlsaW5nIG9yIGxlYWRpbmcgd2hpdGVzcGFjZSBhcm91bmQgaXQuJyk7fX1wcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7dmFyIG5ld1ZhbHVlPXJlYWRDb250ZXh0KGNvbnRleHQpO3ttYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7fXZhciBuZXdDaGlsZHJlbjt7UmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50PXdvcmtJblByb2dyZXNzO3NldElzUmVuZGVyaW5nKHRydWUpO25ld0NoaWxkcmVuPXJlbmRlcihuZXdWYWx1ZSk7c2V0SXNSZW5kZXJpbmcoZmFsc2UpO317bWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTt9Ly8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVBlcmZvcm1lZFdvcms7cmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXdDaGlsZHJlbixyZW5kZXJMYW5lcyk7cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO31mdW5jdGlvbiBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpe2RpZFJlY2VpdmVVcGRhdGU9dHJ1ZTt9ZnVuY3Rpb24gcmVzZXRTdXNwZW5kZWRDdXJyZW50T25Nb3VudEluTGVnYWN5TW9kZShjdXJyZW50LHdvcmtJblByb2dyZXNzKXtpZigod29ya0luUHJvZ3Jlc3MubW9kZSZDb25jdXJyZW50TW9kZSk9PT1Ob01vZGUpe2lmKGN1cnJlbnQhPT1udWxsKXsvLyBBIGxhenkgY29tcG9uZW50IG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZCBpbnNpZGUgYSBub24tXG4vLyBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0byB0cmVhdCBpdCBsaWtlXG4vLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbi8vIERpc2Nvbm5lY3QgdGhlIGFsdGVybmF0ZSBwb2ludGVycy5cbmN1cnJlbnQuYWx0ZXJuYXRlPW51bGw7d29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlPW51bGw7Ly8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVBsYWNlbWVudDt9fX1mdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe2lmKGN1cnJlbnQhPT1udWxsKXsvLyBSZXVzZSBwcmV2aW91cyBkZXBlbmRlbmNpZXNcbndvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcz1jdXJyZW50LmRlcGVuZGVuY2llczt9ey8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoKTt9bWFya1NraXBwZWRVcGRhdGVMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcyk7Ly8gQ2hlY2sgaWYgdGhlIGNoaWxkcmVuIGhhdmUgYW55IHBlbmRpbmcgd29yay5cbmlmKCFpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKXsvLyBUaGUgY2hpbGRyZW4gZG9uJ3QgaGF2ZSBhbnkgd29yayBlaXRoZXIuIFdlIGNhbiBza2lwIHRoZW0uXG4vLyBUT0RPOiBPbmNlIHdlIGFkZCBiYWNrIHJlc3VtaW5nLCB3ZSBzaG91bGQgY2hlY2sgaWYgdGhlIGNoaWxkcmVuIGFyZVxuLy8gYSB3b3JrLWluLXByb2dyZXNzIHNldC4gSWYgc28sIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlaXIgZWZmZWN0cy5cbntyZXR1cm4gbnVsbDt9fS8vIFRoaXMgZmliZXIgZG9lc24ndCBoYXZlIHdvcmssIGJ1dCBpdHMgc3VidHJlZSBkb2VzLiBDbG9uZSB0aGUgY2hpbGRcbi8vIGZpYmVycyBhbmQgY29udGludWUuXG5jbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MpO3JldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDt9ZnVuY3Rpb24gcmVtb3VudEZpYmVyKGN1cnJlbnQsb2xkV29ya0luUHJvZ3Jlc3MsbmV3V29ya0luUHJvZ3Jlc3Mpe3t2YXIgcmV0dXJuRmliZXI9b2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO2lmKHJldHVybkZpYmVyPT09bnVsbCl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbnRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3YXAgdGhlIHJvb3QgZmliZXIuJyk7fS8vIERpc2Nvbm5lY3QgZnJvbSB0aGUgb2xkIGN1cnJlbnQuXG4vLyBJdCB3aWxsIGdldCBkZWxldGVkLlxuY3VycmVudC5hbHRlcm5hdGU9bnVsbDtvbGRXb3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU9bnVsbDsvLyBDb25uZWN0IHRvIHRoZSBuZXcgdHJlZS5cbm5ld1dvcmtJblByb2dyZXNzLmluZGV4PW9sZFdvcmtJblByb2dyZXNzLmluZGV4O25ld1dvcmtJblByb2dyZXNzLnNpYmxpbmc9b2xkV29ya0luUHJvZ3Jlc3Muc2libGluZztuZXdXb3JrSW5Qcm9ncmVzcy5yZXR1cm49b2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO25ld1dvcmtJblByb2dyZXNzLnJlZj1vbGRXb3JrSW5Qcm9ncmVzcy5yZWY7Ly8gUmVwbGFjZSB0aGUgY2hpbGQvc2libGluZyBwb2ludGVycyBhYm92ZSBpdC5cbmlmKG9sZFdvcmtJblByb2dyZXNzPT09cmV0dXJuRmliZXIuY2hpbGQpe3JldHVybkZpYmVyLmNoaWxkPW5ld1dvcmtJblByb2dyZXNzO31lbHNle3ZhciBwcmV2U2libGluZz1yZXR1cm5GaWJlci5jaGlsZDtpZihwcmV2U2libGluZz09PW51bGwpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG50aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBhcmVudCB0byBoYXZlIGEgY2hpbGQuJyk7fXdoaWxlKHByZXZTaWJsaW5nLnNpYmxpbmchPT1vbGRXb3JrSW5Qcm9ncmVzcyl7cHJldlNpYmxpbmc9cHJldlNpYmxpbmcuc2libGluZztpZihwcmV2U2libGluZz09PW51bGwpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG50aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByZXZpb3VzIHNpYmxpbmcuJyk7fX1wcmV2U2libGluZy5zaWJsaW5nPW5ld1dvcmtJblByb2dyZXNzO30vLyBEZWxldGUgdGhlIG9sZCBmaWJlciBhbmQgcGxhY2UgdGhlIG5ldyBvbmUuXG4vLyBTaW5jZSB0aGUgb2xkIGZpYmVyIGlzIGRpc2Nvbm5lY3RlZCwgd2UgaGF2ZSB0byBzY2hlZHVsZSBpdCBtYW51YWxseS5cbnZhciBkZWxldGlvbnM9cmV0dXJuRmliZXIuZGVsZXRpb25zO2lmKGRlbGV0aW9ucz09PW51bGwpe3JldHVybkZpYmVyLmRlbGV0aW9ucz1bY3VycmVudF07cmV0dXJuRmliZXIuZmxhZ3N8PUNoaWxkRGVsZXRpb247fWVsc2V7ZGVsZXRpb25zLnB1c2goY3VycmVudCk7fW5ld1dvcmtJblByb2dyZXNzLmZsYWdzfD1QbGFjZW1lbnQ7Ly8gUmVzdGFydCB3b3JrIGZyb20gdGhlIG5ldyBmaWJlci5cbnJldHVybiBuZXdXb3JrSW5Qcm9ncmVzczt9fWZ1bmN0aW9uIGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQscmVuZGVyTGFuZXMpey8vIEJlZm9yZSBwZXJmb3JtaW5nIGFuIGVhcmx5IGJhaWxvdXQsIHdlIG11c3QgY2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmdcbi8vIHVwZGF0ZXMgb3IgY29udGV4dC5cbnZhciB1cGRhdGVMYW5lcz1jdXJyZW50LmxhbmVzO2lmKGluY2x1ZGVzU29tZUxhbmUodXBkYXRlTGFuZXMscmVuZGVyTGFuZXMpKXtyZXR1cm4gdHJ1ZTt9Ly8gTm8gcGVuZGluZyB1cGRhdGUsIGJ1dCBiZWNhdXNlIGNvbnRleHQgaXMgcHJvcGFnYXRlZCBsYXppbHksIHdlIG5lZWRcbnJldHVybiBmYWxzZTt9ZnVuY3Rpb24gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7Ly8gVGhpcyBmaWJlciBkb2VzIG5vdCBoYXZlIGFueSBwZW5kaW5nIHdvcmsuIEJhaWxvdXQgd2l0aG91dCBlbnRlcmluZ1xuLy8gdGhlIGJlZ2luIHBoYXNlLiBUaGVyZSdzIHN0aWxsIHNvbWUgYm9va2tlZXBpbmcgd2UgdGhhdCBuZWVkcyB0byBiZSBkb25lXG4vLyBpbiB0aGlzIG9wdGltaXplZCBwYXRoLCBtb3N0bHkgcHVzaGluZyBzdHVmZiBvbnRvIHRoZSBzdGFjay5cbnN3aXRjaCh3b3JrSW5Qcm9ncmVzcy50YWcpe2Nhc2UgSG9zdFJvb3Q6cHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7dmFyIHJvb3Q9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO3Jlc2V0SHlkcmF0aW9uU3RhdGUoKTticmVhaztjYXNlIEhvc3RDb21wb25lbnQ6cHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTticmVhaztjYXNlIENsYXNzQ29tcG9uZW50Ont2YXIgQ29tcG9uZW50PXdvcmtJblByb2dyZXNzLnR5cGU7aWYoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSl7cHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7fWJyZWFrO31jYXNlIEhvc3RQb3J0YWw6cHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3Msd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO2JyZWFrO2Nhc2UgQ29udGV4dFByb3ZpZGVyOnt2YXIgbmV3VmFsdWU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZTt2YXIgY29udGV4dD13b3JrSW5Qcm9ncmVzcy50eXBlLl9jb250ZXh0O3B1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyxjb250ZXh0LG5ld1ZhbHVlKTticmVhazt9Y2FzZSBQcm9maWxlcjp7Ly8gUHJvZmlsZXIgc2hvdWxkIG9ubHkgY2FsbCBvblJlbmRlciB3aGVuIG9uZSBvZiBpdHMgZGVzY2VuZGFudHMgYWN0dWFsbHkgcmVuZGVyZWQuXG52YXIgaGFzQ2hpbGRXb3JrPWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7aWYoaGFzQ2hpbGRXb3JrKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VXBkYXRlO317Ly8gUmVzZXQgZWZmZWN0IGR1cmF0aW9ucyBmb3IgdGhlIG5leHQgZXZlbnR1YWwgZWZmZWN0IHBoYXNlLlxuLy8gVGhlc2UgYXJlIHJlc2V0IGR1cmluZyByZW5kZXIgdG8gYWxsb3cgdGhlIERldlRvb2xzIGNvbW1pdCBob29rIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSxcbnZhciBzdGF0ZU5vZGU9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO3N0YXRlTm9kZS5lZmZlY3REdXJhdGlvbj0wO3N0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb249MDt9fWJyZWFrO2Nhc2UgU3VzcGVuc2VDb21wb25lbnQ6e3ZhciBzdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO2lmKHN0YXRlIT09bnVsbCl7aWYoc3RhdGUuZGVoeWRyYXRlZCE9PW51bGwpe3B1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3Msc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSk7Ly8gV2Uga25vdyB0aGF0IHRoaXMgY29tcG9uZW50IHdpbGwgc3VzcGVuZCBhZ2FpbiBiZWNhdXNlIGlmIGl0IGhhc1xuLy8gYmVlbiB1bnN1c3BlbmRlZCBpdCBoYXMgY29tbWl0dGVkIGFzIGEgcmVzb2x2ZWQgU3VzcGVuc2UgY29tcG9uZW50LlxuLy8gSWYgaXQgbmVlZHMgdG8gYmUgcmV0cmllZCwgaXQgc2hvdWxkIGhhdmUgd29yayBzY2hlZHVsZWQgb24gaXQuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9RGlkQ2FwdHVyZTsvLyBXZSBzaG91bGQgbmV2ZXIgcmVuZGVyIHRoZSBjaGlsZHJlbiBvZiBhIGRlaHlkcmF0ZWQgYm91bmRhcnkgdW50aWwgd2Vcbi8vIHVwZ3JhZGUgaXQuIFdlIHJldHVybiBudWxsIGluc3RlYWQgb2YgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yay5cbnJldHVybiBudWxsO30vLyBJZiB0aGlzIGJvdW5kYXJ5IGlzIGN1cnJlbnRseSB0aW1lZCBvdXQsIHdlIG5lZWQgdG8gZGVjaWRlXG4vLyB3aGV0aGVyIHRvIHJldHJ5IHRoZSBwcmltYXJ5IGNoaWxkcmVuLCBvciB0byBza2lwIG92ZXIgaXQgYW5kXG4vLyBnbyBzdHJhaWdodCB0byB0aGUgZmFsbGJhY2suIENoZWNrIHRoZSBwcmlvcml0eSBvZiB0aGUgcHJpbWFyeVxuLy8gY2hpbGQgZnJhZ21lbnQuXG52YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7dmFyIHByaW1hcnlDaGlsZExhbmVzPXByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkTGFuZXM7aWYoaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcyxwcmltYXJ5Q2hpbGRMYW5lcykpey8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBVc2UgdGhlIG5vcm1hbCBwYXRoXG4vLyB0byBhdHRlbXB0IHRvIHJlbmRlciB0aGUgcHJpbWFyeSBjaGlsZHJlbiBhZ2Fpbi5cbnJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt9ZWxzZXsvLyBUaGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCBkb2VzIG5vdCBoYXZlIHBlbmRpbmcgd29yayBtYXJrZWRcbi8vIG9uIGl0XG5wdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCkpOy8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGRvIG5vdCBoYXZlIHBlbmRpbmcgd29yayB3aXRoIHN1ZmZpY2llbnRcbi8vIHByaW9yaXR5LiBCYWlsb3V0LlxudmFyIGNoaWxkPWJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7aWYoY2hpbGQhPT1udWxsKXsvLyBUaGUgZmFsbGJhY2sgY2hpbGRyZW4gaGF2ZSBwZW5kaW5nIHdvcmsuIFNraXAgb3ZlciB0aGVcbi8vIHByaW1hcnkgY2hpbGRyZW4gYW5kIHdvcmsgb24gdGhlIGZhbGxiYWNrLlxucmV0dXJuIGNoaWxkLnNpYmxpbmc7fWVsc2V7Ly8gTm90ZTogV2UgY2FuIHJldHVybiBgbnVsbGAgaGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgY2hlY2tlZFxuLy8gd2hldGhlciB0aGVyZSB3ZXJlIG5lc3RlZCBjb250ZXh0IGNvbnN1bWVycywgdmlhIHRoZSBjYWxsIHRvXG4vLyBgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29ya2AgYWJvdmUuXG5yZXR1cm4gbnVsbDt9fX1lbHNle3B1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3Msc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSk7fWJyZWFrO31jYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDp7dmFyIGRpZFN1c3BlbmRCZWZvcmU9KGN1cnJlbnQuZmxhZ3MmRGlkQ2FwdHVyZSkhPT1Ob0ZsYWdzO3ZhciBfaGFzQ2hpbGRXb3JrPWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7aWYoZGlkU3VzcGVuZEJlZm9yZSl7aWYoX2hhc0NoaWxkV29yayl7Ly8gSWYgc29tZXRoaW5nIHdhcyBpbiBmYWxsYmFjayBzdGF0ZSBsYXN0IHRpbWUsIGFuZCB3ZSBoYXZlIGFsbCB0aGVcbi8vIHNhbWUgY2hpbGRyZW4gdGhlbiB3ZSdyZSBzdGlsbCBpbiBwcm9ncmVzc2l2ZSBsb2FkaW5nIHN0YXRlLlxuLy8gU29tZXRoaW5nIG1pZ2h0IGdldCB1bmJsb2NrZWQgYnkgc3RhdGUgdXBkYXRlcyBvciByZXRyaWVzIGluIHRoZVxuLy8gdHJlZSB3aGljaCB3aWxsIGFmZmVjdCB0aGUgdGFpbC4gU28gd2UgbmVlZCB0byB1c2UgdGhlIG5vcm1hbFxuLy8gcGF0aCB0byBjb21wdXRlIHRoZSBjb3JyZWN0IHRhaWwuXG5yZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO30vLyBJZiBub25lIG9mIHRoZSBjaGlsZHJlbiBoYWQgYW55IHdvcmssIHRoYXQgbWVhbnMgdGhhdCBub25lIG9mXG4vLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcbi8vIGFzIGJlZm9yZS4gV2UgY2FuIGZhc3QgYmFpbCBvdXQuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9RGlkQ2FwdHVyZTt9Ly8gSWYgbm90aGluZyBzdXNwZW5kZWQgYmVmb3JlIGFuZCB3ZSdyZSByZW5kZXJpbmcgdGhlIHNhbWUgY2hpbGRyZW4sXG4vLyB0aGVuIHRoZSB0YWlsIGRvZXNuJ3QgbWF0dGVyLiBBbnl0aGluZyBuZXcgdGhhdCBzdXNwZW5kcyB3aWxsIHdvcmtcbi8vIGluIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSwgc28gd2UgY2FuIGNvbnRpbnVlIGZyb20gdGhlIHN0YXRlIHdlIGhhZC5cbnZhciByZW5kZXJTdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO2lmKHJlbmRlclN0YXRlIT09bnVsbCl7Ly8gUmVzZXQgdG8gdGhlIFwidG9nZXRoZXJcIiBtb2RlIGluIGNhc2Ugd2UndmUgc3RhcnRlZCBhIGRpZmZlcmVudFxuLy8gdXBkYXRlIGluIHRoZSBwYXN0IGJ1dCBkaWRuJ3QgY29tcGxldGUgaXQuXG5yZW5kZXJTdGF0ZS5yZW5kZXJpbmc9bnVsbDtyZW5kZXJTdGF0ZS50YWlsPW51bGw7cmVuZGVyU3RhdGUubGFzdEVmZmVjdD1udWxsO31wdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCk7aWYoX2hhc0NoaWxkV29yayl7YnJlYWs7fWVsc2V7Ly8gSWYgbm9uZSBvZiB0aGUgY2hpbGRyZW4gaGFkIGFueSB3b3JrLCB0aGF0IG1lYW5zIHRoYXQgbm9uZSBvZlxuLy8gdGhlbSBnb3QgcmV0cmllZCBzbyB0aGV5J2xsIHN0aWxsIGJlIGJsb2NrZWQgaW4gdGhlIHNhbWUgd2F5XG4vLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0LlxucmV0dXJuIG51bGw7fX1jYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDp7Ly8gTmVlZCB0byBjaGVjayBpZiB0aGUgdHJlZSBzdGlsbCBuZWVkcyB0byBiZSBkZWZlcnJlZC4gVGhpcyBpc1xuLy8gYWxtb3N0IGlkZW50aWNhbCB0byB0aGUgbG9naWMgdXNlZCBpbiB0aGUgbm9ybWFsIHVwZGF0ZSBwYXRoLFxuLy8gc28gd2UnbGwganVzdCBlbnRlciB0aGF0LiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHdlJ2xsIGJhaWwgb3V0XG4vLyBhdCB0aGUgbmV4dCBsZXZlbCBpbnN0ZWFkIG9mIHRoaXMgb25lLCBiZWNhdXNlIHRoZSBjaGlsZCBwcm9wc1xuLy8gaGF2ZSBub3QgY2hhbmdlZC4gV2hpY2ggaXMgZmluZS5cbi8vIFRPRE86IFByb2JhYmx5IHNob3VsZCByZWZhY3RvciBgYmVnaW5Xb3JrYCB0byBzcGxpdCB0aGUgYmFpbG91dFxuLy8gcGF0aCBmcm9tIHRoZSBub3JtYWwgcGF0aC4gSSdtIHRlbXB0ZWQgdG8gZG8gYSBsYWJlbGVkIGJyZWFrIGhlcmVcbi8vIGJ1dCBJIHdvbid0IDopXG53b3JrSW5Qcm9ncmVzcy5sYW5lcz1Ob0xhbmVzO3JldHVybiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7fX1yZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt9ZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe3tpZih3b3JrSW5Qcm9ncmVzcy5fZGVidWdOZWVkc1JlbW91bnQmJmN1cnJlbnQhPT1udWxsKXsvLyBUaGlzIHdpbGwgcmVzdGFydCB0aGUgYmVnaW4gcGhhc2Ugd2l0aCBhIG5ldyBmaWJlci5cbnJldHVybiByZW1vdW50RmliZXIoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMod29ya0luUHJvZ3Jlc3MudHlwZSx3b3JrSW5Qcm9ncmVzcy5rZXksd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyfHxudWxsLHdvcmtJblByb2dyZXNzLm1vZGUsd29ya0luUHJvZ3Jlc3MubGFuZXMpKTt9fWlmKGN1cnJlbnQhPT1udWxsKXt2YXIgb2xkUHJvcHM9Y3VycmVudC5tZW1vaXplZFByb3BzO3ZhciBuZXdQcm9wcz13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7aWYob2xkUHJvcHMhPT1uZXdQcm9wc3x8aGFzQ29udGV4dENoYW5nZWQoKXx8Ly8gRm9yY2UgYSByZS1yZW5kZXIgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQ6XG53b3JrSW5Qcm9ncmVzcy50eXBlIT09Y3VycmVudC50eXBlKXsvLyBJZiBwcm9wcyBvciBjb250ZXh0IGNoYW5nZWQsIG1hcmsgdGhlIGZpYmVyIGFzIGhhdmluZyBwZXJmb3JtZWQgd29yay5cbi8vIFRoaXMgbWF5IGJlIHVuc2V0IGlmIHRoZSBwcm9wcyBhcmUgZGV0ZXJtaW5lZCB0byBiZSBlcXVhbCBsYXRlciAobWVtbykuXG5kaWRSZWNlaXZlVXBkYXRlPXRydWU7fWVsc2V7Ly8gTmVpdGhlciBwcm9wcyBub3IgbGVnYWN5IGNvbnRleHQgY2hhbmdlcy4gQ2hlY2sgaWYgdGhlcmUncyBhIHBlbmRpbmdcbi8vIHVwZGF0ZSBvciBjb250ZXh0IGNoYW5nZS5cbnZhciBoYXNTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQ9Y2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCxyZW5kZXJMYW5lcyk7aWYoIWhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCYmLy8gSWYgdGhpcyBpcyB0aGUgc2Vjb25kIHBhc3Mgb2YgYW4gZXJyb3Igb3Igc3VzcGVuc2UgYm91bmRhcnksIHRoZXJlXG4vLyBtYXkgbm90IGJlIHdvcmsgc2NoZWR1bGVkIG9uIGBjdXJyZW50YCwgc28gd2UgY2hlY2sgZm9yIHRoaXMgZmxhZy5cbih3b3JrSW5Qcm9ncmVzcy5mbGFncyZEaWRDYXB0dXJlKT09PU5vRmxhZ3Mpey8vIE5vIHBlbmRpbmcgdXBkYXRlcyBvciBjb250ZXh0LiBCYWlsIG91dCBub3cuXG5kaWRSZWNlaXZlVXBkYXRlPWZhbHNlO3JldHVybiBhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZShjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt9aWYoKGN1cnJlbnQuZmxhZ3MmRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSkhPT1Ob0ZsYWdzKXsvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgb25seSBleGlzdHMgZm9yIGxlZ2FjeSBtb2RlLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzE5MjE2LlxuZGlkUmVjZWl2ZVVwZGF0ZT10cnVlO31lbHNley8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIG9uIHRoaXMgZmliZXIsIGJ1dCB0aGVyZSBhcmUgbm8gbmV3IHByb3BzXG4vLyBub3IgbGVnYWN5IGNvbnRleHQuIFNldCB0aGlzIHRvIGZhbHNlLiBJZiBhbiB1cGRhdGUgcXVldWUgb3IgY29udGV4dFxuLy8gY29uc3VtZXIgcHJvZHVjZXMgYSBjaGFuZ2VkIHZhbHVlLCBpdCB3aWxsIHNldCB0aGlzIHRvIHRydWUuIE90aGVyd2lzZSxcbi8vIHRoZSBjb21wb25lbnQgd2lsbCBhc3N1bWUgdGhlIGNoaWxkcmVuIGhhdmUgbm90IGNoYW5nZWQgYW5kIGJhaWwgb3V0LlxuZGlkUmVjZWl2ZVVwZGF0ZT1mYWxzZTt9fX1lbHNle2RpZFJlY2VpdmVVcGRhdGU9ZmFsc2U7aWYoZ2V0SXNIeWRyYXRpbmcoKSYmaXNGb3JrZWRDaGlsZCh3b3JrSW5Qcm9ncmVzcykpey8vIENoZWNrIGlmIHRoaXMgY2hpbGQgYmVsb25ncyB0byBhIGxpc3Qgb2YgbXVsaXBsZSBjaGlsZHJlbiBpblxuLy8gaXRzIHBhcmVudC5cbi8vXG4vLyBJbiBhIHRydWUgbXVsdGktdGhyZWFkZWQgaW1wbGVtZW50YXRpb24sIHdlIHdvdWxkIHJlbmRlciBjaGlsZHJlbiBvblxuLy8gcGFyYWxsZWwgdGhyZWFkcy4gVGhpcyB3b3VsZCByZXByZXNlbnQgdGhlIGJlZ2lubmluZyBvZiBhIG5ldyByZW5kZXJcbi8vIHRocmVhZCBmb3IgdGhpcyBzdWJ0cmVlLlxuLy9cbi8vIFdlIG9ubHkgdXNlIHRoaXMgZm9yIGlkIGdlbmVyYXRpb24gZHVyaW5nIGh5ZHJhdGlvbiwgd2hpY2ggaXMgd2h5IHRoZVxuLy8gbG9naWMgaXMgbG9jYXRlZCBpbiB0aGlzIHNwZWNpYWwgYnJhbmNoLlxudmFyIHNsb3RJbmRleD13b3JrSW5Qcm9ncmVzcy5pbmRleDt2YXIgbnVtYmVyT2ZGb3Jrcz1nZXRGb3Jrc0F0TGV2ZWwoKTtwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLG51bWJlck9mRm9ya3Msc2xvdEluZGV4KTt9fS8vIEJlZm9yZSBlbnRlcmluZyB0aGUgYmVnaW4gcGhhc2UsIGNsZWFyIHBlbmRpbmcgdXBkYXRlIHByaW9yaXR5LlxuLy8gVE9ETzogVGhpcyBhc3N1bWVzIHRoYXQgd2UncmUgYWJvdXQgdG8gZXZhbHVhdGUgdGhlIGNvbXBvbmVudCBhbmQgcHJvY2Vzc1xuLy8gdGhlIHVwZGF0ZSBxdWV1ZS4gSG93ZXZlciwgdGhlcmUncyBhbiBleGNlcHRpb246IFNpbXBsZU1lbW9Db21wb25lbnRcbi8vIHNvbWV0aW1lcyBiYWlscyBvdXQgbGF0ZXIgaW4gdGhlIGJlZ2luIHBoYXNlLiBUaGlzIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZFxuLy8gbW92ZSB0aGlzIGFzc2lnbm1lbnQgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBhbmQgaW50byBlYWNoIGJyYW5jaC5cbndvcmtJblByb2dyZXNzLmxhbmVzPU5vTGFuZXM7c3dpdGNoKHdvcmtJblByb2dyZXNzLnRhZyl7Y2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OntyZXR1cm4gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3Msd29ya0luUHJvZ3Jlc3MudHlwZSxyZW5kZXJMYW5lcyk7fWNhc2UgTGF6eUNvbXBvbmVudDp7dmFyIGVsZW1lbnRUeXBlPXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlO3JldHVybiBtb3VudExhenlDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxlbGVtZW50VHlwZSxyZW5kZXJMYW5lcyk7fWNhc2UgRnVuY3Rpb25Db21wb25lbnQ6e3ZhciBDb21wb25lbnQ9d29ya0luUHJvZ3Jlc3MudHlwZTt2YXIgdW5yZXNvbHZlZFByb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgcmVzb2x2ZWRQcm9wcz13b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZT09PUNvbXBvbmVudD91bnJlc29sdmVkUHJvcHM6cmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsdW5yZXNvbHZlZFByb3BzKTtyZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQscmVzb2x2ZWRQcm9wcyxyZW5kZXJMYW5lcyk7fWNhc2UgQ2xhc3NDb21wb25lbnQ6e3ZhciBfQ29tcG9uZW50PXdvcmtJblByb2dyZXNzLnR5cGU7dmFyIF91bnJlc29sdmVkUHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciBfcmVzb2x2ZWRQcm9wcz13b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZT09PV9Db21wb25lbnQ/X3VucmVzb2x2ZWRQcm9wczpyZXNvbHZlRGVmYXVsdFByb3BzKF9Db21wb25lbnQsX3VucmVzb2x2ZWRQcm9wcyk7cmV0dXJuIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsX0NvbXBvbmVudCxfcmVzb2x2ZWRQcm9wcyxyZW5kZXJMYW5lcyk7fWNhc2UgSG9zdFJvb3Q6cmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO2Nhc2UgSG9zdENvbXBvbmVudDpyZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTtjYXNlIEhvc3RUZXh0OnJldHVybiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LHdvcmtJblByb2dyZXNzKTtjYXNlIFN1c3BlbnNlQ29tcG9uZW50OnJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTtjYXNlIEhvc3RQb3J0YWw6cmV0dXJuIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTtjYXNlIEZvcndhcmRSZWY6e3ZhciB0eXBlPXdvcmtJblByb2dyZXNzLnR5cGU7dmFyIF91bnJlc29sdmVkUHJvcHMyPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgX3Jlc29sdmVkUHJvcHMyPXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlPT09dHlwZT9fdW5yZXNvbHZlZFByb3BzMjpyZXNvbHZlRGVmYXVsdFByb3BzKHR5cGUsX3VucmVzb2x2ZWRQcm9wczIpO3JldHVybiB1cGRhdGVGb3J3YXJkUmVmKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsdHlwZSxfcmVzb2x2ZWRQcm9wczIscmVuZGVyTGFuZXMpO31jYXNlIEZyYWdtZW50OnJldHVybiB1cGRhdGVGcmFnbWVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTtjYXNlIE1vZGU6cmV0dXJuIHVwZGF0ZU1vZGUoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7Y2FzZSBQcm9maWxlcjpyZXR1cm4gdXBkYXRlUHJvZmlsZXIoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7Y2FzZSBDb250ZXh0UHJvdmlkZXI6cmV0dXJuIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTtjYXNlIENvbnRleHRDb25zdW1lcjpyZXR1cm4gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO2Nhc2UgTWVtb0NvbXBvbmVudDp7dmFyIF90eXBlMj13b3JrSW5Qcm9ncmVzcy50eXBlO3ZhciBfdW5yZXNvbHZlZFByb3BzMz13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7Ly8gUmVzb2x2ZSBvdXRlciBwcm9wcyBmaXJzdCwgdGhlbiByZXNvbHZlIGlubmVyIHByb3BzLlxudmFyIF9yZXNvbHZlZFByb3BzMz1yZXNvbHZlRGVmYXVsdFByb3BzKF90eXBlMixfdW5yZXNvbHZlZFByb3BzMyk7e2lmKHdvcmtJblByb2dyZXNzLnR5cGUhPT13b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSl7dmFyIG91dGVyUHJvcFR5cGVzPV90eXBlMi5wcm9wVHlwZXM7aWYob3V0ZXJQcm9wVHlwZXMpe2NoZWNrUHJvcFR5cGVzKG91dGVyUHJvcFR5cGVzLF9yZXNvbHZlZFByb3BzMywvLyBSZXNvbHZlZCBmb3Igb3V0ZXIgb25seVxuJ3Byb3AnLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShfdHlwZTIpKTt9fX1fcmVzb2x2ZWRQcm9wczM9cmVzb2x2ZURlZmF1bHRQcm9wcyhfdHlwZTIudHlwZSxfcmVzb2x2ZWRQcm9wczMpO3JldHVybiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsX3R5cGUyLF9yZXNvbHZlZFByb3BzMyxyZW5kZXJMYW5lcyk7fWNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7cmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyx3b3JrSW5Qcm9ncmVzcy50eXBlLHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxyZW5kZXJMYW5lcyk7fWNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50Ont2YXIgX0NvbXBvbmVudDI9d29ya0luUHJvZ3Jlc3MudHlwZTt2YXIgX3VucmVzb2x2ZWRQcm9wczQ9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciBfcmVzb2x2ZWRQcm9wczQ9d29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU9PT1fQ29tcG9uZW50Mj9fdW5yZXNvbHZlZFByb3BzNDpyZXNvbHZlRGVmYXVsdFByb3BzKF9Db21wb25lbnQyLF91bnJlc29sdmVkUHJvcHM0KTtyZXR1cm4gbW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxfQ29tcG9uZW50MixfcmVzb2x2ZWRQcm9wczQscmVuZGVyTGFuZXMpO31jYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDp7cmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt9Y2FzZSBTY29wZUNvbXBvbmVudDp7YnJlYWs7fWNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OntyZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO319dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIit3b3JrSW5Qcm9ncmVzcy50YWcrXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gXCIrJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9ZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyl7Ly8gVGFnIHRoZSBmaWJlciB3aXRoIGFuIHVwZGF0ZSBlZmZlY3QuIFRoaXMgdHVybnMgYSBQbGFjZW1lbnQgaW50b1xuLy8gYSBQbGFjZW1lbnRBbmRVcGRhdGUuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VXBkYXRlO31mdW5jdGlvbiBtYXJrUmVmJDEod29ya0luUHJvZ3Jlc3Mpe3dvcmtJblByb2dyZXNzLmZsYWdzfD1SZWY7e3dvcmtJblByb2dyZXNzLmZsYWdzfD1SZWZTdGF0aWM7fX12YXIgYXBwZW5kQWxsQ2hpbGRyZW47dmFyIHVwZGF0ZUhvc3RDb250YWluZXI7dmFyIHVwZGF0ZUhvc3RDb21wb25lbnQkMTt2YXIgdXBkYXRlSG9zdFRleHQkMTt7Ly8gTXV0YXRpb24gbW9kZVxuYXBwZW5kQWxsQ2hpbGRyZW49ZnVuY3Rpb24ocGFyZW50LHdvcmtJblByb2dyZXNzLG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSxpc0hpZGRlbil7Ly8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4vLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG52YXIgbm9kZT13b3JrSW5Qcm9ncmVzcy5jaGlsZDt3aGlsZShub2RlIT09bnVsbCl7aWYobm9kZS50YWc9PT1Ib3N0Q29tcG9uZW50fHxub2RlLnRhZz09PUhvc3RUZXh0KXthcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LG5vZGUuc3RhdGVOb2RlKTt9ZWxzZSBpZihub2RlLnRhZz09PUhvc3RQb3J0YWwpO2Vsc2UgaWYobm9kZS5jaGlsZCE9PW51bGwpe25vZGUuY2hpbGQucmV0dXJuPW5vZGU7bm9kZT1ub2RlLmNoaWxkO2NvbnRpbnVlO31pZihub2RlPT09d29ya0luUHJvZ3Jlc3Mpe3JldHVybjt9d2hpbGUobm9kZS5zaWJsaW5nPT09bnVsbCl7aWYobm9kZS5yZXR1cm49PT1udWxsfHxub2RlLnJldHVybj09PXdvcmtJblByb2dyZXNzKXtyZXR1cm47fW5vZGU9bm9kZS5yZXR1cm47fW5vZGUuc2libGluZy5yZXR1cm49bm9kZS5yZXR1cm47bm9kZT1ub2RlLnNpYmxpbmc7fX07dXBkYXRlSG9zdENvbnRhaW5lcj1mdW5jdGlvbihjdXJyZW50LHdvcmtJblByb2dyZXNzKXsvLyBOb29wXG59O3VwZGF0ZUhvc3RDb21wb25lbnQkMT1mdW5jdGlvbihjdXJyZW50LHdvcmtJblByb2dyZXNzLHR5cGUsbmV3UHJvcHMscm9vdENvbnRhaW5lckluc3RhbmNlKXsvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZCB0b1xuLy8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbnZhciBvbGRQcm9wcz1jdXJyZW50Lm1lbW9pemVkUHJvcHM7aWYob2xkUHJvcHM9PT1uZXdQcm9wcyl7Ly8gSW4gbXV0YXRpb24gbW9kZSwgdGhpcyBpcyBzdWZmaWNpZW50IGZvciBhIGJhaWxvdXQgYmVjYXVzZVxuLy8gd2Ugd29uJ3QgdG91Y2ggdGhpcyBub2RlIGV2ZW4gaWYgY2hpbGRyZW4gY2hhbmdlZC5cbnJldHVybjt9Ly8gSWYgd2UgZ2V0IHVwZGF0ZWQgYmVjYXVzZSBvbmUgb2Ygb3VyIGNoaWxkcmVuIHVwZGF0ZWQsIHdlIGRvbid0XG4vLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cbi8vIFRPRE86IFNwbGl0IHRoZSB1cGRhdGUgQVBJIGFzIHNlcGFyYXRlIGZvciB0aGUgcHJvcHMgdnMuIGNoaWxkcmVuLlxuLy8gRXZlbiBiZXR0ZXIgd291bGQgYmUgaWYgY2hpbGRyZW4gd2VyZW4ndCBzcGVjaWFsIGNhc2VkIGF0IGFsbCB0aG8uXG52YXIgaW5zdGFuY2U9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO3ZhciBjdXJyZW50SG9zdENvbnRleHQ9Z2V0SG9zdENvbnRleHQoKTsvLyBUT0RPOiBFeHBlcmllbmNpbmcgYW4gZXJyb3Igd2hlcmUgb2xkUHJvcHMgaXMgbnVsbC4gU3VnZ2VzdHMgYSBob3N0XG4vLyBjb21wb25lbnQgaXMgaGl0dGluZyB0aGUgcmVzdW1lIHBhdGguIEZpZ3VyZSBvdXQgd2h5LiBQb3NzaWJseVxuLy8gcmVsYXRlZCB0byBgaGlkZGVuYC5cbnZhciB1cGRhdGVQYXlsb2FkPXByZXBhcmVVcGRhdGUoaW5zdGFuY2UsdHlwZSxvbGRQcm9wcyxuZXdQcm9wcyxyb290Q29udGFpbmVySW5zdGFuY2UsY3VycmVudEhvc3RDb250ZXh0KTsvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cbndvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlPXVwZGF0ZVBheWxvYWQ7Ly8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4vLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGlzIGRvbmUgaW4gY29tbWl0V29yay5cbmlmKHVwZGF0ZVBheWxvYWQpe21hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO319O3VwZGF0ZUhvc3RUZXh0JDE9ZnVuY3Rpb24oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxvbGRUZXh0LG5ld1RleHQpey8vIElmIHRoZSB0ZXh0IGRpZmZlcnMsIG1hcmsgaXQgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaW4gZG9uZSBpbiBjb21taXRXb3JrLlxuaWYob2xkVGV4dCE9PW5ld1RleHQpe21hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO319O31mdW5jdGlvbiBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKXtpZihnZXRJc0h5ZHJhdGluZygpKXsvLyBJZiB3ZSdyZSBoeWRyYXRpbmcsIHdlIHNob3VsZCBjb25zdW1lIGFzIG1hbnkgaXRlbXMgYXMgd2UgY2FuXG4vLyBzbyB3ZSBkb24ndCBsZWF2ZSBhbnkgYmVoaW5kLlxucmV0dXJuO31zd2l0Y2gocmVuZGVyU3RhdGUudGFpbE1vZGUpe2Nhc2UnaGlkZGVuJzp7Ly8gQW55IGluc2VydGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgdGFpbCBsaXN0IGFmdGVyIHRoaXMgcG9pbnRcbi8vIHNob3VsZCBiZSBpbnZpc2libGUuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1vdW50ZWQgYm91bmRhcmllc1xuLy8gYW55dGhpbmcgYmVmb3JlIHRoZW0gYXJlIG5vdCBjb25zaWRlcmVkIGZvciBjb2xsYXBzaW5nLlxuLy8gVGhlcmVmb3JlIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgdGFpbCB0byBmaW5kIGlmXG4vLyB0aGVyZSBhcmUgYW55LlxudmFyIHRhaWxOb2RlPXJlbmRlclN0YXRlLnRhaWw7dmFyIGxhc3RUYWlsTm9kZT1udWxsO3doaWxlKHRhaWxOb2RlIT09bnVsbCl7aWYodGFpbE5vZGUuYWx0ZXJuYXRlIT09bnVsbCl7bGFzdFRhaWxOb2RlPXRhaWxOb2RlO310YWlsTm9kZT10YWlsTm9kZS5zaWJsaW5nO30vLyBOZXh0IHdlJ3JlIHNpbXBseSBnb2luZyB0byBkZWxldGUgYWxsIGluc2VydGlvbnMgYWZ0ZXIgdGhlXG4vLyBsYXN0IHJlbmRlcmVkIGl0ZW0uXG5pZihsYXN0VGFpbE5vZGU9PT1udWxsKXsvLyBBbGwgcmVtYWluaW5nIGl0ZW1zIGluIHRoZSB0YWlsIGFyZSBpbnNlcnRpb25zLlxucmVuZGVyU3RhdGUudGFpbD1udWxsO31lbHNley8vIERldGFjaCB0aGUgaW5zZXJ0aW9uIGFmdGVyIHRoZSBsYXN0IG5vZGUgdGhhdCB3YXMgYWxyZWFkeVxuLy8gaW5zZXJ0ZWQuXG5sYXN0VGFpbE5vZGUuc2libGluZz1udWxsO31icmVhazt9Y2FzZSdjb2xsYXBzZWQnOnsvLyBBbnkgaW5zZXJ0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSB0YWlsIGxpc3QgYWZ0ZXIgdGhpcyBwb2ludFxuLy8gc2hvdWxkIGJlIGludmlzaWJsZS4gSWYgdGhlcmUgYXJlIGFscmVhZHkgbW91bnRlZCBib3VuZGFyaWVzXG4vLyBhbnl0aGluZyBiZWZvcmUgdGhlbSBhcmUgbm90IGNvbnNpZGVyZWQgZm9yIGNvbGxhcHNpbmcuXG4vLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSB0YWlsIHRvIGZpbmQgaWZcbi8vIHRoZXJlIGFyZSBhbnkuXG52YXIgX3RhaWxOb2RlPXJlbmRlclN0YXRlLnRhaWw7dmFyIF9sYXN0VGFpbE5vZGU9bnVsbDt3aGlsZShfdGFpbE5vZGUhPT1udWxsKXtpZihfdGFpbE5vZGUuYWx0ZXJuYXRlIT09bnVsbCl7X2xhc3RUYWlsTm9kZT1fdGFpbE5vZGU7fV90YWlsTm9kZT1fdGFpbE5vZGUuc2libGluZzt9Ly8gTmV4dCB3ZSdyZSBzaW1wbHkgZ29pbmcgdG8gZGVsZXRlIGFsbCBpbnNlcnRpb25zIGFmdGVyIHRoZVxuLy8gbGFzdCByZW5kZXJlZCBpdGVtLlxuaWYoX2xhc3RUYWlsTm9kZT09PW51bGwpey8vIEFsbCByZW1haW5pbmcgaXRlbXMgaW4gdGhlIHRhaWwgYXJlIGluc2VydGlvbnMuXG5pZighaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrJiZyZW5kZXJTdGF0ZS50YWlsIT09bnVsbCl7Ly8gV2Ugc3VzcGVuZGVkIGR1cmluZyB0aGUgaGVhZC4gV2Ugd2FudCB0byBzaG93IGF0IGxlYXN0IG9uZVxuLy8gcm93IGF0IHRoZSB0YWlsLiBTbyB3ZSdsbCBrZWVwIG9uIGFuZCBjdXQgb2ZmIHRoZSByZXN0LlxucmVuZGVyU3RhdGUudGFpbC5zaWJsaW5nPW51bGw7fWVsc2V7cmVuZGVyU3RhdGUudGFpbD1udWxsO319ZWxzZXsvLyBEZXRhY2ggdGhlIGluc2VydGlvbiBhZnRlciB0aGUgbGFzdCBub2RlIHRoYXQgd2FzIGFscmVhZHlcbi8vIGluc2VydGVkLlxuX2xhc3RUYWlsTm9kZS5zaWJsaW5nPW51bGw7fWJyZWFrO319fWZ1bmN0aW9uIGJ1YmJsZVByb3BlcnRpZXMoY29tcGxldGVkV29yayl7dmFyIGRpZEJhaWxvdXQ9Y29tcGxldGVkV29yay5hbHRlcm5hdGUhPT1udWxsJiZjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZS5jaGlsZD09PWNvbXBsZXRlZFdvcmsuY2hpbGQ7dmFyIG5ld0NoaWxkTGFuZXM9Tm9MYW5lczt2YXIgc3VidHJlZUZsYWdzPU5vRmxhZ3M7aWYoIWRpZEJhaWxvdXQpey8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuaWYoKGNvbXBsZXRlZFdvcmsubW9kZSZQcm9maWxlTW9kZSkhPT1Ob01vZGUpey8vIEluIHByb2ZpbGluZyBtb2RlLCByZXNldENoaWxkRXhwaXJhdGlvblRpbWUgaXMgYWxzbyB1c2VkIHRvIHJlc2V0XG4vLyBwcm9maWxlciBkdXJhdGlvbnMuXG52YXIgYWN0dWFsRHVyYXRpb249Y29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjt2YXIgdHJlZUJhc2VEdXJhdGlvbj1jb21wbGV0ZWRXb3JrLnNlbGZCYXNlRHVyYXRpb247dmFyIGNoaWxkPWNvbXBsZXRlZFdvcmsuY2hpbGQ7d2hpbGUoY2hpbGQhPT1udWxsKXtuZXdDaGlsZExhbmVzPW1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcyxtZXJnZUxhbmVzKGNoaWxkLmxhbmVzLGNoaWxkLmNoaWxkTGFuZXMpKTtzdWJ0cmVlRmxhZ3N8PWNoaWxkLnN1YnRyZWVGbGFncztzdWJ0cmVlRmxhZ3N8PWNoaWxkLmZsYWdzOy8vIFdoZW4gYSBmaWJlciBpcyBjbG9uZWQsIGl0cyBhY3R1YWxEdXJhdGlvbiBpcyByZXNldCB0byAwLiBUaGlzIHZhbHVlIHdpbGxcbi8vIG9ubHkgYmUgdXBkYXRlZCBpZiB3b3JrIGlzIGRvbmUgb24gdGhlIGZpYmVyIChpLmUuIGl0IGRvZXNuJ3QgYmFpbG91dCkuXG4vLyBXaGVuIHdvcmsgaXMgZG9uZSwgaXQgc2hvdWxkIGJ1YmJsZSB0byB0aGUgcGFyZW50J3MgYWN0dWFsRHVyYXRpb24uIElmXG4vLyB0aGUgZmliZXIgaGFzIG5vdCBiZWVuIGNsb25lZCB0aG91Z2gsIChtZWFuaW5nIG5vIHdvcmsgd2FzIGRvbmUpLCB0aGVuXG4vLyB0aGlzIHZhbHVlIHdpbGwgcmVmbGVjdCB0aGUgYW1vdW50IG9mIHRpbWUgc3BlbnQgd29ya2luZyBvbiBhIHByZXZpb3VzXG4vLyByZW5kZXIuIEluIHRoYXQgY2FzZSBpdCBzaG91bGQgbm90IGJ1YmJsZS4gV2UgZGV0ZXJtaW5lIHdoZXRoZXIgaXQgd2FzXG4vLyBjbG9uZWQgYnkgY29tcGFyaW5nIHRoZSBjaGlsZCBwb2ludGVyLlxuYWN0dWFsRHVyYXRpb24rPWNoaWxkLmFjdHVhbER1cmF0aW9uO3RyZWVCYXNlRHVyYXRpb24rPWNoaWxkLnRyZWVCYXNlRHVyYXRpb247Y2hpbGQ9Y2hpbGQuc2libGluZzt9Y29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbj1hY3R1YWxEdXJhdGlvbjtjb21wbGV0ZWRXb3JrLnRyZWVCYXNlRHVyYXRpb249dHJlZUJhc2VEdXJhdGlvbjt9ZWxzZXt2YXIgX2NoaWxkPWNvbXBsZXRlZFdvcmsuY2hpbGQ7d2hpbGUoX2NoaWxkIT09bnVsbCl7bmV3Q2hpbGRMYW5lcz1tZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsbWVyZ2VMYW5lcyhfY2hpbGQubGFuZXMsX2NoaWxkLmNoaWxkTGFuZXMpKTtzdWJ0cmVlRmxhZ3N8PV9jaGlsZC5zdWJ0cmVlRmxhZ3M7c3VidHJlZUZsYWdzfD1fY2hpbGQuZmxhZ3M7Ly8gVXBkYXRlIHRoZSByZXR1cm4gcG9pbnRlciBzbyB0aGUgdHJlZSBpcyBjb25zaXN0ZW50LiBUaGlzIGlzIGEgY29kZVxuLy8gc21lbGwgYmVjYXVzZSBpdCBhc3N1bWVzIHRoZSBjb21taXQgcGhhc2UgaXMgbmV2ZXIgY29uY3VycmVudCB3aXRoXG4vLyB0aGUgcmVuZGVyIHBoYXNlLiBXaWxsIGFkZHJlc3MgZHVyaW5nIHJlZmFjdG9yIHRvIGFsdGVybmF0ZSBtb2RlbC5cbl9jaGlsZC5yZXR1cm49Y29tcGxldGVkV29yaztfY2hpbGQ9X2NoaWxkLnNpYmxpbmc7fX1jb21wbGV0ZWRXb3JrLnN1YnRyZWVGbGFnc3w9c3VidHJlZUZsYWdzO31lbHNley8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuaWYoKGNvbXBsZXRlZFdvcmsubW9kZSZQcm9maWxlTW9kZSkhPT1Ob01vZGUpey8vIEluIHByb2ZpbGluZyBtb2RlLCByZXNldENoaWxkRXhwaXJhdGlvblRpbWUgaXMgYWxzbyB1c2VkIHRvIHJlc2V0XG4vLyBwcm9maWxlciBkdXJhdGlvbnMuXG52YXIgX3RyZWVCYXNlRHVyYXRpb249Y29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uO3ZhciBfY2hpbGQyPWNvbXBsZXRlZFdvcmsuY2hpbGQ7d2hpbGUoX2NoaWxkMiE9PW51bGwpe25ld0NoaWxkTGFuZXM9bWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLG1lcmdlTGFuZXMoX2NoaWxkMi5sYW5lcyxfY2hpbGQyLmNoaWxkTGFuZXMpKTsvLyBcIlN0YXRpY1wiIGZsYWdzIHNoYXJlIHRoZSBsaWZldGltZSBvZiB0aGUgZmliZXIvaG9vayB0aGV5IGJlbG9uZyB0byxcbi8vIHNvIHdlIHNob3VsZCBidWJibGUgdGhvc2UgdXAgZXZlbiBkdXJpbmcgYSBiYWlsb3V0LiBBbGwgdGhlIG90aGVyXG4vLyBmbGFncyBoYXZlIGEgbGlmZXRpbWUgb25seSBvZiBhIHNpbmdsZSByZW5kZXIgKyBjb21taXQsIHNvIHdlIHNob3VsZFxuLy8gaWdub3JlIHRoZW0uXG5zdWJ0cmVlRmxhZ3N8PV9jaGlsZDIuc3VidHJlZUZsYWdzJlN0YXRpY01hc2s7c3VidHJlZUZsYWdzfD1fY2hpbGQyLmZsYWdzJlN0YXRpY01hc2s7X3RyZWVCYXNlRHVyYXRpb24rPV9jaGlsZDIudHJlZUJhc2VEdXJhdGlvbjtfY2hpbGQyPV9jaGlsZDIuc2libGluZzt9Y29tcGxldGVkV29yay50cmVlQmFzZUR1cmF0aW9uPV90cmVlQmFzZUR1cmF0aW9uO31lbHNle3ZhciBfY2hpbGQzPWNvbXBsZXRlZFdvcmsuY2hpbGQ7d2hpbGUoX2NoaWxkMyE9PW51bGwpe25ld0NoaWxkTGFuZXM9bWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLG1lcmdlTGFuZXMoX2NoaWxkMy5sYW5lcyxfY2hpbGQzLmNoaWxkTGFuZXMpKTsvLyBcIlN0YXRpY1wiIGZsYWdzIHNoYXJlIHRoZSBsaWZldGltZSBvZiB0aGUgZmliZXIvaG9vayB0aGV5IGJlbG9uZyB0byxcbi8vIHNvIHdlIHNob3VsZCBidWJibGUgdGhvc2UgdXAgZXZlbiBkdXJpbmcgYSBiYWlsb3V0LiBBbGwgdGhlIG90aGVyXG4vLyBmbGFncyBoYXZlIGEgbGlmZXRpbWUgb25seSBvZiBhIHNpbmdsZSByZW5kZXIgKyBjb21taXQsIHNvIHdlIHNob3VsZFxuLy8gaWdub3JlIHRoZW0uXG5zdWJ0cmVlRmxhZ3N8PV9jaGlsZDMuc3VidHJlZUZsYWdzJlN0YXRpY01hc2s7c3VidHJlZUZsYWdzfD1fY2hpbGQzLmZsYWdzJlN0YXRpY01hc2s7Ly8gVXBkYXRlIHRoZSByZXR1cm4gcG9pbnRlciBzbyB0aGUgdHJlZSBpcyBjb25zaXN0ZW50LiBUaGlzIGlzIGEgY29kZVxuLy8gc21lbGwgYmVjYXVzZSBpdCBhc3N1bWVzIHRoZSBjb21taXQgcGhhc2UgaXMgbmV2ZXIgY29uY3VycmVudCB3aXRoXG4vLyB0aGUgcmVuZGVyIHBoYXNlLiBXaWxsIGFkZHJlc3MgZHVyaW5nIHJlZmFjdG9yIHRvIGFsdGVybmF0ZSBtb2RlbC5cbl9jaGlsZDMucmV0dXJuPWNvbXBsZXRlZFdvcms7X2NoaWxkMz1fY2hpbGQzLnNpYmxpbmc7fX1jb21wbGV0ZWRXb3JrLnN1YnRyZWVGbGFnc3w9c3VidHJlZUZsYWdzO31jb21wbGV0ZWRXb3JrLmNoaWxkTGFuZXM9bmV3Q2hpbGRMYW5lcztyZXR1cm4gZGlkQmFpbG91dDt9ZnVuY3Rpb24gY29tcGxldGVEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeShjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRTdGF0ZSl7aWYoaGFzVW5oeWRyYXRlZFRhaWxOb2RlcygpJiYod29ya0luUHJvZ3Jlc3MubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGUmJih3b3JrSW5Qcm9ncmVzcy5mbGFncyZEaWRDYXB0dXJlKT09PU5vRmxhZ3Mpe3dhcm5JZlVuaHlkcmF0ZWRUYWlsTm9kZXMod29ya0luUHJvZ3Jlc3MpO3Jlc2V0SHlkcmF0aW9uU3RhdGUoKTt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9Rm9yY2VDbGllbnRSZW5kZXJ8SW5jb21wbGV0ZXxTaG91bGRDYXB0dXJlO3JldHVybiBmYWxzZTt9dmFyIHdhc0h5ZHJhdGVkPXBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtpZihuZXh0U3RhdGUhPT1udWxsJiZuZXh0U3RhdGUuZGVoeWRyYXRlZCE9PW51bGwpey8vIFdlIG1pZ2h0IGJlIGluc2lkZSBhIGh5ZHJhdGlvbiBzdGF0ZSB0aGUgZmlyc3QgdGltZSB3ZSdyZSBwaWNraW5nIHVwIHRoaXNcbi8vIFN1c3BlbnNlIGJvdW5kYXJ5LCBhbmQgYWxzbyBhZnRlciB3ZSd2ZSByZWVudGVyZWQgaXQgZm9yIGZ1cnRoZXIgaHlkcmF0aW9uLlxuaWYoY3VycmVudD09PW51bGwpe2lmKCF3YXNIeWRyYXRlZCl7dGhyb3cgbmV3IEVycm9yKCdBIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50IHdhcyBjb21wbGV0ZWQgd2l0aG91dCBhIGh5ZHJhdGVkIG5vZGUuICcrJ1RoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJyk7fXByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7YnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7e2lmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJlByb2ZpbGVNb2RlKSE9PU5vTW9kZSl7dmFyIGlzVGltZWRPdXRTdXNwZW5zZT1uZXh0U3RhdGUhPT1udWxsO2lmKGlzVGltZWRPdXRTdXNwZW5zZSl7Ly8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG52YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7aWYocHJpbWFyeUNoaWxkRnJhZ21lbnQhPT1udWxsKXsvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBzdXBwb3J0IHR5cGUgY2FzdGluZyBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSAtPSBvcGVyYXRvclxud29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbi09cHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjt9fX19cmV0dXJuIGZhbHNlO31lbHNley8vIFdlIG1pZ2h0IGhhdmUgcmVlbnRlcmVkIHRoaXMgYm91bmRhcnkgdG8gaHlkcmF0ZSBpdC4gSWYgc28sIHdlIG5lZWQgdG8gcmVzZXQgdGhlIGh5ZHJhdGlvblxuLy8gc3RhdGUgc2luY2Ugd2UncmUgbm93IGV4aXRpbmcgb3V0IG9mIGl0LiBwb3BIeWRyYXRpb25TdGF0ZSBkb2Vzbid0IGRvIHRoYXQgZm9yIHVzLlxucmVzZXRIeWRyYXRpb25TdGF0ZSgpO2lmKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyZEaWRDYXB0dXJlKT09PU5vRmxhZ3Mpey8vIFRoaXMgYm91bmRhcnkgZGlkIG5vdCBzdXNwZW5kIHNvIGl0J3Mgbm93IGh5ZHJhdGVkIGFuZCB1bnN1c3BlbmRlZC5cbndvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9bnVsbDt9Ly8gSWYgbm90aGluZyBzdXNwZW5kZWQsIHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gZWZmZWN0IHRvIG1hcmsgdGhpcyBib3VuZGFyeVxuLy8gYXMgaGF2aW5nIGh5ZHJhdGVkIHNvIGV2ZW50cyBrbm93IHRoYXQgdGhleSdyZSBmcmVlIHRvIGJlIGludm9rZWQuXG4vLyBJdCdzIGFsc28gYSBzaWduYWwgdG8gcmVwbGF5IGV2ZW50cyBhbmQgdGhlIHN1c3BlbnNlIGNhbGxiYWNrLlxuLy8gSWYgc29tZXRoaW5nIHN1c3BlbmRlZCwgc2NoZWR1bGUgYW4gZWZmZWN0IHRvIGF0dGFjaCByZXRyeSBsaXN0ZW5lcnMuXG4vLyBTbyB3ZSBtaWdodCBhcyB3ZWxsIGFsd2F5cyBtYXJrIHRoaXMuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VXBkYXRlO2J1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3tpZigod29ya0luUHJvZ3Jlc3MubW9kZSZQcm9maWxlTW9kZSkhPT1Ob01vZGUpe3ZhciBfaXNUaW1lZE91dFN1c3BlbnNlPW5leHRTdGF0ZSE9PW51bGw7aWYoX2lzVGltZWRPdXRTdXNwZW5zZSl7Ly8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG52YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50PXdvcmtJblByb2dyZXNzLmNoaWxkO2lmKF9wcmltYXJ5Q2hpbGRGcmFnbWVudCE9PW51bGwpey8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG53b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uLT1fcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjt9fX19cmV0dXJuIGZhbHNlO319ZWxzZXsvLyBTdWNjZXNzZnVsbHkgY29tcGxldGVkIHRoaXMgdHJlZS4gSWYgdGhpcyB3YXMgYSBmb3JjZWQgY2xpZW50IHJlbmRlcixcbi8vIHRoZXJlIG1heSBoYXZlIGJlZW4gcmVjb3ZlcmFibGUgZXJyb3JzIGR1cmluZyBmaXJzdCBoeWRyYXRpb25cbi8vIGF0dGVtcHQuIElmIHNvLCBhZGQgdGhlbSB0byBhIHF1ZXVlIHNvIHdlIGNhbiBsb2cgdGhlbSBpbiB0aGVcbi8vIGNvbW1pdCBwaGFzZS5cbnVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCk7Ly8gRmFsbCB0aHJvdWdoIHRvIG5vcm1hbCBTdXNwZW5zZSBwYXRoXG5yZXR1cm4gdHJ1ZTt9fWZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXt2YXIgbmV3UHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOy8vIE5vdGU6IFRoaXMgaW50ZW50aW9uYWxseSBkb2Vzbid0IGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZyBiZWNhdXNlIGNvbXBhcmluZ1xuLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4vLyBJZGVhbGx5IHdlIHdvdWxkIGhhdmUgYSBzcGVjaWFsIHZlcnNpb24gb2YgdGhlIHdvcmsgbG9vcCBvbmx5XG4vLyBmb3IgaHlkcmF0aW9uLlxucG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO3N3aXRjaCh3b3JrSW5Qcm9ncmVzcy50YWcpe2Nhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpjYXNlIExhenlDb21wb25lbnQ6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OmNhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBGb3J3YXJkUmVmOmNhc2UgRnJhZ21lbnQ6Y2FzZSBNb2RlOmNhc2UgUHJvZmlsZXI6Y2FzZSBDb250ZXh0Q29uc3VtZXI6Y2FzZSBNZW1vQ29tcG9uZW50OmJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO2Nhc2UgQ2xhc3NDb21wb25lbnQ6e3ZhciBDb21wb25lbnQ9d29ya0luUHJvZ3Jlc3MudHlwZTtpZihpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKXtwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTt9YnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7fWNhc2UgSG9zdFJvb3Q6e3ZhciBmaWJlclJvb3Q9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO3BvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO3BvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7cmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7aWYoZmliZXJSb290LnBlbmRpbmdDb250ZXh0KXtmaWJlclJvb3QuY29udGV4dD1maWJlclJvb3QucGVuZGluZ0NvbnRleHQ7ZmliZXJSb290LnBlbmRpbmdDb250ZXh0PW51bGw7fWlmKGN1cnJlbnQ9PT1udWxsfHxjdXJyZW50LmNoaWxkPT09bnVsbCl7Ly8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuLy8gdGhhdCB3ZXJlbid0IGh5ZHJhdGVkLlxudmFyIHdhc0h5ZHJhdGVkPXBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtpZih3YXNIeWRyYXRlZCl7Ly8gSWYgd2UgaHlkcmF0ZWQsIHRoZW4gd2UnbGwgbmVlZCB0byBzY2hlZHVsZSBhbiB1cGRhdGUgZm9yXG4vLyB0aGUgY29tbWl0IHNpZGUtZWZmZWN0cyBvbiB0aGUgcm9vdC5cbm1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO31lbHNle2lmKGN1cnJlbnQhPT1udWxsKXt2YXIgcHJldlN0YXRlPWN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtpZigvLyBDaGVjayBpZiB0aGlzIGlzIGEgY2xpZW50IHJvb3RcbiFwcmV2U3RhdGUuaXNEZWh5ZHJhdGVkfHwvLyBDaGVjayBpZiB3ZSByZXZlcnRlZCB0byBjbGllbnQgcmVuZGVyaW5nIChlLmcuIGR1ZSB0byBhbiBlcnJvcilcbih3b3JrSW5Qcm9ncmVzcy5mbGFncyZGb3JjZUNsaWVudFJlbmRlcikhPT1Ob0ZsYWdzKXsvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gY2xlYXIgdGhpcyBjb250YWluZXIgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuLy8gbmV4dCBjb21taXQuIFRoaXMgaGFuZGxlcyB0aGUgY2FzZSBvZiBSZWFjdCByZW5kZXJpbmcgaW50byBhXG4vLyBjb250YWluZXIgd2l0aCBwcmV2aW91cyBjaGlsZHJlbi4gSXQncyBhbHNvIHNhZmUgdG8gZG8gZm9yXG4vLyB1cGRhdGVzIHRvbywgYmVjYXVzZSBjdXJyZW50LmNoaWxkIHdvdWxkIG9ubHkgYmUgbnVsbCBpZiB0aGVcbi8vIHByZXZpb3VzIHJlbmRlciB3YXMgbnVsbCAoc28gdGhlIGNvbnRhaW5lciB3b3VsZCBhbHJlYWR5XG4vLyBiZSBlbXB0eSkuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9U25hcHNob3Q7Ly8gSWYgdGhpcyB3YXMgYSBmb3JjZWQgY2xpZW50IHJlbmRlciwgdGhlcmUgbWF5IGhhdmUgYmVlblxuLy8gcmVjb3ZlcmFibGUgZXJyb3JzIGR1cmluZyBmaXJzdCBoeWRyYXRpb24gYXR0ZW1wdC4gSWYgc28sIGFkZFxuLy8gdGhlbSB0byBhIHF1ZXVlIHNvIHdlIGNhbiBsb2cgdGhlbSBpbiB0aGUgY29tbWl0IHBoYXNlLlxudXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUoKTt9fX19dXBkYXRlSG9zdENvbnRhaW5lcihjdXJyZW50LHdvcmtJblByb2dyZXNzKTtidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDt9Y2FzZSBIb3N0Q29tcG9uZW50Ontwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7dmFyIHJvb3RDb250YWluZXJJbnN0YW5jZT1nZXRSb290SG9zdENvbnRhaW5lcigpO3ZhciB0eXBlPXdvcmtJblByb2dyZXNzLnR5cGU7aWYoY3VycmVudCE9PW51bGwmJndvcmtJblByb2dyZXNzLnN0YXRlTm9kZSE9bnVsbCl7dXBkYXRlSG9zdENvbXBvbmVudCQxKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsdHlwZSxuZXdQcm9wcyxyb290Q29udGFpbmVySW5zdGFuY2UpO2lmKGN1cnJlbnQucmVmIT09d29ya0luUHJvZ3Jlc3MucmVmKXttYXJrUmVmJDEod29ya0luUHJvZ3Jlc3MpO319ZWxzZXtpZighbmV3UHJvcHMpe2lmKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZT09PW51bGwpe3Rocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJysnY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9Ly8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYWJvcnQgd29yay5cbmJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO312YXIgY3VycmVudEhvc3RDb250ZXh0PWdldEhvc3RDb250ZXh0KCk7Ly8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4vLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4vLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdoZXRoZXIgd2Ugd2FudCB0byBhZGQgdGhlbSB0b3AtPmRvd24gb3Jcbi8vIGJvdHRvbS0+dXAuIFRvcC0+ZG93biBpcyBmYXN0ZXIgaW4gSUUxMS5cbnZhciBfd2FzSHlkcmF0ZWQ9cG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO2lmKF93YXNIeWRyYXRlZCl7Ly8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2Vcbi8vIHRvIGNvbnNvbGlkYXRlLlxuaWYocHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxyb290Q29udGFpbmVySW5zdGFuY2UsY3VycmVudEhvc3RDb250ZXh0KSl7Ly8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG4vLyBjb21taXQtcGhhc2Ugd2UgbWFyayB0aGlzIGFzIHN1Y2guXG5tYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTt9fWVsc2V7dmFyIGluc3RhbmNlPWNyZWF0ZUluc3RhbmNlKHR5cGUsbmV3UHJvcHMscm9vdENvbnRhaW5lckluc3RhbmNlLGN1cnJlbnRIb3N0Q29udGV4dCx3b3JrSW5Qcm9ncmVzcyk7YXBwZW5kQWxsQ2hpbGRyZW4oaW5zdGFuY2Usd29ya0luUHJvZ3Jlc3MsZmFsc2UsZmFsc2UpO3dvcmtJblByb2dyZXNzLnN0YXRlTm9kZT1pbnN0YW5jZTsvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4vLyAoZWcgRE9NIHJlbmRlcmVyIHN1cHBvcnRzIGF1dG8tZm9jdXMgZm9yIGNlcnRhaW4gZWxlbWVudHMpLlxuLy8gTWFrZSBzdXJlIHN1Y2ggcmVuZGVyZXJzIGdldCBzY2hlZHVsZWQgZm9yIGxhdGVyIHdvcmsuXG5pZihmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihpbnN0YW5jZSx0eXBlLG5ld1Byb3BzLHJvb3RDb250YWluZXJJbnN0YW5jZSkpe21hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO319aWYod29ya0luUHJvZ3Jlc3MucmVmIT09bnVsbCl7Ly8gSWYgdGhlcmUgaXMgYSByZWYgb24gYSBob3N0IG5vZGUgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG5tYXJrUmVmJDEod29ya0luUHJvZ3Jlc3MpO319YnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7fWNhc2UgSG9zdFRleHQ6e3ZhciBuZXdUZXh0PW5ld1Byb3BzO2lmKGN1cnJlbnQmJndvcmtJblByb2dyZXNzLnN0YXRlTm9kZSE9bnVsbCl7dmFyIG9sZFRleHQ9Y3VycmVudC5tZW1vaXplZFByb3BzOy8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4vLyB0byBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxudXBkYXRlSG9zdFRleHQkMShjdXJyZW50LHdvcmtJblByb2dyZXNzLG9sZFRleHQsbmV3VGV4dCk7fWVsc2V7aWYodHlwZW9mIG5ld1RleHQhPT0nc3RyaW5nJyl7aWYod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlPT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSAnKydjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO30vLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxufXZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlPWdldFJvb3RIb3N0Q29udGFpbmVyKCk7dmFyIF9jdXJyZW50SG9zdENvbnRleHQ9Z2V0SG9zdENvbnRleHQoKTt2YXIgX3dhc0h5ZHJhdGVkMj1wb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7aWYoX3dhc0h5ZHJhdGVkMil7aWYocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKXttYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTt9fWVsc2V7d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlPWNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LF9yb290Q29udGFpbmVySW5zdGFuY2UsX2N1cnJlbnRIb3N0Q29udGV4dCx3b3JrSW5Qcm9ncmVzcyk7fX1idWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDt9Y2FzZSBTdXNwZW5zZUNvbXBvbmVudDp7cG9wU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzKTt2YXIgbmV4dFN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7Ly8gU3BlY2lhbCBwYXRoIGZvciBkZWh5ZHJhdGVkIGJvdW5kYXJpZXMuIFdlIG1heSBldmVudHVhbGx5IG1vdmUgdGhpc1xuLy8gdG8gaXRzIG93biBmaWJlciB0eXBlIHNvIHRoYXQgd2UgY2FuIGFkZCBvdGhlciBraW5kcyBvZiBoeWRyYXRpb25cbi8vIGJvdW5kYXJpZXMgdGhhdCBhcmVuJ3QgYXNzb2NpYXRlZCB3aXRoIGEgU3VzcGVuc2UgdHJlZS4gSW4gYW50aWNpcGF0aW9uXG4vLyBvZiBzdWNoIGEgcmVmYWN0b3IsIGFsbCB0aGUgaHlkcmF0aW9uIGxvZ2ljIGlzIGNvbnRhaW5lZCBpblxuLy8gdGhpcyBicmFuY2guXG5pZihjdXJyZW50PT09bnVsbHx8Y3VycmVudC5tZW1vaXplZFN0YXRlIT09bnVsbCYmY3VycmVudC5tZW1vaXplZFN0YXRlLmRlaHlkcmF0ZWQhPT1udWxsKXt2YXIgZmFsbHRocm91Z2hUb05vcm1hbFN1c3BlbnNlUGF0aD1jb21wbGV0ZURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dFN0YXRlKTtpZighZmFsbHRocm91Z2hUb05vcm1hbFN1c3BlbnNlUGF0aCl7aWYod29ya0luUHJvZ3Jlc3MuZmxhZ3MmU2hvdWxkQ2FwdHVyZSl7Ly8gU3BlY2lhbCBjYXNlLiBUaGVyZSB3ZXJlIHJlbWFpbmluZyB1bmh5ZHJhdGVkIG5vZGVzLiBXZSB0cmVhdFxuLy8gdGhpcyBhcyBhIG1pc21hdGNoLiBSZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cbnJldHVybiB3b3JrSW5Qcm9ncmVzczt9ZWxzZXsvLyBEaWQgbm90IGZpbmlzaCBoeWRyYXRpbmcsIGVpdGhlciBiZWNhdXNlIHRoaXMgaXMgdGhlIGluaXRpYWxcbi8vIHJlbmRlciBvciBiZWNhdXNlIHNvbWV0aGluZyBzdXNwZW5kZWQuXG5yZXR1cm4gbnVsbDt9fS8vIENvbnRpbnVlIHdpdGggdGhlIG5vcm1hbCBTdXNwZW5zZSBwYXRoLlxufWlmKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyZEaWRDYXB0dXJlKSE9PU5vRmxhZ3Mpey8vIFNvbWV0aGluZyBzdXNwZW5kZWQuIFJlLXJlbmRlciB3aXRoIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbndvcmtJblByb2dyZXNzLmxhbmVzPXJlbmRlckxhbmVzOy8vIERvIG5vdCByZXNldCB0aGUgZWZmZWN0IGxpc3QuXG5pZigod29ya0luUHJvZ3Jlc3MubW9kZSZQcm9maWxlTW9kZSkhPT1Ob01vZGUpe3RyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO30vLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBpbiB0aGlzIGNhc2UuXG5yZXR1cm4gd29ya0luUHJvZ3Jlc3M7fXZhciBuZXh0RGlkVGltZW91dD1uZXh0U3RhdGUhPT1udWxsO3ZhciBwcmV2RGlkVGltZW91dD1jdXJyZW50IT09bnVsbCYmY3VycmVudC5tZW1vaXplZFN0YXRlIT09bnVsbDsvLyBhIHBhc3NpdmUgZWZmZWN0LCB3aGljaCBpcyB3aGVuIHdlIHByb2Nlc3MgdGhlIHRyYW5zaXRpb25zXG5pZihuZXh0RGlkVGltZW91dCE9PXByZXZEaWRUaW1lb3V0KXsvLyBhbiBlZmZlY3QgdG8gdG9nZ2xlIHRoZSBzdWJ0cmVlJ3MgdmlzaWJpbGl0eS4gV2hlbiB3ZSBzd2l0Y2ggZnJvbVxuLy8gZmFsbGJhY2sgLT4gcHJpbWFyeSwgdGhlIGlubmVyIE9mZnNjcmVlbiBmaWJlciBzY2hlZHVsZXMgdGhpcyBlZmZlY3Rcbi8vIGFzIHBhcnQgb2YgaXRzIG5vcm1hbCBjb21wbGV0ZSBwaGFzZS4gQnV0IHdoZW4gd2Ugc3dpdGNoIGZyb21cbi8vIHByaW1hcnkgLT4gZmFsbGJhY2ssIHRoZSBpbm5lciBPZmZzY3JlZW4gZmliZXIgZG9lcyBub3QgaGF2ZSBhIGNvbXBsZXRlXG4vLyBwaGFzZS4gU28gd2UgbmVlZCB0byBzY2hlZHVsZSBpdHMgZWZmZWN0IGhlcmUuXG4vL1xuLy8gV2UgYWxzbyB1c2UgdGhpcyBmbGFnIHRvIGNvbm5lY3QvZGlzY29ubmVjdCB0aGUgZWZmZWN0cywgYnV0IHRoZSBzYW1lXG4vLyBsb2dpYyBhcHBsaWVzOiB3aGVuIHJlLWNvbm5lY3RpbmcsIHRoZSBPZmZzY3JlZW4gZmliZXIncyBjb21wbGV0ZVxuLy8gcGhhc2Ugd2lsbCBoYW5kbGUgc2NoZWR1bGluZyB0aGUgZWZmZWN0LiBJdCdzIG9ubHkgd2hlbiB0aGUgZmFsbGJhY2tcbi8vIGlzIGFjdGl2ZSB0aGF0IHdlIGhhdmUgdG8gZG8gYW55dGhpbmcgc3BlY2lhbC5cbmlmKG5leHREaWRUaW1lb3V0KXt2YXIgX29mZnNjcmVlbkZpYmVyMj13b3JrSW5Qcm9ncmVzcy5jaGlsZDtfb2Zmc2NyZWVuRmliZXIyLmZsYWdzfD1WaXNpYmlsaXR5Oy8vIFRPRE86IFRoaXMgd2lsbCBzdGlsbCBzdXNwZW5kIGEgc3luY2hyb25vdXMgdHJlZSBpZiBhbnl0aGluZ1xuLy8gaW4gdGhlIGNvbmN1cnJlbnQgdHJlZSBhbHJlYWR5IHN1c3BlbmRlZCBkdXJpbmcgdGhpcyByZW5kZXIuXG4vLyBUaGlzIGlzIGEga25vd24gYnVnLlxuaWYoKHdvcmtJblByb2dyZXNzLm1vZGUmQ29uY3VycmVudE1vZGUpIT09Tm9Nb2RlKXsvLyBUT0RPOiBNb3ZlIHRoaXMgYmFjayB0byB0aHJvd0V4Y2VwdGlvbiBiZWNhdXNlIHRoaXMgaXMgdG9vIGxhdGVcbi8vIGlmIHRoaXMgaXMgYSBsYXJnZSB0cmVlIHdoaWNoIGlzIGNvbW1vbiBmb3IgaW5pdGlhbCBsb2Fkcy4gV2Vcbi8vIGRvbid0IGtub3cgaWYgd2Ugc2hvdWxkIHJlc3RhcnQgYSByZW5kZXIgb3Igbm90IHVudGlsIHdlIGdldFxuLy8gdGhpcyBtYXJrZXIsIGFuZCB0aGlzIGlzIHRvbyBsYXRlLlxuLy8gSWYgdGhpcyByZW5kZXIgYWxyZWFkeSBoYWQgYSBwaW5nIG9yIGxvd2VyIHByaSB1cGRhdGVzLFxuLy8gYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2Uga25vdyB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdlXG4vLyBzaG91bGQgYmUgYWJsZSB0byBpbW1lZGlhdGVseSByZXN0YXJ0IGZyb20gd2l0aGluIHRocm93RXhjZXB0aW9uLlxudmFyIGhhc0ludmlzaWJsZUNoaWxkQ29udGV4dD1jdXJyZW50PT09bnVsbCYmKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMudW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2shPT10cnVlfHwhZW5hYmxlU3VzcGVuc2VBdm9pZFRoaXNGYWxsYmFjayk7aWYoaGFzSW52aXNpYmxlQ2hpbGRDb250ZXh0fHxoYXNTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCkpey8vIElmIHRoaXMgd2FzIGluIGFuIGludmlzaWJsZSB0cmVlIG9yIGEgbmV3IHJlbmRlciwgdGhlbiBzaG93aW5nXG4vLyB0aGlzIGJvdW5kYXJ5IGlzIG9rLlxucmVuZGVyRGlkU3VzcGVuZCgpO31lbHNley8vIE90aGVyd2lzZSwgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byBoaWRlIGNvbnRlbnQgc28gd2Ugc2hvdWxkXG4vLyBzdXNwZW5kIGZvciBsb25nZXIgaWYgcG9zc2libGUuXG5yZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7fX19fXZhciB3YWtlYWJsZXM9d29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7aWYod2FrZWFibGVzIT09bnVsbCl7Ly8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIGF0dGFjaCBhIHJldHJ5IGxpc3RlbmVyIHRvIHRoZSBwcm9taXNlLlxuLy8gVE9ETzogTW92ZSB0byBwYXNzaXZlIHBoYXNlXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VXBkYXRlO31idWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTt7aWYoKHdvcmtJblByb2dyZXNzLm1vZGUmUHJvZmlsZU1vZGUpIT09Tm9Nb2RlKXtpZihuZXh0RGlkVGltZW91dCl7Ly8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG52YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7aWYocHJpbWFyeUNoaWxkRnJhZ21lbnQhPT1udWxsKXsvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBzdXBwb3J0IHR5cGUgY2FzdGluZyBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSAtPSBvcGVyYXRvclxud29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbi09cHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjt9fX19cmV0dXJuIG51bGw7fWNhc2UgSG9zdFBvcnRhbDpwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTt1cGRhdGVIb3N0Q29udGFpbmVyKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MpO2lmKGN1cnJlbnQ9PT1udWxsKXtwcmVwYXJlUG9ydGFsTW91bnQod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO31idWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDtjYXNlIENvbnRleHRQcm92aWRlcjovLyBQb3AgcHJvdmlkZXIgZmliZXJcbnZhciBjb250ZXh0PXdvcmtJblByb2dyZXNzLnR5cGUuX2NvbnRleHQ7cG9wUHJvdmlkZXIoY29udGV4dCx3b3JrSW5Qcm9ncmVzcyk7YnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7Y2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6ey8vIFNhbWUgYXMgY2xhc3MgY29tcG9uZW50IGNhc2UuIEkgcHV0IGl0IGRvd24gaGVyZSBzbyB0aGF0IHRoZSB0YWdzIGFyZVxuLy8gc2VxdWVudGlhbCB0byBlbnN1cmUgdGhpcyBzd2l0Y2ggaXMgY29tcGlsZWQgdG8gYSBqdW1wIHRhYmxlLlxudmFyIF9Db21wb25lbnQ9d29ya0luUHJvZ3Jlc3MudHlwZTtpZihpc0NvbnRleHRQcm92aWRlcihfQ29tcG9uZW50KSl7cG9wQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7fWJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO31jYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDp7cG9wU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzKTt2YXIgcmVuZGVyU3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtpZihyZW5kZXJTdGF0ZT09PW51bGwpey8vIFdlJ3JlIHJ1bm5pbmcgaW4gdGhlIGRlZmF1bHQsIFwiaW5kZXBlbmRlbnRcIiBtb2RlLlxuLy8gV2UgZG9uJ3QgZG8gYW55dGhpbmcgaW4gdGhpcyBtb2RlLlxuYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7fXZhciBkaWRTdXNwZW5kQWxyZWFkeT0od29ya0luUHJvZ3Jlc3MuZmxhZ3MmRGlkQ2FwdHVyZSkhPT1Ob0ZsYWdzO3ZhciByZW5kZXJlZFRhaWw9cmVuZGVyU3RhdGUucmVuZGVyaW5nO2lmKHJlbmRlcmVkVGFpbD09PW51bGwpey8vIFdlIGp1c3QgcmVuZGVyZWQgdGhlIGhlYWQuXG5pZighZGlkU3VzcGVuZEFscmVhZHkpey8vIFRoaXMgaXMgdGhlIGZpcnN0IHBhc3MuIFdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiBhbnl0aGluZyBpcyBzdGlsbFxuLy8gc3VzcGVuZGVkIGluIHRoZSByZW5kZXJlZCBzZXQuXG4vLyBJZiBuZXcgY29udGVudCB1bnN1c3BlbmRlZCwgYnV0IHRoZXJlJ3Mgc3RpbGwgc29tZSBjb250ZW50IHRoYXRcbi8vIGRpZG4ndC4gVGhlbiB3ZSBuZWVkIHRvIGRvIGEgc2Vjb25kIHBhc3MgdGhhdCBmb3JjZXMgZXZlcnl0aGluZ1xuLy8gdG8ga2VlcCBzaG93aW5nIHRoZWlyIGZhbGxiYWNrcy5cbi8vIFdlIG1pZ2h0IGJlIHN1c3BlbmRlZCBpZiBzb21ldGhpbmcgaW4gdGhpcyByZW5kZXIgcGFzcyBzdXNwZW5kZWQsIG9yXG4vLyBzb21ldGhpbmcgaW4gdGhlIHByZXZpb3VzIGNvbW1pdHRlZCBwYXNzIHN1c3BlbmRlZC4gT3RoZXJ3aXNlLFxuLy8gdGhlcmUncyBubyBjaGFuY2Ugc28gd2UgY2FuIHNraXAgdGhlIGV4cGVuc2l2ZSBjYWxsIHRvXG4vLyBmaW5kRmlyc3RTdXNwZW5kZWQuXG52YXIgY2Fubm90QmVTdXNwZW5kZWQ9cmVuZGVySGFzTm90U3VzcGVuZGVkWWV0KCkmJihjdXJyZW50PT09bnVsbHx8KGN1cnJlbnQuZmxhZ3MmRGlkQ2FwdHVyZSk9PT1Ob0ZsYWdzKTtpZighY2Fubm90QmVTdXNwZW5kZWQpe3ZhciByb3c9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7d2hpbGUocm93IT09bnVsbCl7dmFyIHN1c3BlbmRlZD1maW5kRmlyc3RTdXNwZW5kZWQocm93KTtpZihzdXNwZW5kZWQhPT1udWxsKXtkaWRTdXNwZW5kQWxyZWFkeT10cnVlO3dvcmtJblByb2dyZXNzLmZsYWdzfD1EaWRDYXB0dXJlO2N1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSxmYWxzZSk7Ly8gSWYgdGhpcyBpcyBhIG5ld2x5IHN1c3BlbmRlZCB0cmVlLCBpdCBtaWdodCBub3QgZ2V0IGNvbW1pdHRlZCBhc1xuLy8gcGFydCBvZiB0aGUgc2Vjb25kIHBhc3MuIEluIHRoYXQgY2FzZSBub3RoaW5nIHdpbGwgc3Vic2NyaWJlIHRvXG4vLyBpdHMgdGhlbmFibGVzLiBJbnN0ZWFkLCB3ZSdsbCB0cmFuc2ZlciBpdHMgdGhlbmFibGVzIHRvIHRoZVxuLy8gU3VzcGVuc2VMaXN0IHNvIHRoYXQgaXQgY2FuIHJldHJ5IGlmIHRoZXkgcmVzb2x2ZS5cbi8vIFRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIG9mIHRoZXNlIGluIHRoZSBsaXN0IGJ1dCBzaW5jZSB3ZSdyZVxuLy8gZ29pbmcgdG8gd2FpdCBmb3IgYWxsIG9mIHRoZW0gYW55d2F5LCBpdCBkb2Vzbid0IHJlYWxseSBtYXR0ZXJcbi8vIHdoaWNoIG9uZXMgZ2V0cyB0byBwaW5nLiBJbiB0aGVvcnkgd2UgY291bGQgZ2V0IGNsZXZlciBhbmQga2VlcFxuLy8gdHJhY2sgb2YgaG93IG1hbnkgZGVwZW5kZW5jaWVzIHJlbWFpbiBidXQgaXQgZ2V0cyB0cmlja3kgYmVjYXVzZVxuLy8gaW4gdGhlIG1lYW50aW1lLCB3ZSBjYW4gYWRkL3JlbW92ZS9jaGFuZ2UgaXRlbXMgYW5kIGRlcGVuZGVuY2llcy5cbi8vIFdlIG1pZ2h0IGJhaWwgb3V0IG9mIHRoZSBsb29wIGJlZm9yZSBmaW5kaW5nIGFueSBidXQgdGhhdFxuLy8gZG9lc24ndCBtYXR0ZXIgc2luY2UgdGhhdCBtZWFucyB0aGF0IHRoZSBvdGhlciBib3VuZGFyaWVzIHRoYXRcbi8vIHdlIGRpZCBmaW5kIGFscmVhZHkgaGFzIHRoZWlyIGxpc3RlbmVycyBhdHRhY2hlZC5cbnZhciBuZXdUaGVuYWJsZXM9c3VzcGVuZGVkLnVwZGF0ZVF1ZXVlO2lmKG5ld1RoZW5hYmxlcyE9PW51bGwpe3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlPW5ld1RoZW5hYmxlczt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VXBkYXRlO30vLyBSZXJlbmRlciB0aGUgd2hvbGUgbGlzdCwgYnV0IHRoaXMgdGltZSwgd2UnbGwgZm9yY2UgZmFsbGJhY2tzXG4vLyB0byBzdGF5IGluIHBsYWNlLlxuLy8gUmVzZXQgdGhlIGVmZmVjdCBmbGFncyBiZWZvcmUgZG9pbmcgdGhlIHNlY29uZCBwYXNzIHNpbmNlIHRoYXQncyBub3cgaW52YWxpZC5cbi8vIFJlc2V0IHRoZSBjaGlsZCBmaWJlcnMgdG8gdGhlaXIgb3JpZ2luYWwgc3RhdGUuXG53b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3M9Tm9GbGFncztyZXNldENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTsvLyBTZXQgdXAgdGhlIFN1c3BlbnNlIENvbnRleHQgdG8gZm9yY2Ugc3VzcGVuc2UgYW5kIGltbWVkaWF0ZWx5XG4vLyByZXJlbmRlciB0aGUgY2hpbGRyZW4uXG5wdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LEZvcmNlU3VzcGVuc2VGYWxsYmFjaykpOy8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGluIHRoaXMgY2FzZS5cbnJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDt9cm93PXJvdy5zaWJsaW5nO319aWYocmVuZGVyU3RhdGUudGFpbCE9PW51bGwmJm5vdygpPmdldFJlbmRlclRhcmdldFRpbWUoKSl7Ly8gV2UgaGF2ZSBhbHJlYWR5IHBhc3NlZCBvdXIgQ1BVIGRlYWRsaW5lIGJ1dCB3ZSBzdGlsbCBoYXZlIHJvd3Ncbi8vIGxlZnQgaW4gdGhlIHRhaWwuIFdlJ2xsIGp1c3QgZ2l2ZSB1cCBmdXJ0aGVyIGF0dGVtcHRzIHRvIHJlbmRlclxuLy8gdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PURpZENhcHR1cmU7ZGlkU3VzcGVuZEFscmVhZHk9dHJ1ZTtjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsZmFsc2UpOy8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzXG4vLyB0byBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXNcbi8vIG9mIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlcixcbi8vIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhc1xuLy8gY29tbWl0dGVkLiBJZiBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmVcbi8vIHBhaW50ZWQuIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy5cbi8vIFdlIGNhbiB1c2UgYW55IFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nXG4vLyBzaW5jZSB3ZSdyZSBsZWF2aW5nIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG53b3JrSW5Qcm9ncmVzcy5sYW5lcz1Tb21lUmV0cnlMYW5lO319ZWxzZXtjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsZmFsc2UpO30vLyBOZXh0IHdlJ3JlIGdvaW5nIHRvIHJlbmRlciB0aGUgdGFpbC5cbn1lbHNley8vIEFwcGVuZCB0aGUgcmVuZGVyZWQgcm93IHRvIHRoZSBjaGlsZCBsaXN0LlxuaWYoIWRpZFN1c3BlbmRBbHJlYWR5KXt2YXIgX3N1c3BlbmRlZD1maW5kRmlyc3RTdXNwZW5kZWQocmVuZGVyZWRUYWlsKTtpZihfc3VzcGVuZGVkIT09bnVsbCl7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PURpZENhcHR1cmU7ZGlkU3VzcGVuZEFscmVhZHk9dHJ1ZTsvLyBFbnN1cmUgd2UgdHJhbnNmZXIgdGhlIHVwZGF0ZSBxdWV1ZSB0byB0aGUgcGFyZW50IHNvIHRoYXQgaXQgZG9lc24ndFxuLy8gZ2V0IGxvc3QgaWYgdGhpcyByb3cgZW5kcyB1cCBkcm9wcGVkIGR1cmluZyBhIHNlY29uZCBwYXNzLlxudmFyIF9uZXdUaGVuYWJsZXM9X3N1c3BlbmRlZC51cGRhdGVRdWV1ZTtpZihfbmV3VGhlbmFibGVzIT09bnVsbCl7d29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU9X25ld1RoZW5hYmxlczt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VXBkYXRlO31jdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsdHJ1ZSk7Ly8gVGhpcyBtaWdodCBoYXZlIGJlZW4gbW9kaWZpZWQuXG5pZihyZW5kZXJTdGF0ZS50YWlsPT09bnVsbCYmcmVuZGVyU3RhdGUudGFpbE1vZGU9PT0naGlkZGVuJyYmIXJlbmRlcmVkVGFpbC5hbHRlcm5hdGUmJiFnZXRJc0h5ZHJhdGluZygpLy8gV2UgZG9uJ3QgY3V0IGl0IGlmIHdlJ3JlIGh5ZHJhdGluZy5cbil7Ly8gV2UncmUgZG9uZS5cbmJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO319ZWxzZSBpZigvLyBUaGUgdGltZSBpdCB0b29rIHRvIHJlbmRlciBsYXN0IHJvdyBpcyBncmVhdGVyIHRoYW4gdGhlIHJlbWFpbmluZ1xuLy8gdGltZSB3ZSBoYXZlIHRvIHJlbmRlci4gU28gcmVuZGVyaW5nIG9uZSBtb3JlIHJvdyB3b3VsZCBsaWtlbHlcbi8vIGV4Y2VlZCBpdC5cbm5vdygpKjItcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lPmdldFJlbmRlclRhcmdldFRpbWUoKSYmcmVuZGVyTGFuZXMhPT1PZmZzY3JlZW5MYW5lKXsvLyBXZSBoYXZlIG5vdyBwYXNzZWQgb3VyIENQVSBkZWFkbGluZSBhbmQgd2UnbGwganVzdCBnaXZlIHVwIGZ1cnRoZXJcbi8vIGF0dGVtcHRzIHRvIHJlbmRlciB0aGUgbWFpbiBjb250ZW50IGFuZCBvbmx5IHJlbmRlciBmYWxsYmFja3MuXG4vLyBUaGUgYXNzdW1wdGlvbiBpcyB0aGF0IHRoaXMgaXMgdXN1YWxseSBmYXN0ZXIuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9RGlkQ2FwdHVyZTtkaWRTdXNwZW5kQWxyZWFkeT10cnVlO2N1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSxmYWxzZSk7Ly8gU2luY2Ugbm90aGluZyBhY3R1YWxseSBzdXNwZW5kZWQsIHRoZXJlIHdpbGwgbm90aGluZyB0byBwaW5nIHRoaXNcbi8vIHRvIGdldCBpdCBzdGFydGVkIGJhY2sgdXAgdG8gYXR0ZW1wdCB0aGUgbmV4dCBpdGVtLiBXaGlsZSBpbiB0ZXJtc1xuLy8gb2YgcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLFxuLy8gaXQncyBub3QgcGFydCBvZiB0aGUgc2FtZSB0cmFuc2l0aW9uIG9uY2UgdGhlIHRyYW5zaXRpb24gaGFzXG4vLyBjb21taXR0ZWQuIElmIGl0J3Mgc3luYywgd2Ugc3RpbGwgd2FudCB0byB5aWVsZCBzbyB0aGF0IGl0IGNhbiBiZVxuLy8gcGFpbnRlZC4gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLlxuLy8gV2UgY2FuIHVzZSBhbnkgUmV0cnlMYW5lIGV2ZW4gaWYgaXQncyB0aGUgb25lIGN1cnJlbnRseSByZW5kZXJpbmdcbi8vIHNpbmNlIHdlJ3JlIGxlYXZpbmcgaXQgYmVoaW5kIG9uIHRoaXMgbm9kZS5cbndvcmtJblByb2dyZXNzLmxhbmVzPVNvbWVSZXRyeUxhbmU7fX1pZihyZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcyl7Ly8gVGhlIGVmZmVjdCBsaXN0IG9mIHRoZSBiYWNrd2FyZHMgdGFpbCB3aWxsIGhhdmUgYmVlbiBhZGRlZFxuLy8gdG8gdGhlIGVuZC4gVGhpcyBicmVha3MgdGhlIGd1YXJhbnRlZSB0aGF0IGxpZmUtY3ljbGVzIGZpcmUgaW5cbi8vIHNpYmxpbmcgb3JkZXIgYnV0IHRoYXQgaXNuJ3QgYSBzdHJvbmcgZ3VhcmFudGVlIHByb21pc2VkIGJ5IFJlYWN0LlxuLy8gRXNwZWNpYWxseSBzaW5jZSB0aGVzZSBtaWdodCBhbHNvIGp1c3QgcG9wIGluIGR1cmluZyBmdXR1cmUgY29tbWl0cy5cbi8vIEFwcGVuZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0LlxucmVuZGVyZWRUYWlsLnNpYmxpbmc9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7d29ya0luUHJvZ3Jlc3MuY2hpbGQ9cmVuZGVyZWRUYWlsO31lbHNle3ZhciBwcmV2aW91c1NpYmxpbmc9cmVuZGVyU3RhdGUubGFzdDtpZihwcmV2aW91c1NpYmxpbmchPT1udWxsKXtwcmV2aW91c1NpYmxpbmcuc2libGluZz1yZW5kZXJlZFRhaWw7fWVsc2V7d29ya0luUHJvZ3Jlc3MuY2hpbGQ9cmVuZGVyZWRUYWlsO31yZW5kZXJTdGF0ZS5sYXN0PXJlbmRlcmVkVGFpbDt9fWlmKHJlbmRlclN0YXRlLnRhaWwhPT1udWxsKXsvLyBXZSBzdGlsbCBoYXZlIHRhaWwgcm93cyB0byByZW5kZXIuXG4vLyBQb3AgYSByb3cuXG52YXIgbmV4dD1yZW5kZXJTdGF0ZS50YWlsO3JlbmRlclN0YXRlLnJlbmRlcmluZz1uZXh0O3JlbmRlclN0YXRlLnRhaWw9bmV4dC5zaWJsaW5nO3JlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZT1ub3coKTtuZXh0LnNpYmxpbmc9bnVsbDsvLyBSZXN0b3JlIHRoZSBjb250ZXh0LlxuLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IGp1c3QgYXZvaWQgcG9wcGluZyBpdCBpbnN0ZWFkIGFuZCBvbmx5XG4vLyBzZXR0aW5nIGl0IHRoZSBmaXJzdCB0aW1lIHdlIGdvIGZyb20gbm90IHN1c3BlbmRlZCB0byBzdXNwZW5kZWQuXG52YXIgc3VzcGVuc2VDb250ZXh0PXN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtpZihkaWRTdXNwZW5kQWxyZWFkeSl7c3VzcGVuc2VDb250ZXh0PXNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7fWVsc2V7c3VzcGVuc2VDb250ZXh0PXNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7fXB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3Msc3VzcGVuc2VDb250ZXh0KTsvLyBEbyBhIHBhc3Mgb3ZlciB0aGUgbmV4dCByb3cuXG4vLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBpbiB0aGlzIGNhc2UuXG5yZXR1cm4gbmV4dDt9YnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7fWNhc2UgU2NvcGVDb21wb25lbnQ6e2JyZWFrO31jYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDp7cG9wUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MpO3ZhciBfbmV4dFN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7dmFyIG5leHRJc0hpZGRlbj1fbmV4dFN0YXRlIT09bnVsbDtpZihjdXJyZW50IT09bnVsbCl7dmFyIF9wcmV2U3RhdGU9Y3VycmVudC5tZW1vaXplZFN0YXRlO3ZhciBwcmV2SXNIaWRkZW49X3ByZXZTdGF0ZSE9PW51bGw7aWYocHJldklzSGlkZGVuIT09bmV4dElzSGlkZGVuJiYvLyBMZWdhY3lIaWRkZW4gZG9lc24ndCBkbyBhbnkgaGlkaW5nIOKAlCBpdCBvbmx5IHByZS1yZW5kZXJzLlxuIWVuYWJsZUxlZ2FjeUhpZGRlbil7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVZpc2liaWxpdHk7fX1pZighbmV4dElzSGlkZGVufHwod29ya0luUHJvZ3Jlc3MubW9kZSZDb25jdXJyZW50TW9kZSk9PT1Ob01vZGUpe2J1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO31lbHNley8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGZvciBoaWRkZW4gY2hpbGRyZW4gdW5sZXNzIHdlJ3JlIHJlbmRlcmluZ1xuLy8gYXQgb2Zmc2NyZWVuIHByaW9yaXR5LlxuaWYoaW5jbHVkZXNTb21lTGFuZShzdWJ0cmVlUmVuZGVyTGFuZXMsT2Zmc2NyZWVuTGFuZSkpe2J1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3svLyBDaGVjayBpZiB0aGVyZSB3YXMgYW4gaW5zZXJ0aW9uIG9yIHVwZGF0ZSBpbiB0aGUgaGlkZGVuIHN1YnRyZWUuXG4vLyBJZiBzbywgd2UgbmVlZCB0byBoaWRlIHRob3NlIG5vZGVzIGluIHRoZSBjb21taXQgcGhhc2UsIHNvXG4vLyBzY2hlZHVsZSBhIHZpc2liaWxpdHkgZWZmZWN0LlxuaWYod29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzJihQbGFjZW1lbnR8VXBkYXRlKSl7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVZpc2liaWxpdHk7fX19fXJldHVybiBudWxsO31jYXNlIENhY2hlQ29tcG9uZW50OntyZXR1cm4gbnVsbDt9Y2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OntyZXR1cm4gbnVsbDt9fXRocm93IG5ldyBFcnJvcihcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIrd29ya0luUHJvZ3Jlc3MudGFnK1wiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFwiKydSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fWZ1bmN0aW9uIHVud2luZFdvcmsoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7Ly8gTm90ZTogVGhpcyBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgY2hlY2sgaWYgd2UncmUgaHlkcmF0aW5nIGJlY2F1c2UgY29tcGFyaW5nXG4vLyB0byB0aGUgY3VycmVudCB0cmVlIHByb3ZpZGVyIGZpYmVyIGlzIGp1c3QgYXMgZmFzdCBhbmQgbGVzcyBlcnJvci1wcm9uZS5cbi8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbi8vIGZvciBoeWRyYXRpb24uXG5wb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7c3dpdGNoKHdvcmtJblByb2dyZXNzLnRhZyl7Y2FzZSBDbGFzc0NvbXBvbmVudDp7dmFyIENvbXBvbmVudD13b3JrSW5Qcm9ncmVzcy50eXBlO2lmKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpe3BvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO312YXIgZmxhZ3M9d29ya0luUHJvZ3Jlc3MuZmxhZ3M7aWYoZmxhZ3MmU2hvdWxkQ2FwdHVyZSl7d29ya0luUHJvZ3Jlc3MuZmxhZ3M9ZmxhZ3MmflNob3VsZENhcHR1cmV8RGlkQ2FwdHVyZTtpZigod29ya0luUHJvZ3Jlc3MubW9kZSZQcm9maWxlTW9kZSkhPT1Ob01vZGUpe3RyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO31yZXR1cm4gd29ya0luUHJvZ3Jlc3M7fXJldHVybiBudWxsO31jYXNlIEhvc3RSb290Ont2YXIgcm9vdD13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7cG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7cG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtyZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMoKTt2YXIgX2ZsYWdzPXdvcmtJblByb2dyZXNzLmZsYWdzO2lmKChfZmxhZ3MmU2hvdWxkQ2FwdHVyZSkhPT1Ob0ZsYWdzJiYoX2ZsYWdzJkRpZENhcHR1cmUpPT09Tm9GbGFncyl7Ly8gVGhlcmUgd2FzIGFuIGVycm9yIGR1cmluZyByZW5kZXIgdGhhdCB3YXNuJ3QgY2FwdHVyZWQgYnkgYSBzdXNwZW5zZVxuLy8gYm91bmRhcnkuIERvIGEgc2Vjb25kIHBhc3Mgb24gdGhlIHJvb3QgdG8gdW5tb3VudCB0aGUgY2hpbGRyZW4uXG53b3JrSW5Qcm9ncmVzcy5mbGFncz1fZmxhZ3MmflNob3VsZENhcHR1cmV8RGlkQ2FwdHVyZTtyZXR1cm4gd29ya0luUHJvZ3Jlc3M7fS8vIFdlIHVud291bmQgdG8gdGhlIHJvb3Qgd2l0aG91dCBjb21wbGV0aW5nIGl0LiBFeGl0LlxucmV0dXJuIG51bGw7fWNhc2UgSG9zdENvbXBvbmVudDp7Ly8gVE9ETzogcG9wSHlkcmF0aW9uU3RhdGVcbnBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDt9Y2FzZSBTdXNwZW5zZUNvbXBvbmVudDp7cG9wU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzKTt2YXIgc3VzcGVuc2VTdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO2lmKHN1c3BlbnNlU3RhdGUhPT1udWxsJiZzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQhPT1udWxsKXtpZih3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ1RocmV3IGluIG5ld2x5IG1vdW50ZWQgZGVoeWRyYXRlZCBjb21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluICcrJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9cmVzZXRIeWRyYXRpb25TdGF0ZSgpO312YXIgX2ZsYWdzMj13b3JrSW5Qcm9ncmVzcy5mbGFncztpZihfZmxhZ3MyJlNob3VsZENhcHR1cmUpe3dvcmtJblByb2dyZXNzLmZsYWdzPV9mbGFnczImflNob3VsZENhcHR1cmV8RGlkQ2FwdHVyZTsvLyBDYXB0dXJlZCBhIHN1c3BlbnNlIGVmZmVjdC4gUmUtcmVuZGVyIHRoZSBib3VuZGFyeS5cbmlmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJlByb2ZpbGVNb2RlKSE9PU5vTW9kZSl7dHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7fXJldHVybiB3b3JrSW5Qcm9ncmVzczt9cmV0dXJuIG51bGw7fWNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50Ontwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpOy8vIFN1c3BlbnNlTGlzdCBkb2Vzbid0IGFjdHVhbGx5IGNhdGNoIGFueXRoaW5nLiBJdCBzaG91bGQndmUgYmVlblxuLy8gY2F1Z2h0IGJ5IGEgbmVzdGVkIGJvdW5kYXJ5LiBJZiBub3QsIGl0IHNob3VsZCBidWJibGUgdGhyb3VnaC5cbnJldHVybiBudWxsO31jYXNlIEhvc3RQb3J0YWw6cG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7Y2FzZSBDb250ZXh0UHJvdmlkZXI6dmFyIGNvbnRleHQ9d29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dDtwb3BQcm92aWRlcihjb250ZXh0LHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDtjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7Y2FzZSBDYWNoZUNvbXBvbmVudDpyZXR1cm4gbnVsbDtkZWZhdWx0OnJldHVybiBudWxsO319ZnVuY3Rpb24gdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsaW50ZXJydXB0ZWRXb3JrLHJlbmRlckxhbmVzKXsvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbi8vIHRvIHRoZSBjdXJyZW50IHRyZWUgcHJvdmlkZXIgZmliZXIgaXMganVzdCBhcyBmYXN0IGFuZCBsZXNzIGVycm9yLXByb25lLlxuLy8gSWRlYWxseSB3ZSB3b3VsZCBoYXZlIGEgc3BlY2lhbCB2ZXJzaW9uIG9mIHRoZSB3b3JrIGxvb3Agb25seVxuLy8gZm9yIGh5ZHJhdGlvbi5cbnBvcFRyZWVDb250ZXh0KGludGVycnVwdGVkV29yayk7c3dpdGNoKGludGVycnVwdGVkV29yay50YWcpe2Nhc2UgQ2xhc3NDb21wb25lbnQ6e3ZhciBjaGlsZENvbnRleHRUeXBlcz1pbnRlcnJ1cHRlZFdvcmsudHlwZS5jaGlsZENvbnRleHRUeXBlcztpZihjaGlsZENvbnRleHRUeXBlcyE9PW51bGwmJmNoaWxkQ29udGV4dFR5cGVzIT09dW5kZWZpbmVkKXtwb3BDb250ZXh0KGludGVycnVwdGVkV29yayk7fWJyZWFrO31jYXNlIEhvc3RSb290Ont2YXIgcm9vdD1pbnRlcnJ1cHRlZFdvcmsuc3RhdGVOb2RlO3BvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoaW50ZXJydXB0ZWRXb3JrKTtyZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMoKTticmVhazt9Y2FzZSBIb3N0Q29tcG9uZW50Ontwb3BIb3N0Q29udGV4dChpbnRlcnJ1cHRlZFdvcmspO2JyZWFrO31jYXNlIEhvc3RQb3J0YWw6cG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO2JyZWFrO2Nhc2UgU3VzcGVuc2VDb21wb25lbnQ6cG9wU3VzcGVuc2VDb250ZXh0KGludGVycnVwdGVkV29yayk7YnJlYWs7Y2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6cG9wU3VzcGVuc2VDb250ZXh0KGludGVycnVwdGVkV29yayk7YnJlYWs7Y2FzZSBDb250ZXh0UHJvdmlkZXI6dmFyIGNvbnRleHQ9aW50ZXJydXB0ZWRXb3JrLnR5cGUuX2NvbnRleHQ7cG9wUHJvdmlkZXIoY29udGV4dCxpbnRlcnJ1cHRlZFdvcmspO2JyZWFrO2Nhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OmNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OnBvcFJlbmRlckxhbmVzKGludGVycnVwdGVkV29yayk7YnJlYWs7fX12YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGU9bnVsbDt7ZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGU9bmV3IFNldCgpO30vLyBVc2VkIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIHRvIHRyYWNrIHRoZSBzdGF0ZSBvZiB0aGUgT2Zmc2NyZWVuIGNvbXBvbmVudCBzdGFjay5cbi8vIEFsbG93cyB1cyB0byBhdm9pZCB0cmF2ZXJzaW5nIHRoZSByZXR1cm4gcGF0aCB0byBmaW5kIHRoZSBuZWFyZXN0IE9mZnNjcmVlbiBhbmNlc3Rvci5cbi8vIE9ubHkgdXNlZCB3aGVuIGVuYWJsZVN1c3BlbnNlTGF5b3V0RWZmZWN0U2VtYW50aWNzIGlzIGVuYWJsZWQuXG52YXIgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuPWZhbHNlO3ZhciBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuPWZhbHNlO3ZhciBQb3NzaWJseVdlYWtTZXQ9dHlwZW9mIFdlYWtTZXQ9PT0nZnVuY3Rpb24nP1dlYWtTZXQ6U2V0O3ZhciBuZXh0RWZmZWN0PW51bGw7Ly8gVXNlZCBmb3IgUHJvZmlsaW5nIGJ1aWxkcyB0byB0cmFjayB1cGRhdGVycy5cbnZhciBpblByb2dyZXNzTGFuZXM9bnVsbDt2YXIgaW5Qcm9ncmVzc1Jvb3Q9bnVsbDtmdW5jdGlvbiByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3Ipey8vIFdyYXBwaW5nIGVhY2ggc21hbGwgcGFydCBvZiB0aGUgY29tbWl0IHBoYXNlIGludG8gYSBndWFyZGVkXG4vLyBjYWxsYmFjayBpcyBhIGJpdCB0b28gc2xvdyAoaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjE2NjYpLlxuLy8gQnV0IHdlIHJlbHkgb24gaXQgdG8gc3VyZmFjZSBlcnJvcnMgdG8gREVWIHRvb2xzIGxpa2Ugb3ZlcmxheXNcbi8vIChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIxNzEyKS5cbi8vIEFzIGEgY29tcHJvbWlzZSwgcmV0aHJvdyBvbmx5IGNhdWdodCBlcnJvcnMgaW4gYSBndWFyZC5cbntpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCxmdW5jdGlvbigpe3Rocm93IGVycm9yO30pO2NsZWFyQ2F1Z2h0RXJyb3IoKTt9fXZhciBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXI9ZnVuY3Rpb24oY3VycmVudCxpbnN0YW5jZSl7aW5zdGFuY2UucHJvcHM9Y3VycmVudC5tZW1vaXplZFByb3BzO2luc3RhbmNlLnN0YXRlPWN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtpZihjdXJyZW50Lm1vZGUmUHJvZmlsZU1vZGUpe3RyeXtzdGFydExheW91dEVmZmVjdFRpbWVyKCk7aW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTt9ZmluYWxseXtyZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihjdXJyZW50KTt9fWVsc2V7aW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTt9fTsvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCBtb3VudGluZy5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21taXRIb29rTGF5b3V0RWZmZWN0TGlzdE1vdW50KGN1cnJlbnQsbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcil7dHJ5e2NvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoTGF5b3V0LGN1cnJlbnQpO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGVycm9yKTt9fS8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG5mdW5jdGlvbiBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGluc3RhbmNlKXt0cnl7Y2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyKGN1cnJlbnQsaW5zdGFuY2UpO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGVycm9yKTt9fS8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IG1vdW50aW5nLlxuZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudERpZE1vdW50KGN1cnJlbnQsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixpbnN0YW5jZSl7dHJ5e2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZXJyb3IpO319Ly8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgbW91bnRpbmcuXG5mdW5jdGlvbiBzYWZlbHlBdHRhY2hSZWYoY3VycmVudCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yKXt0cnl7Y29tbWl0QXR0YWNoUmVmKGN1cnJlbnQpO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGVycm9yKTt9fWZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50LG5lYXJlc3RNb3VudGVkQW5jZXN0b3Ipe3ZhciByZWY9Y3VycmVudC5yZWY7aWYocmVmIT09bnVsbCl7aWYodHlwZW9mIHJlZj09PSdmdW5jdGlvbicpe3ZhciByZXRWYWw7dHJ5e2lmKGVuYWJsZVByb2ZpbGVyVGltZXImJmVuYWJsZVByb2ZpbGVyQ29tbWl0SG9va3MmJmN1cnJlbnQubW9kZSZQcm9maWxlTW9kZSl7dHJ5e3N0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtyZXRWYWw9cmVmKG51bGwpO31maW5hbGx5e3JlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO319ZWxzZXtyZXRWYWw9cmVmKG51bGwpO319Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixlcnJvcik7fXtpZih0eXBlb2YgcmV0VmFsPT09J2Z1bmN0aW9uJyl7ZXJyb3IoJ1VuZXhwZWN0ZWQgcmV0dXJuIHZhbHVlIGZyb20gYSBjYWxsYmFjayByZWYgaW4gJXMuICcrJ0EgY2FsbGJhY2sgcmVmIHNob3VsZCBub3QgcmV0dXJuIGEgZnVuY3Rpb24uJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnQpKTt9fX1lbHNle3JlZi5jdXJyZW50PW51bGw7fX19ZnVuY3Rpb24gc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGRlc3Ryb3kpe3RyeXtkZXN0cm95KCk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZXJyb3IpO319dmFyIGZvY3VzZWRJbnN0YW5jZUhhbmRsZT1udWxsO3ZhciBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI9ZmFsc2U7ZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsZmlyc3RDaGlsZCl7Zm9jdXNlZEluc3RhbmNlSGFuZGxlPXByZXBhcmVGb3JDb21taXQocm9vdC5jb250YWluZXJJbmZvKTtuZXh0RWZmZWN0PWZpcnN0Q2hpbGQ7Y29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2JlZ2luKCk7Ly8gV2Ugbm8gbG9uZ2VyIG5lZWQgdG8gdHJhY2sgdGhlIGFjdGl2ZSBpbnN0YW5jZSBmaWJlclxudmFyIHNob3VsZEZpcmU9c2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyO3Nob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1cj1mYWxzZTtmb2N1c2VkSW5zdGFuY2VIYW5kbGU9bnVsbDtyZXR1cm4gc2hvdWxkRmlyZTt9ZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2JlZ2luKCl7d2hpbGUobmV4dEVmZmVjdCE9PW51bGwpe3ZhciBmaWJlcj1uZXh0RWZmZWN0Oy8vIFRoaXMgcGhhc2UgaXMgb25seSB1c2VkIGZvciBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXIuXG52YXIgY2hpbGQ9ZmliZXIuY2hpbGQ7aWYoKGZpYmVyLnN1YnRyZWVGbGFncyZCZWZvcmVNdXRhdGlvbk1hc2spIT09Tm9GbGFncyYmY2hpbGQhPT1udWxsKXtjaGlsZC5yZXR1cm49ZmliZXI7bmV4dEVmZmVjdD1jaGlsZDt9ZWxzZXtjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfY29tcGxldGUoKTt9fX1mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfY29tcGxldGUoKXt3aGlsZShuZXh0RWZmZWN0IT09bnVsbCl7dmFyIGZpYmVyPW5leHRFZmZlY3Q7c2V0Q3VycmVudEZpYmVyKGZpYmVyKTt0cnl7Y29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaWJlcik7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlcixmaWJlci5yZXR1cm4sZXJyb3IpO31yZXNldEN1cnJlbnRGaWJlcigpO3ZhciBzaWJsaW5nPWZpYmVyLnNpYmxpbmc7aWYoc2libGluZyE9PW51bGwpe3NpYmxpbmcucmV0dXJuPWZpYmVyLnJldHVybjtuZXh0RWZmZWN0PXNpYmxpbmc7cmV0dXJuO31uZXh0RWZmZWN0PWZpYmVyLnJldHVybjt9fWZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrKXt2YXIgY3VycmVudD1maW5pc2hlZFdvcmsuYWx0ZXJuYXRlO3ZhciBmbGFncz1maW5pc2hlZFdvcmsuZmxhZ3M7aWYoKGZsYWdzJlNuYXBzaG90KSE9PU5vRmxhZ3Mpe3NldEN1cnJlbnRGaWJlcihmaW5pc2hlZFdvcmspO3N3aXRjaChmaW5pc2hlZFdvcmsudGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgRm9yd2FyZFJlZjpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e2JyZWFrO31jYXNlIENsYXNzQ29tcG9uZW50OntpZihjdXJyZW50IT09bnVsbCl7dmFyIHByZXZQcm9wcz1jdXJyZW50Lm1lbW9pemVkUHJvcHM7dmFyIHByZXZTdGF0ZT1jdXJyZW50Lm1lbW9pemVkU3RhdGU7dmFyIGluc3RhbmNlPWZpbmlzaGVkV29yay5zdGF0ZU5vZGU7Ly8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4vLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG57aWYoZmluaXNoZWRXb3JrLnR5cGU9PT1maW5pc2hlZFdvcmsuZWxlbWVudFR5cGUmJiFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKXtpZihpbnN0YW5jZS5wcm9wcyE9PWZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKXtlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcrJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnKydUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcrJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJysnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yayl8fCdpbnN0YW5jZScpO31pZihpbnN0YW5jZS5zdGF0ZSE9PWZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKXtlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcrJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnKydUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcrJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJysnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yayl8fCdpbnN0YW5jZScpO319fXZhciBzbmFwc2hvdD1pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGU9PT1maW5pc2hlZFdvcmsudHlwZT9wcmV2UHJvcHM6cmVzb2x2ZURlZmF1bHRQcm9wcyhmaW5pc2hlZFdvcmsudHlwZSxwcmV2UHJvcHMpLHByZXZTdGF0ZSk7e3ZhciBkaWRXYXJuU2V0PWRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlO2lmKHNuYXBzaG90PT09dW5kZWZpbmVkJiYhZGlkV2FyblNldC5oYXMoZmluaXNoZWRXb3JrLnR5cGUpKXtkaWRXYXJuU2V0LmFkZChmaW5pc2hlZFdvcmsudHlwZSk7ZXJyb3IoJyVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCk6IEEgc25hcHNob3QgdmFsdWUgKG9yIG51bGwpICcrJ211c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7fX1pbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZT1zbmFwc2hvdDt9YnJlYWs7fWNhc2UgSG9zdFJvb3Q6e3t2YXIgcm9vdD1maW5pc2hlZFdvcmsuc3RhdGVOb2RlO2NsZWFyQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7fWJyZWFrO31jYXNlIEhvc3RDb21wb25lbnQ6Y2FzZSBIb3N0VGV4dDpjYXNlIEhvc3RQb3J0YWw6Y2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6Ly8gTm90aGluZyB0byBkbyBmb3IgdGhlc2UgY29tcG9uZW50IHR5cGVzXG5icmVhaztkZWZhdWx0Ont0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcrJ2xpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO319cmVzZXRDdXJyZW50RmliZXIoKTt9fWZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChmbGFncyxmaW5pc2hlZFdvcmssbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcil7dmFyIHVwZGF0ZVF1ZXVlPWZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTt2YXIgbGFzdEVmZmVjdD11cGRhdGVRdWV1ZSE9PW51bGw/dXBkYXRlUXVldWUubGFzdEVmZmVjdDpudWxsO2lmKGxhc3RFZmZlY3QhPT1udWxsKXt2YXIgZmlyc3RFZmZlY3Q9bGFzdEVmZmVjdC5uZXh0O3ZhciBlZmZlY3Q9Zmlyc3RFZmZlY3Q7ZG97aWYoKGVmZmVjdC50YWcmZmxhZ3MpPT09ZmxhZ3Mpey8vIFVubW91bnRcbnZhciBkZXN0cm95PWVmZmVjdC5kZXN0cm95O2VmZmVjdC5kZXN0cm95PXVuZGVmaW5lZDtpZihkZXN0cm95IT09dW5kZWZpbmVkKXt7aWYoKGZsYWdzJlBhc3NpdmUkMSkhPT1Ob0ZsYWdzJDEpe21hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTt9ZWxzZSBpZigoZmxhZ3MmTGF5b3V0KSE9PU5vRmxhZ3MkMSl7bWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7fX17aWYoKGZsYWdzJkluc2VydGlvbikhPT1Ob0ZsYWdzJDEpe3NldElzUnVubmluZ0luc2VydGlvbkVmZmVjdCh0cnVlKTt9fXNhZmVseUNhbGxEZXN0cm95KGZpbmlzaGVkV29yayxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGRlc3Ryb3kpO3tpZigoZmxhZ3MmSW5zZXJ0aW9uKSE9PU5vRmxhZ3MkMSl7c2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KGZhbHNlKTt9fXtpZigoZmxhZ3MmUGFzc2l2ZSQxKSE9PU5vRmxhZ3MkMSl7bWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCgpO31lbHNlIGlmKChmbGFncyZMYXlvdXQpIT09Tm9GbGFncyQxKXttYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTt9fX19ZWZmZWN0PWVmZmVjdC5uZXh0O313aGlsZShlZmZlY3QhPT1maXJzdEVmZmVjdCk7fX1mdW5jdGlvbiBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGZsYWdzLGZpbmlzaGVkV29yayl7dmFyIHVwZGF0ZVF1ZXVlPWZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTt2YXIgbGFzdEVmZmVjdD11cGRhdGVRdWV1ZSE9PW51bGw/dXBkYXRlUXVldWUubGFzdEVmZmVjdDpudWxsO2lmKGxhc3RFZmZlY3QhPT1udWxsKXt2YXIgZmlyc3RFZmZlY3Q9bGFzdEVmZmVjdC5uZXh0O3ZhciBlZmZlY3Q9Zmlyc3RFZmZlY3Q7ZG97aWYoKGVmZmVjdC50YWcmZmxhZ3MpPT09ZmxhZ3Mpe3tpZigoZmxhZ3MmUGFzc2l2ZSQxKSE9PU5vRmxhZ3MkMSl7bWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTt9ZWxzZSBpZigoZmxhZ3MmTGF5b3V0KSE9PU5vRmxhZ3MkMSl7bWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZChmaW5pc2hlZFdvcmspO319Ly8gTW91bnRcbnZhciBjcmVhdGU9ZWZmZWN0LmNyZWF0ZTt7aWYoKGZsYWdzJkluc2VydGlvbikhPT1Ob0ZsYWdzJDEpe3NldElzUnVubmluZ0luc2VydGlvbkVmZmVjdCh0cnVlKTt9fWVmZmVjdC5kZXN0cm95PWNyZWF0ZSgpO3tpZigoZmxhZ3MmSW5zZXJ0aW9uKSE9PU5vRmxhZ3MkMSl7c2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KGZhbHNlKTt9fXtpZigoZmxhZ3MmUGFzc2l2ZSQxKSE9PU5vRmxhZ3MkMSl7bWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKTt9ZWxzZSBpZigoZmxhZ3MmTGF5b3V0KSE9PU5vRmxhZ3MkMSl7bWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpO319e3ZhciBkZXN0cm95PWVmZmVjdC5kZXN0cm95O2lmKGRlc3Ryb3khPT11bmRlZmluZWQmJnR5cGVvZiBkZXN0cm95IT09J2Z1bmN0aW9uJyl7dmFyIGhvb2tOYW1lPXZvaWQgMDtpZigoZWZmZWN0LnRhZyZMYXlvdXQpIT09Tm9GbGFncyl7aG9va05hbWU9J3VzZUxheW91dEVmZmVjdCc7fWVsc2UgaWYoKGVmZmVjdC50YWcmSW5zZXJ0aW9uKSE9PU5vRmxhZ3Mpe2hvb2tOYW1lPSd1c2VJbnNlcnRpb25FZmZlY3QnO31lbHNle2hvb2tOYW1lPSd1c2VFZmZlY3QnO312YXIgYWRkZW5kdW09dm9pZCAwO2lmKGRlc3Ryb3k9PT1udWxsKXthZGRlbmR1bT0nIFlvdSByZXR1cm5lZCBudWxsLiBJZiB5b3VyIGVmZmVjdCBkb2VzIG5vdCByZXF1aXJlIGNsZWFuICcrJ3VwLCByZXR1cm4gdW5kZWZpbmVkIChvciBub3RoaW5nKS4nO31lbHNlIGlmKHR5cGVvZiBkZXN0cm95LnRoZW49PT0nZnVuY3Rpb24nKXthZGRlbmR1bT0nXFxuXFxuSXQgbG9va3MgbGlrZSB5b3Ugd3JvdGUgJytob29rTmFtZSsnKGFzeW5jICgpID0+IC4uLikgb3IgcmV0dXJuZWQgYSBQcm9taXNlLiAnKydJbnN0ZWFkLCB3cml0ZSB0aGUgYXN5bmMgZnVuY3Rpb24gaW5zaWRlIHlvdXIgZWZmZWN0ICcrJ2FuZCBjYWxsIGl0IGltbWVkaWF0ZWx5OlxcblxcbicraG9va05hbWUrJygoKSA9PiB7XFxuJysnICBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XFxuJysnICAgIC8vIFlvdSBjYW4gYXdhaXQgaGVyZVxcbicrJyAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IE15QVBJLmdldERhdGEoc29tZUlkKTtcXG4nKycgICAgLy8gLi4uXFxuJysnICB9XFxuJysnICBmZXRjaERhdGEoKTtcXG4nK1wifSwgW3NvbWVJZF0pOyAvLyBPciBbXSBpZiBlZmZlY3QgZG9lc24ndCBuZWVkIHByb3BzIG9yIHN0YXRlXFxuXFxuXCIrJ0xlYXJuIG1vcmUgYWJvdXQgZGF0YSBmZXRjaGluZyB3aXRoIEhvb2tzOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaG9va3MtZGF0YS1mZXRjaGluZyc7fWVsc2V7YWRkZW5kdW09JyBZb3UgcmV0dXJuZWQ6ICcrZGVzdHJveTt9ZXJyb3IoJyVzIG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBiZXNpZGVzIGEgZnVuY3Rpb24sICcrJ3doaWNoIGlzIHVzZWQgZm9yIGNsZWFuLXVwLiVzJyxob29rTmFtZSxhZGRlbmR1bSk7fX19ZWZmZWN0PWVmZmVjdC5uZXh0O313aGlsZShlZmZlY3QhPT1maXJzdEVmZmVjdCk7fX1mdW5jdGlvbiBjb21taXRQYXNzaXZlRWZmZWN0RHVyYXRpb25zKGZpbmlzaGVkUm9vdCxmaW5pc2hlZFdvcmspe3svLyBPbmx5IFByb2ZpbGVycyB3aXRoIHdvcmsgaW4gdGhlaXIgc3VidHJlZSB3aWxsIGhhdmUgYW4gVXBkYXRlIGVmZmVjdCBzY2hlZHVsZWQuXG5pZigoZmluaXNoZWRXb3JrLmZsYWdzJlVwZGF0ZSkhPT1Ob0ZsYWdzKXtzd2l0Y2goZmluaXNoZWRXb3JrLnRhZyl7Y2FzZSBQcm9maWxlcjp7dmFyIHBhc3NpdmVFZmZlY3REdXJhdGlvbj1maW5pc2hlZFdvcmsuc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbjt2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplPWZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLGlkPV9maW5pc2hlZFdvcmskbWVtb2l6ZS5pZCxvblBvc3RDb21taXQ9X2ZpbmlzaGVkV29yayRtZW1vaXplLm9uUG9zdENvbW1pdDsvLyBUaGlzIHZhbHVlIHdpbGwgc3RpbGwgcmVmbGVjdCB0aGUgcHJldmlvdXMgY29tbWl0IHBoYXNlLlxuLy8gSXQgZG9lcyBub3QgZ2V0IHJlc2V0IHVudGlsIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBjb21taXQgcGhhc2UuXG52YXIgY29tbWl0VGltZT1nZXRDb21taXRUaW1lKCk7dmFyIHBoYXNlPWZpbmlzaGVkV29yay5hbHRlcm5hdGU9PT1udWxsPydtb3VudCc6J3VwZGF0ZSc7e2lmKGlzQ3VycmVudFVwZGF0ZU5lc3RlZCgpKXtwaGFzZT0nbmVzdGVkLXVwZGF0ZSc7fX1pZih0eXBlb2Ygb25Qb3N0Q29tbWl0PT09J2Z1bmN0aW9uJyl7b25Qb3N0Q29tbWl0KGlkLHBoYXNlLHBhc3NpdmVFZmZlY3REdXJhdGlvbixjb21taXRUaW1lKTt9Ly8gQnViYmxlIHRpbWVzIHRvIHRoZSBuZXh0IG5lYXJlc3QgYW5jZXN0b3IgUHJvZmlsZXIuXG4vLyBBZnRlciB3ZSBwcm9jZXNzIHRoYXQgUHJvZmlsZXIsIHdlJ2xsIGJ1YmJsZSBmdXJ0aGVyIHVwLlxudmFyIHBhcmVudEZpYmVyPWZpbmlzaGVkV29yay5yZXR1cm47b3V0ZXI6d2hpbGUocGFyZW50RmliZXIhPT1udWxsKXtzd2l0Y2gocGFyZW50RmliZXIudGFnKXtjYXNlIEhvc3RSb290OnZhciByb290PXBhcmVudEZpYmVyLnN0YXRlTm9kZTtyb290LnBhc3NpdmVFZmZlY3REdXJhdGlvbis9cGFzc2l2ZUVmZmVjdER1cmF0aW9uO2JyZWFrIG91dGVyO2Nhc2UgUHJvZmlsZXI6dmFyIHBhcmVudFN0YXRlTm9kZT1wYXJlbnRGaWJlci5zdGF0ZU5vZGU7cGFyZW50U3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbis9cGFzc2l2ZUVmZmVjdER1cmF0aW9uO2JyZWFrIG91dGVyO31wYXJlbnRGaWJlcj1wYXJlbnRGaWJlci5yZXR1cm47fWJyZWFrO319fX19ZnVuY3Rpb24gY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihmaW5pc2hlZFJvb3QsY3VycmVudCxmaW5pc2hlZFdvcmssY29tbWl0dGVkTGFuZXMpe2lmKChmaW5pc2hlZFdvcmsuZmxhZ3MmTGF5b3V0TWFzaykhPT1Ob0ZsYWdzKXtzd2l0Y2goZmluaXNoZWRXb3JrLnRhZyl7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEZvcndhcmRSZWY6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OntpZighb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbil7Ly8gQXQgdGhpcyBwb2ludCBsYXlvdXQgZWZmZWN0cyBoYXZlIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQgKGR1cmluZyBtdXRhdGlvbiBwaGFzZSkuXG4vLyBUaGlzIGlzIGRvbmUgdG8gcHJldmVudCBzaWJsaW5nIGNvbXBvbmVudCBlZmZlY3RzIGZyb20gaW50ZXJmZXJpbmcgd2l0aCBlYWNoIG90aGVyLFxuLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgb3ZlcnJpZGUgYSByZWYgc2V0XG4vLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuaWYoZmluaXNoZWRXb3JrLm1vZGUmUHJvZmlsZU1vZGUpe3RyeXtzdGFydExheW91dEVmZmVjdFRpbWVyKCk7Y29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXR8SGFzRWZmZWN0LGZpbmlzaGVkV29yayk7fWZpbmFsbHl7cmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTt9fWVsc2V7Y29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXR8SGFzRWZmZWN0LGZpbmlzaGVkV29yayk7fX1icmVhazt9Y2FzZSBDbGFzc0NvbXBvbmVudDp7dmFyIGluc3RhbmNlPWZpbmlzaGVkV29yay5zdGF0ZU5vZGU7aWYoZmluaXNoZWRXb3JrLmZsYWdzJlVwZGF0ZSl7aWYoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pe2lmKGN1cnJlbnQ9PT1udWxsKXsvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4vLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbi8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cbntpZihmaW5pc2hlZFdvcmsudHlwZT09PWZpbmlzaGVkV29yay5lbGVtZW50VHlwZSYmIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpe2lmKGluc3RhbmNlLnByb3BzIT09ZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpe2Vycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJysnY29tcG9uZW50RGlkTW91bnQuICcrJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJysnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnKydQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKXx8J2luc3RhbmNlJyk7fWlmKGluc3RhbmNlLnN0YXRlIT09ZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpe2Vycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJysnY29tcG9uZW50RGlkTW91bnQuICcrJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJysnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnKydQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKXx8J2luc3RhbmNlJyk7fX19aWYoZmluaXNoZWRXb3JrLm1vZGUmUHJvZmlsZU1vZGUpe3RyeXtzdGFydExheW91dEVmZmVjdFRpbWVyKCk7aW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTt9ZmluYWxseXtyZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO319ZWxzZXtpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO319ZWxzZXt2YXIgcHJldlByb3BzPWZpbmlzaGVkV29yay5lbGVtZW50VHlwZT09PWZpbmlzaGVkV29yay50eXBlP2N1cnJlbnQubWVtb2l6ZWRQcm9wczpyZXNvbHZlRGVmYXVsdFByb3BzKGZpbmlzaGVkV29yay50eXBlLGN1cnJlbnQubWVtb2l6ZWRQcm9wcyk7dmFyIHByZXZTdGF0ZT1jdXJyZW50Lm1lbW9pemVkU3RhdGU7Ly8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4vLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG57aWYoZmluaXNoZWRXb3JrLnR5cGU9PT1maW5pc2hlZFdvcmsuZWxlbWVudFR5cGUmJiFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKXtpZihpbnN0YW5jZS5wcm9wcyE9PWZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKXtlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcrJ2NvbXBvbmVudERpZFVwZGF0ZS4gJysnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnKydhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcrJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspfHwnaW5zdGFuY2UnKTt9aWYoaW5zdGFuY2Uuc3RhdGUhPT1maW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSl7ZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnKydjb21wb25lbnREaWRVcGRhdGUuICcrJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJysnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnKydQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKXx8J2luc3RhbmNlJyk7fX19aWYoZmluaXNoZWRXb3JrLm1vZGUmUHJvZmlsZU1vZGUpe3RyeXtzdGFydExheW91dEVmZmVjdFRpbWVyKCk7aW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcyxwcmV2U3RhdGUsaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpO31maW5hbGx5e3JlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7fX1lbHNle2luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMscHJldlN0YXRlLGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlKTt9fX19Ly8gVE9ETzogSSB0aGluayB0aGlzIGlzIG5vdyBhbHdheXMgbm9uLW51bGwgYnkgdGhlIHRpbWUgaXQgcmVhY2hlcyB0aGVcbi8vIGNvbW1pdCBwaGFzZS4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHR5cGUgY2hlY2suXG52YXIgdXBkYXRlUXVldWU9ZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO2lmKHVwZGF0ZVF1ZXVlIT09bnVsbCl7e2lmKGZpbmlzaGVkV29yay50eXBlPT09ZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlJiYhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyl7aWYoaW5zdGFuY2UucHJvcHMhPT1maW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyl7ZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnKydwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcrJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJysnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnKydQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKXx8J2luc3RhbmNlJyk7fWlmKGluc3RhbmNlLnN0YXRlIT09ZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpe2Vycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJysncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnKydUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcrJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJysnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yayl8fCdpbnN0YW5jZScpO319fS8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbi8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLHVwZGF0ZVF1ZXVlLGluc3RhbmNlKTt9YnJlYWs7fWNhc2UgSG9zdFJvb3Q6ey8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4vLyBjb21taXQgcGhhc2UuIENvbnNpZGVyIHJlbW92aW5nIHRoZSB0eXBlIGNoZWNrLlxudmFyIF91cGRhdGVRdWV1ZT1maW5pc2hlZFdvcmsudXBkYXRlUXVldWU7aWYoX3VwZGF0ZVF1ZXVlIT09bnVsbCl7dmFyIF9pbnN0YW5jZT1udWxsO2lmKGZpbmlzaGVkV29yay5jaGlsZCE9PW51bGwpe3N3aXRjaChmaW5pc2hlZFdvcmsuY2hpbGQudGFnKXtjYXNlIEhvc3RDb21wb25lbnQ6X2luc3RhbmNlPWdldFB1YmxpY0luc3RhbmNlKGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGUpO2JyZWFrO2Nhc2UgQ2xhc3NDb21wb25lbnQ6X2luc3RhbmNlPWZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7YnJlYWs7fX1jb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssX3VwZGF0ZVF1ZXVlLF9pbnN0YW5jZSk7fWJyZWFrO31jYXNlIEhvc3RDb21wb25lbnQ6e3ZhciBfaW5zdGFuY2UyPWZpbmlzaGVkV29yay5zdGF0ZU5vZGU7Ly8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4vLyAoZWcgRE9NIHJlbmRlcmVyIG1heSBzY2hlZHVsZSBhdXRvLWZvY3VzIGZvciBpbnB1dHMgYW5kIGZvcm0gY29udHJvbHMpLlxuLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG5pZihjdXJyZW50PT09bnVsbCYmZmluaXNoZWRXb3JrLmZsYWdzJlVwZGF0ZSl7dmFyIHR5cGU9ZmluaXNoZWRXb3JrLnR5cGU7dmFyIHByb3BzPWZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO2NvbW1pdE1vdW50KF9pbnN0YW5jZTIsdHlwZSxwcm9wcyk7fWJyZWFrO31jYXNlIEhvc3RUZXh0OnsvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCB0ZXh0LlxuYnJlYWs7fWNhc2UgSG9zdFBvcnRhbDp7Ly8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggcG9ydGFscy5cbmJyZWFrO31jYXNlIFByb2ZpbGVyOnt7dmFyIF9maW5pc2hlZFdvcmskbWVtb2l6ZTI9ZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsb25Db21taXQ9X2ZpbmlzaGVkV29yayRtZW1vaXplMi5vbkNvbW1pdCxvblJlbmRlcj1fZmluaXNoZWRXb3JrJG1lbW9pemUyLm9uUmVuZGVyO3ZhciBlZmZlY3REdXJhdGlvbj1maW5pc2hlZFdvcmsuc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uO3ZhciBjb21taXRUaW1lPWdldENvbW1pdFRpbWUoKTt2YXIgcGhhc2U9Y3VycmVudD09PW51bGw/J21vdW50JzondXBkYXRlJzt7aWYoaXNDdXJyZW50VXBkYXRlTmVzdGVkKCkpe3BoYXNlPSduZXN0ZWQtdXBkYXRlJzt9fWlmKHR5cGVvZiBvblJlbmRlcj09PSdmdW5jdGlvbicpe29uUmVuZGVyKGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLmlkLHBoYXNlLGZpbmlzaGVkV29yay5hY3R1YWxEdXJhdGlvbixmaW5pc2hlZFdvcmsudHJlZUJhc2VEdXJhdGlvbixmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lLGNvbW1pdFRpbWUpO317aWYodHlwZW9mIG9uQ29tbWl0PT09J2Z1bmN0aW9uJyl7b25Db21taXQoZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQscGhhc2UsZWZmZWN0RHVyYXRpb24sY29tbWl0VGltZSk7fS8vIFNjaGVkdWxlIGEgcGFzc2l2ZSBlZmZlY3QgZm9yIHRoaXMgUHJvZmlsZXIgdG8gY2FsbCBvblBvc3RDb21taXQgaG9va3MuXG4vLyBUaGlzIGVmZmVjdCBzaG91bGQgYmUgc2NoZWR1bGVkIGV2ZW4gaWYgdGhlcmUgaXMgbm8gb25Qb3N0Q29tbWl0IGNhbGxiYWNrIGZvciB0aGlzIFByb2ZpbGVyLFxuLy8gYmVjYXVzZSB0aGUgZWZmZWN0IGlzIGFsc28gd2hlcmUgdGltZXMgYnViYmxlIHRvIHBhcmVudCBQcm9maWxlcnMuXG5lbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdChmaW5pc2hlZFdvcmspOy8vIFByb3BhZ2F0ZSBsYXlvdXQgZWZmZWN0IGR1cmF0aW9ucyB0byB0aGUgbmV4dCBuZWFyZXN0IFByb2ZpbGVyIGFuY2VzdG9yLlxuLy8gRG8gbm90IHJlc2V0IHRoZXNlIHZhbHVlcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgc28gRGV2VG9vbHMgaGFzIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSBmaXJzdC5cbnZhciBwYXJlbnRGaWJlcj1maW5pc2hlZFdvcmsucmV0dXJuO291dGVyOndoaWxlKHBhcmVudEZpYmVyIT09bnVsbCl7c3dpdGNoKHBhcmVudEZpYmVyLnRhZyl7Y2FzZSBIb3N0Um9vdDp2YXIgcm9vdD1wYXJlbnRGaWJlci5zdGF0ZU5vZGU7cm9vdC5lZmZlY3REdXJhdGlvbis9ZWZmZWN0RHVyYXRpb247YnJlYWsgb3V0ZXI7Y2FzZSBQcm9maWxlcjp2YXIgcGFyZW50U3RhdGVOb2RlPXBhcmVudEZpYmVyLnN0YXRlTm9kZTtwYXJlbnRTdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24rPWVmZmVjdER1cmF0aW9uO2JyZWFrIG91dGVyO31wYXJlbnRGaWJlcj1wYXJlbnRGaWJlci5yZXR1cm47fX19YnJlYWs7fWNhc2UgU3VzcGVuc2VDb21wb25lbnQ6e2NvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCxmaW5pc2hlZFdvcmspO2JyZWFrO31jYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpjYXNlIFNjb3BlQ29tcG9uZW50OmNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OmNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OmNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDp7YnJlYWs7fWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyAnKydsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9fWlmKCFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKXt7aWYoZmluaXNoZWRXb3JrLmZsYWdzJlJlZil7Y29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yayk7fX19fWZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0c09uRmliZXIobm9kZSl7Ly8gVHVybiBvbiBsYXlvdXQgZWZmZWN0cyBpbiBhIHRyZWUgdGhhdCBwcmV2aW91c2x5IGRpc2FwcGVhcmVkLlxuLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiBMYXlvdXRTdGF0aWNcbnN3aXRjaChub2RlLnRhZyl7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEZvcndhcmRSZWY6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OntpZihub2RlLm1vZGUmUHJvZmlsZU1vZGUpe3RyeXtzdGFydExheW91dEVmZmVjdFRpbWVyKCk7c2FmZWx5Q2FsbENvbW1pdEhvb2tMYXlvdXRFZmZlY3RMaXN0TW91bnQobm9kZSxub2RlLnJldHVybik7fWZpbmFsbHl7cmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24obm9kZSk7fX1lbHNle3NhZmVseUNhbGxDb21taXRIb29rTGF5b3V0RWZmZWN0TGlzdE1vdW50KG5vZGUsbm9kZS5yZXR1cm4pO31icmVhazt9Y2FzZSBDbGFzc0NvbXBvbmVudDp7dmFyIGluc3RhbmNlPW5vZGUuc3RhdGVOb2RlO2lmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudD09PSdmdW5jdGlvbicpe3NhZmVseUNhbGxDb21wb25lbnREaWRNb3VudChub2RlLG5vZGUucmV0dXJuLGluc3RhbmNlKTt9c2FmZWx5QXR0YWNoUmVmKG5vZGUsbm9kZS5yZXR1cm4pO2JyZWFrO31jYXNlIEhvc3RDb21wb25lbnQ6e3NhZmVseUF0dGFjaFJlZihub2RlLG5vZGUucmV0dXJuKTticmVhazt9fX1mdW5jdGlvbiBoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbihmaW5pc2hlZFdvcmssaXNIaWRkZW4pey8vIE9ubHkgaGlkZSBvciB1bmhpZGUgdGhlIHRvcC1tb3N0IGhvc3Qgbm9kZXMuXG52YXIgaG9zdFN1YnRyZWVSb290PW51bGw7ey8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbi8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbnZhciBub2RlPWZpbmlzaGVkV29yazt3aGlsZSh0cnVlKXtpZihub2RlLnRhZz09PUhvc3RDb21wb25lbnQpe2lmKGhvc3RTdWJ0cmVlUm9vdD09PW51bGwpe2hvc3RTdWJ0cmVlUm9vdD1ub2RlO3RyeXt2YXIgaW5zdGFuY2U9bm9kZS5zdGF0ZU5vZGU7aWYoaXNIaWRkZW4pe2hpZGVJbnN0YW5jZShpbnN0YW5jZSk7fWVsc2V7dW5oaWRlSW5zdGFuY2Uobm9kZS5zdGF0ZU5vZGUsbm9kZS5tZW1vaXplZFByb3BzKTt9fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybixlcnJvcik7fX19ZWxzZSBpZihub2RlLnRhZz09PUhvc3RUZXh0KXtpZihob3N0U3VidHJlZVJvb3Q9PT1udWxsKXt0cnl7dmFyIF9pbnN0YW5jZTM9bm9kZS5zdGF0ZU5vZGU7aWYoaXNIaWRkZW4pe2hpZGVUZXh0SW5zdGFuY2UoX2luc3RhbmNlMyk7fWVsc2V7dW5oaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZTMsbm9kZS5tZW1vaXplZFByb3BzKTt9fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybixlcnJvcik7fX19ZWxzZSBpZigobm9kZS50YWc9PT1PZmZzY3JlZW5Db21wb25lbnR8fG5vZGUudGFnPT09TGVnYWN5SGlkZGVuQ29tcG9uZW50KSYmbm9kZS5tZW1vaXplZFN0YXRlIT09bnVsbCYmbm9kZSE9PWZpbmlzaGVkV29yayk7ZWxzZSBpZihub2RlLmNoaWxkIT09bnVsbCl7bm9kZS5jaGlsZC5yZXR1cm49bm9kZTtub2RlPW5vZGUuY2hpbGQ7Y29udGludWU7fWlmKG5vZGU9PT1maW5pc2hlZFdvcmspe3JldHVybjt9d2hpbGUobm9kZS5zaWJsaW5nPT09bnVsbCl7aWYobm9kZS5yZXR1cm49PT1udWxsfHxub2RlLnJldHVybj09PWZpbmlzaGVkV29yayl7cmV0dXJuO31pZihob3N0U3VidHJlZVJvb3Q9PT1ub2RlKXtob3N0U3VidHJlZVJvb3Q9bnVsbDt9bm9kZT1ub2RlLnJldHVybjt9aWYoaG9zdFN1YnRyZWVSb290PT09bm9kZSl7aG9zdFN1YnRyZWVSb290PW51bGw7fW5vZGUuc2libGluZy5yZXR1cm49bm9kZS5yZXR1cm47bm9kZT1ub2RlLnNpYmxpbmc7fX19ZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yayl7dmFyIHJlZj1maW5pc2hlZFdvcmsucmVmO2lmKHJlZiE9PW51bGwpe3ZhciBpbnN0YW5jZT1maW5pc2hlZFdvcmsuc3RhdGVOb2RlO3ZhciBpbnN0YW5jZVRvVXNlO3N3aXRjaChmaW5pc2hlZFdvcmsudGFnKXtjYXNlIEhvc3RDb21wb25lbnQ6aW5zdGFuY2VUb1VzZT1nZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSk7YnJlYWs7ZGVmYXVsdDppbnN0YW5jZVRvVXNlPWluc3RhbmNlO30vLyBNb3ZlZCBvdXRzaWRlIHRvIGVuc3VyZSBEQ0Ugd29ya3Mgd2l0aCB0aGlzIGZsYWdcbmlmKHR5cGVvZiByZWY9PT0nZnVuY3Rpb24nKXt2YXIgcmV0VmFsO2lmKGZpbmlzaGVkV29yay5tb2RlJlByb2ZpbGVNb2RlKXt0cnl7c3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO3JldFZhbD1yZWYoaW5zdGFuY2VUb1VzZSk7fWZpbmFsbHl7cmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTt9fWVsc2V7cmV0VmFsPXJlZihpbnN0YW5jZVRvVXNlKTt9e2lmKHR5cGVvZiByZXRWYWw9PT0nZnVuY3Rpb24nKXtlcnJvcignVW5leHBlY3RlZCByZXR1cm4gdmFsdWUgZnJvbSBhIGNhbGxiYWNrIHJlZiBpbiAlcy4gJysnQSBjYWxsYmFjayByZWYgc2hvdWxkIG5vdCByZXR1cm4gYSBmdW5jdGlvbi4nLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7fX19ZWxzZXt7aWYoIXJlZi5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKXtlcnJvcignVW5leHBlY3RlZCByZWYgb2JqZWN0IHByb3ZpZGVkIGZvciAlcy4gJysnVXNlIGVpdGhlciBhIHJlZi1zZXR0ZXIgZnVuY3Rpb24gb3IgUmVhY3QuY3JlYXRlUmVmKCkuJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykpO319cmVmLmN1cnJlbnQ9aW5zdGFuY2VUb1VzZTt9fX1mdW5jdGlvbiBkZXRhY2hGaWJlck11dGF0aW9uKGZpYmVyKXsvLyBDdXQgb2ZmIHRoZSByZXR1cm4gcG9pbnRlciB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuXG4vLyBUaGlzIGVuYWJsZXMgdXMgdG8gZGV0ZWN0IGFuZCB3YXJuIGFnYWluc3Qgc3RhdGUgdXBkYXRlcyBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlxuLy8gSXQgYWxzbyBwcmV2ZW50cyBldmVudHMgZnJvbSBidWJibGluZyBmcm9tIHdpdGhpbiBkaXNjb25uZWN0ZWQgY29tcG9uZW50cy5cbi8vXG4vLyBJZGVhbGx5LCB3ZSBzaG91bGQgYWxzbyBjbGVhciB0aGUgY2hpbGQgcG9pbnRlciBvZiB0aGUgcGFyZW50IGFsdGVybmF0ZSB0byBsZXQgdGhpc1xuLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuLy8gb25lIHNvIHdlJ2xsIHNldHRsZSBmb3IgR0M6aW5nIHRoZSBzdWJ0cmVlIG9mIHRoaXMgY2hpbGQuXG4vLyBUaGlzIGNoaWxkIGl0c2VsZiB3aWxsIGJlIEdDOmVkIHdoZW4gdGhlIHBhcmVudCB1cGRhdGVzIHRoZSBuZXh0IHRpbWUuXG4vL1xuLy8gTm90ZSB0aGF0IHdlIGNhbid0IGNsZWFyIGNoaWxkIG9yIHNpYmxpbmcgcG9pbnRlcnMgeWV0LlxuLy8gVGhleSdyZSBuZWVkZWQgZm9yIHBhc3NpdmUgZWZmZWN0cyBhbmQgZm9yIGZpbmRET01Ob2RlLlxuLy8gV2UgZGVmZXIgdGhvc2UgZmllbGRzLCBhbmQgYWxsIG90aGVyIGNsZWFudXAsIHRvIHRoZSBwYXNzaXZlIHBoYXNlIChzZWUgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMpLlxuLy9cbi8vIERvbid0IHJlc2V0IHRoZSBhbHRlcm5hdGUgeWV0LCBlaXRoZXIuIFdlIG5lZWQgdGhhdCBzbyB3ZSBjYW4gZGV0YWNoIHRoZVxuLy8gYWx0ZXJuYXRlJ3MgZmllbGRzIGluIHRoZSBwYXNzaXZlIHBoYXNlLiBDbGVhcmluZyB0aGUgcmV0dXJuIHBvaW50ZXIgaXNcbi8vIHN1ZmZpY2llbnQgZm9yIGZpbmRET01Ob2RlIHNlbWFudGljcy5cbnZhciBhbHRlcm5hdGU9ZmliZXIuYWx0ZXJuYXRlO2lmKGFsdGVybmF0ZSE9PW51bGwpe2FsdGVybmF0ZS5yZXR1cm49bnVsbDt9ZmliZXIucmV0dXJuPW51bGw7fWZ1bmN0aW9uIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGZpYmVyKXt2YXIgYWx0ZXJuYXRlPWZpYmVyLmFsdGVybmF0ZTtpZihhbHRlcm5hdGUhPT1udWxsKXtmaWJlci5hbHRlcm5hdGU9bnVsbDtkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhhbHRlcm5hdGUpO30vLyBOb3RlOiBEZWZlbnNpdmVseSB1c2luZyBuZWdhdGlvbiBpbnN0ZWFkIG9mIDwgaW4gY2FzZVxuLy8gYGRlbGV0ZWRUcmVlQ2xlYW5VcExldmVsYCBpcyB1bmRlZmluZWQuXG57Ly8gQ2xlYXIgY3ljbGljYWwgRmliZXIgZmllbGRzLiBUaGlzIGxldmVsIGFsb25lIGlzIGRlc2lnbmVkIHRvIHJvdWdobHlcbi8vIGFwcHJveGltYXRlIHRoZSBwbGFubmVkIEZpYmVyIHJlZmFjdG9yLiBJbiB0aGF0IHdvcmxkLCBgc2V0U3RhdGVgIHdpbGwgYmVcbi8vIGJvdW5kIHRvIGEgc3BlY2lhbCBcImluc3RhbmNlXCIgb2JqZWN0IGluc3RlYWQgb2YgYSBGaWJlci4gVGhlIEluc3RhbmNlXG4vLyBvYmplY3Qgd2lsbCBub3QgaGF2ZSBhbnkgb2YgdGhlc2UgZmllbGRzLiBJdCB3aWxsIG9ubHkgYmUgY29ubmVjdGVkIHRvXG4vLyB0aGUgZmliZXIgdHJlZSB2aWEgYSBzaW5nbGUgbGluayBhdCB0aGUgcm9vdC4gU28gaWYgdGhpcyBsZXZlbCBhbG9uZSBpc1xuLy8gc3VmZmljaWVudCB0byBmaXggbWVtb3J5IGlzc3VlcywgdGhhdCBib2RlcyB3ZWxsIGZvciBvdXIgcGxhbnMuXG5maWJlci5jaGlsZD1udWxsO2ZpYmVyLmRlbGV0aW9ucz1udWxsO2ZpYmVyLnNpYmxpbmc9bnVsbDsvLyBUaGUgYHN0YXRlTm9kZWAgaXMgY3ljbGljYWwgYmVjYXVzZSBvbiBob3N0IG5vZGVzIGl0IHBvaW50cyB0byB0aGUgaG9zdFxuLy8gdHJlZSwgd2hpY2ggaGFzIGl0cyBvd24gcG9pbnRlcnMgdG8gY2hpbGRyZW4sIHBhcmVudHMsIGFuZCBzaWJsaW5ncy5cbi8vIFRoZSBvdGhlciBob3N0IG5vZGVzIGFsc28gcG9pbnQgYmFjayB0byBmaWJlcnMsIHNvIHdlIHNob3VsZCBkZXRhY2ggdGhhdFxuLy8gb25lLCB0b28uXG5pZihmaWJlci50YWc9PT1Ib3N0Q29tcG9uZW50KXt2YXIgaG9zdEluc3RhbmNlPWZpYmVyLnN0YXRlTm9kZTtpZihob3N0SW5zdGFuY2UhPT1udWxsKXtkZXRhY2hEZWxldGVkSW5zdGFuY2UoaG9zdEluc3RhbmNlKTt9fWZpYmVyLnN0YXRlTm9kZT1udWxsOy8vIEknbSBpbnRlbnRpb25hbGx5IG5vdCBjbGVhcmluZyB0aGUgYHJldHVybmAgZmllbGQgaW4gdGhpcyBsZXZlbC4gV2Vcbi8vIGFscmVhZHkgZGlzY29ubmVjdCB0aGUgYHJldHVybmAgcG9pbnRlciBhdCB0aGUgcm9vdCBvZiB0aGUgZGVsZXRlZFxuLy8gc3VidHJlZSAoaW4gYGRldGFjaEZpYmVyTXV0YXRpb25gKS4gQmVzaWRlcywgYHJldHVybmAgYnkgaXRzZWxmIGlzIG5vdFxuLy8gY3ljbGljYWwg4oCUIGl0J3Mgb25seSBjeWNsaWNhbCB3aGVuIGNvbWJpbmVkIHdpdGggYGNoaWxkYCwgYHNpYmxpbmdgLCBhbmRcbi8vIGBhbHRlcm5hdGVgLiBCdXQgd2UnbGwgY2xlYXIgaXQgaW4gdGhlIG5leHQgbGV2ZWwgYW55d2F5LCBqdXN0IGluIGNhc2UuXG57ZmliZXIuX2RlYnVnT3duZXI9bnVsbDt9ey8vIFRoZW9yZXRpY2FsbHksIG5vdGhpbmcgaW4gaGVyZSBzaG91bGQgYmUgbmVjZXNzYXJ5LCBiZWNhdXNlIHdlIGFscmVhZHlcbi8vIGRpc2Nvbm5lY3RlZCB0aGUgZmliZXIgZnJvbSB0aGUgdHJlZS4gU28gZXZlbiBpZiBzb21ldGhpbmcgbGVha3MgdGhpc1xuLy8gcGFydGljdWxhciBmaWJlciwgaXQgd29uJ3QgbGVhayBhbnl0aGluZyBlbHNlXG4vL1xuLy8gVGhlIHB1cnBvc2Ugb2YgdGhpcyBicmFuY2ggaXMgdG8gYmUgc3VwZXIgYWdncmVzc2l2ZSBzbyB3ZSBjYW4gbWVhc3VyZVxuLy8gaWYgdGhlcmUncyBhbnkgZGlmZmVyZW5jZSBpbiBtZW1vcnkgaW1wYWN0LiBJZiB0aGVyZSBpcywgdGhhdCBjb3VsZFxuLy8gaW5kaWNhdGUgYSBSZWFjdCBsZWFrIHdlIGRvbid0IGtub3cgYWJvdXQuXG5maWJlci5yZXR1cm49bnVsbDtmaWJlci5kZXBlbmRlbmNpZXM9bnVsbDtmaWJlci5tZW1vaXplZFByb3BzPW51bGw7ZmliZXIubWVtb2l6ZWRTdGF0ZT1udWxsO2ZpYmVyLnBlbmRpbmdQcm9wcz1udWxsO2ZpYmVyLnN0YXRlTm9kZT1udWxsOy8vIFRPRE86IE1vdmUgdG8gYGNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyYCBpbnN0ZWFkLlxuZmliZXIudXBkYXRlUXVldWU9bnVsbDt9fX1mdW5jdGlvbiBnZXRIb3N0UGFyZW50RmliZXIoZmliZXIpe3ZhciBwYXJlbnQ9ZmliZXIucmV0dXJuO3doaWxlKHBhcmVudCE9PW51bGwpe2lmKGlzSG9zdFBhcmVudChwYXJlbnQpKXtyZXR1cm4gcGFyZW50O31wYXJlbnQ9cGFyZW50LnJldHVybjt9dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyAnKydpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fWZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcil7cmV0dXJuIGZpYmVyLnRhZz09PUhvc3RDb21wb25lbnR8fGZpYmVyLnRhZz09PUhvc3RSb290fHxmaWJlci50YWc9PT1Ib3N0UG9ydGFsO31mdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcil7Ly8gV2UncmUgZ29pbmcgdG8gc2VhcmNoIGZvcndhcmQgaW50byB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGEgc2libGluZyBob3N0XG4vLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbi8vIHNlYXJjaCBwYXN0IHRoZW0uIFRoaXMgbGVhZHMgdG8gZXhwb25lbnRpYWwgc2VhcmNoIGZvciB0aGUgbmV4dCBzaWJsaW5nLlxuLy8gVE9ETzogRmluZCBhIG1vcmUgZWZmaWNpZW50IHdheSB0byBkbyB0aGlzLlxudmFyIG5vZGU9ZmliZXI7c2libGluZ3M6d2hpbGUodHJ1ZSl7Ly8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxud2hpbGUobm9kZS5zaWJsaW5nPT09bnVsbCl7aWYobm9kZS5yZXR1cm49PT1udWxsfHxpc0hvc3RQYXJlbnQobm9kZS5yZXR1cm4pKXsvLyBJZiB3ZSBwb3Agb3V0IG9mIHRoZSByb290IG9yIGhpdCB0aGUgcGFyZW50IHRoZSBmaWJlciB3ZSBhcmUgdGhlXG4vLyBsYXN0IHNpYmxpbmcuXG5yZXR1cm4gbnVsbDt9bm9kZT1ub2RlLnJldHVybjt9bm9kZS5zaWJsaW5nLnJldHVybj1ub2RlLnJldHVybjtub2RlPW5vZGUuc2libGluZzt3aGlsZShub2RlLnRhZyE9PUhvc3RDb21wb25lbnQmJm5vZGUudGFnIT09SG9zdFRleHQmJm5vZGUudGFnIT09RGVoeWRyYXRlZEZyYWdtZW50KXsvLyBJZiBpdCBpcyBub3QgaG9zdCBub2RlIGFuZCwgd2UgbWlnaHQgaGF2ZSBhIGhvc3Qgbm9kZSBpbnNpZGUgaXQuXG4vLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG5pZihub2RlLmZsYWdzJlBsYWNlbWVudCl7Ly8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG5jb250aW51ZSBzaWJsaW5nczt9Ly8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4vLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuaWYobm9kZS5jaGlsZD09PW51bGx8fG5vZGUudGFnPT09SG9zdFBvcnRhbCl7Y29udGludWUgc2libGluZ3M7fWVsc2V7bm9kZS5jaGlsZC5yZXR1cm49bm9kZTtub2RlPW5vZGUuY2hpbGQ7fX0vLyBDaGVjayBpZiB0aGlzIGhvc3Qgbm9kZSBpcyBzdGFibGUgb3IgYWJvdXQgdG8gYmUgcGxhY2VkLlxuaWYoIShub2RlLmZsYWdzJlBsYWNlbWVudCkpey8vIEZvdW5kIGl0IVxucmV0dXJuIG5vZGUuc3RhdGVOb2RlO319fWZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspe3ZhciBwYXJlbnRGaWJlcj1nZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTsvLyBOb3RlOiB0aGVzZSB0d28gdmFyaWFibGVzICptdXN0KiBhbHdheXMgYmUgdXBkYXRlZCB0b2dldGhlci5cbnN3aXRjaChwYXJlbnRGaWJlci50YWcpe2Nhc2UgSG9zdENvbXBvbmVudDp7dmFyIHBhcmVudD1wYXJlbnRGaWJlci5zdGF0ZU5vZGU7aWYocGFyZW50RmliZXIuZmxhZ3MmQ29udGVudFJlc2V0KXsvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG5yZXNldFRleHRDb250ZW50KHBhcmVudCk7Ly8gQ2xlYXIgQ29udGVudFJlc2V0IGZyb20gdGhlIGVmZmVjdCB0YWdcbnBhcmVudEZpYmVyLmZsYWdzJj1+Q29udGVudFJlc2V0O312YXIgYmVmb3JlPWdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7Ly8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGZpbmlzaGVkV29yayxiZWZvcmUscGFyZW50KTticmVhazt9Y2FzZSBIb3N0Um9vdDpjYXNlIEhvc3RQb3J0YWw6e3ZhciBfcGFyZW50PXBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO3ZhciBfYmVmb3JlPWdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7aW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihmaW5pc2hlZFdvcmssX2JlZm9yZSxfcGFyZW50KTticmVhazt9Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5kZWZhdWx0OnRocm93IG5ldyBFcnJvcignSW52YWxpZCBob3N0IHBhcmVudCBmaWJlci4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcrJ2luIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9fWZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSxiZWZvcmUscGFyZW50KXt2YXIgdGFnPW5vZGUudGFnO3ZhciBpc0hvc3Q9dGFnPT09SG9zdENvbXBvbmVudHx8dGFnPT09SG9zdFRleHQ7aWYoaXNIb3N0KXt2YXIgc3RhdGVOb2RlPW5vZGUuc3RhdGVOb2RlO2lmKGJlZm9yZSl7aW5zZXJ0SW5Db250YWluZXJCZWZvcmUocGFyZW50LHN0YXRlTm9kZSxiZWZvcmUpO31lbHNle2FwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LHN0YXRlTm9kZSk7fX1lbHNlIGlmKHRhZz09PUhvc3RQb3J0YWwpO2Vsc2V7dmFyIGNoaWxkPW5vZGUuY2hpbGQ7aWYoY2hpbGQhPT1udWxsKXtpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKGNoaWxkLGJlZm9yZSxwYXJlbnQpO3ZhciBzaWJsaW5nPWNoaWxkLnNpYmxpbmc7d2hpbGUoc2libGluZyE9PW51bGwpe2luc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoc2libGluZyxiZWZvcmUscGFyZW50KTtzaWJsaW5nPXNpYmxpbmcuc2libGluZzt9fX19ZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsYmVmb3JlLHBhcmVudCl7dmFyIHRhZz1ub2RlLnRhZzt2YXIgaXNIb3N0PXRhZz09PUhvc3RDb21wb25lbnR8fHRhZz09PUhvc3RUZXh0O2lmKGlzSG9zdCl7dmFyIHN0YXRlTm9kZT1ub2RlLnN0YXRlTm9kZTtpZihiZWZvcmUpe2luc2VydEJlZm9yZShwYXJlbnQsc3RhdGVOb2RlLGJlZm9yZSk7fWVsc2V7YXBwZW5kQ2hpbGQocGFyZW50LHN0YXRlTm9kZSk7fX1lbHNlIGlmKHRhZz09PUhvc3RQb3J0YWwpO2Vsc2V7dmFyIGNoaWxkPW5vZGUuY2hpbGQ7aWYoY2hpbGQhPT1udWxsKXtpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoY2hpbGQsYmVmb3JlLHBhcmVudCk7dmFyIHNpYmxpbmc9Y2hpbGQuc2libGluZzt3aGlsZShzaWJsaW5nIT09bnVsbCl7aW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKHNpYmxpbmcsYmVmb3JlLHBhcmVudCk7c2libGluZz1zaWJsaW5nLnNpYmxpbmc7fX19fS8vIFRoZXNlIGFyZSB0cmFja2VkIG9uIHRoZSBzdGFjayBhcyB3ZSByZWN1cnNpdmVseSB0cmF2ZXJzZSBhXG4vLyBkZWxldGVkIHN1YnRyZWUuXG4vLyBUT0RPOiBVcGRhdGUgdGhlc2UgZHVyaW5nIHRoZSB3aG9sZSBtdXRhdGlvbiBwaGFzZSwgbm90IGp1c3QgZHVyaW5nXG4vLyBhIGRlbGV0aW9uLlxudmFyIGhvc3RQYXJlbnQ9bnVsbDt2YXIgaG9zdFBhcmVudElzQ29udGFpbmVyPWZhbHNlO2Z1bmN0aW9uIGNvbW1pdERlbGV0aW9uRWZmZWN0cyhyb290LHJldHVybkZpYmVyLGRlbGV0ZWRGaWJlcil7ey8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGRlbGV0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuLy8gUmVjdXJzaXZlbHkgZGVsZXRlIGFsbCBob3N0IG5vZGVzIGZyb20gdGhlIHBhcmVudCwgZGV0YWNoIHJlZnMsIGNsZWFuXG4vLyB1cCBtb3VudGVkIGxheW91dCBlZmZlY3RzLCBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudC5cbi8vIFdlIG9ubHkgbmVlZCB0byByZW1vdmUgdGhlIHRvcG1vc3QgaG9zdCBjaGlsZCBpbiBlYWNoIGJyYW5jaC4gQnV0IHRoZW4gd2Vcbi8vIHN0aWxsIG5lZWQgdG8ga2VlcCB0cmF2ZXJzaW5nIHRvIHVubW91bnQgZWZmZWN0cywgcmVmcywgYW5kIGNXVS4gVE9ETzogV2Vcbi8vIGNvdWxkIHNwbGl0IHRoaXMgaW50byB0d28gc2VwYXJhdGUgdHJhdmVyc2FscyBmdW5jdGlvbnMsIHdoZXJlIHRoZSBzZWNvbmRcbi8vIG9uZSBkb2Vzbid0IGluY2x1ZGUgYW55IHJlbW92ZUNoaWxkIGxvZ2ljLiBUaGlzIGlzIG1heWJlIHRoZSBzYW1lXG4vLyBmdW5jdGlvbiBhcyBcImRpc2FwcGVhckxheW91dEVmZmVjdHNcIiAob3Igd2hhdGV2ZXIgdGhhdCB0dXJucyBpbnRvIGFmdGVyXG4vLyB0aGUgbGF5b3V0IHBoYXNlIGlzIHJlZmFjdG9yZWQgdG8gdXNlIHJlY3Vyc2lvbikuXG4vLyBCZWZvcmUgc3RhcnRpbmcsIGZpbmQgdGhlIG5lYXJlc3QgaG9zdCBwYXJlbnQgb24gdGhlIHN0YWNrIHNvIHdlIGtub3dcbi8vIHdoaWNoIGluc3RhbmNlL2NvbnRhaW5lciB0byByZW1vdmUgdGhlIGNoaWxkcmVuIGZyb20uXG4vLyBUT0RPOiBJbnN0ZWFkIG9mIHNlYXJjaGluZyB1cCB0aGUgZmliZXIgcmV0dXJuIHBhdGggb24gZXZlcnkgZGVsZXRpb24sIHdlXG4vLyBjYW4gdHJhY2sgdGhlIG5lYXJlc3QgaG9zdCBjb21wb25lbnQgb24gdGhlIEpTIHN0YWNrIGFzIHdlIHRyYXZlcnNlIHRoZVxuLy8gdHJlZSBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gVGhpcyB3b3VsZCBtYWtlIGluc2VydGlvbnMgZmFzdGVyLCB0b28uXG52YXIgcGFyZW50PXJldHVybkZpYmVyO2ZpbmRQYXJlbnQ6d2hpbGUocGFyZW50IT09bnVsbCl7c3dpdGNoKHBhcmVudC50YWcpe2Nhc2UgSG9zdENvbXBvbmVudDp7aG9zdFBhcmVudD1wYXJlbnQuc3RhdGVOb2RlO2hvc3RQYXJlbnRJc0NvbnRhaW5lcj1mYWxzZTticmVhayBmaW5kUGFyZW50O31jYXNlIEhvc3RSb290Ontob3N0UGFyZW50PXBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztob3N0UGFyZW50SXNDb250YWluZXI9dHJ1ZTticmVhayBmaW5kUGFyZW50O31jYXNlIEhvc3RQb3J0YWw6e2hvc3RQYXJlbnQ9cGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2hvc3RQYXJlbnRJc0NvbnRhaW5lcj10cnVlO2JyZWFrIGZpbmRQYXJlbnQ7fX1wYXJlbnQ9cGFyZW50LnJldHVybjt9aWYoaG9zdFBhcmVudD09PW51bGwpe3Rocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgJysnYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31jb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKHJvb3QscmV0dXJuRmliZXIsZGVsZXRlZEZpYmVyKTtob3N0UGFyZW50PW51bGw7aG9zdFBhcmVudElzQ29udGFpbmVyPWZhbHNlO31kZXRhY2hGaWJlck11dGF0aW9uKGRlbGV0ZWRGaWJlcik7fWZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IscGFyZW50KXsvLyBUT0RPOiBVc2UgYSBzdGF0aWMgZmxhZyB0byBza2lwIHRyZWVzIHRoYXQgZG9uJ3QgaGF2ZSB1bm1vdW50IGVmZmVjdHNcbnZhciBjaGlsZD1wYXJlbnQuY2hpbGQ7d2hpbGUoY2hpbGQhPT1udWxsKXtjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkUm9vdCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGNoaWxkKTtjaGlsZD1jaGlsZC5zaWJsaW5nO319ZnVuY3Rpb24gY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFJvb3QsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixkZWxldGVkRmliZXIpe29uQ29tbWl0VW5tb3VudChkZWxldGVkRmliZXIpOy8vIFRoZSBjYXNlcyBpbiB0aGlzIG91dGVyIHN3aXRjaCBtb2RpZnkgdGhlIHN0YWNrIGJlZm9yZSB0aGV5IHRyYXZlcnNlXG4vLyBpbnRvIHRoZWlyIHN1YnRyZWUuIFRoZXJlIGFyZSBzaW1wbGVyIGNhc2VzIGluIHRoZSBpbm5lciBzd2l0Y2hcbi8vIHRoYXQgZG9uJ3QgbW9kaWZ5IHRoZSBzdGFjay5cbnN3aXRjaChkZWxldGVkRmliZXIudGFnKXtjYXNlIEhvc3RDb21wb25lbnQ6e2lmKCFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKXtzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO30vLyBJbnRlbnRpb25hbCBmYWxsdGhyb3VnaCB0byBuZXh0IGJyYW5jaFxufS8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuY2FzZSBIb3N0VGV4dDp7Ly8gV2Ugb25seSBuZWVkIHRvIHJlbW92ZSB0aGUgbmVhcmVzdCBob3N0IGNoaWxkLiBTZXQgdGhlIGhvc3QgcGFyZW50XG4vLyB0byBgbnVsbGAgb24gdGhlIHN0YWNrIHRvIGluZGljYXRlIHRoYXQgbmVzdGVkIGNoaWxkcmVuIGRvbid0XG4vLyBuZWVkIHRvIGJlIHJlbW92ZWQuXG57dmFyIHByZXZIb3N0UGFyZW50PWhvc3RQYXJlbnQ7dmFyIHByZXZIb3N0UGFyZW50SXNDb250YWluZXI9aG9zdFBhcmVudElzQ29udGFpbmVyO2hvc3RQYXJlbnQ9bnVsbDtyZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGRlbGV0ZWRGaWJlcik7aG9zdFBhcmVudD1wcmV2SG9zdFBhcmVudDtob3N0UGFyZW50SXNDb250YWluZXI9cHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcjtpZihob3N0UGFyZW50IT09bnVsbCl7Ly8gTm93IHRoYXQgYWxsIHRoZSBjaGlsZCBlZmZlY3RzIGhhdmUgdW5tb3VudGVkLCB3ZSBjYW4gcmVtb3ZlIHRoZVxuLy8gbm9kZSBmcm9tIHRoZSB0cmVlLlxuaWYoaG9zdFBhcmVudElzQ29udGFpbmVyKXtyZW1vdmVDaGlsZEZyb21Db250YWluZXIoaG9zdFBhcmVudCxkZWxldGVkRmliZXIuc3RhdGVOb2RlKTt9ZWxzZXtyZW1vdmVDaGlsZChob3N0UGFyZW50LGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO319fXJldHVybjt9Y2FzZSBEZWh5ZHJhdGVkRnJhZ21lbnQ6ey8vIERlbGV0ZSB0aGUgZGVoeWRyYXRlZCBzdXNwZW5zZSBib3VuZGFyeSBhbmQgYWxsIG9mIGl0cyBjb250ZW50Llxue2lmKGhvc3RQYXJlbnQhPT1udWxsKXtpZihob3N0UGFyZW50SXNDb250YWluZXIpe2NsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIoaG9zdFBhcmVudCxkZWxldGVkRmliZXIuc3RhdGVOb2RlKTt9ZWxzZXtjbGVhclN1c3BlbnNlQm91bmRhcnkoaG9zdFBhcmVudCxkZWxldGVkRmliZXIuc3RhdGVOb2RlKTt9fX1yZXR1cm47fWNhc2UgSG9zdFBvcnRhbDp7ey8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxudmFyIF9wcmV2SG9zdFBhcmVudD1ob3N0UGFyZW50O3ZhciBfcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcj1ob3N0UGFyZW50SXNDb250YWluZXI7aG9zdFBhcmVudD1kZWxldGVkRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87aG9zdFBhcmVudElzQ29udGFpbmVyPXRydWU7cmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixkZWxldGVkRmliZXIpO2hvc3RQYXJlbnQ9X3ByZXZIb3N0UGFyZW50O2hvc3RQYXJlbnRJc0NvbnRhaW5lcj1fcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcjt9cmV0dXJuO31jYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgRm9yd2FyZFJlZjpjYXNlIE1lbW9Db21wb25lbnQ6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OntpZighb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbil7dmFyIHVwZGF0ZVF1ZXVlPWRlbGV0ZWRGaWJlci51cGRhdGVRdWV1ZTtpZih1cGRhdGVRdWV1ZSE9PW51bGwpe3ZhciBsYXN0RWZmZWN0PXVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q7aWYobGFzdEVmZmVjdCE9PW51bGwpe3ZhciBmaXJzdEVmZmVjdD1sYXN0RWZmZWN0Lm5leHQ7dmFyIGVmZmVjdD1maXJzdEVmZmVjdDtkb3t2YXIgX2VmZmVjdD1lZmZlY3QsZGVzdHJveT1fZWZmZWN0LmRlc3Ryb3ksdGFnPV9lZmZlY3QudGFnO2lmKGRlc3Ryb3khPT11bmRlZmluZWQpe2lmKCh0YWcmSW5zZXJ0aW9uKSE9PU5vRmxhZ3MkMSl7c2FmZWx5Q2FsbERlc3Ryb3koZGVsZXRlZEZpYmVyLG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZGVzdHJveSk7fWVsc2UgaWYoKHRhZyZMYXlvdXQpIT09Tm9GbGFncyQxKXt7bWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGRlbGV0ZWRGaWJlcik7fWlmKGRlbGV0ZWRGaWJlci5tb2RlJlByb2ZpbGVNb2RlKXtzdGFydExheW91dEVmZmVjdFRpbWVyKCk7c2FmZWx5Q2FsbERlc3Ryb3koZGVsZXRlZEZpYmVyLG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZGVzdHJveSk7cmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZGVsZXRlZEZpYmVyKTt9ZWxzZXtzYWZlbHlDYWxsRGVzdHJveShkZWxldGVkRmliZXIsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixkZXN0cm95KTt9e21hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpO319fWVmZmVjdD1lZmZlY3QubmV4dDt9d2hpbGUoZWZmZWN0IT09Zmlyc3RFZmZlY3QpO319fXJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZGVsZXRlZEZpYmVyKTtyZXR1cm47fWNhc2UgQ2xhc3NDb21wb25lbnQ6e2lmKCFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKXtzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO3ZhciBpbnN0YW5jZT1kZWxldGVkRmliZXIuc3RhdGVOb2RlO2lmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudD09PSdmdW5jdGlvbicpe3NhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChkZWxldGVkRmliZXIsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixpbnN0YW5jZSk7fX1yZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGRlbGV0ZWRGaWJlcik7cmV0dXJuO31jYXNlIFNjb3BlQ29tcG9uZW50OntyZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGRlbGV0ZWRGaWJlcik7cmV0dXJuO31jYXNlIE9mZnNjcmVlbkNvbXBvbmVudDp7aWYoLy8gVE9ETzogUmVtb3ZlIHRoaXMgZGVhZCBmbGFnXG5kZWxldGVkRmliZXIubW9kZSZDb25jdXJyZW50TW9kZSl7Ly8gSWYgdGhpcyBvZmZzY3JlZW4gY29tcG9uZW50IGlzIGhpZGRlbiwgd2UgYWxyZWFkeSB1bm1vdW50ZWQgaXQuIEJlZm9yZVxuLy8gZGVsZXRpbmcgdGhlIGNoaWxkcmVuLCB0cmFjayB0aGF0IGl0J3MgYWxyZWFkeSB1bm1vdW50ZWQgc28gdGhhdCB3ZVxuLy8gZG9uJ3QgYXR0ZW1wdCB0byB1bm1vdW50IHRoZSBlZmZlY3RzIGFnYWluLlxuLy8gVE9ETzogSWYgdGhlIHRyZWUgaXMgaGlkZGVuLCBpbiBtb3N0IGNhc2VzIHdlIHNob3VsZCBiZSBhYmxlIHRvIHNraXBcbi8vIG92ZXIgdGhlIG5lc3RlZCBjaGlsZHJlbiBlbnRpcmVseS4gQW4gZXhjZXB0aW9uIGlzIHdlIGhhdmVuJ3QgeWV0IGZvdW5kXG4vLyB0aGUgdG9wbW9zdCBob3N0IG5vZGUgdG8gZGVsZXRlLCB3aGljaCB3ZSBhbHJlYWR5IHRyYWNrIG9uIHRoZSBzdGFjay5cbi8vIEJ1dCB0aGUgb3RoZXIgY2FzZSBpcyBwb3J0YWxzLCB3aGljaCBuZWVkIHRvIGJlIGRldGFjaGVkIG5vIG1hdHRlciBob3dcbi8vIGRlZXBseSB0aGV5IGFyZSBuZXN0ZWQuIFdlIHNob3VsZCB1c2UgYSBzdWJ0cmVlIGZsYWcgdG8gdHJhY2sgd2hldGhlciBhXG4vLyBzdWJ0cmVlIGluY2x1ZGVzIGEgbmVzdGVkIHBvcnRhbC5cbnZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbj1vZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO29mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW49cHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW58fGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlIT09bnVsbDtyZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGRlbGV0ZWRGaWJlcik7b2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbj1wcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjt9ZWxzZXtyZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGRlbGV0ZWRGaWJlcik7fWJyZWFrO31kZWZhdWx0OntyZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGRlbGV0ZWRGaWJlcik7cmV0dXJuO319fWZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlQ2FsbGJhY2soZmluaXNoZWRXb3JrKXsvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcGFzc2l2ZSBwaGFzZVxudmFyIG5ld1N0YXRlPWZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO31mdW5jdGlvbiBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsZmluaXNoZWRXb3JrKXt2YXIgbmV3U3RhdGU9ZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7aWYobmV3U3RhdGU9PT1udWxsKXt2YXIgY3VycmVudD1maW5pc2hlZFdvcmsuYWx0ZXJuYXRlO2lmKGN1cnJlbnQhPT1udWxsKXt2YXIgcHJldlN0YXRlPWN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtpZihwcmV2U3RhdGUhPT1udWxsKXt2YXIgc3VzcGVuc2VJbnN0YW5jZT1wcmV2U3RhdGUuZGVoeWRyYXRlZDtpZihzdXNwZW5zZUluc3RhbmNlIT09bnVsbCl7Y29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO319fX19ZnVuY3Rpb24gYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmspey8vIElmIHRoaXMgYm91bmRhcnkganVzdCB0aW1lZCBvdXQsIHRoZW4gaXQgd2lsbCBoYXZlIGEgc2V0IG9mIHdha2VhYmxlcy5cbi8vIEZvciBlYWNoIHdha2VhYmxlLCBhdHRhY2ggYSBsaXN0ZW5lciBzbyB0aGF0IHdoZW4gaXQgcmVzb2x2ZXMsIFJlYWN0XG4vLyBhdHRlbXB0cyB0byByZS1yZW5kZXIgdGhlIGJvdW5kYXJ5IGluIHRoZSBwcmltYXJ5IChwcmUtdGltZW91dCkgc3RhdGUuXG52YXIgd2FrZWFibGVzPWZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtpZih3YWtlYWJsZXMhPT1udWxsKXtmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU9bnVsbDt2YXIgcmV0cnlDYWNoZT1maW5pc2hlZFdvcmsuc3RhdGVOb2RlO2lmKHJldHJ5Q2FjaGU9PT1udWxsKXtyZXRyeUNhY2hlPWZpbmlzaGVkV29yay5zdGF0ZU5vZGU9bmV3IFBvc3NpYmx5V2Vha1NldCgpO313YWtlYWJsZXMuZm9yRWFjaChmdW5jdGlvbih3YWtlYWJsZSl7Ly8gTWVtb2l6ZSB1c2luZyB0aGUgYm91bmRhcnkgZmliZXIgdG8gcHJldmVudCByZWR1bmRhbnQgbGlzdGVuZXJzLlxudmFyIHJldHJ5PXJlc29sdmVSZXRyeVdha2VhYmxlLmJpbmQobnVsbCxmaW5pc2hlZFdvcmssd2FrZWFibGUpO2lmKCFyZXRyeUNhY2hlLmhhcyh3YWtlYWJsZSkpe3JldHJ5Q2FjaGUuYWRkKHdha2VhYmxlKTt7aWYoaXNEZXZUb29sc1ByZXNlbnQpe2lmKGluUHJvZ3Jlc3NMYW5lcyE9PW51bGwmJmluUHJvZ3Jlc3NSb290IT09bnVsbCl7Ly8gSWYgd2UgaGF2ZSBwZW5kaW5nIHdvcmsgc3RpbGwsIGFzc29jaWF0ZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnMgd2l0aCBpdC5cbnJlc3RvcmVQZW5kaW5nVXBkYXRlcnMoaW5Qcm9ncmVzc1Jvb3QsaW5Qcm9ncmVzc0xhbmVzKTt9ZWxzZXt0aHJvdyBFcnJvcignRXhwZWN0ZWQgZmluaXNoZWQgcm9vdCBhbmQgbGFuZXMgdG8gYmUgc2V0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO319fXdha2VhYmxlLnRoZW4ocmV0cnkscmV0cnkpO319KTt9fS8vIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB3aGVuIGEgU3VzcGVuc2UgYm91bmRhcnkgZ29lcyBmcm9tIHZpc2libGUgdG8gaGlkZGVuLlxuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsZmluaXNoZWRXb3JrLGNvbW1pdHRlZExhbmVzKXtpblByb2dyZXNzTGFuZXM9Y29tbWl0dGVkTGFuZXM7aW5Qcm9ncmVzc1Jvb3Q9cm9vdDtzZXRDdXJyZW50RmliZXIoZmluaXNoZWRXb3JrKTtjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkV29yayxyb290KTtzZXRDdXJyZW50RmliZXIoZmluaXNoZWRXb3JrKTtpblByb2dyZXNzTGFuZXM9bnVsbDtpblByb2dyZXNzUm9vdD1udWxsO31mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QscGFyZW50RmliZXIsbGFuZXMpey8vIERlbGV0aW9ucyBlZmZlY3RzIGNhbiBiZSBzY2hlZHVsZWQgb24gYW55IGZpYmVyIHR5cGUuIFRoZXkgbmVlZCB0byBoYXBwZW5cbi8vIGJlZm9yZSB0aGUgY2hpbGRyZW4gZWZmZWN0cyBoYWUgZmlyZWQuXG52YXIgZGVsZXRpb25zPXBhcmVudEZpYmVyLmRlbGV0aW9ucztpZihkZWxldGlvbnMhPT1udWxsKXtmb3IodmFyIGk9MDtpPGRlbGV0aW9ucy5sZW5ndGg7aSsrKXt2YXIgY2hpbGRUb0RlbGV0ZT1kZWxldGlvbnNbaV07dHJ5e2NvbW1pdERlbGV0aW9uRWZmZWN0cyhyb290LHBhcmVudEZpYmVyLGNoaWxkVG9EZWxldGUpO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY2hpbGRUb0RlbGV0ZSxwYXJlbnRGaWJlcixlcnJvcik7fX19dmFyIHByZXZEZWJ1Z0ZpYmVyPWdldEN1cnJlbnRGaWJlcigpO2lmKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyZNdXRhdGlvbk1hc2spe3ZhciBjaGlsZD1wYXJlbnRGaWJlci5jaGlsZDt3aGlsZShjaGlsZCE9PW51bGwpe3NldEN1cnJlbnRGaWJlcihjaGlsZCk7Y29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihjaGlsZCxyb290KTtjaGlsZD1jaGlsZC5zaWJsaW5nO319c2V0Q3VycmVudEZpYmVyKHByZXZEZWJ1Z0ZpYmVyKTt9ZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmsscm9vdCxsYW5lcyl7dmFyIGN1cnJlbnQ9ZmluaXNoZWRXb3JrLmFsdGVybmF0ZTt2YXIgZmxhZ3M9ZmluaXNoZWRXb3JrLmZsYWdzOy8vIFRoZSBlZmZlY3QgZmxhZyBzaG91bGQgYmUgY2hlY2tlZCAqYWZ0ZXIqIHdlIHJlZmluZSB0aGUgdHlwZSBvZiBmaWJlcixcbi8vIGJlY2F1c2UgdGhlIGZpYmVyIHRhZyBpcyBtb3JlIHNwZWNpZmljLiBBbiBleGNlcHRpb24gaXMgYW55IGZsYWcgcmVsYXRlZFxuLy8gdG8gcmVjb25jaWxhdGlvbiwgYmVjYXVzZSB0aG9zZSBjYW4gYmUgc2V0IG9uIGFsbCBmaWJlciB0eXBlcy5cbnN3aXRjaChmaW5pc2hlZFdvcmsudGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgRm9yd2FyZFJlZjpjYXNlIE1lbW9Db21wb25lbnQ6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OntyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsZmluaXNoZWRXb3JrKTtjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtpZihmbGFncyZVcGRhdGUpe3RyeXtjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoSW5zZXJ0aW9ufEhhc0VmZmVjdCxmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybik7Y29tbWl0SG9va0VmZmVjdExpc3RNb3VudChJbnNlcnRpb258SGFzRWZmZWN0LGZpbmlzaGVkV29yayk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybixlcnJvcik7fS8vIExheW91dCBlZmZlY3RzIGFyZSBkZXN0cm95ZWQgZHVyaW5nIHRoZSBtdXRhdGlvbiBwaGFzZSBzbyB0aGF0IGFsbFxuLy8gZGVzdHJveSBmdW5jdGlvbnMgZm9yIGFsbCBmaWJlcnMgYXJlIGNhbGxlZCBiZWZvcmUgYW55IGNyZWF0ZSBmdW5jdGlvbnMuXG4vLyBUaGlzIHByZXZlbnRzIHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4vLyBlLmcuIGEgZGVzdHJveSBmdW5jdGlvbiBpbiBvbmUgY29tcG9uZW50IHNob3VsZCBuZXZlciBvdmVycmlkZSBhIHJlZiBzZXRcbi8vIGJ5IGEgY3JlYXRlIGZ1bmN0aW9uIGluIGFub3RoZXIgY29tcG9uZW50IGR1cmluZyB0aGUgc2FtZSBjb21taXQuXG5pZihmaW5pc2hlZFdvcmsubW9kZSZQcm9maWxlTW9kZSl7dHJ5e3N0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0fEhhc0VmZmVjdCxmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybik7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybixlcnJvcik7fXJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7fWVsc2V7dHJ5e2NvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXR8SGFzRWZmZWN0LGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuLGVycm9yKTt9fX1yZXR1cm47fWNhc2UgQ2xhc3NDb21wb25lbnQ6e3JlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCxmaW5pc2hlZFdvcmspO2NvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO2lmKGZsYWdzJlJlZil7aWYoY3VycmVudCE9PW51bGwpe3NhZmVseURldGFjaFJlZihjdXJyZW50LGN1cnJlbnQucmV0dXJuKTt9fXJldHVybjt9Y2FzZSBIb3N0Q29tcG9uZW50OntyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsZmluaXNoZWRXb3JrKTtjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtpZihmbGFncyZSZWYpe2lmKGN1cnJlbnQhPT1udWxsKXtzYWZlbHlEZXRhY2hSZWYoY3VycmVudCxjdXJyZW50LnJldHVybik7fX17Ly8gVE9ETzogQ29udGVudFJlc2V0IGdldHMgY2xlYXJlZCBieSB0aGUgY2hpbGRyZW4gZHVyaW5nIHRoZSBjb21taXRcbi8vIHBoYXNlLiBUaGlzIGlzIGEgcmVmYWN0b3IgaGF6YXJkIGJlY2F1c2UgaXQgbWVhbnMgd2UgbXVzdCByZWFkXG4vLyBmbGFncyB0aGUgZmxhZ3MgYWZ0ZXIgYGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0c2AgaGFzIGFscmVhZHkgcnVuO1xuLy8gdGhlIG9yZGVyIG1hdHRlcnMuIFdlIHNob3VsZCByZWZhY3RvciBzbyB0aGF0IENvbnRlbnRSZXNldCBkb2VzIG5vdFxuLy8gcmVseSBvbiBtdXRhdGluZyB0aGUgZmxhZyBkdXJpbmcgY29tbWl0LiBMaWtlIGJ5IHNldHRpbmcgYSBmbGFnXG4vLyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSBpbnN0ZWFkLlxuaWYoZmluaXNoZWRXb3JrLmZsYWdzJkNvbnRlbnRSZXNldCl7dmFyIGluc3RhbmNlPWZpbmlzaGVkV29yay5zdGF0ZU5vZGU7dHJ5e3Jlc2V0VGV4dENvbnRlbnQoaW5zdGFuY2UpO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4sZXJyb3IpO319aWYoZmxhZ3MmVXBkYXRlKXt2YXIgX2luc3RhbmNlND1maW5pc2hlZFdvcmsuc3RhdGVOb2RlO2lmKF9pbnN0YW5jZTQhPW51bGwpey8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxudmFyIG5ld1Byb3BzPWZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzOy8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbi8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuLy8gdGhpcyBjYXNlLlxudmFyIG9sZFByb3BzPWN1cnJlbnQhPT1udWxsP2N1cnJlbnQubWVtb2l6ZWRQcm9wczpuZXdQcm9wczt2YXIgdHlwZT1maW5pc2hlZFdvcmsudHlwZTsvLyBUT0RPOiBUeXBlIHRoZSB1cGRhdGVRdWV1ZSB0byBiZSBzcGVjaWZpYyB0byBob3N0IGNvbXBvbmVudHMuXG52YXIgdXBkYXRlUGF5bG9hZD1maW5pc2hlZFdvcmsudXBkYXRlUXVldWU7ZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlPW51bGw7aWYodXBkYXRlUGF5bG9hZCE9PW51bGwpe3RyeXtjb21taXRVcGRhdGUoX2luc3RhbmNlNCx1cGRhdGVQYXlsb2FkLHR5cGUsb2xkUHJvcHMsbmV3UHJvcHMsZmluaXNoZWRXb3JrKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuLGVycm9yKTt9fX19fXJldHVybjt9Y2FzZSBIb3N0VGV4dDp7cmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LGZpbmlzaGVkV29yayk7Y29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7aWYoZmxhZ3MmVXBkYXRlKXt7aWYoZmluaXNoZWRXb3JrLnN0YXRlTm9kZT09PW51bGwpe3Rocm93IG5ldyBFcnJvcignVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJysnY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9dmFyIHRleHRJbnN0YW5jZT1maW5pc2hlZFdvcmsuc3RhdGVOb2RlO3ZhciBuZXdUZXh0PWZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzOy8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbi8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuLy8gdGhpcyBjYXNlLlxudmFyIG9sZFRleHQ9Y3VycmVudCE9PW51bGw/Y3VycmVudC5tZW1vaXplZFByb3BzOm5ld1RleHQ7dHJ5e2NvbW1pdFRleHRVcGRhdGUodGV4dEluc3RhbmNlLG9sZFRleHQsbmV3VGV4dCk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybixlcnJvcik7fX19cmV0dXJuO31jYXNlIEhvc3RSb290OntyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsZmluaXNoZWRXb3JrKTtjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtpZihmbGFncyZVcGRhdGUpe3tpZihjdXJyZW50IT09bnVsbCl7dmFyIHByZXZSb290U3RhdGU9Y3VycmVudC5tZW1vaXplZFN0YXRlO2lmKHByZXZSb290U3RhdGUuaXNEZWh5ZHJhdGVkKXt0cnl7Y29tbWl0SHlkcmF0ZWRDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuLGVycm9yKTt9fX19fXJldHVybjt9Y2FzZSBIb3N0UG9ydGFsOntyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsZmluaXNoZWRXb3JrKTtjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtyZXR1cm47fWNhc2UgU3VzcGVuc2VDb21wb25lbnQ6e3JlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCxmaW5pc2hlZFdvcmspO2NvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO3ZhciBvZmZzY3JlZW5GaWJlcj1maW5pc2hlZFdvcmsuY2hpbGQ7aWYob2Zmc2NyZWVuRmliZXIuZmxhZ3MmVmlzaWJpbGl0eSl7dmFyIG9mZnNjcmVlbkluc3RhbmNlPW9mZnNjcmVlbkZpYmVyLnN0YXRlTm9kZTt2YXIgbmV3U3RhdGU9b2Zmc2NyZWVuRmliZXIubWVtb2l6ZWRTdGF0ZTt2YXIgaXNIaWRkZW49bmV3U3RhdGUhPT1udWxsOy8vIFRyYWNrIHRoZSBjdXJyZW50IHN0YXRlIG9uIHRoZSBPZmZzY3JlZW4gaW5zdGFuY2Ugc28gd2UgY2FuXG4vLyByZWFkIGl0IGR1cmluZyBhbiBldmVudFxub2Zmc2NyZWVuSW5zdGFuY2UuaXNIaWRkZW49aXNIaWRkZW47aWYoaXNIaWRkZW4pe3ZhciB3YXNIaWRkZW49b2Zmc2NyZWVuRmliZXIuYWx0ZXJuYXRlIT09bnVsbCYmb2Zmc2NyZWVuRmliZXIuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUhPT1udWxsO2lmKCF3YXNIaWRkZW4pey8vIFRPRE86IE1vdmUgdG8gcGFzc2l2ZSBwaGFzZVxubWFya0NvbW1pdFRpbWVPZkZhbGxiYWNrKCk7fX19aWYoZmxhZ3MmVXBkYXRlKXt0cnl7Y29tbWl0U3VzcGVuc2VDYWxsYmFjayhmaW5pc2hlZFdvcmspO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4sZXJyb3IpO31hdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7fXJldHVybjt9Y2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6e3ZhciBfd2FzSGlkZGVuPWN1cnJlbnQhPT1udWxsJiZjdXJyZW50Lm1lbW9pemVkU3RhdGUhPT1udWxsO2lmKC8vIFRPRE86IFJlbW92ZSB0aGlzIGRlYWQgZmxhZ1xuZmluaXNoZWRXb3JrLm1vZGUmQ29uY3VycmVudE1vZGUpey8vIEJlZm9yZSBjb21taXR0aW5nIHRoZSBjaGlsZHJlbiwgdHJhY2sgb24gdGhlIHN0YWNrIHdoZXRoZXIgdGhpc1xuLy8gb2Zmc2NyZWVuIHN1YnRyZWUgd2FzIGFscmVhZHkgaGlkZGVuLCBzbyB0aGF0IHdlIGRvbid0IHVubW91bnQgdGhlXG4vLyBlZmZlY3RzIGFnYWluLlxudmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuPW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47b2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbj1wcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbnx8X3dhc0hpZGRlbjtyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsZmluaXNoZWRXb3JrKTtvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuPXByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO31lbHNle3JlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCxmaW5pc2hlZFdvcmspO31jb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtpZihmbGFncyZWaXNpYmlsaXR5KXt2YXIgX29mZnNjcmVlbkluc3RhbmNlPWZpbmlzaGVkV29yay5zdGF0ZU5vZGU7dmFyIF9uZXdTdGF0ZT1maW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTt2YXIgX2lzSGlkZGVuPV9uZXdTdGF0ZSE9PW51bGw7dmFyIG9mZnNjcmVlbkJvdW5kYXJ5PWZpbmlzaGVkV29yazsvLyBUcmFjayB0aGUgY3VycmVudCBzdGF0ZSBvbiB0aGUgT2Zmc2NyZWVuIGluc3RhbmNlIHNvIHdlIGNhblxuLy8gcmVhZCBpdCBkdXJpbmcgYW4gZXZlbnRcbl9vZmZzY3JlZW5JbnN0YW5jZS5pc0hpZGRlbj1faXNIaWRkZW47e2lmKF9pc0hpZGRlbil7aWYoIV93YXNIaWRkZW4pe2lmKChvZmZzY3JlZW5Cb3VuZGFyeS5tb2RlJkNvbmN1cnJlbnRNb2RlKSE9PU5vTW9kZSl7bmV4dEVmZmVjdD1vZmZzY3JlZW5Cb3VuZGFyeTt2YXIgb2Zmc2NyZWVuQ2hpbGQ9b2Zmc2NyZWVuQm91bmRhcnkuY2hpbGQ7d2hpbGUob2Zmc2NyZWVuQ2hpbGQhPT1udWxsKXtuZXh0RWZmZWN0PW9mZnNjcmVlbkNoaWxkO2Rpc2FwcGVhckxheW91dEVmZmVjdHNfYmVnaW4ob2Zmc2NyZWVuQ2hpbGQpO29mZnNjcmVlbkNoaWxkPW9mZnNjcmVlbkNoaWxkLnNpYmxpbmc7fX19fX17Ly8gVE9ETzogVGhpcyBuZWVkcyB0byBydW4gd2hlbmV2ZXIgdGhlcmUncyBhbiBpbnNlcnRpb24gb3IgdXBkYXRlXG4vLyBpbnNpZGUgYSBoaWRkZW4gT2Zmc2NyZWVuIHRyZWUuXG5oaWRlT3JVbmhpZGVBbGxDaGlsZHJlbihvZmZzY3JlZW5Cb3VuZGFyeSxfaXNIaWRkZW4pO319cmV0dXJuO31jYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDp7cmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LGZpbmlzaGVkV29yayk7Y29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7aWYoZmxhZ3MmVXBkYXRlKXthdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7fXJldHVybjt9Y2FzZSBTY29wZUNvbXBvbmVudDp7cmV0dXJuO31kZWZhdWx0OntyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsZmluaXNoZWRXb3JrKTtjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtyZXR1cm47fX19ZnVuY3Rpb24gY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayl7Ly8gUGxhY2VtZW50IGVmZmVjdHMgKGluc2VydGlvbnMsIHJlb3JkZXJzKSBjYW4gYmUgc2NoZWR1bGVkIG9uIGFueSBmaWJlclxuLy8gdHlwZS4gVGhleSBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgdGhlIGNoaWxkcmVuIGVmZmVjdHMgaGF2ZSBmaXJlZCwgYnV0XG4vLyBiZWZvcmUgdGhlIGVmZmVjdHMgb24gdGhpcyBmaWJlciBoYXZlIGZpcmVkLlxudmFyIGZsYWdzPWZpbmlzaGVkV29yay5mbGFncztpZihmbGFncyZQbGFjZW1lbnQpe3RyeXtjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuLGVycm9yKTt9Ly8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXNcbi8vIGluc2VydGVkLCBiZWZvcmUgYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4vLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkIGRvZXNcbi8vIGFuZCBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZCBhbnl3YXkgc28gd2Ugc2hvdWxkIGJlIGFibGUgdG8ga2lsbCB0aGlzLlxuZmluaXNoZWRXb3JrLmZsYWdzJj1+UGxhY2VtZW50O31pZihmbGFncyZIeWRyYXRpbmcpe2ZpbmlzaGVkV29yay5mbGFncyY9fkh5ZHJhdGluZzt9fWZ1bmN0aW9uIGNvbW1pdExheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLHJvb3QsY29tbWl0dGVkTGFuZXMpe2luUHJvZ3Jlc3NMYW5lcz1jb21taXR0ZWRMYW5lcztpblByb2dyZXNzUm9vdD1yb290O25leHRFZmZlY3Q9ZmluaXNoZWRXb3JrO2NvbW1pdExheW91dEVmZmVjdHNfYmVnaW4oZmluaXNoZWRXb3JrLHJvb3QsY29tbWl0dGVkTGFuZXMpO2luUHJvZ3Jlc3NMYW5lcz1udWxsO2luUHJvZ3Jlc3NSb290PW51bGw7fWZ1bmN0aW9uIGNvbW1pdExheW91dEVmZmVjdHNfYmVnaW4oc3VidHJlZVJvb3Qscm9vdCxjb21taXR0ZWRMYW5lcyl7Ly8gU3VzcGVuc2UgbGF5b3V0IGVmZmVjdHMgc2VtYW50aWNzIGRvbid0IGNoYW5nZSBmb3IgbGVnYWN5IHJvb3RzLlxudmFyIGlzTW9kZXJuUm9vdD0oc3VidHJlZVJvb3QubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGU7d2hpbGUobmV4dEVmZmVjdCE9PW51bGwpe3ZhciBmaWJlcj1uZXh0RWZmZWN0O3ZhciBmaXJzdENoaWxkPWZpYmVyLmNoaWxkO2lmKGZpYmVyLnRhZz09PU9mZnNjcmVlbkNvbXBvbmVudCYmaXNNb2Rlcm5Sb290KXsvLyBLZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IE9mZnNjcmVlbiBzdGFjaydzIHN0YXRlLlxudmFyIGlzSGlkZGVuPWZpYmVyLm1lbW9pemVkU3RhdGUhPT1udWxsO3ZhciBuZXdPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW49aXNIaWRkZW58fG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtpZihuZXdPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4pey8vIFRoZSBPZmZzY3JlZW4gdHJlZSBpcyBoaWRkZW4uIFNraXAgb3ZlciBpdHMgbGF5b3V0IGVmZmVjdHMuXG5jb21taXRMYXlvdXRNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3Qscm9vdCxjb21taXR0ZWRMYW5lcyk7Y29udGludWU7fWVsc2V7Ly8gVE9ETyAoT2Zmc2NyZWVuKSBBbHNvIGNoZWNrOiBzdWJ0cmVlRmxhZ3MgJiBMYXlvdXRNYXNrXG52YXIgY3VycmVudD1maWJlci5hbHRlcm5hdGU7dmFyIHdhc0hpZGRlbj1jdXJyZW50IT09bnVsbCYmY3VycmVudC5tZW1vaXplZFN0YXRlIT09bnVsbDt2YXIgbmV3T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbj13YXNIaWRkZW58fG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47dmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW49b2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO3ZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbj1vZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuOy8vIFRyYXZlcnNlIHRoZSBPZmZzY3JlZW4gc3VidHJlZSB3aXRoIHRoZSBjdXJyZW50IE9mZnNjcmVlbiBhcyB0aGUgcm9vdC5cbm9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbj1uZXdPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47b2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbj1uZXdPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO2lmKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4mJiFwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbil7Ly8gVGhpcyBpcyB0aGUgcm9vdCBvZiBhIHJlYXBwZWFyaW5nIGJvdW5kYXJ5LiBUdXJuIGl0cyBsYXlvdXQgZWZmZWN0c1xuLy8gYmFjayBvbi5cbm5leHRFZmZlY3Q9ZmliZXI7cmVhcHBlYXJMYXlvdXRFZmZlY3RzX2JlZ2luKGZpYmVyKTt9dmFyIGNoaWxkPWZpcnN0Q2hpbGQ7d2hpbGUoY2hpbGQhPT1udWxsKXtuZXh0RWZmZWN0PWNoaWxkO2NvbW1pdExheW91dEVmZmVjdHNfYmVnaW4oY2hpbGQsLy8gTmV3IHJvb3Q7IGJ1YmJsZSBiYWNrIHVwIHRvIGhlcmUgYW5kIHN0b3AuXG5yb290LGNvbW1pdHRlZExhbmVzKTtjaGlsZD1jaGlsZC5zaWJsaW5nO30vLyBSZXN0b3JlIE9mZnNjcmVlbiBzdGF0ZSBhbmQgcmVzdW1lIGluIG91ci1wcm9ncmVzcyB0cmF2ZXJzYWwuXG5uZXh0RWZmZWN0PWZpYmVyO29mZnNjcmVlblN1YnRyZWVJc0hpZGRlbj1wcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO29mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW49cHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47Y29tbWl0TGF5b3V0TW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LHJvb3QsY29tbWl0dGVkTGFuZXMpO2NvbnRpbnVlO319aWYoKGZpYmVyLnN1YnRyZWVGbGFncyZMYXlvdXRNYXNrKSE9PU5vRmxhZ3MmJmZpcnN0Q2hpbGQhPT1udWxsKXtmaXJzdENoaWxkLnJldHVybj1maWJlcjtuZXh0RWZmZWN0PWZpcnN0Q2hpbGQ7fWVsc2V7Y29tbWl0TGF5b3V0TW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LHJvb3QsY29tbWl0dGVkTGFuZXMpO319fWZ1bmN0aW9uIGNvbW1pdExheW91dE1vdW50RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCxyb290LGNvbW1pdHRlZExhbmVzKXt3aGlsZShuZXh0RWZmZWN0IT09bnVsbCl7dmFyIGZpYmVyPW5leHRFZmZlY3Q7aWYoKGZpYmVyLmZsYWdzJkxheW91dE1hc2spIT09Tm9GbGFncyl7dmFyIGN1cnJlbnQ9ZmliZXIuYWx0ZXJuYXRlO3NldEN1cnJlbnRGaWJlcihmaWJlcik7dHJ5e2NvbW1pdExheW91dEVmZmVjdE9uRmliZXIocm9vdCxjdXJyZW50LGZpYmVyLGNvbW1pdHRlZExhbmVzKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLGZpYmVyLnJldHVybixlcnJvcik7fXJlc2V0Q3VycmVudEZpYmVyKCk7fWlmKGZpYmVyPT09c3VidHJlZVJvb3Qpe25leHRFZmZlY3Q9bnVsbDtyZXR1cm47fXZhciBzaWJsaW5nPWZpYmVyLnNpYmxpbmc7aWYoc2libGluZyE9PW51bGwpe3NpYmxpbmcucmV0dXJuPWZpYmVyLnJldHVybjtuZXh0RWZmZWN0PXNpYmxpbmc7cmV0dXJuO31uZXh0RWZmZWN0PWZpYmVyLnJldHVybjt9fWZ1bmN0aW9uIGRpc2FwcGVhckxheW91dEVmZmVjdHNfYmVnaW4oc3VidHJlZVJvb3Qpe3doaWxlKG5leHRFZmZlY3QhPT1udWxsKXt2YXIgZmliZXI9bmV4dEVmZmVjdDt2YXIgZmlyc3RDaGlsZD1maWJlci5jaGlsZDsvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIChSZWZTdGF0aWMgfCBMYXlvdXRTdGF0aWMpXG5zd2l0Y2goZmliZXIudGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgRm9yd2FyZFJlZjpjYXNlIE1lbW9Db21wb25lbnQ6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OntpZihmaWJlci5tb2RlJlByb2ZpbGVNb2RlKXt0cnl7c3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO2NvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQsZmliZXIsZmliZXIucmV0dXJuKTt9ZmluYWxseXtyZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaWJlcik7fX1lbHNle2NvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQsZmliZXIsZmliZXIucmV0dXJuKTt9YnJlYWs7fWNhc2UgQ2xhc3NDb21wb25lbnQ6ey8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgUmVmU3RhdGljXG5zYWZlbHlEZXRhY2hSZWYoZmliZXIsZmliZXIucmV0dXJuKTt2YXIgaW5zdGFuY2U9ZmliZXIuc3RhdGVOb2RlO2lmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudD09PSdmdW5jdGlvbicpe3NhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChmaWJlcixmaWJlci5yZXR1cm4saW5zdGFuY2UpO31icmVhazt9Y2FzZSBIb3N0Q29tcG9uZW50OntzYWZlbHlEZXRhY2hSZWYoZmliZXIsZmliZXIucmV0dXJuKTticmVhazt9Y2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6ey8vIENoZWNrIGlmIHRoaXMgaXMgYVxudmFyIGlzSGlkZGVuPWZpYmVyLm1lbW9pemVkU3RhdGUhPT1udWxsO2lmKGlzSGlkZGVuKXsvLyBOZXN0ZWQgT2Zmc2NyZWVuIHRyZWUgaXMgYWxyZWFkeSBoaWRkZW4uIERvbid0IGRpc2FwcGVhclxuLy8gaXRzIGVmZmVjdHMuXG5kaXNhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KTtjb250aW51ZTt9YnJlYWs7fX0vLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBzdWJ0cmVlRmxhZ3MgJiBMYXlvdXRTdGF0aWNcbmlmKGZpcnN0Q2hpbGQhPT1udWxsKXtmaXJzdENoaWxkLnJldHVybj1maWJlcjtuZXh0RWZmZWN0PWZpcnN0Q2hpbGQ7fWVsc2V7ZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCk7fX19ZnVuY3Rpb24gZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCl7d2hpbGUobmV4dEVmZmVjdCE9PW51bGwpe3ZhciBmaWJlcj1uZXh0RWZmZWN0O2lmKGZpYmVyPT09c3VidHJlZVJvb3Qpe25leHRFZmZlY3Q9bnVsbDtyZXR1cm47fXZhciBzaWJsaW5nPWZpYmVyLnNpYmxpbmc7aWYoc2libGluZyE9PW51bGwpe3NpYmxpbmcucmV0dXJuPWZpYmVyLnJldHVybjtuZXh0RWZmZWN0PXNpYmxpbmc7cmV0dXJuO31uZXh0RWZmZWN0PWZpYmVyLnJldHVybjt9fWZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbihzdWJ0cmVlUm9vdCl7d2hpbGUobmV4dEVmZmVjdCE9PW51bGwpe3ZhciBmaWJlcj1uZXh0RWZmZWN0O3ZhciBmaXJzdENoaWxkPWZpYmVyLmNoaWxkO2lmKGZpYmVyLnRhZz09PU9mZnNjcmVlbkNvbXBvbmVudCl7dmFyIGlzSGlkZGVuPWZpYmVyLm1lbW9pemVkU3RhdGUhPT1udWxsO2lmKGlzSGlkZGVuKXsvLyBOZXN0ZWQgT2Zmc2NyZWVuIHRyZWUgaXMgc3RpbGwgaGlkZGVuLiBEb24ndCByZS1hcHBlYXIgaXRzIGVmZmVjdHMuXG5yZWFwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpO2NvbnRpbnVlO319Ly8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogc3VidHJlZUZsYWdzICYgTGF5b3V0U3RhdGljXG5pZihmaXJzdENoaWxkIT09bnVsbCl7Ly8gVGhpcyBub2RlIG1heSBoYXZlIGJlZW4gcmV1c2VkIGZyb20gYSBwcmV2aW91cyByZW5kZXIsIHNvIHdlIGNhbid0XG4vLyBhc3N1bWUgaXRzIHJldHVybiBwb2ludGVyIGlzIGNvcnJlY3QuXG5maXJzdENoaWxkLnJldHVybj1maWJlcjtuZXh0RWZmZWN0PWZpcnN0Q2hpbGQ7fWVsc2V7cmVhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KTt9fX1mdW5jdGlvbiByZWFwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3Qpe3doaWxlKG5leHRFZmZlY3QhPT1udWxsKXt2YXIgZmliZXI9bmV4dEVmZmVjdDsvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIExheW91dFN0YXRpY1xuc2V0Q3VycmVudEZpYmVyKGZpYmVyKTt0cnl7cmVhcHBlYXJMYXlvdXRFZmZlY3RzT25GaWJlcihmaWJlcik7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlcixmaWJlci5yZXR1cm4sZXJyb3IpO31yZXNldEN1cnJlbnRGaWJlcigpO2lmKGZpYmVyPT09c3VidHJlZVJvb3Qpe25leHRFZmZlY3Q9bnVsbDtyZXR1cm47fXZhciBzaWJsaW5nPWZpYmVyLnNpYmxpbmc7aWYoc2libGluZyE9PW51bGwpey8vIFRoaXMgbm9kZSBtYXkgaGF2ZSBiZWVuIHJldXNlZCBmcm9tIGEgcHJldmlvdXMgcmVuZGVyLCBzbyB3ZSBjYW4ndFxuLy8gYXNzdW1lIGl0cyByZXR1cm4gcG9pbnRlciBpcyBjb3JyZWN0Llxuc2libGluZy5yZXR1cm49ZmliZXIucmV0dXJuO25leHRFZmZlY3Q9c2libGluZztyZXR1cm47fW5leHRFZmZlY3Q9ZmliZXIucmV0dXJuO319ZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0cyhyb290LGZpbmlzaGVkV29yayxjb21taXR0ZWRMYW5lcyxjb21taXR0ZWRUcmFuc2l0aW9ucyl7bmV4dEVmZmVjdD1maW5pc2hlZFdvcms7Y29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c19iZWdpbihmaW5pc2hlZFdvcmsscm9vdCxjb21taXR0ZWRMYW5lcyxjb21taXR0ZWRUcmFuc2l0aW9ucyk7fWZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfYmVnaW4oc3VidHJlZVJvb3Qscm9vdCxjb21taXR0ZWRMYW5lcyxjb21taXR0ZWRUcmFuc2l0aW9ucyl7d2hpbGUobmV4dEVmZmVjdCE9PW51bGwpe3ZhciBmaWJlcj1uZXh0RWZmZWN0O3ZhciBmaXJzdENoaWxkPWZpYmVyLmNoaWxkO2lmKChmaWJlci5zdWJ0cmVlRmxhZ3MmUGFzc2l2ZU1hc2spIT09Tm9GbGFncyYmZmlyc3RDaGlsZCE9PW51bGwpe2ZpcnN0Q2hpbGQucmV0dXJuPWZpYmVyO25leHRFZmZlY3Q9Zmlyc3RDaGlsZDt9ZWxzZXtjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LHJvb3QsY29tbWl0dGVkTGFuZXMsY29tbWl0dGVkVHJhbnNpdGlvbnMpO319fWZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3Qscm9vdCxjb21taXR0ZWRMYW5lcyxjb21taXR0ZWRUcmFuc2l0aW9ucyl7d2hpbGUobmV4dEVmZmVjdCE9PW51bGwpe3ZhciBmaWJlcj1uZXh0RWZmZWN0O2lmKChmaWJlci5mbGFncyZQYXNzaXZlKSE9PU5vRmxhZ3Mpe3NldEN1cnJlbnRGaWJlcihmaWJlcik7dHJ5e2NvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIocm9vdCxmaWJlcixjb21taXR0ZWRMYW5lcyxjb21taXR0ZWRUcmFuc2l0aW9ucyk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlcixmaWJlci5yZXR1cm4sZXJyb3IpO31yZXNldEN1cnJlbnRGaWJlcigpO31pZihmaWJlcj09PXN1YnRyZWVSb290KXtuZXh0RWZmZWN0PW51bGw7cmV0dXJuO312YXIgc2libGluZz1maWJlci5zaWJsaW5nO2lmKHNpYmxpbmchPT1udWxsKXtzaWJsaW5nLnJldHVybj1maWJlci5yZXR1cm47bmV4dEVmZmVjdD1zaWJsaW5nO3JldHVybjt9bmV4dEVmZmVjdD1maWJlci5yZXR1cm47fX1mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKGZpbmlzaGVkUm9vdCxmaW5pc2hlZFdvcmssY29tbWl0dGVkTGFuZXMsY29tbWl0dGVkVHJhbnNpdGlvbnMpe3N3aXRjaChmaW5pc2hlZFdvcmsudGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgRm9yd2FyZFJlZjpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e2lmKGZpbmlzaGVkV29yay5tb2RlJlByb2ZpbGVNb2RlKXtzdGFydFBhc3NpdmVFZmZlY3RUaW1lcigpO3RyeXtjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KFBhc3NpdmUkMXxIYXNFZmZlY3QsZmluaXNoZWRXb3JrKTt9ZmluYWxseXtyZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTt9fWVsc2V7Y29tbWl0SG9va0VmZmVjdExpc3RNb3VudChQYXNzaXZlJDF8SGFzRWZmZWN0LGZpbmlzaGVkV29yayk7fWJyZWFrO319fWZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaXJzdENoaWxkKXtuZXh0RWZmZWN0PWZpcnN0Q2hpbGQ7Y29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzX2JlZ2luKCk7fWZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19iZWdpbigpe3doaWxlKG5leHRFZmZlY3QhPT1udWxsKXt2YXIgZmliZXI9bmV4dEVmZmVjdDt2YXIgY2hpbGQ9ZmliZXIuY2hpbGQ7aWYoKG5leHRFZmZlY3QuZmxhZ3MmQ2hpbGREZWxldGlvbikhPT1Ob0ZsYWdzKXt2YXIgZGVsZXRpb25zPWZpYmVyLmRlbGV0aW9ucztpZihkZWxldGlvbnMhPT1udWxsKXtmb3IodmFyIGk9MDtpPGRlbGV0aW9ucy5sZW5ndGg7aSsrKXt2YXIgZmliZXJUb0RlbGV0ZT1kZWxldGlvbnNbaV07bmV4dEVmZmVjdD1maWJlclRvRGVsZXRlO2NvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oZmliZXJUb0RlbGV0ZSxmaWJlcik7fXsvLyBBIGZpYmVyIHdhcyBkZWxldGVkIGZyb20gdGhpcyBwYXJlbnQgZmliZXIsIGJ1dCBpdCdzIHN0aWxsIHBhcnQgb2Zcbi8vIHRoZSBwcmV2aW91cyAoYWx0ZXJuYXRlKSBwYXJlbnQgZmliZXIncyBsaXN0IG9mIGNoaWxkcmVuLiBCZWNhdXNlXG4vLyBjaGlsZHJlbiBhcmUgYSBsaW5rZWQgbGlzdCwgYW4gZWFybGllciBzaWJsaW5nIHRoYXQncyBzdGlsbCBhbGl2ZVxuLy8gd2lsbCBiZSBjb25uZWN0ZWQgdG8gdGhlIGRlbGV0ZWQgZmliZXIgdmlhIGl0cyBgYWx0ZXJuYXRlYDpcbi8vXG4vLyAgIGxpdmUgZmliZXJcbi8vICAgLS1hbHRlcm5hdGUtLT4gcHJldmlvdXMgbGl2ZSBmaWJlclxuLy8gICAtLXNpYmxpbmctLT4gZGVsZXRlZCBmaWJlclxuLy9cbi8vIFdlIGNhbid0IGRpc2Nvbm5lY3QgYGFsdGVybmF0ZWAgb24gbm9kZXMgdGhhdCBoYXZlbid0IGJlZW4gZGVsZXRlZFxuLy8geWV0LCBidXQgd2UgY2FuIGRpc2Nvbm5lY3QgdGhlIGBzaWJsaW5nYCBhbmQgYGNoaWxkYCBwb2ludGVycy5cbnZhciBwcmV2aW91c0ZpYmVyPWZpYmVyLmFsdGVybmF0ZTtpZihwcmV2aW91c0ZpYmVyIT09bnVsbCl7dmFyIGRldGFjaGVkQ2hpbGQ9cHJldmlvdXNGaWJlci5jaGlsZDtpZihkZXRhY2hlZENoaWxkIT09bnVsbCl7cHJldmlvdXNGaWJlci5jaGlsZD1udWxsO2Rve3ZhciBkZXRhY2hlZFNpYmxpbmc9ZGV0YWNoZWRDaGlsZC5zaWJsaW5nO2RldGFjaGVkQ2hpbGQuc2libGluZz1udWxsO2RldGFjaGVkQ2hpbGQ9ZGV0YWNoZWRTaWJsaW5nO313aGlsZShkZXRhY2hlZENoaWxkIT09bnVsbCk7fX19bmV4dEVmZmVjdD1maWJlcjt9fWlmKChmaWJlci5zdWJ0cmVlRmxhZ3MmUGFzc2l2ZU1hc2spIT09Tm9GbGFncyYmY2hpbGQhPT1udWxsKXtjaGlsZC5yZXR1cm49ZmliZXI7bmV4dEVmZmVjdD1jaGlsZDt9ZWxzZXtjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNfY29tcGxldGUoKTt9fX1mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNfY29tcGxldGUoKXt3aGlsZShuZXh0RWZmZWN0IT09bnVsbCl7dmFyIGZpYmVyPW5leHRFZmZlY3Q7aWYoKGZpYmVyLmZsYWdzJlBhc3NpdmUpIT09Tm9GbGFncyl7c2V0Q3VycmVudEZpYmVyKGZpYmVyKTtjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIoZmliZXIpO3Jlc2V0Q3VycmVudEZpYmVyKCk7fXZhciBzaWJsaW5nPWZpYmVyLnNpYmxpbmc7aWYoc2libGluZyE9PW51bGwpe3NpYmxpbmcucmV0dXJuPWZpYmVyLnJldHVybjtuZXh0RWZmZWN0PXNpYmxpbmc7cmV0dXJuO31uZXh0RWZmZWN0PWZpYmVyLnJldHVybjt9fWZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihmaW5pc2hlZFdvcmspe3N3aXRjaChmaW5pc2hlZFdvcmsudGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgRm9yd2FyZFJlZjpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e2lmKGZpbmlzaGVkV29yay5tb2RlJlByb2ZpbGVNb2RlKXtzdGFydFBhc3NpdmVFZmZlY3RUaW1lcigpO2NvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDF8SGFzRWZmZWN0LGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuKTtyZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTt9ZWxzZXtjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoUGFzc2l2ZSQxfEhhc0VmZmVjdCxmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybik7fWJyZWFrO319fWZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oZGVsZXRlZFN1YnRyZWVSb290LG5lYXJlc3RNb3VudGVkQW5jZXN0b3Ipe3doaWxlKG5leHRFZmZlY3QhPT1udWxsKXt2YXIgZmliZXI9bmV4dEVmZmVjdDsvLyBEZWxldGlvbiBlZmZlY3RzIGZpcmUgaW4gcGFyZW50IC0+IGNoaWxkIG9yZGVyXG4vLyBUT0RPOiBDaGVjayBpZiBmaWJlciBoYXMgYSBQYXNzaXZlU3RhdGljIGZsYWdcbnNldEN1cnJlbnRGaWJlcihmaWJlcik7Y29tbWl0UGFzc2l2ZVVubW91bnRJbnNpZGVEZWxldGVkVHJlZU9uRmliZXIoZmliZXIsbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7cmVzZXRDdXJyZW50RmliZXIoKTt2YXIgY2hpbGQ9ZmliZXIuY2hpbGQ7Ly8gVE9ETzogT25seSB0cmF2ZXJzZSBzdWJ0cmVlIGlmIGl0IGhhcyBhIFBhc3NpdmVTdGF0aWMgZmxhZy4gKEJ1dCwgaWYgd2Vcbi8vIGRvIHRoaXMsIHN0aWxsIG5lZWQgdG8gaGFuZGxlIGBkZWxldGVkVHJlZUNsZWFuVXBMZXZlbGAgY29ycmVjdGx5LilcbmlmKGNoaWxkIT09bnVsbCl7Y2hpbGQucmV0dXJuPWZpYmVyO25leHRFZmZlY3Q9Y2hpbGQ7fWVsc2V7Y29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9jb21wbGV0ZShkZWxldGVkU3VidHJlZVJvb3QpO319fWZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfY29tcGxldGUoZGVsZXRlZFN1YnRyZWVSb290KXt3aGlsZShuZXh0RWZmZWN0IT09bnVsbCl7dmFyIGZpYmVyPW5leHRFZmZlY3Q7dmFyIHNpYmxpbmc9ZmliZXIuc2libGluZzt2YXIgcmV0dXJuRmliZXI9ZmliZXIucmV0dXJuO3svLyBSZWN1cnNpdmVseSB0cmF2ZXJzZSB0aGUgZW50aXJlIGRlbGV0ZWQgdHJlZSBhbmQgY2xlYW4gdXAgZmliZXIgZmllbGRzLlxuLy8gVGhpcyBpcyBtb3JlIGFnZ3Jlc3NpdmUgdGhhbiBpZGVhbCwgYW5kIHRoZSBsb25nIHRlcm0gZ29hbCBpcyB0byBvbmx5XG4vLyBoYXZlIHRvIGRldGFjaCB0aGUgZGVsZXRlZCB0cmVlIGF0IHRoZSByb290LlxuZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpO2lmKGZpYmVyPT09ZGVsZXRlZFN1YnRyZWVSb290KXtuZXh0RWZmZWN0PW51bGw7cmV0dXJuO319aWYoc2libGluZyE9PW51bGwpe3NpYmxpbmcucmV0dXJuPXJldHVybkZpYmVyO25leHRFZmZlY3Q9c2libGluZztyZXR1cm47fW5leHRFZmZlY3Q9cmV0dXJuRmliZXI7fX1mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlcihjdXJyZW50LG5lYXJlc3RNb3VudGVkQW5jZXN0b3Ipe3N3aXRjaChjdXJyZW50LnRhZyl7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEZvcndhcmRSZWY6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OntpZihjdXJyZW50Lm1vZGUmUHJvZmlsZU1vZGUpe3N0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCk7Y29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFBhc3NpdmUkMSxjdXJyZW50LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO3JlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbihjdXJyZW50KTt9ZWxzZXtjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoUGFzc2l2ZSQxLGN1cnJlbnQsbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7fWJyZWFrO319fS8vIFRPRE86IFJldXNlIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyB0cmF2ZXJzYWwgaGVyZT9cbmZ1bmN0aW9uIGludm9rZUxheW91dEVmZmVjdE1vdW50SW5ERVYoZmliZXIpe3svLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxuc3dpdGNoKGZpYmVyLnRhZyl7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEZvcndhcmRSZWY6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50Ont0cnl7Y29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXR8SGFzRWZmZWN0LGZpYmVyKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLGZpYmVyLnJldHVybixlcnJvcik7fWJyZWFrO31jYXNlIENsYXNzQ29tcG9uZW50Ont2YXIgaW5zdGFuY2U9ZmliZXIuc3RhdGVOb2RlO3RyeXtpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsZmliZXIucmV0dXJuLGVycm9yKTt9YnJlYWs7fX19fWZ1bmN0aW9uIGludm9rZVBhc3NpdmVFZmZlY3RNb3VudEluREVWKGZpYmVyKXt7Ly8gV2UgZG9uJ3QgbmVlZCB0byByZS1jaGVjayBTdHJpY3RFZmZlY3RzTW9kZSBoZXJlLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cbnN3aXRjaChmaWJlci50YWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBGb3J3YXJkUmVmOmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7dHJ5e2NvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoUGFzc2l2ZSQxfEhhc0VmZmVjdCxmaWJlcik7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlcixmaWJlci5yZXR1cm4sZXJyb3IpO31icmVhazt9fX19ZnVuY3Rpb24gaW52b2tlTGF5b3V0RWZmZWN0VW5tb3VudEluREVWKGZpYmVyKXt7Ly8gV2UgZG9uJ3QgbmVlZCB0byByZS1jaGVjayBTdHJpY3RFZmZlY3RzTW9kZSBoZXJlLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cbnN3aXRjaChmaWJlci50YWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBGb3J3YXJkUmVmOmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7dHJ5e2NvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXR8SGFzRWZmZWN0LGZpYmVyLGZpYmVyLnJldHVybik7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlcixmaWJlci5yZXR1cm4sZXJyb3IpO31icmVhazt9Y2FzZSBDbGFzc0NvbXBvbmVudDp7dmFyIGluc3RhbmNlPWZpYmVyLnN0YXRlTm9kZTtpZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQ9PT0nZnVuY3Rpb24nKXtzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoZmliZXIsZmliZXIucmV0dXJuLGluc3RhbmNlKTt9YnJlYWs7fX19fWZ1bmN0aW9uIGludm9rZVBhc3NpdmVFZmZlY3RVbm1vdW50SW5ERVYoZmliZXIpe3svLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxuc3dpdGNoKGZpYmVyLnRhZyl7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEZvcndhcmRSZWY6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50Ont0cnl7Y29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFBhc3NpdmUkMXxIYXNFZmZlY3QsZmliZXIsZmliZXIucmV0dXJuKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLGZpYmVyLnJldHVybixlcnJvcik7fX19fX12YXIgQ09NUE9ORU5UX1RZUEU9MDt2YXIgSEFTX1BTRVVET19DTEFTU19UWVBFPTE7dmFyIFJPTEVfVFlQRT0yO3ZhciBURVNUX05BTUVfVFlQRT0zO3ZhciBURVhUX1RZUEU9NDtpZih0eXBlb2YgU3ltYm9sPT09J2Z1bmN0aW9uJyYmU3ltYm9sLmZvcil7dmFyIHN5bWJvbEZvcj1TeW1ib2wuZm9yO0NPTVBPTkVOVF9UWVBFPXN5bWJvbEZvcignc2VsZWN0b3IuY29tcG9uZW50Jyk7SEFTX1BTRVVET19DTEFTU19UWVBFPXN5bWJvbEZvcignc2VsZWN0b3IuaGFzX3BzZXVkb19jbGFzcycpO1JPTEVfVFlQRT1zeW1ib2xGb3IoJ3NlbGVjdG9yLnJvbGUnKTtURVNUX05BTUVfVFlQRT1zeW1ib2xGb3IoJ3NlbGVjdG9yLnRlc3RfaWQnKTtURVhUX1RZUEU9c3ltYm9sRm9yKCdzZWxlY3Rvci50ZXh0Jyk7fXZhciBjb21taXRIb29rcz1bXTtmdW5jdGlvbiBvbkNvbW1pdFJvb3QkMSgpe3tjb21taXRIb29rcy5mb3JFYWNoKGZ1bmN0aW9uKGNvbW1pdEhvb2spe3JldHVybiBjb21taXRIb29rKCk7fSk7fX12YXIgUmVhY3RDdXJyZW50QWN0UXVldWU9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QWN0UXVldWU7ZnVuY3Rpb24gaXNMZWdhY3lBY3RFbnZpcm9ubWVudChmaWJlcil7ey8vIExlZ2FjeSBtb2RlLiBXZSBwcmVzZXJ2ZSB0aGUgYmVoYXZpb3Igb2YgUmVhY3QgMTcncyBhY3QuIEl0IGFzc3VtZXMgYW5cbi8vIGFjdCBlbnZpcm9ubWVudCB3aGVuZXZlciBgamVzdGAgaXMgZGVmaW5lZCwgYnV0IHlvdSBjYW4gc3RpbGwgdHVybiBvZmZcbi8vIHNwdXJpb3VzIHdhcm5pbmdzIGJ5IHNldHRpbmcgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIGV4cGxpY2l0bHlcbi8vIHRvIGZhbHNlLlxudmFyIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbD0vLyAkRmxvd0V4cGVjdGVkRXJyb3Ig4oCTIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCBnbG9iYWxcbnR5cGVvZiBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQhPT0ndW5kZWZpbmVkJz9JU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQ6dW5kZWZpbmVkOy8vICRGbG93RXhwZWN0ZWRFcnJvciAtIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IGplc3RcbnZhciBqZXN0SXNEZWZpbmVkPXR5cGVvZiBqZXN0IT09J3VuZGVmaW5lZCc7cmV0dXJuIGplc3RJc0RlZmluZWQmJmlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCE9PWZhbHNlO319ZnVuY3Rpb24gaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKXt7dmFyIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbD0vLyAkRmxvd0V4cGVjdGVkRXJyb3Ig4oCTIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCBnbG9iYWxcbnR5cGVvZiBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQhPT0ndW5kZWZpbmVkJz9JU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQ6dW5kZWZpbmVkO2lmKCFpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwmJlJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQhPT1udWxsKXsvLyBUT0RPOiBJbmNsdWRlIGxpbmsgdG8gcmVsZXZhbnQgZG9jdW1lbnRhdGlvbiBwYWdlLlxuZXJyb3IoJ1RoZSBjdXJyZW50IHRlc3RpbmcgZW52aXJvbm1lbnQgaXMgbm90IGNvbmZpZ3VyZWQgdG8gc3VwcG9ydCAnKydhY3QoLi4uKScpO31yZXR1cm4gaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsO319dmFyIGNlaWw9TWF0aC5jZWlsO3ZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDI9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixSZWFjdEN1cnJlbnRPd25lciQyPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyLFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDM9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsUmVhY3RDdXJyZW50QWN0UXVldWUkMT1SZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRBY3RRdWV1ZTt2YXIgTm9Db250ZXh0PS8qICAgICAgICAgICAgICovMDt2YXIgQmF0Y2hlZENvbnRleHQ9LyogICAgICAgICAgICAgICAqLzE7dmFyIFJlbmRlckNvbnRleHQ9LyogICAgICAgICAgICAgICAgKi8yO3ZhciBDb21taXRDb250ZXh0PS8qICAgICAgICAgICAgICAgICovNDt2YXIgUm9vdEluUHJvZ3Jlc3M9MDt2YXIgUm9vdEZhdGFsRXJyb3JlZD0xO3ZhciBSb290RXJyb3JlZD0yO3ZhciBSb290U3VzcGVuZGVkPTM7dmFyIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk9NDt2YXIgUm9vdENvbXBsZXRlZD01O3ZhciBSb290RGlkTm90Q29tcGxldGU9NjsvLyBEZXNjcmliZXMgd2hlcmUgd2UgYXJlIGluIHRoZSBSZWFjdCBleGVjdXRpb24gc3RhY2tcbnZhciBleGVjdXRpb25Db250ZXh0PU5vQ29udGV4dDsvLyBUaGUgcm9vdCB3ZSdyZSB3b3JraW5nIG9uXG52YXIgd29ya0luUHJvZ3Jlc3NSb290PW51bGw7Ly8gVGhlIGZpYmVyIHdlJ3JlIHdvcmtpbmcgb25cbnZhciB3b3JrSW5Qcm9ncmVzcz1udWxsOy8vIFRoZSBsYW5lcyB3ZSdyZSByZW5kZXJpbmdcbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcz1Ob0xhbmVzOy8vIFN0YWNrIHRoYXQgYWxsb3dzIGNvbXBvbmVudHMgdG8gY2hhbmdlIHRoZSByZW5kZXIgbGFuZXMgZm9yIGl0cyBzdWJ0cmVlXG4vLyBUaGlzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGxhbmVzIHdlIHN0YXJ0ZWQgd29ya2luZyBvbiBhdCB0aGUgcm9vdC4gVGhlIG9ubHlcbi8vIGNhc2Ugd2hlcmUgaXQncyBkaWZmZXJlbnQgZnJvbSBgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNgIGlzIHdoZW4gd2Vcbi8vIGVudGVyIGEgc3VidHJlZSB0aGF0IGlzIGhpZGRlbiBhbmQgbmVlZHMgdG8gYmUgdW5oaWRkZW46IFN1c3BlbnNlIGFuZFxuLy8gT2Zmc2NyZWVuIGNvbXBvbmVudC5cbi8vXG4vLyBNb3N0IHRoaW5ncyBpbiB0aGUgd29yayBsb29wIHNob3VsZCBkZWFsIHdpdGggd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMuXG4vLyBNb3N0IHRoaW5ncyBpbiBiZWdpbi9jb21wbGV0ZSBwaGFzZXMgc2hvdWxkIGRlYWwgd2l0aCBzdWJ0cmVlUmVuZGVyTGFuZXMuXG52YXIgc3VidHJlZVJlbmRlckxhbmVzPU5vTGFuZXM7dmFyIHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvcj1jcmVhdGVDdXJzb3IoTm9MYW5lcyk7Ly8gV2hldGhlciB0byByb290IGNvbXBsZXRlZCwgZXJyb3JlZCwgc3VzcGVuZGVkLCBldGMuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz1Sb290SW5Qcm9ncmVzczsvLyBBIGZhdGFsIGVycm9yLCBpZiBvbmUgaXMgdGhyb3duXG52YXIgd29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvcj1udWxsOy8vIFwiSW5jbHVkZWRcIiBsYW5lcyByZWZlciB0byBsYW5lcyB0aGF0IHdlcmUgd29ya2VkIG9uIGR1cmluZyB0aGlzIHJlbmRlci4gSXQnc1xuLy8gc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gYHJlbmRlckxhbmVzYCBiZWNhdXNlIGByZW5kZXJMYW5lc2AgY2FuIGNoYW5nZSBhcyB5b3Vcbi8vIGVudGVyIGFuZCBleGl0IGFuIE9mZnNjcmVlbiB0cmVlLiBUaGlzIHZhbHVlIGlzIHRoZSBjb21iaW5hdGlvbiBvZiBhbGwgcmVuZGVyXG4vLyBsYW5lcyBmb3IgdGhlIGVudGlyZSByZW5kZXIgcGhhc2UuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcz1Ob0xhbmVzOy8vIFRoZSB3b3JrIGxlZnQgb3ZlciBieSBjb21wb25lbnRzIHRoYXQgd2VyZSB2aXNpdGVkIGR1cmluZyB0aGlzIHJlbmRlci4gT25seVxuLy8gaW5jbHVkZXMgdW5wcm9jZXNzZWQgdXBkYXRlcywgbm90IHdvcmsgaW4gYmFpbGVkIG91dCBjaGlsZHJlbi5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXM9Tm9MYW5lczsvLyBMYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCAoaW4gYW4gaW50ZXJsZWF2ZWQgZXZlbnQpIGR1cmluZyB0aGlzIHJlbmRlci5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcz1Ob0xhbmVzOy8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlICgqbm90KiBhbiBpbnRlcmxlYXZlZCBldmVudCkuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXM9Tm9MYW5lczsvLyBFcnJvcnMgdGhhdCBhcmUgdGhyb3duIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxudmFyIHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnM9bnVsbDsvLyBUaGVzZSBhcmUgZXJyb3JzIHRoYXQgd2UgcmVjb3ZlcmVkIGZyb20gd2l0aG91dCBzdXJmYWNpbmcgdGhlbSB0byB0aGUgVUkuXG4vLyBXZSB3aWxsIGxvZyB0aGVtIG9uY2UgdGhlIHRyZWUgY29tbWl0cy5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycz1udWxsOy8vIFRoZSBtb3N0IHJlY2VudCB0aW1lIHdlIGNvbW1pdHRlZCBhIGZhbGxiYWNrLiBUaGlzIGxldHMgdXMgZW5zdXJlIGEgdHJhaW5cbi8vIG1vZGVsIHdoZXJlIHdlIGRvbid0IGNvbW1pdCBuZXcgbG9hZGluZyBzdGF0ZXMgaW4gdG9vIHF1aWNrIHN1Y2Nlc3Npb24uXG52YXIgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZT0wO3ZhciBGQUxMQkFDS19USFJPVFRMRV9NUz01MDA7Ly8gVGhlIGFic29sdXRlIHRpbWUgZm9yIHdoZW4gd2Ugc2hvdWxkIHN0YXJ0IGdpdmluZyB1cCBvbiByZW5kZXJpbmdcbi8vIG1vcmUgYW5kIHByZWZlciBDUFUgc3VzcGVuc2UgaGV1cmlzdGljcyBpbnN0ZWFkLlxudmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWU9SW5maW5pdHk7Ly8gSG93IGxvbmcgYSByZW5kZXIgaXMgc3VwcG9zZWQgdG8gdGFrZSBiZWZvcmUgd2Ugc3RhcnQgZm9sbG93aW5nIENQVVxuLy8gc3VzcGVuc2UgaGV1cmlzdGljcyBhbmQgb3B0IG91dCBvZiByZW5kZXJpbmcgbW9yZSBjb250ZW50LlxudmFyIFJFTkRFUl9USU1FT1VUX01TPTUwMDt2YXIgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucz1udWxsO2Z1bmN0aW9uIHJlc2V0UmVuZGVyVGltZXIoKXt3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lPW5vdygpK1JFTkRFUl9USU1FT1VUX01TO31mdW5jdGlvbiBnZXRSZW5kZXJUYXJnZXRUaW1lKCl7cmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWU7fXZhciBoYXNVbmNhdWdodEVycm9yPWZhbHNlO3ZhciBmaXJzdFVuY2F1Z2h0RXJyb3I9bnVsbDt2YXIgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQ9bnVsbDsvLyBPbmx5IHVzZWQgd2hlbiBlbmFibGVQcm9maWxlck5lc3RlZFVwZGF0ZVNjaGVkdWxlZEhvb2sgaXMgdHJ1ZTtcbnZhciByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cz1mYWxzZTt2YXIgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHM9bnVsbDt2YXIgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM9Tm9MYW5lczt2YXIgcGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHM9W107dmFyIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnM9bnVsbDsvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG52YXIgTkVTVEVEX1VQREFURV9MSU1JVD01MDt2YXIgbmVzdGVkVXBkYXRlQ291bnQ9MDt2YXIgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzPW51bGw7dmFyIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cz1mYWxzZTt2YXIgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cz1mYWxzZTt2YXIgTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUPTUwO3ZhciBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQ9MDt2YXIgcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcz1udWxsOy8vIElmIHR3byB1cGRhdGVzIGFyZSBzY2hlZHVsZWQgd2l0aGluIHRoZSBzYW1lIGV2ZW50LCB3ZSBzaG91bGQgdHJlYXQgdGhlaXJcbi8vIGV2ZW50IHRpbWVzIGFzIHNpbXVsdGFuZW91cywgZXZlbiBpZiB0aGUgYWN0dWFsIGNsb2NrIHRpbWUgaGFzIGFkdmFuY2VkXG4vLyBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGNhbGwuXG52YXIgY3VycmVudEV2ZW50VGltZT1Ob1RpbWVzdGFtcDt2YXIgY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmU9Tm9MYW5lczt2YXIgaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0PWZhbHNlO2Z1bmN0aW9uIGdldFdvcmtJblByb2dyZXNzUm9vdCgpe3JldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3Q7fWZ1bmN0aW9uIHJlcXVlc3RFdmVudFRpbWUoKXtpZigoZXhlY3V0aW9uQ29udGV4dCYoUmVuZGVyQ29udGV4dHxDb21taXRDb250ZXh0KSkhPT1Ob0NvbnRleHQpey8vIFdlJ3JlIGluc2lkZSBSZWFjdCwgc28gaXQncyBmaW5lIHRvIHJlYWQgdGhlIGFjdHVhbCB0aW1lLlxucmV0dXJuIG5vdygpO30vLyBXZSdyZSBub3QgaW5zaWRlIFJlYWN0LCBzbyB3ZSBtYXkgYmUgaW4gdGhlIG1pZGRsZSBvZiBhIGJyb3dzZXIgZXZlbnQuXG5pZihjdXJyZW50RXZlbnRUaW1lIT09Tm9UaW1lc3RhbXApey8vIFVzZSB0aGUgc2FtZSBzdGFydCB0aW1lIGZvciBhbGwgdXBkYXRlcyB1bnRpbCB3ZSBlbnRlciBSZWFjdCBhZ2Fpbi5cbnJldHVybiBjdXJyZW50RXZlbnRUaW1lO30vLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgc2luY2UgUmVhY3QgeWllbGRlZC4gQ29tcHV0ZSBhIG5ldyBzdGFydCB0aW1lLlxuY3VycmVudEV2ZW50VGltZT1ub3coKTtyZXR1cm4gY3VycmVudEV2ZW50VGltZTt9ZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpey8vIFNwZWNpYWwgY2FzZXNcbnZhciBtb2RlPWZpYmVyLm1vZGU7aWYoKG1vZGUmQ29uY3VycmVudE1vZGUpPT09Tm9Nb2RlKXtyZXR1cm4gU3luY0xhbmU7fWVsc2UgaWYoKGV4ZWN1dGlvbkNvbnRleHQmUmVuZGVyQ29udGV4dCkhPT1Ob0NvbnRleHQmJndvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIT09Tm9MYW5lcyl7Ly8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFRoZXNlIGFyZSBub3Qgb2ZmaWNpYWxseSBzdXBwb3J0ZWQuIFRoZVxuLy8gb2xkIGJlaGF2aW9yIGlzIHRvIGdpdmUgdGhpcyB0aGUgc2FtZSBcInRocmVhZFwiIChsYW5lcykgYXNcbi8vIHdoYXRldmVyIGlzIGN1cnJlbnRseSByZW5kZXJpbmcuIFNvIGlmIHlvdSBjYWxsIGBzZXRTdGF0ZWAgb24gYSBjb21wb25lbnRcbi8vIHRoYXQgaGFwcGVucyBsYXRlciBpbiB0aGUgc2FtZSByZW5kZXIsIGl0IHdpbGwgZmx1c2guIElkZWFsbHksIHdlIHdhbnQgdG9cbi8vIHJlbW92ZSB0aGUgc3BlY2lhbCBjYXNlIGFuZCB0cmVhdCB0aGVtIGFzIGlmIHRoZXkgY2FtZSBmcm9tIGFuXG4vLyBpbnRlcmxlYXZlZCBldmVudC4gUmVnYXJkbGVzcywgdGhpcyBwYXR0ZXJuIGlzIG5vdCBvZmZpY2lhbGx5IHN1cHBvcnRlZC5cbi8vIFRoaXMgYmVoYXZpb3IgaXMgb25seSBhIGZhbGxiYWNrLiBUaGUgZmxhZyBvbmx5IGV4aXN0cyB1bnRpbCB3ZSBjYW4gcm9sbFxuLy8gb3V0IHRoZSBzZXRTdGF0ZSB3YXJuaW5nLCBzaW5jZSBleGlzdGluZyBjb2RlIG1pZ2h0IGFjY2lkZW50YWxseSByZWx5IG9uXG4vLyB0aGUgY3VycmVudCBiZWhhdmlvci5cbnJldHVybiBwaWNrQXJiaXRyYXJ5TGFuZSh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7fXZhciBpc1RyYW5zaXRpb249cmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCkhPT1Ob1RyYW5zaXRpb247aWYoaXNUcmFuc2l0aW9uKXtpZihSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb24hPT1udWxsKXt2YXIgdHJhbnNpdGlvbj1SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb247aWYoIXRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpe3RyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnM9bmV3IFNldCgpO310cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmFkZChmaWJlcik7fS8vIFRoZSBhbGdvcml0aG0gZm9yIGFzc2lnbmluZyBhbiB1cGRhdGUgdG8gYSBsYW5lIHNob3VsZCBiZSBzdGFibGUgZm9yIGFsbFxuLy8gdXBkYXRlcyBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoaW4gdGhlIHNhbWUgZXZlbnQuIFRvIGRvIHRoaXMsIHRoZVxuLy8gaW5wdXRzIHRvIHRoZSBhbGdvcml0aG0gbXVzdCBiZSB0aGUgc2FtZS5cbi8vXG4vLyBUaGUgdHJpY2sgd2UgdXNlIGlzIHRvIGNhY2hlIHRoZSBmaXJzdCBvZiBlYWNoIG9mIHRoZXNlIGlucHV0cyB3aXRoaW4gYW5cbi8vIGV2ZW50LiBUaGVuIHJlc2V0IHRoZSBjYWNoZWQgdmFsdWVzIG9uY2Ugd2UgY2FuIGJlIHN1cmUgdGhlIGV2ZW50IGlzXG4vLyBvdmVyLiBPdXIgaGV1cmlzdGljIGZvciB0aGF0IGlzIHdoZW5ldmVyIHdlIGVudGVyIGEgY29uY3VycmVudCB3b3JrIGxvb3AuXG5pZihjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZT09PU5vTGFuZSl7Ly8gQWxsIHRyYW5zaXRpb25zIHdpdGhpbiB0aGUgc2FtZSBldmVudCBhcmUgYXNzaWduZWQgdGhlIHNhbWUgbGFuZS5cbmN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lPWNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCk7fXJldHVybiBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZTt9Ly8gVXBkYXRlcyBvcmlnaW5hdGluZyBpbnNpZGUgY2VydGFpbiBSZWFjdCBtZXRob2RzLCBsaWtlIGZsdXNoU3luYywgaGF2ZVxuLy8gdGhlaXIgcHJpb3JpdHkgc2V0IGJ5IHRyYWNraW5nIGl0IHdpdGggYSBjb250ZXh0IHZhcmlhYmxlLlxuLy9cbi8vIFRoZSBvcGFxdWUgdHlwZSByZXR1cm5lZCBieSB0aGUgaG9zdCBjb25maWcgaXMgaW50ZXJuYWxseSBhIGxhbmUsIHNvIHdlIGNhblxuLy8gdXNlIHRoYXQgZGlyZWN0bHkuXG4vLyBUT0RPOiBNb3ZlIHRoaXMgdHlwZSBjb252ZXJzaW9uIHRvIHRoZSBldmVudCBwcmlvcml0eSBtb2R1bGUuXG52YXIgdXBkYXRlTGFuZT1nZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtpZih1cGRhdGVMYW5lIT09Tm9MYW5lKXtyZXR1cm4gdXBkYXRlTGFuZTt9Ly8gVGhpcyB1cGRhdGUgb3JpZ2luYXRlZCBvdXRzaWRlIFJlYWN0LiBBc2sgdGhlIGhvc3QgZW52aXJvbm1lbnQgZm9yIGFuXG4vLyBhcHByb3ByaWF0ZSBwcmlvcml0eSwgYmFzZWQgb24gdGhlIHR5cGUgb2YgZXZlbnQuXG4vL1xuLy8gVGhlIG9wYXF1ZSB0eXBlIHJldHVybmVkIGJ5IHRoZSBob3N0IGNvbmZpZyBpcyBpbnRlcm5hbGx5IGEgbGFuZSwgc28gd2UgY2FuXG4vLyB1c2UgdGhhdCBkaXJlY3RseS5cbi8vIFRPRE86IE1vdmUgdGhpcyB0eXBlIGNvbnZlcnNpb24gdG8gdGhlIGV2ZW50IHByaW9yaXR5IG1vZHVsZS5cbnZhciBldmVudExhbmU9Z2V0Q3VycmVudEV2ZW50UHJpb3JpdHkoKTtyZXR1cm4gZXZlbnRMYW5lO31mdW5jdGlvbiByZXF1ZXN0UmV0cnlMYW5lKGZpYmVyKXsvLyBUaGlzIGlzIGEgZm9yayBvZiBgcmVxdWVzdFVwZGF0ZUxhbmVgIGRlc2lnbmVkIHNwZWNpZmljYWxseSBmb3IgU3VzcGVuc2Vcbi8vIFwicmV0cmllc1wiIOKAlCBhIHNwZWNpYWwgdXBkYXRlIHRoYXQgYXR0ZW1wdHMgdG8gZmxpcCBhIFN1c3BlbnNlIGJvdW5kYXJ5XG4vLyBmcm9tIGl0cyBwbGFjZWhvbGRlciBzdGF0ZSB0byBpdHMgcHJpbWFyeS9yZXNvbHZlZCBzdGF0ZS5cbi8vIFNwZWNpYWwgY2FzZXNcbnZhciBtb2RlPWZpYmVyLm1vZGU7aWYoKG1vZGUmQ29uY3VycmVudE1vZGUpPT09Tm9Nb2RlKXtyZXR1cm4gU3luY0xhbmU7fXJldHVybiBjbGFpbU5leHRSZXRyeUxhbmUoKTt9ZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsbGFuZSxldmVudFRpbWUpe2NoZWNrRm9yTmVzdGVkVXBkYXRlcygpO3tpZihpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3Qpe2Vycm9yKCd1c2VJbnNlcnRpb25FZmZlY3QgbXVzdCBub3Qgc2NoZWR1bGUgdXBkYXRlcy4nKTt9fXtpZihpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMpe2RpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHM9dHJ1ZTt9fS8vIE1hcmsgdGhhdCB0aGUgcm9vdCBoYXMgYSBwZW5kaW5nIHVwZGF0ZS5cbm1hcmtSb290VXBkYXRlZChyb290LGxhbmUsZXZlbnRUaW1lKTtpZigoZXhlY3V0aW9uQ29udGV4dCZSZW5kZXJDb250ZXh0KSE9PU5vTGFuZXMmJnJvb3Q9PT13b3JrSW5Qcm9ncmVzc1Jvb3Qpey8vIFRoaXMgdXBkYXRlIHdhcyBkaXNwYXRjaGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGlzIGlzIGEgbWlzdGFrZVxuLy8gaWYgdGhlIHVwZGF0ZSBvcmlnaW5hdGVzIGZyb20gdXNlciBzcGFjZSAod2l0aCB0aGUgZXhjZXB0aW9uIG9mIGxvY2FsXG4vLyBob29rIHVwZGF0ZXMsIHdoaWNoIGFyZSBoYW5kbGVkIGRpZmZlcmVudGx5IGFuZCBkb24ndCByZWFjaCB0aGlzXG4vLyBmdW5jdGlvbiksIGJ1dCB0aGVyZSBhcmUgc29tZSBpbnRlcm5hbCBSZWFjdCBmZWF0dXJlcyB0aGF0IHVzZSB0aGlzIGFzXG4vLyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwsIGxpa2Ugc2VsZWN0aXZlIGh5ZHJhdGlvbi5cbndhcm5BYm91dFJlbmRlclBoYXNlVXBkYXRlc0luREVWKGZpYmVyKTsvLyBUcmFjayBsYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZVxufWVsc2V7Ly8gVGhpcyBpcyBhIG5vcm1hbCB1cGRhdGUsIHNjaGVkdWxlZCBmcm9tIG91dHNpZGUgdGhlIHJlbmRlciBwaGFzZS4gRm9yXG4vLyBleGFtcGxlLCBkdXJpbmcgYW4gaW5wdXQgZXZlbnQuXG57aWYoaXNEZXZUb29sc1ByZXNlbnQpe2FkZEZpYmVyVG9MYW5lc01hcChyb290LGZpYmVyLGxhbmUpO319d2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKTtpZihyb290PT09d29ya0luUHJvZ3Jlc3NSb290KXsvLyBSZWNlaXZlZCBhbiB1cGRhdGUgdG8gYSB0cmVlIHRoYXQncyBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlcmluZy4gTWFya1xuLy8gdGhhdCB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgdXBkYXRlIHdvcmsgb24gdGhpcyByb290LiBVbmxlc3MgdGhlXG4vLyBgZGVmZXJSZW5kZXJQaGFzZVVwZGF0ZVRvTmV4dEJhdGNoYCBmbGFnIGlzIG9mZiBhbmQgdGhpcyBpcyBhIHJlbmRlclxuLy8gcGhhc2UgdXBkYXRlLiBJbiB0aGF0IGNhc2UsIHdlIGRvbid0IHRyZWF0IHJlbmRlciBwaGFzZSB1cGRhdGVzIGFzIGlmXG4vLyB0aGV5IHdlcmUgaW50ZXJsZWF2ZWQsIGZvciBiYWNrd2FyZHMgY29tcGF0IHJlYXNvbnMuXG5pZigoZXhlY3V0aW9uQ29udGV4dCZSZW5kZXJDb250ZXh0KT09PU5vQ29udGV4dCl7d29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXM9bWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyxsYW5lKTt9aWYod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz09PVJvb3RTdXNwZW5kZWRXaXRoRGVsYXkpey8vIFRoZSByb290IGFscmVhZHkgc3VzcGVuZGVkIHdpdGggYSBkZWxheSwgd2hpY2ggbWVhbnMgdGhpcyByZW5kZXJcbi8vIGRlZmluaXRlbHkgd29uJ3QgZmluaXNoLiBTaW5jZSB3ZSBoYXZlIGEgbmV3IHVwZGF0ZSwgbGV0J3MgbWFyayBpdCBhc1xuLy8gc3VzcGVuZGVkIG5vdywgcmlnaHQgYmVmb3JlIG1hcmtpbmcgdGhlIGluY29taW5nIHVwZGF0ZS4gVGhpcyBoYXMgdGhlXG4vLyBlZmZlY3Qgb2YgaW50ZXJydXB0aW5nIHRoZSBjdXJyZW50IHJlbmRlciBhbmQgc3dpdGNoaW5nIHRvIHRoZSB1cGRhdGUuXG4vLyBUT0RPOiBNYWtlIHN1cmUgdGhpcyBkb2Vzbid0IG92ZXJyaWRlIHBpbmdzIHRoYXQgaGFwcGVuIHdoaWxlIHdlJ3ZlXG4vLyBhbHJlYWR5IHN0YXJ0ZWQgcmVuZGVyaW5nLlxubWFya1Jvb3RTdXNwZW5kZWQkMShyb290LHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTt9fWVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LGV2ZW50VGltZSk7aWYobGFuZT09PVN5bmNMYW5lJiZleGVjdXRpb25Db250ZXh0PT09Tm9Db250ZXh0JiYoZmliZXIubW9kZSZDb25jdXJyZW50TW9kZSk9PT1Ob01vZGUmJi8vIFRyZWF0IGBhY3RgIGFzIGlmIGl0J3MgaW5zaWRlIGBiYXRjaGVkVXBkYXRlc2AsIGV2ZW4gaW4gbGVnYWN5IG1vZGUuXG4hUmVhY3RDdXJyZW50QWN0UXVldWUkMS5pc0JhdGNoaW5nTGVnYWN5KXsvLyBGbHVzaCB0aGUgc3luY2hyb25vdXMgd29yayBub3csIHVubGVzcyB3ZSdyZSBhbHJlYWR5IHdvcmtpbmcgb3IgaW5zaWRlXG4vLyBhIGJhdGNoLiBUaGlzIGlzIGludGVudGlvbmFsbHkgaW5zaWRlIHNjaGVkdWxlVXBkYXRlT25GaWJlciBpbnN0ZWFkIG9mXG4vLyBzY2hlZHVsZUNhbGxiYWNrRm9yRmliZXIgdG8gcHJlc2VydmUgdGhlIGFiaWxpdHkgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuLy8gd2l0aG91dCBpbW1lZGlhdGVseSBmbHVzaGluZyBpdC4gV2Ugb25seSBkbyB0aGlzIGZvciB1c2VyLWluaXRpYXRlZFxuLy8gdXBkYXRlcywgdG8gcHJlc2VydmUgaGlzdG9yaWNhbCBiZWhhdmlvciBvZiBsZWdhY3kgbW9kZS5cbnJlc2V0UmVuZGVyVGltZXIoKTtmbHVzaFN5bmNDYWxsYmFja3NPbmx5SW5MZWdhY3lNb2RlKCk7fX19ZnVuY3Rpb24gc2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290KHJvb3QsbGFuZSxldmVudFRpbWUpey8vIFRoaXMgaXMgYSBzcGVjaWFsIGZvcmsgb2Ygc2NoZWR1bGVVcGRhdGVPbkZpYmVyIHRoYXQgaXMgb25seSB1c2VkIHRvXG4vLyBzY2hlZHVsZSB0aGUgaW5pdGlhbCBoeWRyYXRpb24gb2YgYSByb290IHRoYXQgaGFzIGp1c3QgYmVlbiBjcmVhdGVkLiBNb3N0XG4vLyBvZiB0aGUgc3R1ZmYgaW4gc2NoZWR1bGVVcGRhdGVPbkZpYmVyIGNhbiBiZSBza2lwcGVkLlxuLy9cbi8vIFRoZSBtYWluIHJlYXNvbiBmb3IgdGhpcyBzZXBhcmF0ZSBwYXRoLCB0aG91Z2gsIGlzIHRvIGRpc3Rpbmd1aXNoIHRoZVxuLy8gaW5pdGlhbCBjaGlsZHJlbiBmcm9tIHN1YnNlcXVlbnQgdXBkYXRlcy4gSW4gZnVsbHkgY2xpZW50LXJlbmRlcmVkIHJvb3RzXG4vLyAoY3JlYXRlUm9vdCBpbnN0ZWFkIG9mIGh5ZHJhdGVSb290KSwgYWxsIHRvcC1sZXZlbCByZW5kZXJzIGFyZSBtb2RlbGVkIGFzXG4vLyB1cGRhdGVzLCBidXQgaHlkcmF0aW9uIHJvb3RzIGFyZSBzcGVjaWFsIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIG11c3Rcbi8vIG1hdGNoIHdoYXQgd2FzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIuXG52YXIgY3VycmVudD1yb290LmN1cnJlbnQ7Y3VycmVudC5sYW5lcz1sYW5lO21hcmtSb290VXBkYXRlZChyb290LGxhbmUsZXZlbnRUaW1lKTtlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCxldmVudFRpbWUpO31mdW5jdGlvbiBpc1Vuc2FmZUNsYXNzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpey8vIENoZWNrIGlmIHRoaXMgaXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlLiBPbmx5IGNhbGxlZCBieSBjbGFzcyBjb21wb25lbnRzLFxuLy8gd2hpY2ggc3BlY2lhbCAoZGVwcmVjYXRlZCkgYmVoYXZpb3IgZm9yIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZSBwcm9wcy5cbnJldHVybigvLyBUT0RPOiBSZW1vdmUgb3V0ZGF0ZWQgZGVmZXJSZW5kZXJQaGFzZVVwZGF0ZVRvTmV4dEJhdGNoIGV4cGVyaW1lbnQuIFdlXG4vLyBkZWNpZGVkIG5vdCB0byBlbmFibGUgaXQuXG4oZXhlY3V0aW9uQ29udGV4dCZSZW5kZXJDb250ZXh0KSE9PU5vQ29udGV4dCk7fS8vIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHNjaGVkdWxlIGEgdGFzayBmb3IgYSByb290LiBUaGVyZSdzIG9ubHkgb25lIHRhc2sgcGVyXG4vLyByb290OyBpZiBhIHRhc2sgd2FzIGFscmVhZHkgc2NoZWR1bGVkLCB3ZSdsbCBjaGVjayB0byBtYWtlIHN1cmUgdGhlIHByaW9yaXR5XG4vLyBvZiB0aGUgZXhpc3RpbmcgdGFzayBpcyB0aGUgc2FtZSBhcyB0aGUgcHJpb3JpdHkgb2YgdGhlIG5leHQgbGV2ZWwgdGhhdCB0aGVcbi8vIHJvb3QgaGFzIHdvcmsgb24uIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5IHVwZGF0ZSwgYW5kIHJpZ2h0IGJlZm9yZVxuLy8gZXhpdGluZyBhIHRhc2suXG5mdW5jdGlvbiBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCxjdXJyZW50VGltZSl7dmFyIGV4aXN0aW5nQ2FsbGJhY2tOb2RlPXJvb3QuY2FsbGJhY2tOb2RlOy8vIENoZWNrIGlmIGFueSBsYW5lcyBhcmUgYmVpbmcgc3RhcnZlZCBieSBvdGhlciB3b3JrLiBJZiBzbywgbWFyayB0aGVtIGFzXG4vLyBleHBpcmVkIHNvIHdlIGtub3cgdG8gd29yayBvbiB0aG9zZSBuZXh0LlxubWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LGN1cnJlbnRUaW1lKTsvLyBEZXRlcm1pbmUgdGhlIG5leHQgbGFuZXMgdG8gd29yayBvbiwgYW5kIHRoZWlyIHByaW9yaXR5LlxudmFyIG5leHRMYW5lcz1nZXROZXh0TGFuZXMocm9vdCxyb290PT09d29ya0luUHJvZ3Jlc3NSb290P3dvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzOk5vTGFuZXMpO2lmKG5leHRMYW5lcz09PU5vTGFuZXMpey8vIFNwZWNpYWwgY2FzZTogVGhlcmUncyBub3RoaW5nIHRvIHdvcmsgb24uXG5pZihleGlzdGluZ0NhbGxiYWNrTm9kZSE9PW51bGwpe2NhbmNlbENhbGxiYWNrJDEoZXhpc3RpbmdDYWxsYmFja05vZGUpO31yb290LmNhbGxiYWNrTm9kZT1udWxsO3Jvb3QuY2FsbGJhY2tQcmlvcml0eT1Ob0xhbmU7cmV0dXJuO30vLyBXZSB1c2UgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgbGFuZSB0byByZXByZXNlbnQgdGhlIHByaW9yaXR5IG9mIHRoZSBjYWxsYmFjay5cbnZhciBuZXdDYWxsYmFja1ByaW9yaXR5PWdldEhpZ2hlc3RQcmlvcml0eUxhbmUobmV4dExhbmVzKTsvLyBDaGVjayBpZiB0aGVyZSdzIGFuIGV4aXN0aW5nIHRhc2suIFdlIG1heSBiZSBhYmxlIHRvIHJldXNlIGl0LlxudmFyIGV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eT1yb290LmNhbGxiYWNrUHJpb3JpdHk7aWYoZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5PT09bmV3Q2FsbGJhY2tQcmlvcml0eSYmLy8gU3BlY2lhbCBjYXNlIHJlbGF0ZWQgdG8gYGFjdGAuIElmIHRoZSBjdXJyZW50bHkgc2NoZWR1bGVkIHRhc2sgaXMgYVxuLy8gU2NoZWR1bGVyIHRhc2ssIHJhdGhlciB0aGFuIGFuIGBhY3RgIHRhc2ssIGNhbmNlbCBpdCBhbmQgcmUtc2NoZWR1bGVkXG4vLyBvbiB0aGUgYGFjdGAgcXVldWUuXG4hKFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudCE9PW51bGwmJmV4aXN0aW5nQ2FsbGJhY2tOb2RlIT09ZmFrZUFjdENhbGxiYWNrTm9kZSkpe3svLyBJZiB3ZSdyZSBnb2luZyB0byByZS11c2UgYW4gZXhpc3RpbmcgdGFzaywgaXQgbmVlZHMgdG8gZXhpc3QuXG4vLyBBc3N1bWUgdGhhdCBkaXNjcmV0ZSB1cGRhdGUgbWljcm90YXNrcyBhcmUgbm9uLWNhbmNlbGxhYmxlIGFuZCBudWxsLlxuLy8gVE9ETzogVGVtcG9yYXJ5IHVudGlsIHdlIGNvbmZpcm0gdGhpcyB3YXJuaW5nIGlzIG5vdCBmaXJlZC5cbmlmKGV4aXN0aW5nQ2FsbGJhY2tOb2RlPT1udWxsJiZleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkhPT1TeW5jTGFuZSl7ZXJyb3IoJ0V4cGVjdGVkIHNjaGVkdWxlZCBjYWxsYmFjayB0byBleGlzdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9fS8vIFRoZSBwcmlvcml0eSBoYXNuJ3QgY2hhbmdlZC4gV2UgY2FuIHJldXNlIHRoZSBleGlzdGluZyB0YXNrLiBFeGl0LlxucmV0dXJuO31pZihleGlzdGluZ0NhbGxiYWNrTm9kZSE9bnVsbCl7Ly8gQ2FuY2VsIHRoZSBleGlzdGluZyBjYWxsYmFjay4gV2UnbGwgc2NoZWR1bGUgYSBuZXcgb25lIGJlbG93LlxuY2FuY2VsQ2FsbGJhY2skMShleGlzdGluZ0NhbGxiYWNrTm9kZSk7fS8vIFNjaGVkdWxlIGEgbmV3IGNhbGxiYWNrLlxudmFyIG5ld0NhbGxiYWNrTm9kZTtpZihuZXdDYWxsYmFja1ByaW9yaXR5PT09U3luY0xhbmUpey8vIFNwZWNpYWwgY2FzZTogU3luYyBSZWFjdCBjYWxsYmFja3MgYXJlIHNjaGVkdWxlZCBvbiBhIHNwZWNpYWxcbi8vIGludGVybmFsIHF1ZXVlXG5pZihyb290LnRhZz09PUxlZ2FjeVJvb3Qpe2lmKFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuaXNCYXRjaGluZ0xlZ2FjeSE9PW51bGwpe1JlYWN0Q3VycmVudEFjdFF1ZXVlJDEuZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGU9dHJ1ZTt9c2NoZWR1bGVMZWdhY3lTeW5jQ2FsbGJhY2socGVyZm9ybVN5bmNXb3JrT25Sb290LmJpbmQobnVsbCxyb290KSk7fWVsc2V7c2NoZWR1bGVTeW5jQ2FsbGJhY2socGVyZm9ybVN5bmNXb3JrT25Sb290LmJpbmQobnVsbCxyb290KSk7fXsvLyBGbHVzaCB0aGUgcXVldWUgaW4gYSBtaWNyb3Rhc2suXG5pZihSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQhPT1udWxsKXsvLyBJbnNpZGUgYGFjdGAsIHVzZSBvdXIgaW50ZXJuYWwgYGFjdGAgcXVldWUgc28gdGhhdCB0aGVzZSBnZXQgZmx1c2hlZFxuLy8gYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzY29wZSBldmVuIHdoZW4gdXNpbmcgdGhlIHN5bmMgdmVyc2lvblxuLy8gb2YgYGFjdGAuXG5SZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQucHVzaChmbHVzaFN5bmNDYWxsYmFja3MpO31lbHNle3NjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uKCl7Ly8gSW4gU2FmYXJpLCBhcHBlbmRpbmcgYW4gaWZyYW1lIGZvcmNlcyBtaWNyb3Rhc2tzIHRvIHJ1bi5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjI0NTlcbi8vIFdlIGRvbid0IHN1cHBvcnQgcnVubmluZyBjYWxsYmFja3MgaW4gdGhlIG1pZGRsZSBvZiByZW5kZXJcbi8vIG9yIGNvbW1pdCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QgdGhhdC5cbmlmKChleGVjdXRpb25Db250ZXh0JihSZW5kZXJDb250ZXh0fENvbW1pdENvbnRleHQpKT09PU5vQ29udGV4dCl7Ly8gTm90ZSB0aGF0IHRoaXMgd291bGQgc3RpbGwgcHJlbWF0dXJlbHkgZmx1c2ggdGhlIGNhbGxiYWNrc1xuLy8gaWYgdGhpcyBoYXBwZW5zIG91dHNpZGUgcmVuZGVyIG9yIGNvbW1pdCBwaGFzZSAoZS5nLiBpbiBhbiBldmVudCkuXG5mbHVzaFN5bmNDYWxsYmFja3MoKTt9fSk7fX1uZXdDYWxsYmFja05vZGU9bnVsbDt9ZWxzZXt2YXIgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbDtzd2l0Y2gobGFuZXNUb0V2ZW50UHJpb3JpdHkobmV4dExhbmVzKSl7Y2FzZSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk6c2NoZWR1bGVyUHJpb3JpdHlMZXZlbD1JbW1lZGlhdGVQcmlvcml0eTticmVhaztjYXNlIENvbnRpbnVvdXNFdmVudFByaW9yaXR5OnNjaGVkdWxlclByaW9yaXR5TGV2ZWw9VXNlckJsb2NraW5nUHJpb3JpdHk7YnJlYWs7Y2FzZSBEZWZhdWx0RXZlbnRQcmlvcml0eTpzY2hlZHVsZXJQcmlvcml0eUxldmVsPU5vcm1hbFByaW9yaXR5O2JyZWFrO2Nhc2UgSWRsZUV2ZW50UHJpb3JpdHk6c2NoZWR1bGVyUHJpb3JpdHlMZXZlbD1JZGxlUHJpb3JpdHk7YnJlYWs7ZGVmYXVsdDpzY2hlZHVsZXJQcmlvcml0eUxldmVsPU5vcm1hbFByaW9yaXR5O2JyZWFrO31uZXdDYWxsYmFja05vZGU9c2NoZWR1bGVDYWxsYmFjayQxKHNjaGVkdWxlclByaW9yaXR5TGV2ZWwscGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290LmJpbmQobnVsbCxyb290KSk7fXJvb3QuY2FsbGJhY2tQcmlvcml0eT1uZXdDYWxsYmFja1ByaW9yaXR5O3Jvb3QuY2FsbGJhY2tOb2RlPW5ld0NhbGxiYWNrTm9kZTt9Ly8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGV2ZXJ5IGNvbmN1cnJlbnQgdGFzaywgaS5lLiBhbnl0aGluZyB0aGF0XG4vLyBnb2VzIHRocm91Z2ggU2NoZWR1bGVyLlxuZnVuY3Rpb24gcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290KHJvb3QsZGlkVGltZW91dCl7e3Jlc2V0TmVzdGVkVXBkYXRlRmxhZygpO30vLyBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIGEgUmVhY3QgZXZlbnQsIHdlIGNhbiBjbGVhciB0aGUgY3VycmVudFxuLy8gZXZlbnQgdGltZS4gVGhlIG5leHQgdXBkYXRlIHdpbGwgY29tcHV0ZSBhIG5ldyBldmVudCB0aW1lLlxuY3VycmVudEV2ZW50VGltZT1Ob1RpbWVzdGFtcDtjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZT1Ob0xhbmVzO2lmKChleGVjdXRpb25Db250ZXh0JihSZW5kZXJDb250ZXh0fENvbW1pdENvbnRleHQpKSE9PU5vQ29udGV4dCl7dGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTt9Ly8gRmx1c2ggYW55IHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzIGJlZm9yZSBkZWNpZGluZyB3aGljaCBsYW5lcyB0byB3b3JrIG9uLFxuLy8gaW4gY2FzZSB0aGV5IHNjaGVkdWxlIGFkZGl0aW9uYWwgd29yay5cbnZhciBvcmlnaW5hbENhbGxiYWNrTm9kZT1yb290LmNhbGxiYWNrTm9kZTt2YXIgZGlkRmx1c2hQYXNzaXZlRWZmZWN0cz1mbHVzaFBhc3NpdmVFZmZlY3RzKCk7aWYoZGlkRmx1c2hQYXNzaXZlRWZmZWN0cyl7Ly8gU29tZXRoaW5nIGluIHRoZSBwYXNzaXZlIGVmZmVjdCBwaGFzZSBtYXkgaGF2ZSBjYW5jZWxlZCB0aGUgY3VycmVudCB0YXNrLlxuLy8gQ2hlY2sgaWYgdGhlIHRhc2sgbm9kZSBmb3IgdGhpcyByb290IHdhcyBjaGFuZ2VkLlxuaWYocm9vdC5jYWxsYmFja05vZGUhPT1vcmlnaW5hbENhbGxiYWNrTm9kZSl7Ly8gVGhlIGN1cnJlbnQgdGFzayB3YXMgY2FuY2VsZWQuIEV4aXQuIFdlIGRvbid0IG5lZWQgdG8gY2FsbFxuLy8gYGVuc3VyZVJvb3RJc1NjaGVkdWxlZGAgYmVjYXVzZSB0aGUgY2hlY2sgYWJvdmUgaW1wbGllcyBlaXRoZXIgdGhhdFxuLy8gdGhlcmUncyBhIG5ldyB0YXNrLCBvciB0aGF0IHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsgb24gdGhpcyByb290LlxucmV0dXJuIG51bGw7fX0vLyBEZXRlcm1pbmUgdGhlIG5leHQgbGFuZXMgdG8gd29yayBvbiwgdXNpbmcgdGhlIGZpZWxkcyBzdG9yZWRcbi8vIG9uIHRoZSByb290LlxudmFyIGxhbmVzPWdldE5leHRMYW5lcyhyb290LHJvb3Q9PT13b3JrSW5Qcm9ncmVzc1Jvb3Q/d29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM6Tm9MYW5lcyk7aWYobGFuZXM9PT1Ob0xhbmVzKXsvLyBEZWZlbnNpdmUgY29kaW5nLiBUaGlzIGlzIG5ldmVyIGV4cGVjdGVkIHRvIGhhcHBlbi5cbnJldHVybiBudWxsO30vLyBXZSBkaXNhYmxlIHRpbWUtc2xpY2luZyBpbiBzb21lIGNhc2VzOiBpZiB0aGUgd29yayBoYXMgYmVlbiBDUFUtYm91bmRcbi8vIGZvciB0b28gbG9uZyAoXCJleHBpcmVkXCIgd29yaywgdG8gcHJldmVudCBzdGFydmF0aW9uKSwgb3Igd2UncmUgaW5cbi8vIHN5bmMtdXBkYXRlcy1ieS1kZWZhdWx0IG1vZGUuXG4vLyBUT0RPOiBXZSBvbmx5IGNoZWNrIGBkaWRUaW1lb3V0YCBkZWZlbnNpdmVseSwgdG8gYWNjb3VudCBmb3IgYSBTY2hlZHVsZXJcbi8vIGJ1ZyB3ZSdyZSBzdGlsbCBpbnZlc3RpZ2F0aW5nLiBPbmNlIHRoZSBidWcgaW4gU2NoZWR1bGVyIGlzIGZpeGVkLFxuLy8gd2UgY2FuIHJlbW92ZSB0aGlzLCBzaW5jZSB3ZSB0cmFjayBleHBpcmF0aW9uIG91cnNlbHZlcy5cbnZhciBzaG91bGRUaW1lU2xpY2U9IWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsbGFuZXMpJiYhaW5jbHVkZXNFeHBpcmVkTGFuZShyb290LGxhbmVzKSYmIWRpZFRpbWVvdXQ7dmFyIGV4aXRTdGF0dXM9c2hvdWxkVGltZVNsaWNlP3JlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsbGFuZXMpOnJlbmRlclJvb3RTeW5jKHJvb3QsbGFuZXMpO2lmKGV4aXRTdGF0dXMhPT1Sb290SW5Qcm9ncmVzcyl7aWYoZXhpdFN0YXR1cz09PVJvb3RFcnJvcmVkKXsvLyBJZiBzb21ldGhpbmcgdGhyZXcgYW4gZXJyb3IsIHRyeSByZW5kZXJpbmcgb25lIG1vcmUgdGltZS4gV2UnbGxcbi8vIHJlbmRlciBzeW5jaHJvbm91c2x5IHRvIGJsb2NrIGNvbmN1cnJlbnQgZGF0YSBtdXRhdGlvbnMsIGFuZCB3ZSdsbFxuLy8gaW5jbHVkZXMgYWxsIHBlbmRpbmcgdXBkYXRlcyBhcmUgaW5jbHVkZWQuIElmIGl0IHN0aWxsIGZhaWxzIGFmdGVyXG4vLyB0aGUgc2Vjb25kIGF0dGVtcHQsIHdlJ2xsIGdpdmUgdXAgYW5kIGNvbW1pdCB0aGUgcmVzdWx0aW5nIHRyZWUuXG52YXIgZXJyb3JSZXRyeUxhbmVzPWdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpO2lmKGVycm9yUmV0cnlMYW5lcyE9PU5vTGFuZXMpe2xhbmVzPWVycm9yUmV0cnlMYW5lcztleGl0U3RhdHVzPXJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsZXJyb3JSZXRyeUxhbmVzKTt9fWlmKGV4aXRTdGF0dXM9PT1Sb290RmF0YWxFcnJvcmVkKXt2YXIgZmF0YWxFcnJvcj13b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yO3ByZXBhcmVGcmVzaFN0YWNrKHJvb3QsTm9MYW5lcyk7bWFya1Jvb3RTdXNwZW5kZWQkMShyb290LGxhbmVzKTtlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCxub3coKSk7dGhyb3cgZmF0YWxFcnJvcjt9aWYoZXhpdFN0YXR1cz09PVJvb3REaWROb3RDb21wbGV0ZSl7Ly8gVGhlIHJlbmRlciB1bndvdW5kIHdpdGhvdXQgY29tcGxldGluZyB0aGUgdHJlZS4gVGhpcyBoYXBwZW5zIGluIHNwZWNpYWxcbi8vIGNhc2VzIHdoZXJlIG5lZWQgdG8gZXhpdCB0aGUgY3VycmVudCByZW5kZXIgd2l0aG91dCBwcm9kdWNpbmcgYVxuLy8gY29uc2lzdGVudCB0cmVlIG9yIGNvbW1pdHRpbmcuXG4vL1xuLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gZHVyaW5nIGEgY29uY3VycmVudCByZW5kZXIsIG5vdCBhIGRpc2NyZXRlIG9yXG4vLyBzeW5jaHJvbm91cyB1cGRhdGUuIFdlIHNob3VsZCBoYXZlIGFscmVhZHkgY2hlY2tlZCBmb3IgdGhpcyB3aGVuIHdlXG4vLyB1bndvdW5kIHRoZSBzdGFjay5cbm1hcmtSb290U3VzcGVuZGVkJDEocm9vdCxsYW5lcyk7fWVsc2V7Ly8gVGhlIHJlbmRlciBjb21wbGV0ZWQuXG4vLyBDaGVjayBpZiB0aGlzIHJlbmRlciBtYXkgaGF2ZSB5aWVsZGVkIHRvIGEgY29uY3VycmVudCBldmVudCwgYW5kIGlmIHNvLFxuLy8gY29uZmlybSB0aGF0IGFueSBuZXdseSByZW5kZXJlZCBzdG9yZXMgYXJlIGNvbnNpc3RlbnQuXG4vLyBUT0RPOiBJdCdzIHBvc3NpYmxlIHRoYXQgZXZlbiBhIGNvbmN1cnJlbnQgcmVuZGVyIG1heSBuZXZlciBoYXZlIHlpZWxkZWRcbi8vIHRvIHRoZSBtYWluIHRocmVhZCwgaWYgaXQgd2FzIGZhc3QgZW5vdWdoLCBvciBpZiBpdCBleHBpcmVkLiBXZSBjb3VsZFxuLy8gc2tpcCB0aGUgY29uc2lzdGVuY3kgY2hlY2sgaW4gdGhhdCBjYXNlLCB0b28uXG52YXIgcmVuZGVyV2FzQ29uY3VycmVudD0haW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCxsYW5lcyk7dmFyIGZpbmlzaGVkV29yaz1yb290LmN1cnJlbnQuYWx0ZXJuYXRlO2lmKHJlbmRlcldhc0NvbmN1cnJlbnQmJiFpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZmluaXNoZWRXb3JrKSl7Ly8gQSBzdG9yZSB3YXMgbXV0YXRlZCBpbiBhbiBpbnRlcmxlYXZlZCBldmVudC4gUmVuZGVyIGFnYWluLFxuLy8gc3luY2hyb25vdXNseSwgdG8gYmxvY2sgZnVydGhlciBtdXRhdGlvbnMuXG5leGl0U3RhdHVzPXJlbmRlclJvb3RTeW5jKHJvb3QsbGFuZXMpOy8vIFdlIG5lZWQgdG8gY2hlY2sgYWdhaW4gaWYgc29tZXRoaW5nIHRocmV3XG5pZihleGl0U3RhdHVzPT09Um9vdEVycm9yZWQpe3ZhciBfZXJyb3JSZXRyeUxhbmVzPWdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpO2lmKF9lcnJvclJldHJ5TGFuZXMhPT1Ob0xhbmVzKXtsYW5lcz1fZXJyb3JSZXRyeUxhbmVzO2V4aXRTdGF0dXM9cmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3Iocm9vdCxfZXJyb3JSZXRyeUxhbmVzKTsvLyBXZSBhc3N1bWUgdGhlIHRyZWUgaXMgbm93IGNvbnNpc3RlbnQgYmVjYXVzZSB3ZSBkaWRuJ3QgeWllbGQgdG8gYW55XG4vLyBjb25jdXJyZW50IGV2ZW50cy5cbn19aWYoZXhpdFN0YXR1cz09PVJvb3RGYXRhbEVycm9yZWQpe3ZhciBfZmF0YWxFcnJvcj13b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yO3ByZXBhcmVGcmVzaFN0YWNrKHJvb3QsTm9MYW5lcyk7bWFya1Jvb3RTdXNwZW5kZWQkMShyb290LGxhbmVzKTtlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCxub3coKSk7dGhyb3cgX2ZhdGFsRXJyb3I7fX0vLyBXZSBub3cgaGF2ZSBhIGNvbnNpc3RlbnQgdHJlZS4gVGhlIG5leHQgc3RlcCBpcyBlaXRoZXIgdG8gY29tbWl0IGl0LFxuLy8gb3IsIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHdhaXQgdG8gY29tbWl0IGl0IGFmdGVyIGEgdGltZW91dC5cbnJvb3QuZmluaXNoZWRXb3JrPWZpbmlzaGVkV29yaztyb290LmZpbmlzaGVkTGFuZXM9bGFuZXM7ZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LGV4aXRTdGF0dXMsbGFuZXMpO319ZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3Qsbm93KCkpO2lmKHJvb3QuY2FsbGJhY2tOb2RlPT09b3JpZ2luYWxDYWxsYmFja05vZGUpey8vIFRoZSB0YXNrIG5vZGUgc2NoZWR1bGVkIGZvciB0aGlzIHJvb3QgaXMgdGhlIHNhbWUgb25lIHRoYXQnc1xuLy8gY3VycmVudGx5IGV4ZWN1dGVkLiBOZWVkIHRvIHJldHVybiBhIGNvbnRpbnVhdGlvbi5cbnJldHVybiBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLHJvb3QpO31yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gcmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3Iocm9vdCxlcnJvclJldHJ5TGFuZXMpey8vIElmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBoeWRyYXRpb24sIGRpc2NhcmQgc2VydmVyIHJlc3BvbnNlIGFuZCBmYWxsXG4vLyBiYWNrIHRvIGNsaWVudCBzaWRlIHJlbmRlci5cbi8vIEJlZm9yZSByZW5kZXJpbmcgYWdhaW4sIHNhdmUgdGhlIGVycm9ycyBmcm9tIHRoZSBwcmV2aW91cyBhdHRlbXB0LlxudmFyIGVycm9yc0Zyb21GaXJzdEF0dGVtcHQ9d29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycztpZihpc1Jvb3REZWh5ZHJhdGVkKHJvb3QpKXsvLyBUaGUgc2hlbGwgZmFpbGVkIHRvIGh5ZHJhdGUuIFNldCBhIGZsYWcgdG8gZm9yY2UgYSBjbGllbnQgcmVuZGVyaW5nXG4vLyBkdXJpbmcgdGhlIG5leHQgYXR0ZW1wdC4gVG8gZG8gdGhpcywgd2UgY2FsbCBwcmVwYXJlRnJlc2hTdGFjayBub3dcbi8vIHRvIGNyZWF0ZSB0aGUgcm9vdCB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBUaGlzIGlzIGEgYml0IHdlaXJkIGluIHRlcm1zXG4vLyBvZiBmYWN0b3JpbmcsIGJlY2F1c2UgaXQgcmVsaWVzIG9uIHJlbmRlclJvb3RTeW5jIG5vdCBjYWxsaW5nXG4vLyBwcmVwYXJlRnJlc2hTdGFjayBhZ2FpbiBpbiB0aGUgY2FsbCBiZWxvdywgd2hpY2ggaGFwcGVucyBiZWNhdXNlIHRoZVxuLy8gcm9vdCBhbmQgbGFuZXMgaGF2ZW4ndCBjaGFuZ2VkLlxuLy9cbi8vIFRPRE86IEkgdGhpbmsgd2hhdCB3ZSBzaG91bGQgZG8gaXMgc2V0IEZvcmNlQ2xpZW50UmVuZGVyIGluc2lkZVxuLy8gdGhyb3dFeGNlcHRpb24sIGxpa2Ugd2UgZG8gZm9yIG5lc3RlZCBTdXNwZW5zZSBib3VuZGFyaWVzLiBUaGUgcmVhc29uXG4vLyBpdCdzIGhlcmUgaW5zdGVhZCBpcyBzbyB3ZSBjYW4gc3dpdGNoIHRvIHRoZSBzeW5jaHJvbm91cyB3b3JrIGxvb3AsIHRvby5cbi8vIFNvbWV0aGluZyB0byBjb25zaWRlciBmb3IgYSBmdXR1cmUgcmVmYWN0b3IuXG52YXIgcm9vdFdvcmtJblByb2dyZXNzPXByZXBhcmVGcmVzaFN0YWNrKHJvb3QsZXJyb3JSZXRyeUxhbmVzKTtyb290V29ya0luUHJvZ3Jlc3MuZmxhZ3N8PUZvcmNlQ2xpZW50UmVuZGVyO3tlcnJvckh5ZHJhdGluZ0NvbnRhaW5lcihyb290LmNvbnRhaW5lckluZm8pO319dmFyIGV4aXRTdGF0dXM9cmVuZGVyUm9vdFN5bmMocm9vdCxlcnJvclJldHJ5TGFuZXMpO2lmKGV4aXRTdGF0dXMhPT1Sb290RXJyb3JlZCl7Ly8gU3VjY2Vzc2Z1bGx5IGZpbmlzaGVkIHJlbmRlcmluZyBvbiByZXRyeVxuLy8gVGhlIGVycm9ycyBmcm9tIHRoZSBmYWlsZWQgZmlyc3QgYXR0ZW1wdCBoYXZlIGJlZW4gcmVjb3ZlcmVkLiBBZGRcbi8vIHRoZW0gdG8gdGhlIGNvbGxlY3Rpb24gb2YgcmVjb3ZlcmFibGUgZXJyb3JzLiBXZSdsbCBsb2cgdGhlbSBpbiB0aGVcbi8vIGNvbW1pdCBwaGFzZS5cbnZhciBlcnJvcnNGcm9tU2Vjb25kQXR0ZW1wdD13b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9yczt3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycz1lcnJvcnNGcm9tRmlyc3RBdHRlbXB0Oy8vIFRoZSBlcnJvcnMgZnJvbSB0aGUgc2Vjb25kIGF0dGVtcHQgc2hvdWxkIGJlIHF1ZXVlZCBhZnRlciB0aGUgZXJyb3JzXG4vLyBmcm9tIHRoZSBmaXJzdCBhdHRlbXB0LCB0byBwcmVzZXJ2ZSB0aGUgY2F1c2FsIHNlcXVlbmNlLlxuaWYoZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQhPT1udWxsKXtxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGVycm9yc0Zyb21TZWNvbmRBdHRlbXB0KTt9fXJldHVybiBleGl0U3RhdHVzO31mdW5jdGlvbiBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGVycm9ycyl7aWYod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM9PT1udWxsKXt3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycz1lcnJvcnM7fWVsc2V7d29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMucHVzaC5hcHBseSh3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxlcnJvcnMpO319ZnVuY3Rpb24gZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LGV4aXRTdGF0dXMsbGFuZXMpe3N3aXRjaChleGl0U3RhdHVzKXtjYXNlIFJvb3RJblByb2dyZXNzOmNhc2UgUm9vdEZhdGFsRXJyb3JlZDp7dGhyb3cgbmV3IEVycm9yKCdSb290IGRpZCBub3QgY29tcGxldGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7fS8vIEZsb3cga25vd3MgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnMgaWYgSSBhZGQgYSBicmVha1xuLy8gc3RhdGVtZW50LCBidXQgZXNsaW50IGRvZXNuJ3Qga25vdyBhYm91dCBpbnZhcmlhbnQsIHNvIGl0IGNvbXBsYWluc1xuLy8gaWYgSSBkby4gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5jYXNlIFJvb3RFcnJvcmVkOnsvLyBXZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGF0dGVtcHRlZCB0byByZXRyeSB0aGlzIHRyZWUuIElmIHdlIHJlYWNoZWRcbi8vIHRoaXMgcG9pbnQsIGl0IGVycm9yZWQgYWdhaW4uIENvbW1pdCBpdC5cbmNvbW1pdFJvb3Qocm9vdCx3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyx3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKTticmVhazt9Y2FzZSBSb290U3VzcGVuZGVkOnttYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsbGFuZXMpOy8vIFdlIGhhdmUgYW4gYWNjZXB0YWJsZSBsb2FkaW5nIHN0YXRlLiBXZSBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgd2Vcbi8vIHNob3VsZCBpbW1lZGlhdGVseSBjb21taXQgaXQgb3Igd2FpdCBhIGJpdC5cbmlmKGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpJiYvLyBkbyBub3QgZGVsYXkgaWYgd2UncmUgaW5zaWRlIGFuIGFjdCgpIHNjb3BlXG4hc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCkpey8vIFRoaXMgcmVuZGVyIG9ubHkgaW5jbHVkZWQgcmV0cmllcywgbm8gdXBkYXRlcy4gVGhyb3R0bGUgY29tbWl0dGluZ1xuLy8gcmV0cmllcyBzbyB0aGF0IHdlIGRvbid0IHNob3cgdG9vIG1hbnkgbG9hZGluZyBzdGF0ZXMgdG9vIHF1aWNrbHkuXG52YXIgbXNVbnRpbFRpbWVvdXQ9Z2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZStGQUxMQkFDS19USFJPVFRMRV9NUy1ub3coKTsvLyBEb24ndCBib3RoZXIgd2l0aCBhIHZlcnkgc2hvcnQgc3VzcGVuc2UgdGltZS5cbmlmKG1zVW50aWxUaW1lb3V0PjEwKXt2YXIgbmV4dExhbmVzPWdldE5leHRMYW5lcyhyb290LE5vTGFuZXMpO2lmKG5leHRMYW5lcyE9PU5vTGFuZXMpey8vIFRoZXJlJ3MgYWRkaXRpb25hbCB3b3JrIG9uIHRoaXMgcm9vdC5cbmJyZWFrO312YXIgc3VzcGVuZGVkTGFuZXM9cm9vdC5zdXNwZW5kZWRMYW5lcztpZighaXNTdWJzZXRPZkxhbmVzKHN1c3BlbmRlZExhbmVzLGxhbmVzKSl7Ly8gV2Ugc2hvdWxkIHByZWZlciB0byByZW5kZXIgdGhlIGZhbGxiYWNrIG9mIGF0IHRoZSBsYXN0XG4vLyBzdXNwZW5kZWQgbGV2ZWwuIFBpbmcgdGhlIGxhc3Qgc3VzcGVuZGVkIGxldmVsIHRvIHRyeVxuLy8gcmVuZGVyaW5nIGl0IGFnYWluLlxuLy8gRklYTUU6IFdoYXQgaWYgdGhlIHN1c3BlbmRlZCBsYW5lcyBhcmUgSWRsZT8gU2hvdWxkIG5vdCByZXN0YXJ0LlxudmFyIGV2ZW50VGltZT1yZXF1ZXN0RXZlbnRUaW1lKCk7bWFya1Jvb3RQaW5nZWQocm9vdCxzdXNwZW5kZWRMYW5lcyk7YnJlYWs7fS8vIFRoZSByZW5kZXIgaXMgc3VzcGVuZGVkLCBpdCBoYXNuJ3QgdGltZWQgb3V0LCBhbmQgdGhlcmUncyBub1xuLy8gbG93ZXIgcHJpb3JpdHkgd29yayB0byBkby4gSW5zdGVhZCBvZiBjb21taXR0aW5nIHRoZSBmYWxsYmFja1xuLy8gaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG5yb290LnRpbWVvdXRIYW5kbGU9c2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3QuYmluZChudWxsLHJvb3Qsd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyksbXNVbnRpbFRpbWVvdXQpO2JyZWFrO319Ly8gVGhlIHdvcmsgZXhwaXJlZC4gQ29tbWl0IGltbWVkaWF0ZWx5LlxuY29tbWl0Um9vdChyb290LHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMpO2JyZWFrO31jYXNlIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk6e21hcmtSb290U3VzcGVuZGVkJDEocm9vdCxsYW5lcyk7aWYoaW5jbHVkZXNPbmx5VHJhbnNpdGlvbnMobGFuZXMpKXsvLyBUaGlzIGlzIGEgdHJhbnNpdGlvbiwgc28gd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCBjb21taXR0aW5nIGFcbi8vIHBsYWNlaG9sZGVyIGFuZCB3aXRob3V0IHNjaGVkdWxpbmcgYSB0aW1lb3V0LiBEZWxheSBpbmRlZmluaXRlbHlcbi8vIHVudGlsIHdlIHJlY2VpdmUgbW9yZSBkYXRhLlxuYnJlYWs7fWlmKCFzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKSl7Ly8gVGhpcyBpcyBub3QgYSB0cmFuc2l0aW9uLCBidXQgd2UgZGlkIHRyaWdnZXIgYW4gYXZvaWRlZCBzdGF0ZS5cbi8vIFNjaGVkdWxlIGEgcGxhY2Vob2xkZXIgdG8gZGlzcGxheSBhZnRlciBhIHNob3J0IGRlbGF5LCB1c2luZyB0aGUgSnVzdFxuLy8gTm90aWNlYWJsZSBEaWZmZXJlbmNlLlxuLy8gVE9ETzogSXMgdGhlIEpORCBvcHRpbWl6YXRpb24gd29ydGggdGhlIGFkZGVkIGNvbXBsZXhpdHk/IElmIHRoaXMgaXNcbi8vIHRoZSBvbmx5IHJlYXNvbiB3ZSB0cmFjayB0aGUgZXZlbnQgdGltZSwgdGhlbiBwcm9iYWJseSBub3QuXG4vLyBDb25zaWRlciByZW1vdmluZy5cbnZhciBtb3N0UmVjZW50RXZlbnRUaW1lPWdldE1vc3RSZWNlbnRFdmVudFRpbWUocm9vdCxsYW5lcyk7dmFyIGV2ZW50VGltZU1zPW1vc3RSZWNlbnRFdmVudFRpbWU7dmFyIHRpbWVFbGFwc2VkTXM9bm93KCktZXZlbnRUaW1lTXM7dmFyIF9tc1VudGlsVGltZW91dD1qbmQodGltZUVsYXBzZWRNcyktdGltZUVsYXBzZWRNczsvLyBEb24ndCBib3RoZXIgd2l0aCBhIHZlcnkgc2hvcnQgc3VzcGVuc2UgdGltZS5cbmlmKF9tc1VudGlsVGltZW91dD4xMCl7Ly8gSW5zdGVhZCBvZiBjb21taXR0aW5nIHRoZSBmYWxsYmFjayBpbW1lZGlhdGVseSwgd2FpdCBmb3IgbW9yZSBkYXRhXG4vLyB0byBhcnJpdmUuXG5yb290LnRpbWVvdXRIYW5kbGU9c2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3QuYmluZChudWxsLHJvb3Qsd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyksX21zVW50aWxUaW1lb3V0KTticmVhazt9fS8vIENvbW1pdCB0aGUgcGxhY2Vob2xkZXIuXG5jb21taXRSb290KHJvb3Qsd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyk7YnJlYWs7fWNhc2UgUm9vdENvbXBsZXRlZDp7Ly8gVGhlIHdvcmsgY29tcGxldGVkLiBSZWFkeSB0byBjb21taXQuXG5jb21taXRSb290KHJvb3Qsd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyk7YnJlYWs7fWRlZmF1bHQ6e3Rocm93IG5ldyBFcnJvcignVW5rbm93biByb290IGV4aXQgc3RhdHVzLicpO319fWZ1bmN0aW9uIGlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3JlcyhmaW5pc2hlZFdvcmspey8vIFNlYXJjaCB0aGUgcmVuZGVyZWQgdHJlZSBmb3IgZXh0ZXJuYWwgc3RvcmUgcmVhZHMsIGFuZCBjaGVjayB3aGV0aGVyIHRoZVxuLy8gc3RvcmVzIHdlcmUgbXV0YXRlZCBpbiBhIGNvbmN1cnJlbnQgZXZlbnQuIEludGVudGlvbmFsbHkgdXNpbmcgYW4gaXRlcmF0aXZlXG4vLyBsb29wIGluc3RlYWQgb2YgcmVjdXJzaW9uIHNvIHdlIGNhbiBleGl0IGVhcmx5LlxudmFyIG5vZGU9ZmluaXNoZWRXb3JrO3doaWxlKHRydWUpe2lmKG5vZGUuZmxhZ3MmU3RvcmVDb25zaXN0ZW5jeSl7dmFyIHVwZGF0ZVF1ZXVlPW5vZGUudXBkYXRlUXVldWU7aWYodXBkYXRlUXVldWUhPT1udWxsKXt2YXIgY2hlY2tzPXVwZGF0ZVF1ZXVlLnN0b3JlcztpZihjaGVja3MhPT1udWxsKXtmb3IodmFyIGk9MDtpPGNoZWNrcy5sZW5ndGg7aSsrKXt2YXIgY2hlY2s9Y2hlY2tzW2ldO3ZhciBnZXRTbmFwc2hvdD1jaGVjay5nZXRTbmFwc2hvdDt2YXIgcmVuZGVyZWRWYWx1ZT1jaGVjay52YWx1ZTt0cnl7aWYoIW9iamVjdElzKGdldFNuYXBzaG90KCkscmVuZGVyZWRWYWx1ZSkpey8vIEZvdW5kIGFuIGluY29uc2lzdGVudCBzdG9yZS5cbnJldHVybiBmYWxzZTt9fWNhdGNoKGVycm9yKXsvLyBJZiBgZ2V0U25hcHNob3RgIHRocm93cywgcmV0dXJuIGBmYWxzZWAuIFRoaXMgd2lsbCBzY2hlZHVsZVxuLy8gYSByZS1yZW5kZXIsIGFuZCB0aGUgZXJyb3Igd2lsbCBiZSByZXRocm93biBkdXJpbmcgcmVuZGVyLlxucmV0dXJuIGZhbHNlO319fX19dmFyIGNoaWxkPW5vZGUuY2hpbGQ7aWYobm9kZS5zdWJ0cmVlRmxhZ3MmU3RvcmVDb25zaXN0ZW5jeSYmY2hpbGQhPT1udWxsKXtjaGlsZC5yZXR1cm49bm9kZTtub2RlPWNoaWxkO2NvbnRpbnVlO31pZihub2RlPT09ZmluaXNoZWRXb3JrKXtyZXR1cm4gdHJ1ZTt9d2hpbGUobm9kZS5zaWJsaW5nPT09bnVsbCl7aWYobm9kZS5yZXR1cm49PT1udWxsfHxub2RlLnJldHVybj09PWZpbmlzaGVkV29yayl7cmV0dXJuIHRydWU7fW5vZGU9bm9kZS5yZXR1cm47fW5vZGUuc2libGluZy5yZXR1cm49bm9kZS5yZXR1cm47bm9kZT1ub2RlLnNpYmxpbmc7fS8vIEZsb3cgZG9lc24ndCBrbm93IHRoaXMgaXMgdW5yZWFjaGFibGUsIGJ1dCBlc2xpbnQgZG9lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG5yZXR1cm4gdHJ1ZTt9ZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LHN1c3BlbmRlZExhbmVzKXsvLyBXaGVuIHN1c3BlbmRpbmcsIHdlIHNob3VsZCBhbHdheXMgZXhjbHVkZSBsYW5lcyB0aGF0IHdlcmUgcGluZ2VkIG9yIChtb3JlXG4vLyByYXJlbHksIHNpbmNlIHdlIHRyeSB0byBhdm9pZCBpdCkgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbi8vIFRPRE86IExvbCBtYXliZSB0aGVyZSdzIGEgYmV0dGVyIHdheSB0byBmYWN0b3IgdGhpcyBiZXNpZGVzIHRoaXNcbi8vIG9ibm94aW91c2x5IG5hbWVkIGZ1bmN0aW9uIDopXG5zdXNwZW5kZWRMYW5lcz1yZW1vdmVMYW5lcyhzdXNwZW5kZWRMYW5lcyx3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyk7c3VzcGVuZGVkTGFuZXM9cmVtb3ZlTGFuZXMoc3VzcGVuZGVkTGFuZXMsd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMpO21hcmtSb290U3VzcGVuZGVkKHJvb3Qsc3VzcGVuZGVkTGFuZXMpO30vLyBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3Igc3luY2hyb25vdXMgdGFza3MgdGhhdCBkb24ndCBnb1xuLy8gdGhyb3VnaCBTY2hlZHVsZXJcbmZ1bmN0aW9uIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290KXt7c3luY05lc3RlZFVwZGF0ZUZsYWcoKTt9aWYoKGV4ZWN1dGlvbkNvbnRleHQmKFJlbmRlckNvbnRleHR8Q29tbWl0Q29udGV4dCkpIT09Tm9Db250ZXh0KXt0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLicpO31mbHVzaFBhc3NpdmVFZmZlY3RzKCk7dmFyIGxhbmVzPWdldE5leHRMYW5lcyhyb290LE5vTGFuZXMpO2lmKCFpbmNsdWRlc1NvbWVMYW5lKGxhbmVzLFN5bmNMYW5lKSl7Ly8gVGhlcmUncyBubyByZW1haW5pbmcgc3luYyB3b3JrIGxlZnQuXG5lbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCxub3coKSk7cmV0dXJuIG51bGw7fXZhciBleGl0U3RhdHVzPXJlbmRlclJvb3RTeW5jKHJvb3QsbGFuZXMpO2lmKHJvb3QudGFnIT09TGVnYWN5Um9vdCYmZXhpdFN0YXR1cz09PVJvb3RFcnJvcmVkKXsvLyBJZiBzb21ldGhpbmcgdGhyZXcgYW4gZXJyb3IsIHRyeSByZW5kZXJpbmcgb25lIG1vcmUgdGltZS4gV2UnbGwgcmVuZGVyXG4vLyBzeW5jaHJvbm91c2x5IHRvIGJsb2NrIGNvbmN1cnJlbnQgZGF0YSBtdXRhdGlvbnMsIGFuZCB3ZSdsbCBpbmNsdWRlc1xuLy8gYWxsIHBlbmRpbmcgdXBkYXRlcyBhcmUgaW5jbHVkZWQuIElmIGl0IHN0aWxsIGZhaWxzIGFmdGVyIHRoZSBzZWNvbmRcbi8vIGF0dGVtcHQsIHdlJ2xsIGdpdmUgdXAgYW5kIGNvbW1pdCB0aGUgcmVzdWx0aW5nIHRyZWUuXG52YXIgZXJyb3JSZXRyeUxhbmVzPWdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpO2lmKGVycm9yUmV0cnlMYW5lcyE9PU5vTGFuZXMpe2xhbmVzPWVycm9yUmV0cnlMYW5lcztleGl0U3RhdHVzPXJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsZXJyb3JSZXRyeUxhbmVzKTt9fWlmKGV4aXRTdGF0dXM9PT1Sb290RmF0YWxFcnJvcmVkKXt2YXIgZmF0YWxFcnJvcj13b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yO3ByZXBhcmVGcmVzaFN0YWNrKHJvb3QsTm9MYW5lcyk7bWFya1Jvb3RTdXNwZW5kZWQkMShyb290LGxhbmVzKTtlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCxub3coKSk7dGhyb3cgZmF0YWxFcnJvcjt9aWYoZXhpdFN0YXR1cz09PVJvb3REaWROb3RDb21wbGV0ZSl7dGhyb3cgbmV3IEVycm9yKCdSb290IGRpZCBub3QgY29tcGxldGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7fS8vIFdlIG5vdyBoYXZlIGEgY29uc2lzdGVudCB0cmVlLiBCZWNhdXNlIHRoaXMgaXMgYSBzeW5jIHJlbmRlciwgd2Vcbi8vIHdpbGwgY29tbWl0IGl0IGV2ZW4gaWYgc29tZXRoaW5nIHN1c3BlbmRlZC5cbnZhciBmaW5pc2hlZFdvcms9cm9vdC5jdXJyZW50LmFsdGVybmF0ZTtyb290LmZpbmlzaGVkV29yaz1maW5pc2hlZFdvcms7cm9vdC5maW5pc2hlZExhbmVzPWxhbmVzO2NvbW1pdFJvb3Qocm9vdCx3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyx3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKTsvLyBCZWZvcmUgZXhpdGluZywgbWFrZSBzdXJlIHRoZXJlJ3MgYSBjYWxsYmFjayBzY2hlZHVsZWQgZm9yIHRoZSBuZXh0XG4vLyBwZW5kaW5nIGxldmVsLlxuZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3Qsbm93KCkpO3JldHVybiBudWxsO31mdW5jdGlvbiBmbHVzaFJvb3Qocm9vdCxsYW5lcyl7aWYobGFuZXMhPT1Ob0xhbmVzKXttYXJrUm9vdEVudGFuZ2xlZChyb290LG1lcmdlTGFuZXMobGFuZXMsU3luY0xhbmUpKTtlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCxub3coKSk7aWYoKGV4ZWN1dGlvbkNvbnRleHQmKFJlbmRlckNvbnRleHR8Q29tbWl0Q29udGV4dCkpPT09Tm9Db250ZXh0KXtyZXNldFJlbmRlclRpbWVyKCk7Zmx1c2hTeW5jQ2FsbGJhY2tzKCk7fX19ZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMkMShmbixhKXt2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQ9ZXhlY3V0aW9uQ29udGV4dDtleGVjdXRpb25Db250ZXh0fD1CYXRjaGVkQ29udGV4dDt0cnl7cmV0dXJuIGZuKGEpO31maW5hbGx5e2V4ZWN1dGlvbkNvbnRleHQ9cHJldkV4ZWN1dGlvbkNvbnRleHQ7Ly8gSWYgdGhlcmUgd2VyZSBsZWdhY3kgc3luYyB1cGRhdGVzLCBmbHVzaCB0aGVtIGF0IHRoZSBlbmQgb2YgdGhlIG91dGVyXG4vLyBtb3N0IGJhdGNoZWRVcGRhdGVzLWxpa2UgbWV0aG9kLlxuaWYoZXhlY3V0aW9uQ29udGV4dD09PU5vQ29udGV4dCYmLy8gVHJlYXQgYGFjdGAgYXMgaWYgaXQncyBpbnNpZGUgYGJhdGNoZWRVcGRhdGVzYCwgZXZlbiBpbiBsZWdhY3kgbW9kZS5cbiFSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmlzQmF0Y2hpbmdMZWdhY3kpe3Jlc2V0UmVuZGVyVGltZXIoKTtmbHVzaFN5bmNDYWxsYmFja3NPbmx5SW5MZWdhY3lNb2RlKCk7fX19ZnVuY3Rpb24gZGlzY3JldGVVcGRhdGVzKGZuLGEsYixjLGQpe3ZhciBwcmV2aW91c1ByaW9yaXR5PWdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO3ZhciBwcmV2VHJhbnNpdGlvbj1SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb247dHJ5e1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbj1udWxsO3NldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO3JldHVybiBmbihhLGIsYyxkKTt9ZmluYWxseXtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uPXByZXZUcmFuc2l0aW9uO2lmKGV4ZWN1dGlvbkNvbnRleHQ9PT1Ob0NvbnRleHQpe3Jlc2V0UmVuZGVyVGltZXIoKTt9fX0vLyBPdmVybG9hZCB0aGUgZGVmaW5pdGlvbiB0byB0aGUgdHdvIHZhbGlkIHNpZ25hdHVyZXMuXG4vLyBXYXJuaW5nLCB0aGlzIG9wdHMtb3V0IG9mIGNoZWNraW5nIHRoZSBmdW5jdGlvbiBib2R5LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuZnVuY3Rpb24gZmx1c2hTeW5jKGZuKXsvLyBJbiBsZWdhY3kgbW9kZSwgd2UgZmx1c2ggcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGVcbi8vIG5leHQgZXZlbnQsIG5vdCBhdCB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyBvbmUuXG5pZihyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyE9PW51bGwmJnJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLnRhZz09PUxlZ2FjeVJvb3QmJihleGVjdXRpb25Db250ZXh0JihSZW5kZXJDb250ZXh0fENvbW1pdENvbnRleHQpKT09PU5vQ29udGV4dCl7Zmx1c2hQYXNzaXZlRWZmZWN0cygpO312YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQ9ZXhlY3V0aW9uQ29udGV4dDtleGVjdXRpb25Db250ZXh0fD1CYXRjaGVkQ29udGV4dDt2YXIgcHJldlRyYW5zaXRpb249UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uO3ZhciBwcmV2aW91c1ByaW9yaXR5PWdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO3RyeXtSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb249bnVsbDtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtpZihmbil7cmV0dXJuIGZuKCk7fWVsc2V7cmV0dXJuIHVuZGVmaW5lZDt9fWZpbmFsbHl7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbj1wcmV2VHJhbnNpdGlvbjtleGVjdXRpb25Db250ZXh0PXByZXZFeGVjdXRpb25Db250ZXh0Oy8vIEZsdXNoIHRoZSBpbW1lZGlhdGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgYmF0Y2guXG4vLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGhhcHBlbiBldmVuIGlmIGJhdGNoZWRVcGRhdGVzIGlzIGhpZ2hlciB1cFxuLy8gdGhlIHN0YWNrLlxuaWYoKGV4ZWN1dGlvbkNvbnRleHQmKFJlbmRlckNvbnRleHR8Q29tbWl0Q29udGV4dCkpPT09Tm9Db250ZXh0KXtmbHVzaFN5bmNDYWxsYmFja3MoKTt9fX1mdW5jdGlvbiBpc0FscmVhZHlSZW5kZXJpbmcoKXsvLyBVc2VkIGJ5IHRoZSByZW5kZXJlciB0byBwcmludCBhIHdhcm5pbmcgaWYgY2VydGFpbiBBUElzIGFyZSBjYWxsZWQgZnJvbVxuLy8gdGhlIHdyb25nIGNvbnRleHQuXG5yZXR1cm4oZXhlY3V0aW9uQ29udGV4dCYoUmVuZGVyQ29udGV4dHxDb21taXRDb250ZXh0KSkhPT1Ob0NvbnRleHQ7fWZ1bmN0aW9uIHB1c2hSZW5kZXJMYW5lcyhmaWJlcixsYW5lcyl7cHVzaChzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3Isc3VidHJlZVJlbmRlckxhbmVzLGZpYmVyKTtzdWJ0cmVlUmVuZGVyTGFuZXM9bWVyZ2VMYW5lcyhzdWJ0cmVlUmVuZGVyTGFuZXMsbGFuZXMpO3dvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXM9bWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzLGxhbmVzKTt9ZnVuY3Rpb24gcG9wUmVuZGVyTGFuZXMoZmliZXIpe3N1YnRyZWVSZW5kZXJMYW5lcz1zdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IuY3VycmVudDtwb3Aoc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yLGZpYmVyKTt9ZnVuY3Rpb24gcHJlcGFyZUZyZXNoU3RhY2socm9vdCxsYW5lcyl7cm9vdC5maW5pc2hlZFdvcms9bnVsbDtyb290LmZpbmlzaGVkTGFuZXM9Tm9MYW5lczt2YXIgdGltZW91dEhhbmRsZT1yb290LnRpbWVvdXRIYW5kbGU7aWYodGltZW91dEhhbmRsZSE9PW5vVGltZW91dCl7Ly8gVGhlIHJvb3QgcHJldmlvdXMgc3VzcGVuZGVkIGFuZCBzY2hlZHVsZWQgYSB0aW1lb3V0IHRvIGNvbW1pdCBhIGZhbGxiYWNrXG4vLyBzdGF0ZS4gTm93IHRoYXQgd2UgaGF2ZSBhZGRpdGlvbmFsIHdvcmssIGNhbmNlbCB0aGUgdGltZW91dC5cbnJvb3QudGltZW91dEhhbmRsZT1ub1RpbWVvdXQ7Ly8gJEZsb3dGaXhNZSBDb21wbGFpbnMgbm9UaW1lb3V0IGlzIG5vdCBhIFRpbWVvdXRJRCwgZGVzcGl0ZSB0aGUgY2hlY2sgYWJvdmVcbmNhbmNlbFRpbWVvdXQodGltZW91dEhhbmRsZSk7fWlmKHdvcmtJblByb2dyZXNzIT09bnVsbCl7dmFyIGludGVycnVwdGVkV29yaz13b3JrSW5Qcm9ncmVzcy5yZXR1cm47d2hpbGUoaW50ZXJydXB0ZWRXb3JrIT09bnVsbCl7dmFyIGN1cnJlbnQ9aW50ZXJydXB0ZWRXb3JrLmFsdGVybmF0ZTt1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCxpbnRlcnJ1cHRlZFdvcmspO2ludGVycnVwdGVkV29yaz1pbnRlcnJ1cHRlZFdvcmsucmV0dXJuO319d29ya0luUHJvZ3Jlc3NSb290PXJvb3Q7dmFyIHJvb3RXb3JrSW5Qcm9ncmVzcz1jcmVhdGVXb3JrSW5Qcm9ncmVzcyhyb290LmN1cnJlbnQsbnVsbCk7d29ya0luUHJvZ3Jlc3M9cm9vdFdvcmtJblByb2dyZXNzO3dvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzPXN1YnRyZWVSZW5kZXJMYW5lcz13b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzPWxhbmVzO3dvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9Um9vdEluUHJvZ3Jlc3M7d29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvcj1udWxsO3dvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcz1Ob0xhbmVzO3dvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzPU5vTGFuZXM7d29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXM9Tm9MYW5lczt3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzPW51bGw7d29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM9bnVsbDtmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCk7e1JlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmRpc2NhcmRQZW5kaW5nV2FybmluZ3MoKTt9cmV0dXJuIHJvb3RXb3JrSW5Qcm9ncmVzczt9ZnVuY3Rpb24gaGFuZGxlRXJyb3Iocm9vdCx0aHJvd25WYWx1ZSl7ZG97dmFyIGVycm9yZWRXb3JrPXdvcmtJblByb2dyZXNzO3RyeXsvLyBSZXNldCBtb2R1bGUtbGV2ZWwgc3RhdGUgdGhhdCB3YXMgc2V0IGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxucmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7cmVzZXRIb29rc0FmdGVyVGhyb3coKTtyZXNldEN1cnJlbnRGaWJlcigpOy8vIFRPRE86IEkgZm91bmQgYW5kIGFkZGVkIHRoaXMgbWlzc2luZyBsaW5lIHdoaWxlIGludmVzdGlnYXRpbmcgYVxuLy8gc2VwYXJhdGUgaXNzdWUuIFdyaXRlIGEgcmVncmVzc2lvbiB0ZXN0IHVzaW5nIHN0cmluZyByZWZzLlxuUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50PW51bGw7aWYoZXJyb3JlZFdvcms9PT1udWxsfHxlcnJvcmVkV29yay5yZXR1cm49PT1udWxsKXsvLyBFeHBlY3RlZCB0byBiZSB3b3JraW5nIG9uIGEgbm9uLXJvb3QgZmliZXIuIFRoaXMgaXMgYSBmYXRhbCBlcnJvclxuLy8gYmVjYXVzZSB0aGVyZSdzIG5vIGFuY2VzdG9yIHRoYXQgY2FuIGhhbmRsZSBpdDsgdGhlIHJvb3QgaXNcbi8vIHN1cHBvc2VkIHRvIGNhcHR1cmUgYWxsIGVycm9ycyB0aGF0IHdlcmVuJ3QgY2F1Z2h0IGJ5IGFuIGVycm9yXG4vLyBib3VuZGFyeS5cbndvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9Um9vdEZhdGFsRXJyb3JlZDt3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yPXRocm93blZhbHVlOy8vIFNldCBgd29ya0luUHJvZ3Jlc3NgIHRvIG51bGwuIFRoaXMgcmVwcmVzZW50cyBhZHZhbmNpbmcgdG8gdGhlIG5leHRcbi8vIHNpYmxpbmcsIG9yIHRoZSBwYXJlbnQgaWYgdGhlcmUgYXJlIG5vIHNpYmxpbmdzLiBCdXQgc2luY2UgdGhlIHJvb3Rcbi8vIGhhcyBubyBzaWJsaW5ncyBub3IgYSBwYXJlbnQsIHdlIHNldCBpdCB0byBudWxsLiBVc3VhbGx5IHRoaXMgaXNcbi8vIGhhbmRsZWQgYnkgYGNvbXBsZXRlVW5pdE9mV29ya2Agb3IgYHVud2luZFdvcmtgLCBidXQgc2luY2Ugd2UncmVcbi8vIGludGVudGlvbmFsbHkgbm90IGNhbGxpbmcgdGhvc2UsIHdlIG5lZWQgc2V0IGl0IGhlcmUuXG4vLyBUT0RPOiBDb25zaWRlciBjYWxsaW5nIGB1bndpbmRXb3JrYCB0byBwb3AgdGhlIGNvbnRleHRzLlxud29ya0luUHJvZ3Jlc3M9bnVsbDtyZXR1cm47fWlmKGVuYWJsZVByb2ZpbGVyVGltZXImJmVycm9yZWRXb3JrLm1vZGUmUHJvZmlsZU1vZGUpey8vIFJlY29yZCB0aGUgdGltZSBzcGVudCByZW5kZXJpbmcgYmVmb3JlIGFuIGVycm9yIHdhcyB0aHJvd24uIFRoaXNcbi8vIGF2b2lkcyBpbmFjY3VyYXRlIFByb2ZpbGVyIGR1cmF0aW9ucyBpbiB0aGUgY2FzZSBvZiBhXG4vLyBzdXNwZW5kZWQgcmVuZGVyLlxuc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShlcnJvcmVkV29yayx0cnVlKTt9aWYoZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyKXttYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO2lmKHRocm93blZhbHVlIT09bnVsbCYmdHlwZW9mIHRocm93blZhbHVlPT09J29iamVjdCcmJnR5cGVvZiB0aHJvd25WYWx1ZS50aGVuPT09J2Z1bmN0aW9uJyl7dmFyIHdha2VhYmxlPXRocm93blZhbHVlO21hcmtDb21wb25lbnRTdXNwZW5kZWQoZXJyb3JlZFdvcmssd2FrZWFibGUsd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO31lbHNle21hcmtDb21wb25lbnRFcnJvcmVkKGVycm9yZWRXb3JrLHRocm93blZhbHVlLHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTt9fXRocm93RXhjZXB0aW9uKHJvb3QsZXJyb3JlZFdvcmsucmV0dXJuLGVycm9yZWRXb3JrLHRocm93blZhbHVlLHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtjb21wbGV0ZVVuaXRPZldvcmsoZXJyb3JlZFdvcmspO31jYXRjaCh5ZXRBbm90aGVyVGhyb3duVmFsdWUpey8vIFNvbWV0aGluZyBpbiB0aGUgcmV0dXJuIHBhdGggYWxzbyB0aHJldy5cbnRocm93blZhbHVlPXlldEFub3RoZXJUaHJvd25WYWx1ZTtpZih3b3JrSW5Qcm9ncmVzcz09PWVycm9yZWRXb3JrJiZlcnJvcmVkV29yayE9PW51bGwpey8vIElmIHRoaXMgYm91bmRhcnkgaGFzIGFscmVhZHkgZXJyb3JlZCwgdGhlbiB3ZSBoYWQgdHJvdWJsZSBwcm9jZXNzaW5nXG4vLyB0aGUgZXJyb3IuIEJ1YmJsZSBpdCB0byB0aGUgbmV4dCBib3VuZGFyeS5cbmVycm9yZWRXb3JrPWVycm9yZWRXb3JrLnJldHVybjt3b3JrSW5Qcm9ncmVzcz1lcnJvcmVkV29yazt9ZWxzZXtlcnJvcmVkV29yaz13b3JrSW5Qcm9ncmVzczt9Y29udGludWU7fS8vIFJldHVybiB0byB0aGUgbm9ybWFsIHdvcmsgbG9vcC5cbnJldHVybjt9d2hpbGUodHJ1ZSk7fWZ1bmN0aW9uIHB1c2hEaXNwYXRjaGVyKCl7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMi5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMi5jdXJyZW50PUNvbnRleHRPbmx5RGlzcGF0Y2hlcjtpZihwcmV2RGlzcGF0Y2hlcj09PW51bGwpey8vIFRoZSBSZWFjdCBpc29tb3JwaGljIHBhY2thZ2UgZG9lcyBub3QgaW5jbHVkZSBhIGRlZmF1bHQgZGlzcGF0Y2hlci5cbi8vIEluc3RlYWQgdGhlIGZpcnN0IHJlbmRlcmVyIHdpbGwgbGF6aWx5IGF0dGFjaCBvbmUsIGluIG9yZGVyIHRvIGdpdmVcbi8vIG5pY2VyIGVycm9yIG1lc3NhZ2VzLlxucmV0dXJuIENvbnRleHRPbmx5RGlzcGF0Y2hlcjt9ZWxzZXtyZXR1cm4gcHJldkRpc3BhdGNoZXI7fX1mdW5jdGlvbiBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9ZnVuY3Rpb24gbWFya0NvbW1pdFRpbWVPZkZhbGxiYWNrKCl7Z2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZT1ub3coKTt9ZnVuY3Rpb24gbWFya1NraXBwZWRVcGRhdGVMYW5lcyhsYW5lKXt3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXM9bWVyZ2VMYW5lcyhsYW5lLHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyk7fWZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmQoKXtpZih3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPT09Um9vdEluUHJvZ3Jlc3Mpe3dvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9Um9vdFN1c3BlbmRlZDt9fWZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKXtpZih3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPT09Um9vdEluUHJvZ3Jlc3N8fHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9PT1Sb290U3VzcGVuZGVkfHx3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPT09Um9vdEVycm9yZWQpe3dvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9Um9vdFN1c3BlbmRlZFdpdGhEZWxheTt9Ly8gQ2hlY2sgaWYgdGhlcmUgYXJlIHVwZGF0ZXMgdGhhdCB3ZSBza2lwcGVkIHRyZWUgdGhhdCBtaWdodCBoYXZlIHVuYmxvY2tlZFxuLy8gdGhpcyByZW5kZXIuXG5pZih3b3JrSW5Qcm9ncmVzc1Jvb3QhPT1udWxsJiYoaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMpfHxpbmNsdWRlc05vbklkbGVXb3JrKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzKSkpey8vIE1hcmsgdGhlIGN1cnJlbnQgcmVuZGVyIGFzIHN1c3BlbmRlZCBzbyB0aGF0IHdlIHN3aXRjaCB0byB3b3JraW5nIG9uXG4vLyB0aGUgdXBkYXRlcyB0aGF0IHdlcmUgc2tpcHBlZC4gVXN1YWxseSB3ZSBvbmx5IHN1c3BlbmQgYXQgdGhlIGVuZCBvZlxuLy8gdGhlIHJlbmRlciBwaGFzZS5cbi8vIFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBhbHdheXMgbWFyayB0aGUgcm9vdCBhcyBzdXNwZW5kZWQgaW1tZWRpYXRlbHlcbi8vIChpbnNpZGUgdGhpcyBmdW5jdGlvbiksIHNpbmNlIGJ5IHN1c3BlbmRpbmcgYXQgdGhlIGVuZCBvZiB0aGUgcmVuZGVyXG4vLyBwaGFzZSBpbnRyb2R1Y2VzIGEgcG90ZW50aWFsIG1pc3Rha2Ugd2hlcmUgd2Ugc3VzcGVuZCBsYW5lcyB0aGF0IHdlcmVcbi8vIHBpbmdlZCBvciB1cGRhdGVkIHdoaWxlIHdlIHdlcmUgcmVuZGVyaW5nLlxubWFya1Jvb3RTdXNwZW5kZWQkMSh3b3JrSW5Qcm9ncmVzc1Jvb3Qsd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO319ZnVuY3Rpb24gcmVuZGVyRGlkRXJyb3IoZXJyb3Ipe2lmKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMhPT1Sb290U3VzcGVuZGVkV2l0aERlbGF5KXt3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPVJvb3RFcnJvcmVkO31pZih3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzPT09bnVsbCl7d29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycz1bZXJyb3JdO31lbHNle3dvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMucHVzaChlcnJvcik7fX0vLyBDYWxsZWQgZHVyaW5nIHJlbmRlciB0byBkZXRlcm1pbmUgaWYgYW55dGhpbmcgaGFzIHN1c3BlbmRlZC5cbi8vIFJldHVybnMgZmFsc2UgaWYgd2UncmUgbm90IHN1cmUuXG5mdW5jdGlvbiByZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKXsvLyBJZiBzb21ldGhpbmcgZXJyb3JlZCBvciBjb21wbGV0ZWQsIHdlIGNhbid0IHJlYWxseSBiZSBzdXJlLFxuLy8gc28gdGhvc2UgYXJlIGZhbHNlLlxucmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9PT1Sb290SW5Qcm9ncmVzczt9ZnVuY3Rpb24gcmVuZGVyUm9vdFN5bmMocm9vdCxsYW5lcyl7dmFyIHByZXZFeGVjdXRpb25Db250ZXh0PWV4ZWN1dGlvbkNvbnRleHQ7ZXhlY3V0aW9uQ29udGV4dHw9UmVuZGVyQ29udGV4dDt2YXIgcHJldkRpc3BhdGNoZXI9cHVzaERpc3BhdGNoZXIoKTsvLyBJZiB0aGUgcm9vdCBvciBsYW5lcyBoYXZlIGNoYW5nZWQsIHRocm93IG91dCB0aGUgZXhpc3Rpbmcgc3RhY2tcbi8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5pZih3b3JrSW5Qcm9ncmVzc1Jvb3QhPT1yb290fHx3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyE9PWxhbmVzKXt7aWYoaXNEZXZUb29sc1ByZXNlbnQpe3ZhciBtZW1vaXplZFVwZGF0ZXJzPXJvb3QubWVtb2l6ZWRVcGRhdGVycztpZihtZW1vaXplZFVwZGF0ZXJzLnNpemU+MCl7cmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTttZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7fS8vIEF0IHRoaXMgcG9pbnQsIG1vdmUgRmliZXJzIHRoYXQgc2NoZWR1bGVkIHRoZSB1cGNvbWluZyB3b3JrIGZyb20gdGhlIE1hcCB0byB0aGUgU2V0LlxuLy8gSWYgd2UgYmFpbG91dCBvbiB0aGlzIHdvcmssIHdlJ2xsIG1vdmUgdGhlbSBiYWNrIChsaWtlIGFib3ZlKS5cbi8vIEl0J3MgaW1wb3J0YW50IHRvIG1vdmUgdGhlbSBub3cgaW4gY2FzZSB0aGUgd29yayBzcGF3bnMgbW9yZSB3b3JrIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGggZGlmZmVyZW50IHVwZGF0ZXJzLlxuLy8gVGhhdCB3YXkgd2UgY2FuIGtlZXAgdGhlIGN1cnJlbnQgdXBkYXRlIGFuZCBmdXR1cmUgdXBkYXRlcyBzZXBhcmF0ZS5cbm1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LGxhbmVzKTt9fXdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnM9Z2V0VHJhbnNpdGlvbnNGb3JMYW5lcygpO3ByZXBhcmVGcmVzaFN0YWNrKHJvb3QsbGFuZXMpO317bWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO31kb3t0cnl7d29ya0xvb3BTeW5jKCk7YnJlYWs7fWNhdGNoKHRocm93blZhbHVlKXtoYW5kbGVFcnJvcihyb290LHRocm93blZhbHVlKTt9fXdoaWxlKHRydWUpO3Jlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO2V4ZWN1dGlvbkNvbnRleHQ9cHJldkV4ZWN1dGlvbkNvbnRleHQ7cG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcik7aWYod29ya0luUHJvZ3Jlc3MhPT1udWxsKXsvLyBUaGlzIGlzIGEgc3luYyByZW5kZXIsIHNvIHdlIHNob3VsZCBoYXZlIGZpbmlzaGVkIHRoZSB3aG9sZSB0cmVlLlxudGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tbWl0IGFuIGluY29tcGxldGUgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgJysnYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9e21hcmtSZW5kZXJTdG9wcGVkKCk7fS8vIFNldCB0aGlzIHRvIG51bGwgdG8gaW5kaWNhdGUgdGhlcmUncyBubyBpbi1wcm9ncmVzcyByZW5kZXIuXG53b3JrSW5Qcm9ncmVzc1Jvb3Q9bnVsbDt3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcz1Ob0xhbmVzO3JldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO30vLyBUaGUgd29yayBsb29wIGlzIGFuIGV4dHJlbWVseSBob3QgcGF0aC4gVGVsbCBDbG9zdXJlIG5vdCB0byBpbmxpbmUgaXQuXG4vKiogQG5vaW5saW5lICovZnVuY3Rpb24gd29ya0xvb3BTeW5jKCl7Ly8gQWxyZWFkeSB0aW1lZCBvdXQsIHNvIHBlcmZvcm0gd29yayB3aXRob3V0IGNoZWNraW5nIGlmIHdlIG5lZWQgdG8geWllbGQuXG53aGlsZSh3b3JrSW5Qcm9ncmVzcyE9PW51bGwpe3BlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTt9fWZ1bmN0aW9uIHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsbGFuZXMpe3ZhciBwcmV2RXhlY3V0aW9uQ29udGV4dD1leGVjdXRpb25Db250ZXh0O2V4ZWN1dGlvbkNvbnRleHR8PVJlbmRlckNvbnRleHQ7dmFyIHByZXZEaXNwYXRjaGVyPXB1c2hEaXNwYXRjaGVyKCk7Ly8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4vLyBhbmQgcHJlcGFyZSBhIGZyZXNoIG9uZS4gT3RoZXJ3aXNlIHdlJ2xsIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmLlxuaWYod29ya0luUHJvZ3Jlc3NSb290IT09cm9vdHx8d29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMhPT1sYW5lcyl7e2lmKGlzRGV2VG9vbHNQcmVzZW50KXt2YXIgbWVtb2l6ZWRVcGRhdGVycz1yb290Lm1lbW9pemVkVXBkYXRlcnM7aWYobWVtb2l6ZWRVcGRhdGVycy5zaXplPjApe3Jlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCx3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7bWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO30vLyBBdCB0aGlzIHBvaW50LCBtb3ZlIEZpYmVycyB0aGF0IHNjaGVkdWxlZCB0aGUgdXBjb21pbmcgd29yayBmcm9tIHRoZSBNYXAgdG8gdGhlIFNldC5cbi8vIElmIHdlIGJhaWxvdXQgb24gdGhpcyB3b3JrLCB3ZSdsbCBtb3ZlIHRoZW0gYmFjayAobGlrZSBhYm92ZSkuXG4vLyBJdCdzIGltcG9ydGFudCB0byBtb3ZlIHRoZW0gbm93IGluIGNhc2UgdGhlIHdvcmsgc3Bhd25zIG1vcmUgd29yayBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoIGRpZmZlcmVudCB1cGRhdGVycy5cbi8vIFRoYXQgd2F5IHdlIGNhbiBrZWVwIHRoZSBjdXJyZW50IHVwZGF0ZSBhbmQgZnV0dXJlIHVwZGF0ZXMgc2VwYXJhdGUuXG5tb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCxsYW5lcyk7fX13b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zPWdldFRyYW5zaXRpb25zRm9yTGFuZXMoKTtyZXNldFJlbmRlclRpbWVyKCk7cHJlcGFyZUZyZXNoU3RhY2socm9vdCxsYW5lcyk7fXttYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7fWRve3RyeXt3b3JrTG9vcENvbmN1cnJlbnQoKTticmVhazt9Y2F0Y2godGhyb3duVmFsdWUpe2hhbmRsZUVycm9yKHJvb3QsdGhyb3duVmFsdWUpO319d2hpbGUodHJ1ZSk7cmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7cG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcik7ZXhlY3V0aW9uQ29udGV4dD1wcmV2RXhlY3V0aW9uQ29udGV4dDtpZih3b3JrSW5Qcm9ncmVzcyE9PW51bGwpey8vIFN0aWxsIHdvcmsgcmVtYWluaW5nLlxue21hcmtSZW5kZXJZaWVsZGVkKCk7fXJldHVybiBSb290SW5Qcm9ncmVzczt9ZWxzZXsvLyBDb21wbGV0ZWQgdGhlIHRyZWUuXG57bWFya1JlbmRlclN0b3BwZWQoKTt9Ly8gU2V0IHRoaXMgdG8gbnVsbCB0byBpbmRpY2F0ZSB0aGVyZSdzIG5vIGluLXByb2dyZXNzIHJlbmRlci5cbndvcmtJblByb2dyZXNzUm9vdD1udWxsO3dvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzPU5vTGFuZXM7Ly8gUmV0dXJuIHRoZSBmaW5hbCBleGl0IHN0YXR1cy5cbnJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO319LyoqIEBub2lubGluZSAqL2Z1bmN0aW9uIHdvcmtMb29wQ29uY3VycmVudCgpey8vIFBlcmZvcm0gd29yayB1bnRpbCBTY2hlZHVsZXIgYXNrcyB1cyB0byB5aWVsZFxud2hpbGUod29ya0luUHJvZ3Jlc3MhPT1udWxsJiYhc2hvdWxkWWllbGQoKSl7cGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO319ZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsodW5pdE9mV29yayl7Ly8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3Rcbi8vIG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpbiBwcm9ncmVzcy5cbnZhciBjdXJyZW50PXVuaXRPZldvcmsuYWx0ZXJuYXRlO3NldEN1cnJlbnRGaWJlcih1bml0T2ZXb3JrKTt2YXIgbmV4dDtpZigodW5pdE9mV29yay5tb2RlJlByb2ZpbGVNb2RlKSE9PU5vTW9kZSl7c3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspO25leHQ9YmVnaW5Xb3JrJDEoY3VycmVudCx1bml0T2ZXb3JrLHN1YnRyZWVSZW5kZXJMYW5lcyk7c3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh1bml0T2ZXb3JrLHRydWUpO31lbHNle25leHQ9YmVnaW5Xb3JrJDEoY3VycmVudCx1bml0T2ZXb3JrLHN1YnRyZWVSZW5kZXJMYW5lcyk7fXJlc2V0Q3VycmVudEZpYmVyKCk7dW5pdE9mV29yay5tZW1vaXplZFByb3BzPXVuaXRPZldvcmsucGVuZGluZ1Byb3BzO2lmKG5leHQ9PT1udWxsKXsvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG5jb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7fWVsc2V7d29ya0luUHJvZ3Jlc3M9bmV4dDt9UmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50PW51bGw7fWZ1bmN0aW9uIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKXsvLyBBdHRlbXB0IHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IHVuaXQgb2Ygd29yaywgdGhlbiBtb3ZlIHRvIHRoZSBuZXh0XG4vLyBzaWJsaW5nLiBJZiB0aGVyZSBhcmUgbm8gbW9yZSBzaWJsaW5ncywgcmV0dXJuIHRvIHRoZSBwYXJlbnQgZmliZXIuXG52YXIgY29tcGxldGVkV29yaz11bml0T2ZXb3JrO2Rvey8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuIElkZWFsbHlcbi8vIG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZSBtZWFucyB0aGF0IHdlIGRvbid0XG4vLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG52YXIgY3VycmVudD1jb21wbGV0ZWRXb3JrLmFsdGVybmF0ZTt2YXIgcmV0dXJuRmliZXI9Y29tcGxldGVkV29yay5yZXR1cm47Ly8gQ2hlY2sgaWYgdGhlIHdvcmsgY29tcGxldGVkIG9yIGlmIHNvbWV0aGluZyB0aHJldy5cbmlmKChjb21wbGV0ZWRXb3JrLmZsYWdzJkluY29tcGxldGUpPT09Tm9GbGFncyl7c2V0Q3VycmVudEZpYmVyKGNvbXBsZXRlZFdvcmspO3ZhciBuZXh0PXZvaWQgMDtpZigoY29tcGxldGVkV29yay5tb2RlJlByb2ZpbGVNb2RlKT09PU5vTW9kZSl7bmV4dD1jb21wbGV0ZVdvcmsoY3VycmVudCxjb21wbGV0ZWRXb3JrLHN1YnRyZWVSZW5kZXJMYW5lcyk7fWVsc2V7c3RhcnRQcm9maWxlclRpbWVyKGNvbXBsZXRlZFdvcmspO25leHQ9Y29tcGxldGVXb3JrKGN1cnJlbnQsY29tcGxldGVkV29yayxzdWJ0cmVlUmVuZGVyTGFuZXMpOy8vIFVwZGF0ZSByZW5kZXIgZHVyYXRpb24gYXNzdW1pbmcgd2UgZGlkbid0IGVycm9yLlxuc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShjb21wbGV0ZWRXb3JrLGZhbHNlKTt9cmVzZXRDdXJyZW50RmliZXIoKTtpZihuZXh0IT09bnVsbCl7Ly8gQ29tcGxldGluZyB0aGlzIGZpYmVyIHNwYXduZWQgbmV3IHdvcmsuIFdvcmsgb24gdGhhdCBuZXh0Llxud29ya0luUHJvZ3Jlc3M9bmV4dDtyZXR1cm47fX1lbHNley8vIFRoaXMgZmliZXIgZGlkIG5vdCBjb21wbGV0ZSBiZWNhdXNlIHNvbWV0aGluZyB0aHJldy4gUG9wIHZhbHVlcyBvZmZcbi8vIHRoZSBzdGFjayB3aXRob3V0IGVudGVyaW5nIHRoZSBjb21wbGV0ZSBwaGFzZS4gSWYgdGhpcyBpcyBhIGJvdW5kYXJ5LFxuLy8gY2FwdHVyZSB2YWx1ZXMgaWYgcG9zc2libGUuXG52YXIgX25leHQ9dW53aW5kV29yayhjdXJyZW50LGNvbXBsZXRlZFdvcmspOy8vIEJlY2F1c2UgdGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlLCBkb24ndCByZXNldCBpdHMgbGFuZXMuXG5pZihfbmV4dCE9PW51bGwpey8vIElmIGNvbXBsZXRpbmcgdGhpcyB3b3JrIHNwYXduZWQgbmV3IHdvcmssIGRvIHRoYXQgbmV4dC4gV2UnbGwgY29tZVxuLy8gYmFjayBoZXJlIGFnYWluLlxuLy8gU2luY2Ugd2UncmUgcmVzdGFydGluZywgcmVtb3ZlIGFueXRoaW5nIHRoYXQgaXMgbm90IGEgaG9zdCBlZmZlY3Rcbi8vIGZyb20gdGhlIGVmZmVjdCB0YWcuXG5fbmV4dC5mbGFncyY9SG9zdEVmZmVjdE1hc2s7d29ya0luUHJvZ3Jlc3M9X25leHQ7cmV0dXJuO31pZigoY29tcGxldGVkV29yay5tb2RlJlByb2ZpbGVNb2RlKSE9PU5vTW9kZSl7Ly8gUmVjb3JkIHRoZSByZW5kZXIgZHVyYXRpb24gZm9yIHRoZSBmaWJlciB0aGF0IGVycm9yZWQuXG5zdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGNvbXBsZXRlZFdvcmssZmFsc2UpOy8vIEluY2x1ZGUgdGhlIHRpbWUgc3BlbnQgd29ya2luZyBvbiBmYWlsZWQgY2hpbGRyZW4gYmVmb3JlIGNvbnRpbnVpbmcuXG52YXIgYWN0dWFsRHVyYXRpb249Y29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjt2YXIgY2hpbGQ9Y29tcGxldGVkV29yay5jaGlsZDt3aGlsZShjaGlsZCE9PW51bGwpe2FjdHVhbER1cmF0aW9uKz1jaGlsZC5hY3R1YWxEdXJhdGlvbjtjaGlsZD1jaGlsZC5zaWJsaW5nO31jb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uPWFjdHVhbER1cmF0aW9uO31pZihyZXR1cm5GaWJlciE9PW51bGwpey8vIE1hcmsgdGhlIHBhcmVudCBmaWJlciBhcyBpbmNvbXBsZXRlIGFuZCBjbGVhciBpdHMgc3VidHJlZSBmbGFncy5cbnJldHVybkZpYmVyLmZsYWdzfD1JbmNvbXBsZXRlO3JldHVybkZpYmVyLnN1YnRyZWVGbGFncz1Ob0ZsYWdzO3JldHVybkZpYmVyLmRlbGV0aW9ucz1udWxsO31lbHNley8vIFdlJ3ZlIHVud291bmQgYWxsIHRoZSB3YXkgdG8gdGhlIHJvb3QuXG53b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPVJvb3REaWROb3RDb21wbGV0ZTt3b3JrSW5Qcm9ncmVzcz1udWxsO3JldHVybjt9fXZhciBzaWJsaW5nRmliZXI9Y29tcGxldGVkV29yay5zaWJsaW5nO2lmKHNpYmxpbmdGaWJlciE9PW51bGwpey8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG53b3JrSW5Qcm9ncmVzcz1zaWJsaW5nRmliZXI7cmV0dXJuO30vLyBPdGhlcndpc2UsIHJldHVybiB0byB0aGUgcGFyZW50XG5jb21wbGV0ZWRXb3JrPXJldHVybkZpYmVyOy8vIFVwZGF0ZSB0aGUgbmV4dCB0aGluZyB3ZSdyZSB3b3JraW5nIG9uIGluIGNhc2Ugc29tZXRoaW5nIHRocm93cy5cbndvcmtJblByb2dyZXNzPWNvbXBsZXRlZFdvcms7fXdoaWxlKGNvbXBsZXRlZFdvcmshPT1udWxsKTsvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuaWYod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz09PVJvb3RJblByb2dyZXNzKXt3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPVJvb3RDb21wbGV0ZWQ7fX1mdW5jdGlvbiBjb21taXRSb290KHJvb3QscmVjb3ZlcmFibGVFcnJvcnMsdHJhbnNpdGlvbnMpey8vIFRPRE86IFRoaXMgbm8gbG9uZ2VyIG1ha2VzIGFueSBzZW5zZS4gV2UgYWxyZWFkeSB3cmFwIHRoZSBtdXRhdGlvbiBhbmRcbi8vIGxheW91dCBwaGFzZXMuIFNob3VsZCBiZSBhYmxlIHRvIHJlbW92ZS5cbnZhciBwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eT1nZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTt2YXIgcHJldlRyYW5zaXRpb249UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uO3RyeXtSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb249bnVsbDtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtjb21taXRSb290SW1wbChyb290LHJlY292ZXJhYmxlRXJyb3JzLHRyYW5zaXRpb25zLHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5KTt9ZmluYWxseXtSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb249cHJldlRyYW5zaXRpb247c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5KTt9cmV0dXJuIG51bGw7fWZ1bmN0aW9uIGNvbW1pdFJvb3RJbXBsKHJvb3QscmVjb3ZlcmFibGVFcnJvcnMsdHJhbnNpdGlvbnMscmVuZGVyUHJpb3JpdHlMZXZlbCl7ZG97Ly8gYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIHdpbGwgY2FsbCBgZmx1c2hTeW5jVXBkYXRlUXVldWVgIGF0IHRoZSBlbmQsIHdoaWNoXG4vLyBtZWFucyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBzb21ldGltZXMgcmVzdWx0IGluIGFkZGl0aW9uYWxcbi8vIHBhc3NpdmUgZWZmZWN0cy4gU28gd2UgbmVlZCB0byBrZWVwIGZsdXNoaW5nIGluIGEgbG9vcCB1bnRpbCB0aGVyZSBhcmVcbi8vIG5vIG1vcmUgcGVuZGluZyBlZmZlY3RzLlxuLy8gVE9ETzogTWlnaHQgYmUgYmV0dGVyIGlmIGBmbHVzaFBhc3NpdmVFZmZlY3RzYCBkaWQgbm90IGF1dG9tYXRpY2FsbHlcbi8vIGZsdXNoIHN5bmNocm9ub3VzIHdvcmsgYXQgdGhlIGVuZCwgdG8gYXZvaWQgZmFjdG9yaW5nIGhhemFyZHMgbGlrZSB0aGlzLlxuZmx1c2hQYXNzaXZlRWZmZWN0cygpO313aGlsZShyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyE9PW51bGwpO2ZsdXNoUmVuZGVyUGhhc2VTdHJpY3RNb2RlV2FybmluZ3NJbkRFVigpO2lmKChleGVjdXRpb25Db250ZXh0JihSZW5kZXJDb250ZXh0fENvbW1pdENvbnRleHQpKSE9PU5vQ29udGV4dCl7dGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTt9dmFyIGZpbmlzaGVkV29yaz1yb290LmZpbmlzaGVkV29yazt2YXIgbGFuZXM9cm9vdC5maW5pc2hlZExhbmVzO3ttYXJrQ29tbWl0U3RhcnRlZChsYW5lcyk7fWlmKGZpbmlzaGVkV29yaz09PW51bGwpe3ttYXJrQ29tbWl0U3RvcHBlZCgpO31yZXR1cm4gbnVsbDt9ZWxzZXt7aWYobGFuZXM9PT1Ob0xhbmVzKXtlcnJvcigncm9vdC5maW5pc2hlZExhbmVzIHNob3VsZCBub3QgYmUgZW1wdHkgZHVyaW5nIGEgY29tbWl0LiBUaGlzIGlzIGEgJysnYnVnIGluIFJlYWN0LicpO319fXJvb3QuZmluaXNoZWRXb3JrPW51bGw7cm9vdC5maW5pc2hlZExhbmVzPU5vTGFuZXM7aWYoZmluaXNoZWRXb3JrPT09cm9vdC5jdXJyZW50KXt0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21taXQgdGhlIHNhbWUgdHJlZSBhcyBiZWZvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSAnKydhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fS8vIGNvbW1pdFJvb3QgbmV2ZXIgcmV0dXJucyBhIGNvbnRpbnVhdGlvbjsgaXQgYWx3YXlzIGZpbmlzaGVzIHN5bmNocm9ub3VzbHkuXG4vLyBTbyB3ZSBjYW4gY2xlYXIgdGhlc2Ugbm93IHRvIGFsbG93IGEgbmV3IGNhbGxiYWNrIHRvIGJlIHNjaGVkdWxlZC5cbnJvb3QuY2FsbGJhY2tOb2RlPW51bGw7cm9vdC5jYWxsYmFja1ByaW9yaXR5PU5vTGFuZTsvLyBVcGRhdGUgdGhlIGZpcnN0IGFuZCBsYXN0IHBlbmRpbmcgdGltZXMgb24gdGhpcyByb290LiBUaGUgbmV3IGZpcnN0XG4vLyBwZW5kaW5nIHRpbWUgaXMgd2hhdGV2ZXIgaXMgbGVmdCBvbiB0aGUgcm9vdCBmaWJlci5cbnZhciByZW1haW5pbmdMYW5lcz1tZXJnZUxhbmVzKGZpbmlzaGVkV29yay5sYW5lcyxmaW5pc2hlZFdvcmsuY2hpbGRMYW5lcyk7bWFya1Jvb3RGaW5pc2hlZChyb290LHJlbWFpbmluZ0xhbmVzKTtpZihyb290PT09d29ya0luUHJvZ3Jlc3NSb290KXsvLyBXZSBjYW4gcmVzZXQgdGhlc2Ugbm93IHRoYXQgdGhleSBhcmUgZmluaXNoZWQuXG53b3JrSW5Qcm9ncmVzc1Jvb3Q9bnVsbDt3b3JrSW5Qcm9ncmVzcz1udWxsO3dvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzPU5vTGFuZXM7fS8vIElmIHRoZXJlIGFyZSBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cywgc2NoZWR1bGUgYSBjYWxsYmFjayB0byBwcm9jZXNzIHRoZW0uXG4vLyBEbyB0aGlzIGFzIGVhcmx5IGFzIHBvc3NpYmxlLCBzbyBpdCBpcyBxdWV1ZWQgYmVmb3JlIGFueXRoaW5nIGVsc2UgdGhhdFxuLy8gbWlnaHQgZ2V0IHNjaGVkdWxlZCBpbiB0aGUgY29tbWl0IHBoYXNlLiAoU2VlICMxNjcxNC4pXG4vLyBUT0RPOiBEZWxldGUgYWxsIG90aGVyIHBsYWNlcyB0aGF0IHNjaGVkdWxlIHRoZSBwYXNzaXZlIGVmZmVjdCBjYWxsYmFja1xuLy8gVGhleSdyZSByZWR1bmRhbnQuXG5pZigoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyZQYXNzaXZlTWFzaykhPT1Ob0ZsYWdzfHwoZmluaXNoZWRXb3JrLmZsYWdzJlBhc3NpdmVNYXNrKSE9PU5vRmxhZ3Mpe2lmKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyl7cm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHM9dHJ1ZTsvLyB0byBzdG9yZSBpdCBpbiBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zIHVudGlsIHRoZXkgZ2V0IHByb2Nlc3NlZFxuLy8gV2UgbmVlZCB0byBwYXNzIHRoaXMgdGhyb3VnaCBhcyBhbiBhcmd1bWVudCB0byBjb21taXRSb290XG4vLyBiZWNhdXNlIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgbWlnaHQgaGF2ZSBjaGFuZ2VkIGJldHdlZW5cbi8vIHRoZSBwcmV2aW91cyByZW5kZXIgYW5kIGNvbW1pdCBpZiB3ZSB0aHJvdHRsZSB0aGUgY29tbWl0XG4vLyB3aXRoIHNldFRpbWVvdXRcbnBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnM9dHJhbnNpdGlvbnM7c2NoZWR1bGVDYWxsYmFjayQxKE5vcm1hbFByaW9yaXR5LGZ1bmN0aW9uKCl7Zmx1c2hQYXNzaXZlRWZmZWN0cygpOy8vIFRoaXMgcmVuZGVyIHRyaWdnZXJlZCBwYXNzaXZlIGVmZmVjdHM6IHJlbGVhc2UgdGhlIHJvb3QgY2FjaGUgcG9vbFxuLy8gKmFmdGVyKiBwYXNzaXZlIGVmZmVjdHMgZmlyZSB0byBhdm9pZCBmcmVlaW5nIGEgY2FjaGUgcG9vbCB0aGF0IG1heVxuLy8gYmUgcmVmZXJlbmNlZCBieSBhIG5vZGUgaW4gdGhlIHRyZWUgKEhvc3RSb290LCBDYWNoZSBib3VuZGFyeSBldGMpXG5yZXR1cm4gbnVsbDt9KTt9fS8vIENoZWNrIGlmIHRoZXJlIGFyZSBhbnkgZWZmZWN0cyBpbiB0aGUgd2hvbGUgdHJlZS5cbi8vIFRPRE86IFRoaXMgaXMgbGVmdCBvdmVyIGZyb20gdGhlIGVmZmVjdCBsaXN0IGltcGxlbWVudGF0aW9uLCB3aGVyZSB3ZSBoYWRcbi8vIHRvIGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGBmaXJzdEVmZmVjdGAgdG8gc2F0aXNmeSBGbG93LiBJIHRoaW5rIHRoZVxuLy8gb25seSBvdGhlciByZWFzb24gdGhpcyBvcHRpbWl6YXRpb24gZXhpc3RzIGlzIGJlY2F1c2UgaXQgYWZmZWN0cyBwcm9maWxpbmcuXG4vLyBSZWNvbnNpZGVyIHdoZXRoZXIgdGhpcyBpcyBuZWNlc3NhcnkuXG52YXIgc3VidHJlZUhhc0VmZmVjdHM9KGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MmKEJlZm9yZU11dGF0aW9uTWFza3xNdXRhdGlvbk1hc2t8TGF5b3V0TWFza3xQYXNzaXZlTWFzaykpIT09Tm9GbGFnczt2YXIgcm9vdEhhc0VmZmVjdD0oZmluaXNoZWRXb3JrLmZsYWdzJihCZWZvcmVNdXRhdGlvbk1hc2t8TXV0YXRpb25NYXNrfExheW91dE1hc2t8UGFzc2l2ZU1hc2spKSE9PU5vRmxhZ3M7aWYoc3VidHJlZUhhc0VmZmVjdHN8fHJvb3RIYXNFZmZlY3Qpe3ZhciBwcmV2VHJhbnNpdGlvbj1SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb247UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uPW51bGw7dmFyIHByZXZpb3VzUHJpb3JpdHk9Z2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7dmFyIHByZXZFeGVjdXRpb25Db250ZXh0PWV4ZWN1dGlvbkNvbnRleHQ7ZXhlY3V0aW9uQ29udGV4dHw9Q29tbWl0Q29udGV4dDsvLyBSZXNldCB0aGlzIHRvIG51bGwgYmVmb3JlIGNhbGxpbmcgbGlmZWN5Y2xlc1xuUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50PW51bGw7Ly8gVGhlIGNvbW1pdCBwaGFzZSBpcyBicm9rZW4gaW50byBzZXZlcmFsIHN1Yi1waGFzZXMuIFdlIGRvIGEgc2VwYXJhdGUgcGFzc1xuLy8gb2YgdGhlIGVmZmVjdCBsaXN0IGZvciBlYWNoIHBoYXNlOiBhbGwgbXV0YXRpb24gZWZmZWN0cyBjb21lIGJlZm9yZSBhbGxcbi8vIGxheW91dCBlZmZlY3RzLCBhbmQgc28gb24uXG4vLyBUaGUgZmlyc3QgcGhhc2UgYSBcImJlZm9yZSBtdXRhdGlvblwiIHBoYXNlLiBXZSB1c2UgdGhpcyBwaGFzZSB0byByZWFkIHRoZVxuLy8gc3RhdGUgb2YgdGhlIGhvc3QgdHJlZSByaWdodCBiZWZvcmUgd2UgbXV0YXRlIGl0LiBUaGlzIGlzIHdoZXJlXG4vLyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSBpcyBjYWxsZWQuXG52YXIgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyPWNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LGZpbmlzaGVkV29yayk7ey8vIE1hcmsgdGhlIGN1cnJlbnQgY29tbWl0IHRpbWUgdG8gYmUgc2hhcmVkIGJ5IGFsbCBQcm9maWxlcnMgaW4gdGhpc1xuLy8gYmF0Y2guIFRoaXMgZW5hYmxlcyB0aGVtIHRvIGJlIGdyb3VwZWQgbGF0ZXIuXG5yZWNvcmRDb21taXRUaW1lKCk7fWNvbW1pdE11dGF0aW9uRWZmZWN0cyhyb290LGZpbmlzaGVkV29yayxsYW5lcyk7cmVzZXRBZnRlckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pOy8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHRyZWUgaXMgbm93IHRoZSBjdXJyZW50IHRyZWUuIFRoaXMgbXVzdCBjb21lIGFmdGVyXG4vLyB0aGUgbXV0YXRpb24gcGhhc2UsIHNvIHRoYXQgdGhlIHByZXZpb3VzIHRyZWUgaXMgc3RpbGwgY3VycmVudCBkdXJpbmdcbi8vIGNvbXBvbmVudFdpbGxVbm1vdW50LCBidXQgYmVmb3JlIHRoZSBsYXlvdXQgcGhhc2UsIHNvIHRoYXQgdGhlIGZpbmlzaGVkXG4vLyB3b3JrIGlzIGN1cnJlbnQgZHVyaW5nIGNvbXBvbmVudERpZE1vdW50L1VwZGF0ZS5cbnJvb3QuY3VycmVudD1maW5pc2hlZFdvcms7Ly8gVGhlIG5leHQgcGhhc2UgaXMgdGhlIGxheW91dCBwaGFzZSwgd2hlcmUgd2UgY2FsbCBlZmZlY3RzIHRoYXQgcmVhZFxue21hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZChsYW5lcyk7fWNvbW1pdExheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLHJvb3QsbGFuZXMpO3ttYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQoKTt9Ly8gb3Bwb3J0dW5pdHkgdG8gcGFpbnQuXG5yZXF1ZXN0UGFpbnQoKTtleGVjdXRpb25Db250ZXh0PXByZXZFeGVjdXRpb25Db250ZXh0Oy8vIFJlc2V0IHRoZSBwcmlvcml0eSB0byB0aGUgcHJldmlvdXMgbm9uLXN5bmMgdmFsdWUuXG5zZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uPXByZXZUcmFuc2l0aW9uO31lbHNley8vIE5vIGVmZmVjdHMuXG5yb290LmN1cnJlbnQ9ZmluaXNoZWRXb3JrOy8vIE1lYXN1cmUgdGhlc2UgYW55d2F5IHNvIHRoZSBmbGFtZWdyYXBoIGV4cGxpY2l0bHkgc2hvd3MgdGhhdCB0aGVyZSB3ZXJlXG4vLyBubyBlZmZlY3RzLlxuLy8gVE9ETzogTWF5YmUgdGhlcmUncyBhIGJldHRlciB3YXkgdG8gcmVwb3J0IHRoaXMuXG57cmVjb3JkQ29tbWl0VGltZSgpO319dmFyIHJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHM9cm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHM7aWYocm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpey8vIFRoaXMgY29tbWl0IGhhcyBwYXNzaXZlIGVmZmVjdHMuIFN0YXNoIGEgcmVmZXJlbmNlIHRvIHRoZW0uIEJ1dCBkb24ndFxuLy8gc2NoZWR1bGUgYSBjYWxsYmFjayB1bnRpbCBhZnRlciBmbHVzaGluZyBsYXlvdXQgd29yay5cbnJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzPWZhbHNlO3Jvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzPXJvb3Q7cGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM9bGFuZXM7fWVsc2V7e25lc3RlZFBhc3NpdmVVcGRhdGVDb3VudD0wO3Jvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXM9bnVsbDt9fS8vIFJlYWQgdGhpcyBhZ2Fpbiwgc2luY2UgYW4gZWZmZWN0IG1pZ2h0IGhhdmUgdXBkYXRlZCBpdFxucmVtYWluaW5nTGFuZXM9cm9vdC5wZW5kaW5nTGFuZXM7Ly8gQ2hlY2sgaWYgdGhlcmUncyByZW1haW5pbmcgd29yayBvbiB0aGlzIHJvb3Rcbi8vIFRPRE86IFRoaXMgaXMgcGFydCBvZiB0aGUgYGNvbXBvbmVudERpZENhdGNoYCBpbXBsZW1lbnRhdGlvbi4gSXRzIHB1cnBvc2Vcbi8vIGlzIHRvIGRldGVjdCB3aGV0aGVyIHNvbWV0aGluZyBtaWdodCBoYXZlIGNhbGxlZCBzZXRTdGF0ZSBpbnNpZGVcbi8vIGBjb21wb25lbnREaWRDYXRjaGAuIFRoZSBtZWNoYW5pc20gaXMga25vd24gdG8gYmUgZmxhd2VkIGJlY2F1c2UgYHNldFN0YXRlYFxuLy8gaW5zaWRlIGBjb21wb25lbnREaWRDYXRjaGAgaXMgaXRzZWxmIGZsYXdlZCDigJQgdGhhdCdzIHdoeSB3ZSByZWNvbW1lbmRcbi8vIGBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3JgIGluc3RlYWQuIEhvd2V2ZXIsIGl0IGNvdWxkIGJlIGltcHJvdmVkIGJ5XG4vLyBjaGVja2luZyBpZiByZW1haW5pbmdMYW5lcyBpbmNsdWRlcyBTeW5jIHdvcmssIGluc3RlYWQgb2Ygd2hldGhlciB0aGVyZSdzXG4vLyBhbnkgd29yayByZW1haW5pbmcgYXQgYWxsICh3aGljaCB3b3VsZCBhbHNvIGluY2x1ZGUgc3R1ZmYgbGlrZSBTdXNwZW5zZVxuLy8gcmV0cmllcyBvciB0cmFuc2l0aW9ucykuIEl0J3MgYmVlbiBsaWtlIHRoaXMgZm9yIGEgd2hpbGUsIHRob3VnaCwgc28gZml4aW5nXG4vLyBpdCBwcm9iYWJseSBpc24ndCB0aGF0IHVyZ2VudC5cbmlmKHJlbWFpbmluZ0xhbmVzPT09Tm9MYW5lcyl7Ly8gSWYgdGhlcmUncyBubyByZW1haW5pbmcgd29yaywgd2UgY2FuIGNsZWFyIHRoZSBzZXQgb2YgYWxyZWFkeSBmYWlsZWRcbi8vIGVycm9yIGJvdW5kYXJpZXMuXG5sZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZD1udWxsO317aWYoIXJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMpe2NvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290LmN1cnJlbnQsZmFsc2UpO319b25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUscmVuZGVyUHJpb3JpdHlMZXZlbCk7e2lmKGlzRGV2VG9vbHNQcmVzZW50KXtyb290Lm1lbW9pemVkVXBkYXRlcnMuY2xlYXIoKTt9fXtvbkNvbW1pdFJvb3QkMSgpO30vLyBBbHdheXMgY2FsbCB0aGlzIGJlZm9yZSBleGl0aW5nIGBjb21taXRSb290YCwgdG8gZW5zdXJlIHRoYXQgYW55XG4vLyBhZGRpdGlvbmFsIHdvcmsgb24gdGhpcyByb290IGlzIHNjaGVkdWxlZC5cbmVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LG5vdygpKTtpZihyZWNvdmVyYWJsZUVycm9ycyE9PW51bGwpey8vIFRoZXJlIHdlcmUgZXJyb3JzIGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IHJlY292ZXJlZCBmcm9tIHRoZW0gd2l0aG91dFxuLy8gbmVlZGluZyB0byBzdXJmYWNlIGl0IHRvIHRoZSBVSS4gV2UgbG9nIHRoZW0gaGVyZS5cbnZhciBvblJlY292ZXJhYmxlRXJyb3I9cm9vdC5vblJlY292ZXJhYmxlRXJyb3I7Zm9yKHZhciBpPTA7aTxyZWNvdmVyYWJsZUVycm9ycy5sZW5ndGg7aSsrKXt2YXIgcmVjb3ZlcmFibGVFcnJvcj1yZWNvdmVyYWJsZUVycm9yc1tpXTt2YXIgY29tcG9uZW50U3RhY2s9cmVjb3ZlcmFibGVFcnJvci5zdGFjazt2YXIgZGlnZXN0PXJlY292ZXJhYmxlRXJyb3IuZGlnZXN0O29uUmVjb3ZlcmFibGVFcnJvcihyZWNvdmVyYWJsZUVycm9yLnZhbHVlLHtjb21wb25lbnRTdGFjazpjb21wb25lbnRTdGFjayxkaWdlc3Q6ZGlnZXN0fSk7fX1pZihoYXNVbmNhdWdodEVycm9yKXtoYXNVbmNhdWdodEVycm9yPWZhbHNlO3ZhciBlcnJvciQxPWZpcnN0VW5jYXVnaHRFcnJvcjtmaXJzdFVuY2F1Z2h0RXJyb3I9bnVsbDt0aHJvdyBlcnJvciQxO30vLyBJZiB0aGUgcGFzc2l2ZSBlZmZlY3RzIGFyZSB0aGUgcmVzdWx0IG9mIGEgZGlzY3JldGUgcmVuZGVyLCBmbHVzaCB0aGVtXG4vLyBzeW5jaHJvbm91c2x5IGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgdGFzayBzbyB0aGF0IHRoZSByZXN1bHQgaXNcbi8vIGltbWVkaWF0ZWx5IG9ic2VydmFibGUuIE90aGVyd2lzZSwgd2UgYXNzdW1lIHRoYXQgdGhleSBhcmUgbm90XG4vLyBvcmRlci1kZXBlbmRlbnQgYW5kIGRvIG5vdCBuZWVkIHRvIGJlIG9ic2VydmVkIGJ5IGV4dGVybmFsIHN5c3RlbXMsIHNvIHdlXG4vLyBjYW4gd2FpdCB1bnRpbCBhZnRlciBwYWludC5cbi8vIFRPRE86IFdlIGNhbiBvcHRpbWl6ZSB0aGlzIGJ5IG5vdCBzY2hlZHVsaW5nIHRoZSBjYWxsYmFjayBlYXJsaWVyLiBTaW5jZSB3ZVxuLy8gY3VycmVudGx5IHNjaGVkdWxlIHRoZSBjYWxsYmFjayBpbiBtdWx0aXBsZSBwbGFjZXMsIHdpbGwgd2FpdCB1bnRpbCB0aG9zZVxuLy8gYXJlIGNvbnNvbGlkYXRlZC5cbmlmKGluY2x1ZGVzU29tZUxhbmUocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMsU3luY0xhbmUpJiZyb290LnRhZyE9PUxlZ2FjeVJvb3Qpe2ZsdXNoUGFzc2l2ZUVmZmVjdHMoKTt9Ly8gUmVhZCB0aGlzIGFnYWluLCBzaW5jZSBhIHBhc3NpdmUgZWZmZWN0IG1pZ2h0IGhhdmUgdXBkYXRlZCBpdFxucmVtYWluaW5nTGFuZXM9cm9vdC5wZW5kaW5nTGFuZXM7aWYoaW5jbHVkZXNTb21lTGFuZShyZW1haW5pbmdMYW5lcyxTeW5jTGFuZSkpe3ttYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkKCk7fS8vIENvdW50IHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIHJvb3Qgc3luY2hyb25vdXNseSByZS1yZW5kZXJzIHdpdGhvdXRcbi8vIGZpbmlzaGluZy4gSWYgdGhlcmUgYXJlIHRvbyBtYW55LCBpdCBpbmRpY2F0ZXMgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AuXG5pZihyb290PT09cm9vdFdpdGhOZXN0ZWRVcGRhdGVzKXtuZXN0ZWRVcGRhdGVDb3VudCsrO31lbHNle25lc3RlZFVwZGF0ZUNvdW50PTA7cm9vdFdpdGhOZXN0ZWRVcGRhdGVzPXJvb3Q7fX1lbHNle25lc3RlZFVwZGF0ZUNvdW50PTA7fS8vIElmIGxheW91dCB3b3JrIHdhcyBzY2hlZHVsZWQsIGZsdXNoIGl0IG5vdy5cbmZsdXNoU3luY0NhbGxiYWNrcygpO3ttYXJrQ29tbWl0U3RvcHBlZCgpO31yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gZmx1c2hQYXNzaXZlRWZmZWN0cygpey8vIFJldHVybnMgd2hldGhlciBwYXNzaXZlIGVmZmVjdHMgd2VyZSBmbHVzaGVkLlxuLy8gVE9ETzogQ29tYmluZSB0aGlzIGNoZWNrIHdpdGggdGhlIG9uZSBpbiBmbHVzaFBhc3NpdmVFRmZlY3RzSW1wbC4gV2Ugc2hvdWxkXG4vLyBwcm9iYWJseSBqdXN0IGNvbWJpbmUgdGhlIHR3byBmdW5jdGlvbnMuIEkgYmVsaWV2ZSB0aGV5IHdlcmUgb25seSBzZXBhcmF0ZVxuLy8gaW4gdGhlIGZpcnN0IHBsYWNlIGJlY2F1c2Ugd2UgdXNlZCB0byB3cmFwIGl0IHdpdGhcbi8vIGBTY2hlZHVsZXIucnVuV2l0aFByaW9yaXR5YCwgd2hpY2ggYWNjZXB0cyBhIGZ1bmN0aW9uLiBCdXQgbm93IHdlIHRyYWNrIHRoZVxuLy8gcHJpb3JpdHkgd2l0aGluIFJlYWN0IGl0c2VsZiwgc28gd2UgY2FuIG11dGF0ZSB0aGUgdmFyaWFibGUgZGlyZWN0bHkuXG5pZihyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyE9PW51bGwpe3ZhciByZW5kZXJQcmlvcml0eT1sYW5lc1RvRXZlbnRQcmlvcml0eShwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyk7dmFyIHByaW9yaXR5PWxvd2VyRXZlbnRQcmlvcml0eShEZWZhdWx0RXZlbnRQcmlvcml0eSxyZW5kZXJQcmlvcml0eSk7dmFyIHByZXZUcmFuc2l0aW9uPVJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbjt2YXIgcHJldmlvdXNQcmlvcml0eT1nZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTt0cnl7UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uPW51bGw7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByaW9yaXR5KTtyZXR1cm4gZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGwoKTt9ZmluYWxseXtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uPXByZXZUcmFuc2l0aW9uOy8vIE9uY2UgcGFzc2l2ZSBlZmZlY3RzIGhhdmUgcnVuIGZvciB0aGUgdHJlZSAtIGdpdmluZyBjb21wb25lbnRzIGFcbn19cmV0dXJuIGZhbHNlO31mdW5jdGlvbiBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdChmaWJlcil7e3BlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzLnB1c2goZmliZXIpO2lmKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyl7cm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHM9dHJ1ZTtzY2hlZHVsZUNhbGxiYWNrJDEoTm9ybWFsUHJpb3JpdHksZnVuY3Rpb24oKXtmbHVzaFBhc3NpdmVFZmZlY3RzKCk7cmV0dXJuIG51bGw7fSk7fX19ZnVuY3Rpb24gZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGwoKXtpZihyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cz09PW51bGwpe3JldHVybiBmYWxzZTt9Ly8gQ2FjaGUgYW5kIGNsZWFyIHRoZSB0cmFuc2l0aW9ucyBmbGFnXG52YXIgdHJhbnNpdGlvbnM9cGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucztwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zPW51bGw7dmFyIHJvb3Q9cm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHM7dmFyIGxhbmVzPXBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzO3Jvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzPW51bGw7Ly8gVE9ETzogVGhpcyBpcyBzb21ldGltZXMgb3V0IG9mIHN5bmMgd2l0aCByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cy5cbi8vIEZpZ3VyZSBvdXQgd2h5IGFuZCBmaXggaXQuIEl0J3Mgbm90IGNhdXNpbmcgYW55IGtub3duIGlzc3VlcyAocHJvYmFibHlcbi8vIGJlY2F1c2UgaXQncyBvbmx5IHVzZWQgZm9yIHByb2ZpbGluZyksIGJ1dCBpdCdzIGEgcmVmYWN0b3IgaGF6YXJkLlxucGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM9Tm9MYW5lcztpZigoZXhlY3V0aW9uQ29udGV4dCYoUmVuZGVyQ29udGV4dHxDb21taXRDb250ZXh0KSkhPT1Ob0NvbnRleHQpe3Rocm93IG5ldyBFcnJvcignQ2Fubm90IGZsdXNoIHBhc3NpdmUgZWZmZWN0cyB3aGlsZSBhbHJlYWR5IHJlbmRlcmluZy4nKTt9e2lzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cz10cnVlO2RpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHM9ZmFsc2U7fXttYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTt9dmFyIHByZXZFeGVjdXRpb25Db250ZXh0PWV4ZWN1dGlvbkNvbnRleHQ7ZXhlY3V0aW9uQ29udGV4dHw9Q29tbWl0Q29udGV4dDtjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHMocm9vdC5jdXJyZW50KTtjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzKHJvb3Qscm9vdC5jdXJyZW50LGxhbmVzLHRyYW5zaXRpb25zKTsvLyBUT0RPOiBNb3ZlIHRvIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNcbnt2YXIgcHJvZmlsZXJFZmZlY3RzPXBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzO3BlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzPVtdO2Zvcih2YXIgaT0wO2k8cHJvZmlsZXJFZmZlY3RzLmxlbmd0aDtpKyspe3ZhciBfZmliZXI9cHJvZmlsZXJFZmZlY3RzW2ldO2NvbW1pdFBhc3NpdmVFZmZlY3REdXJhdGlvbnMocm9vdCxfZmliZXIpO319e21hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTt9e2NvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290LmN1cnJlbnQsdHJ1ZSk7fWV4ZWN1dGlvbkNvbnRleHQ9cHJldkV4ZWN1dGlvbkNvbnRleHQ7Zmx1c2hTeW5jQ2FsbGJhY2tzKCk7ey8vIElmIGFkZGl0aW9uYWwgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgc2NoZWR1bGVkLCBpbmNyZW1lbnQgYSBjb3VudGVyLiBJZiB0aGlzXG4vLyBleGNlZWRzIHRoZSBsaW1pdCwgd2UnbGwgZmlyZSBhIHdhcm5pbmcuXG5pZihkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzKXtpZihyb290PT09cm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyl7bmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50Kys7fWVsc2V7bmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50PTA7cm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcz1yb290O319ZWxzZXtuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQ9MDt9aXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzPWZhbHNlO2RpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHM9ZmFsc2U7fS8vIFRPRE86IE1vdmUgdG8gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c1xub25Qb3N0Q29tbWl0Um9vdChyb290KTt7dmFyIHN0YXRlTm9kZT1yb290LmN1cnJlbnQuc3RhdGVOb2RlO3N0YXRlTm9kZS5lZmZlY3REdXJhdGlvbj0wO3N0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb249MDt9cmV0dXJuIHRydWU7fWZ1bmN0aW9uIGlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2Upe3JldHVybiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCE9PW51bGwmJmxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSk7fWZ1bmN0aW9uIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQoaW5zdGFuY2Upe2lmKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkPT09bnVsbCl7bGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQ9bmV3IFNldChbaW5zdGFuY2VdKTt9ZWxzZXtsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5hZGQoaW5zdGFuY2UpO319ZnVuY3Rpb24gcHJlcGFyZVRvVGhyb3dVbmNhdWdodEVycm9yKGVycm9yKXtpZighaGFzVW5jYXVnaHRFcnJvcil7aGFzVW5jYXVnaHRFcnJvcj10cnVlO2ZpcnN0VW5jYXVnaHRFcnJvcj1lcnJvcjt9fXZhciBvblVuY2F1Z2h0RXJyb3I9cHJlcGFyZVRvVGhyb3dVbmNhdWdodEVycm9yO2Z1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHJvb3RGaWJlcixzb3VyY2VGaWJlcixlcnJvcil7dmFyIGVycm9ySW5mbz1jcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvcixzb3VyY2VGaWJlcik7dmFyIHVwZGF0ZT1jcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLGVycm9ySW5mbyxTeW5jTGFuZSk7dmFyIHJvb3Q9ZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsdXBkYXRlLFN5bmNMYW5lKTt2YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTtpZihyb290IT09bnVsbCl7bWFya1Jvb3RVcGRhdGVkKHJvb3QsU3luY0xhbmUsZXZlbnRUaW1lKTtlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCxldmVudFRpbWUpO319ZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3Ioc291cmNlRmliZXIsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixlcnJvciQxKXt7cmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yJDEpO3NldElzUnVubmluZ0luc2VydGlvbkVmZmVjdChmYWxzZSk7fWlmKHNvdXJjZUZpYmVyLnRhZz09PUhvc3RSb290KXsvLyBFcnJvciB3YXMgdGhyb3duIGF0IHRoZSByb290LiBUaGVyZSBpcyBubyBwYXJlbnQsIHNvIHRoZSByb290XG4vLyBpdHNlbGYgc2hvdWxkIGNhcHR1cmUgaXQuXG5jYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChzb3VyY2VGaWJlcixzb3VyY2VGaWJlcixlcnJvciQxKTtyZXR1cm47fXZhciBmaWJlcj1udWxsO3tmaWJlcj1uZWFyZXN0TW91bnRlZEFuY2VzdG9yO313aGlsZShmaWJlciE9PW51bGwpe2lmKGZpYmVyLnRhZz09PUhvc3RSb290KXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChmaWJlcixzb3VyY2VGaWJlcixlcnJvciQxKTtyZXR1cm47fWVsc2UgaWYoZmliZXIudGFnPT09Q2xhc3NDb21wb25lbnQpe3ZhciBjdG9yPWZpYmVyLnR5cGU7dmFyIGluc3RhbmNlPWZpYmVyLnN0YXRlTm9kZTtpZih0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I9PT0nZnVuY3Rpb24nfHx0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2g9PT0nZnVuY3Rpb24nJiYhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpe3ZhciBlcnJvckluZm89Y3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoZXJyb3IkMSxzb3VyY2VGaWJlcik7dmFyIHVwZGF0ZT1jcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLGVycm9ySW5mbyxTeW5jTGFuZSk7dmFyIHJvb3Q9ZW5xdWV1ZVVwZGF0ZShmaWJlcix1cGRhdGUsU3luY0xhbmUpO3ZhciBldmVudFRpbWU9cmVxdWVzdEV2ZW50VGltZSgpO2lmKHJvb3QhPT1udWxsKXttYXJrUm9vdFVwZGF0ZWQocm9vdCxTeW5jTGFuZSxldmVudFRpbWUpO2Vuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LGV2ZW50VGltZSk7fXJldHVybjt9fWZpYmVyPWZpYmVyLnJldHVybjt9ey8vIFRPRE86IFVudGlsIHdlIHJlLWxhbmQgc2tpcFVubW91bnRlZEJvdW5kYXJpZXMgKHNlZSAjMjAxNDcpLCB0aGlzIHdhcm5pbmdcbi8vIHdpbGwgZmlyZSBmb3IgZXJyb3JzIHRoYXQgYXJlIHRocm93biBieSBkZXN0cm95IGZ1bmN0aW9ucyBpbnNpZGUgZGVsZXRlZFxuLy8gdHJlZXMuIFdoYXQgaXQgc2hvdWxkIGluc3RlYWQgZG8gaXMgcHJvcGFnYXRlIHRoZSBlcnJvciB0byB0aGUgcGFyZW50IG9mXG4vLyB0aGUgZGVsZXRlZCB0cmVlLiBJbiB0aGUgbWVhbnRpbWUsIGRvIG5vdCBhZGQgdGhpcyB3YXJuaW5nIHRvIHRoZVxuLy8gYWxsb3dsaXN0OyB0aGlzIGlzIG9ubHkgZm9yIG91ciBpbnRlcm5hbCB1c2UuXG5lcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEF0dGVtcHRlZCB0byBjYXB0dXJlIGEgY29tbWl0IHBoYXNlIGVycm9yICcrJ2luc2lkZSBhIGRldGFjaGVkIHRyZWUuIFRoaXMgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0LiBMaWtlbHkgJysnY2F1c2VzIGluY2x1ZGUgZGVsZXRpbmcgdGhlIHNhbWUgZmliZXIgbW9yZSB0aGFuIG9uY2UsIGNvbW1pdHRpbmcgYW4gJysnYWxyZWFkeS1maW5pc2hlZCB0cmVlLCBvciBhbiBpbmNvbnNpc3RlbnQgcmV0dXJuIHBvaW50ZXIuXFxuXFxuJysnRXJyb3IgbWVzc2FnZTpcXG5cXG4lcycsZXJyb3IkMSk7fX1mdW5jdGlvbiBwaW5nU3VzcGVuZGVkUm9vdChyb290LHdha2VhYmxlLHBpbmdlZExhbmVzKXt2YXIgcGluZ0NhY2hlPXJvb3QucGluZ0NhY2hlO2lmKHBpbmdDYWNoZSE9PW51bGwpey8vIFRoZSB3YWtlYWJsZSByZXNvbHZlZCwgc28gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gbWVtb2l6ZSwgYmVjYXVzZSBpdCB3aWxsXG4vLyBuZXZlciBiZSB0aHJvd24gYWdhaW4uXG5waW5nQ2FjaGUuZGVsZXRlKHdha2VhYmxlKTt9dmFyIGV2ZW50VGltZT1yZXF1ZXN0RXZlbnRUaW1lKCk7bWFya1Jvb3RQaW5nZWQocm9vdCxwaW5nZWRMYW5lcyk7d2FybklmU3VzcGVuc2VSZXNvbHV0aW9uTm90V3JhcHBlZFdpdGhBY3RERVYocm9vdCk7aWYod29ya0luUHJvZ3Jlc3NSb290PT09cm9vdCYmaXNTdWJzZXRPZkxhbmVzKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLHBpbmdlZExhbmVzKSl7Ly8gUmVjZWl2ZWQgYSBwaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5IGxldmVsIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseVxuLy8gcmVuZGVyaW5nLiBXZSBtaWdodCB3YW50IHRvIHJlc3RhcnQgdGhpcyByZW5kZXIuIFRoaXMgc2hvdWxkIG1pcnJvclxuLy8gdGhlIGxvZ2ljIG9mIHdoZXRoZXIgb3Igbm90IGEgcm9vdCBzdXNwZW5kcyBvbmNlIGl0IGNvbXBsZXRlcy5cbi8vIFRPRE86IElmIHdlJ3JlIHJlbmRlcmluZyBzeW5jIGVpdGhlciBkdWUgdG8gU3luYywgQmF0Y2hlZCBvciBleHBpcmVkLFxuLy8gd2Ugc2hvdWxkIHByb2JhYmx5IG5ldmVyIHJlc3RhcnQuXG4vLyBJZiB3ZSdyZSBzdXNwZW5kZWQgd2l0aCBkZWxheSwgb3IgaWYgaXQncyBhIHJldHJ5LCB3ZSdsbCBhbHdheXMgc3VzcGVuZFxuLy8gc28gd2UgY2FuIGFsd2F5cyByZXN0YXJ0LlxuaWYod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz09PVJvb3RTdXNwZW5kZWRXaXRoRGVsYXl8fHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9PT1Sb290U3VzcGVuZGVkJiZpbmNsdWRlc09ubHlSZXRyaWVzKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSYmbm93KCktZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZTxGQUxMQkFDS19USFJPVFRMRV9NUyl7Ly8gUmVzdGFydCBmcm9tIHRoZSByb290LlxucHJlcGFyZUZyZXNoU3RhY2socm9vdCxOb0xhbmVzKTt9ZWxzZXsvLyBFdmVuIHRob3VnaCB3ZSBjYW4ndCByZXN0YXJ0IHJpZ2h0IG5vdywgd2UgbWlnaHQgZ2V0IGFuXG4vLyBvcHBvcnR1bml0eSBsYXRlci4gU28gd2UgbWFyayB0aGlzIHJlbmRlciBhcyBoYXZpbmcgYSBwaW5nLlxud29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXM9bWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyxwaW5nZWRMYW5lcyk7fX1lbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCxldmVudFRpbWUpO31mdW5jdGlvbiByZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlcixyZXRyeUxhbmUpey8vIFRoZSBib3VuZGFyeSBmaWJlciAoYSBTdXNwZW5zZSBjb21wb25lbnQgb3IgU3VzcGVuc2VMaXN0IGNvbXBvbmVudClcbi8vIHByZXZpb3VzbHkgd2FzIHJlbmRlcmVkIGluIGl0cyBmYWxsYmFjayBzdGF0ZS4gT25lIG9mIHRoZSBwcm9taXNlcyB0aGF0XG4vLyBzdXNwZW5kZWQgaXQgaGFzIHJlc29sdmVkLCB3aGljaCBtZWFucyBhdCBsZWFzdCBwYXJ0IG9mIHRoZSB0cmVlIHdhc1xuLy8gbGlrZWx5IHVuYmxvY2tlZC4gVHJ5IHJlbmRlcmluZyBhZ2FpbiwgYXQgYSBuZXcgbGFuZXMuXG5pZihyZXRyeUxhbmU9PT1Ob0xhbmUpey8vIFRPRE86IEFzc2lnbiB0aGlzIHRvIGBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZWA/IHRvIGF2b2lkXG4vLyB1bm5lY2Vzc2FyeSBlbnRhbmdsZW1lbnQ/XG5yZXRyeUxhbmU9cmVxdWVzdFJldHJ5TGFuZShib3VuZGFyeUZpYmVyKTt9Ly8gVE9ETzogU3BlY2lhbCBjYXNlIGlkbGUgcHJpb3JpdHk/XG52YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTt2YXIgcm9vdD1lbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoYm91bmRhcnlGaWJlcixyZXRyeUxhbmUpO2lmKHJvb3QhPT1udWxsKXttYXJrUm9vdFVwZGF0ZWQocm9vdCxyZXRyeUxhbmUsZXZlbnRUaW1lKTtlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCxldmVudFRpbWUpO319ZnVuY3Rpb24gcmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeShib3VuZGFyeUZpYmVyKXt2YXIgc3VzcGVuc2VTdGF0ZT1ib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGU7dmFyIHJldHJ5TGFuZT1Ob0xhbmU7aWYoc3VzcGVuc2VTdGF0ZSE9PW51bGwpe3JldHJ5TGFuZT1zdXNwZW5zZVN0YXRlLnJldHJ5TGFuZTt9cmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIscmV0cnlMYW5lKTt9ZnVuY3Rpb24gcmVzb2x2ZVJldHJ5V2FrZWFibGUoYm91bmRhcnlGaWJlcix3YWtlYWJsZSl7dmFyIHJldHJ5TGFuZT1Ob0xhbmU7Ly8gRGVmYXVsdFxudmFyIHJldHJ5Q2FjaGU7c3dpdGNoKGJvdW5kYXJ5RmliZXIudGFnKXtjYXNlIFN1c3BlbnNlQ29tcG9uZW50OnJldHJ5Q2FjaGU9Ym91bmRhcnlGaWJlci5zdGF0ZU5vZGU7dmFyIHN1c3BlbnNlU3RhdGU9Ym91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlO2lmKHN1c3BlbnNlU3RhdGUhPT1udWxsKXtyZXRyeUxhbmU9c3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmU7fWJyZWFrO2Nhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OnJldHJ5Q2FjaGU9Ym91bmRhcnlGaWJlci5zdGF0ZU5vZGU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoJ1BpbmdlZCB1bmtub3duIHN1c3BlbnNlIGJvdW5kYXJ5IHR5cGUuICcrJ1RoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJyk7fWlmKHJldHJ5Q2FjaGUhPT1udWxsKXsvLyBUaGUgd2FrZWFibGUgcmVzb2x2ZWQsIHNvIHdlIG5vIGxvbmdlciBuZWVkIHRvIG1lbW9pemUsIGJlY2F1c2UgaXQgd2lsbFxuLy8gbmV2ZXIgYmUgdGhyb3duIGFnYWluLlxucmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO31yZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlcixyZXRyeUxhbmUpO30vLyBDb21wdXRlcyB0aGUgbmV4dCBKdXN0IE5vdGljZWFibGUgRGlmZmVyZW5jZSAoSk5EKSBib3VuZGFyeS5cbi8vIFRoZSB0aGVvcnkgaXMgdGhhdCBhIHBlcnNvbiBjYW4ndCB0ZWxsIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gc21hbGwgZGlmZmVyZW5jZXMgaW4gdGltZS5cbi8vIFRoZXJlZm9yZSwgaWYgd2Ugd2FpdCBhIGJpdCBsb25nZXIgdGhhbiBuZWNlc3NhcnkgdGhhdCB3b24ndCB0cmFuc2xhdGUgdG8gYSBub3RpY2VhYmxlXG4vLyBkaWZmZXJlbmNlIGluIHRoZSBleHBlcmllbmNlLiBIb3dldmVyLCB3YWl0aW5nIGZvciBsb25nZXIgbWlnaHQgbWVhbiB0aGF0IHdlIGNhbiBhdm9pZFxuLy8gc2hvd2luZyBhbiBpbnRlcm1lZGlhdGUgbG9hZGluZyBzdGF0ZS4gVGhlIGxvbmdlciB3ZSBoYXZlIGFscmVhZHkgd2FpdGVkLCB0aGUgaGFyZGVyIGl0XG4vLyBpcyB0byB0ZWxsIHNtYWxsIGRpZmZlcmVuY2VzIGluIHRpbWUuIFRoZXJlZm9yZSwgdGhlIGxvbmdlciB3ZSd2ZSBhbHJlYWR5IHdhaXRlZCxcbi8vIHRoZSBsb25nZXIgd2UgY2FuIHdhaXQgYWRkaXRpb25hbGx5LiBBdCBzb21lIHBvaW50IHdlIGhhdmUgdG8gZ2l2ZSB1cCB0aG91Z2guXG4vLyBXZSBwaWNrIGEgdHJhaW4gbW9kZWwgd2hlcmUgdGhlIG5leHQgYm91bmRhcnkgY29tbWl0cyBhdCBhIGNvbnNpc3RlbnQgc2NoZWR1bGUuXG4vLyBUaGVzZSBwYXJ0aWN1bGFyIG51bWJlcnMgYXJlIHZhZ3VlIGVzdGltYXRlcy4gV2UgZXhwZWN0IHRvIGFkanVzdCB0aGVtIGJhc2VkIG9uIHJlc2VhcmNoLlxuZnVuY3Rpb24gam5kKHRpbWVFbGFwc2VkKXtyZXR1cm4gdGltZUVsYXBzZWQ8MTIwPzEyMDp0aW1lRWxhcHNlZDw0ODA/NDgwOnRpbWVFbGFwc2VkPDEwODA/MTA4MDp0aW1lRWxhcHNlZDwxOTIwPzE5MjA6dGltZUVsYXBzZWQ8MzAwMD8zMDAwOnRpbWVFbGFwc2VkPDQzMjA/NDMyMDpjZWlsKHRpbWVFbGFwc2VkLzE5NjApKjE5NjA7fWZ1bmN0aW9uIGNoZWNrRm9yTmVzdGVkVXBkYXRlcygpe2lmKG5lc3RlZFVwZGF0ZUNvdW50Pk5FU1RFRF9VUERBVEVfTElNSVQpe25lc3RlZFVwZGF0ZUNvdW50PTA7cm9vdFdpdGhOZXN0ZWRVcGRhdGVzPW51bGw7dGhyb3cgbmV3IEVycm9yKCdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgJysncmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciAnKydjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvICcrJ3ByZXZlbnQgaW5maW5pdGUgbG9vcHMuJyk7fXtpZihuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQ+TkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUKXtuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQ9MDtyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzPW51bGw7ZXJyb3IoJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCAnK1wiY2FsbHMgc2V0U3RhdGUgaW5zaWRlIHVzZUVmZmVjdCwgYnV0IHVzZUVmZmVjdCBlaXRoZXIgZG9lc24ndCBcIisnaGF2ZSBhIGRlcGVuZGVuY3kgYXJyYXksIG9yIG9uZSBvZiB0aGUgZGVwZW5kZW5jaWVzIGNoYW5nZXMgb24gJysnZXZlcnkgcmVuZGVyLicpO319fWZ1bmN0aW9uIGZsdXNoUmVuZGVyUGhhc2VTdHJpY3RNb2RlV2FybmluZ3NJbkRFVigpe3tSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nKCk7e1JlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKCk7fX19ZnVuY3Rpb24gY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKGZpYmVyLGhhc1Bhc3NpdmVFZmZlY3RzKXt7Ly8gVE9ETyAoU3RyaWN0RWZmZWN0cykgU2hvdWxkIHdlIHNldCBhIG1hcmtlciBvbiB0aGUgcm9vdCBpZiBpdCBjb250YWlucyBzdHJpY3QgZWZmZWN0c1xuLy8gc28gd2UgZG9uJ3QgdHJhdmVyc2UgdW5uZWNlc3NhcmlseT8gc2ltaWxhciB0byBzdWJ0cmVlRmxhZ3MgYnV0IGp1c3QgYXQgdGhlIHJvb3QgbGV2ZWwuXG4vLyBNYXliZSBub3QgYSBiaWcgZGVhbCBzaW5jZSB0aGlzIGlzIERFViBvbmx5IGJlaGF2aW9yLlxuc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtpbnZva2VFZmZlY3RzSW5EZXYoZmliZXIsTW91bnRMYXlvdXREZXYsaW52b2tlTGF5b3V0RWZmZWN0VW5tb3VudEluREVWKTtpZihoYXNQYXNzaXZlRWZmZWN0cyl7aW52b2tlRWZmZWN0c0luRGV2KGZpYmVyLE1vdW50UGFzc2l2ZURldixpbnZva2VQYXNzaXZlRWZmZWN0VW5tb3VudEluREVWKTt9aW52b2tlRWZmZWN0c0luRGV2KGZpYmVyLE1vdW50TGF5b3V0RGV2LGludm9rZUxheW91dEVmZmVjdE1vdW50SW5ERVYpO2lmKGhhc1Bhc3NpdmVFZmZlY3RzKXtpbnZva2VFZmZlY3RzSW5EZXYoZmliZXIsTW91bnRQYXNzaXZlRGV2LGludm9rZVBhc3NpdmVFZmZlY3RNb3VudEluREVWKTt9cmVzZXRDdXJyZW50RmliZXIoKTt9fWZ1bmN0aW9uIGludm9rZUVmZmVjdHNJbkRldihmaXJzdENoaWxkLGZpYmVyRmxhZ3MsaW52b2tlRWZmZWN0Rm4pe3svLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxudmFyIGN1cnJlbnQ9Zmlyc3RDaGlsZDt2YXIgc3VidHJlZVJvb3Q9bnVsbDt3aGlsZShjdXJyZW50IT09bnVsbCl7dmFyIHByaW1hcnlTdWJ0cmVlRmxhZz1jdXJyZW50LnN1YnRyZWVGbGFncyZmaWJlckZsYWdzO2lmKGN1cnJlbnQhPT1zdWJ0cmVlUm9vdCYmY3VycmVudC5jaGlsZCE9PW51bGwmJnByaW1hcnlTdWJ0cmVlRmxhZyE9PU5vRmxhZ3Mpe2N1cnJlbnQ9Y3VycmVudC5jaGlsZDt9ZWxzZXtpZigoY3VycmVudC5mbGFncyZmaWJlckZsYWdzKSE9PU5vRmxhZ3Mpe2ludm9rZUVmZmVjdEZuKGN1cnJlbnQpO31pZihjdXJyZW50LnNpYmxpbmchPT1udWxsKXtjdXJyZW50PWN1cnJlbnQuc2libGluZzt9ZWxzZXtjdXJyZW50PXN1YnRyZWVSb290PWN1cnJlbnQucmV0dXJuO319fX19dmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQ9bnVsbDtmdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKXt7aWYoKGV4ZWN1dGlvbkNvbnRleHQmUmVuZGVyQ29udGV4dCkhPT1Ob0NvbnRleHQpey8vIFdlIGxldCB0aGUgb3RoZXIgd2FybmluZyBhYm91dCByZW5kZXIgcGhhc2UgdXBkYXRlcyBkZWFsIHdpdGggdGhpcyBvbmUuXG5yZXR1cm47fWlmKCEoZmliZXIubW9kZSZDb25jdXJyZW50TW9kZSkpe3JldHVybjt9dmFyIHRhZz1maWJlci50YWc7aWYodGFnIT09SW5kZXRlcm1pbmF0ZUNvbXBvbmVudCYmdGFnIT09SG9zdFJvb3QmJnRhZyE9PUNsYXNzQ29tcG9uZW50JiZ0YWchPT1GdW5jdGlvbkNvbXBvbmVudCYmdGFnIT09Rm9yd2FyZFJlZiYmdGFnIT09TWVtb0NvbXBvbmVudCYmdGFnIT09U2ltcGxlTWVtb0NvbXBvbmVudCl7Ly8gT25seSB3YXJuIGZvciB1c2VyLWRlZmluZWQgY29tcG9uZW50cywgbm90IGludGVybmFsIG9uZXMgbGlrZSBTdXNwZW5zZS5cbnJldHVybjt9Ly8gV2Ugc2hvdyB0aGUgd2hvbGUgc3RhY2sgYnV0IGRlZHVwZSBvbiB0aGUgdG9wIGNvbXBvbmVudCdzIG5hbWUgYmVjYXVzZVxuLy8gdGhlIHByb2JsZW1hdGljIGNvZGUgYWxtb3N0IGFsd2F5cyBsaWVzIGluc2lkZSB0aGF0IGNvbXBvbmVudC5cbnZhciBjb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpfHwnUmVhY3RDb21wb25lbnQnO2lmKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQhPT1udWxsKXtpZihkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSl7cmV0dXJuO31kaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTt9ZWxzZXtkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50PW5ldyBTZXQoW2NvbXBvbmVudE5hbWVdKTt9dmFyIHByZXZpb3VzRmliZXI9Y3VycmVudDt0cnl7c2V0Q3VycmVudEZpYmVyKGZpYmVyKTtlcnJvcihcIkNhbid0IHBlcmZvcm0gYSBSZWFjdCBzdGF0ZSB1cGRhdGUgb24gYSBjb21wb25lbnQgdGhhdCBoYXNuJ3QgbW91bnRlZCB5ZXQuIFwiKydUaGlzIGluZGljYXRlcyB0aGF0IHlvdSBoYXZlIGEgc2lkZS1lZmZlY3QgaW4geW91ciByZW5kZXIgZnVuY3Rpb24gdGhhdCAnKydhc3luY2hyb25vdXNseSBsYXRlciBjYWxscyB0cmllcyB0byB1cGRhdGUgdGhlIGNvbXBvbmVudC4gTW92ZSB0aGlzIHdvcmsgdG8gJysndXNlRWZmZWN0IGluc3RlYWQuJyk7fWZpbmFsbHl7aWYocHJldmlvdXNGaWJlcil7c2V0Q3VycmVudEZpYmVyKGZpYmVyKTt9ZWxzZXtyZXNldEN1cnJlbnRGaWJlcigpO319fX12YXIgYmVnaW5Xb3JrJDE7e3ZhciBkdW1teUZpYmVyPW51bGw7YmVnaW5Xb3JrJDE9ZnVuY3Rpb24oY3VycmVudCx1bml0T2ZXb3JrLGxhbmVzKXsvLyBJZiBhIGNvbXBvbmVudCB0aHJvd3MgYW4gZXJyb3IsIHdlIHJlcGxheSBpdCBhZ2FpbiBpbiBhIHN5bmNocm9ub3VzbHlcbi8vIGRpc3BhdGNoZWQgZXZlbnQsIHNvIHRoYXQgdGhlIGRlYnVnZ2VyIHdpbGwgdHJlYXQgaXQgYXMgYW4gdW5jYXVnaHRcbi8vIGVycm9yIFNlZSBSZWFjdEVycm9yVXRpbHMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4vLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjb3B5IHRoZSB3b3JrLWluLXByb2dyZXNzIG9udG8gYSBkdW1teVxuLy8gZmliZXIuIElmIGJlZ2luV29yayB0aHJvd3MsIHdlJ2xsIHVzZSB0aGlzIHRvIHJlc2V0IHRoZSBzdGF0ZS5cbnZhciBvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weT1hc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVihkdW1teUZpYmVyLHVuaXRPZldvcmspO3RyeXtyZXR1cm4gYmVnaW5Xb3JrKGN1cnJlbnQsdW5pdE9mV29yayxsYW5lcyk7fWNhdGNoKG9yaWdpbmFsRXJyb3Ipe2lmKGRpZFN1c3BlbmRPckVycm9yV2hpbGVIeWRyYXRpbmdERVYoKXx8b3JpZ2luYWxFcnJvciE9PW51bGwmJnR5cGVvZiBvcmlnaW5hbEVycm9yPT09J29iamVjdCcmJnR5cGVvZiBvcmlnaW5hbEVycm9yLnRoZW49PT0nZnVuY3Rpb24nKXsvLyBEb24ndCByZXBsYXkgcHJvbWlzZXMuXG4vLyBEb24ndCByZXBsYXkgZXJyb3JzIGlmIHdlIGFyZSBoeWRyYXRpbmcgYW5kIGhhdmUgYWxyZWFkeSBzdXNwZW5kZWQgb3IgaGFuZGxlZCBhbiBlcnJvclxudGhyb3cgb3JpZ2luYWxFcnJvcjt9Ly8gS2VlcCB0aGlzIGNvZGUgaW4gc3luYyB3aXRoIGhhbmRsZUVycm9yOyBhbnkgY2hhbmdlcyBoZXJlIG11c3QgaGF2ZVxuLy8gY29ycmVzcG9uZGluZyBjaGFuZ2VzIHRoZXJlLlxucmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7cmVzZXRIb29rc0FmdGVyVGhyb3coKTsvLyBEb24ndCByZXNldCBjdXJyZW50IGRlYnVnIGZpYmVyLCBzaW5jZSB3ZSdyZSBhYm91dCB0byB3b3JrIG9uIHRoZVxuLy8gc2FtZSBmaWJlciBhZ2Fpbi5cbi8vIFVud2luZCB0aGUgZmFpbGVkIHN0YWNrIGZyYW1lXG51bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCx1bml0T2ZXb3JrKTsvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm9wZXJ0aWVzIG9mIHRoZSBmaWJlci5cbmFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWKHVuaXRPZldvcmssb3JpZ2luYWxXb3JrSW5Qcm9ncmVzc0NvcHkpO2lmKHVuaXRPZldvcmsubW9kZSZQcm9maWxlTW9kZSl7Ly8gUmVzZXQgdGhlIHByb2ZpbGVyIHRpbWVyLlxuc3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspO30vLyBSdW4gYmVnaW5Xb3JrIGFnYWluLlxuaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsYmVnaW5Xb3JrLG51bGwsY3VycmVudCx1bml0T2ZXb3JrLGxhbmVzKTtpZihoYXNDYXVnaHRFcnJvcigpKXt2YXIgcmVwbGF5RXJyb3I9Y2xlYXJDYXVnaHRFcnJvcigpO2lmKHR5cGVvZiByZXBsYXlFcnJvcj09PSdvYmplY3QnJiZyZXBsYXlFcnJvciE9PW51bGwmJnJlcGxheUVycm9yLl9zdXBwcmVzc0xvZ2dpbmcmJnR5cGVvZiBvcmlnaW5hbEVycm9yPT09J29iamVjdCcmJm9yaWdpbmFsRXJyb3IhPT1udWxsJiYhb3JpZ2luYWxFcnJvci5fc3VwcHJlc3NMb2dnaW5nKXsvLyBJZiBzdXBwcmVzc2VkLCBsZXQgdGhlIGZsYWcgY2Fycnkgb3ZlciB0byB0aGUgb3JpZ2luYWwgZXJyb3Igd2hpY2ggaXMgdGhlIG9uZSB3ZSdsbCByZXRocm93Llxub3JpZ2luYWxFcnJvci5fc3VwcHJlc3NMb2dnaW5nPXRydWU7fX0vLyBXZSBhbHdheXMgdGhyb3cgdGhlIG9yaWdpbmFsIGVycm9yIGluIGNhc2UgdGhlIHNlY29uZCByZW5kZXIgcGFzcyBpcyBub3QgaWRlbXBvdGVudC5cbi8vIFRoaXMgY2FuIGhhcHBlbiBpZiBhIG1lbW9pemVkIGZ1bmN0aW9uIG9yIENvbW1vbkpTIG1vZHVsZSBkb2Vzbid0IHRocm93IGFmdGVyIGZpcnN0IGludm9jYXRpb24uXG50aHJvdyBvcmlnaW5hbEVycm9yO319O312YXIgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXI9ZmFsc2U7dmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudDt7ZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50PW5ldyBTZXQoKTt9ZnVuY3Rpb24gd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpe3tpZihpc1JlbmRlcmluZyYmIWdldElzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2VJbkRFVigpKXtzd2l0Y2goZmliZXIudGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgRm9yd2FyZFJlZjpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e3ZhciByZW5kZXJpbmdDb21wb25lbnROYW1lPXdvcmtJblByb2dyZXNzJiZnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKXx8J1Vua25vd24nOy8vIERlZHVwZSBieSB0aGUgcmVuZGVyaW5nIGNvbXBvbmVudCBiZWNhdXNlIGl0J3MgdGhlIG9uZSB0aGF0IG5lZWRzIHRvIGJlIGZpeGVkLlxudmFyIGRlZHVwZUtleT1yZW5kZXJpbmdDb21wb25lbnROYW1lO2lmKCFkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQuaGFzKGRlZHVwZUtleSkpe2RpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5hZGQoZGVkdXBlS2V5KTt2YXIgc2V0U3RhdGVDb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpfHwnVW5rbm93bic7ZXJyb3IoJ0Nhbm5vdCB1cGRhdGUgYSBjb21wb25lbnQgKGAlc2ApIHdoaWxlIHJlbmRlcmluZyBhICcrJ2RpZmZlcmVudCBjb21wb25lbnQgKGAlc2ApLiBUbyBsb2NhdGUgdGhlIGJhZCBzZXRTdGF0ZSgpIGNhbGwgaW5zaWRlIGAlc2AsICcrJ2ZvbGxvdyB0aGUgc3RhY2sgdHJhY2UgYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zZXRzdGF0ZS1pbi1yZW5kZXInLHNldFN0YXRlQ29tcG9uZW50TmFtZSxyZW5kZXJpbmdDb21wb25lbnROYW1lLHJlbmRlcmluZ0NvbXBvbmVudE5hbWUpO31icmVhazt9Y2FzZSBDbGFzc0NvbXBvbmVudDp7aWYoIWRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyKXtlcnJvcignQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyAnKyd3aXRoaW4gYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlICcrJ2Z1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4nKTtkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlcj10cnVlO31icmVhazt9fX19fWZ1bmN0aW9uIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCxsYW5lcyl7e2lmKGlzRGV2VG9vbHNQcmVzZW50KXt2YXIgbWVtb2l6ZWRVcGRhdGVycz1yb290Lm1lbW9pemVkVXBkYXRlcnM7bWVtb2l6ZWRVcGRhdGVycy5mb3JFYWNoKGZ1bmN0aW9uKHNjaGVkdWxpbmdGaWJlcil7YWRkRmliZXJUb0xhbmVzTWFwKHJvb3Qsc2NoZWR1bGluZ0ZpYmVyLGxhbmVzKTt9KTsvLyBUaGlzIGZ1bmN0aW9uIGludGVudGlvbmFsbHkgZG9lcyBub3QgY2xlYXIgbWVtb2l6ZWQgdXBkYXRlcnMuXG4vLyBUaG9zZSBtYXkgc3RpbGwgYmUgcmVsZXZhbnQgdG8gdGhlIGN1cnJlbnQgY29tbWl0XG4vLyBhbmQgYSBmdXR1cmUgb25lIChlLmcuIFN1c3BlbnNlKS5cbn19fXZhciBmYWtlQWN0Q2FsbGJhY2tOb2RlPXt9O2Z1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2skMShwcmlvcml0eUxldmVsLGNhbGxiYWNrKXt7Ly8gSWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhbiBgYWN0YCBzY29wZSwgYnlwYXNzIFNjaGVkdWxlciBhbmQgcHVzaCB0b1xuLy8gdGhlIGBhY3RgIHF1ZXVlIGluc3RlYWQuXG52YXIgYWN0UXVldWU9UmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50O2lmKGFjdFF1ZXVlIT09bnVsbCl7YWN0UXVldWUucHVzaChjYWxsYmFjayk7cmV0dXJuIGZha2VBY3RDYWxsYmFja05vZGU7fWVsc2V7cmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCxjYWxsYmFjayk7fX19ZnVuY3Rpb24gY2FuY2VsQ2FsbGJhY2skMShjYWxsYmFja05vZGUpe2lmKGNhbGxiYWNrTm9kZT09PWZha2VBY3RDYWxsYmFja05vZGUpe3JldHVybjt9Ly8gSW4gcHJvZHVjdGlvbiwgYWx3YXlzIGNhbGwgU2NoZWR1bGVyLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgc3RyaXBwZWQgb3V0LlxucmV0dXJuIGNhbmNlbENhbGxiYWNrKGNhbGxiYWNrTm9kZSk7fWZ1bmN0aW9uIHNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpey8vIE5ldmVyIGZvcmNlIGZsdXNoIGluIHByb2R1Y3Rpb24uIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGdldCBzdHJpcHBlZCBvdXQuXG5yZXR1cm4gUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50IT09bnVsbDt9ZnVuY3Rpb24gd2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKXt7aWYoZmliZXIubW9kZSZDb25jdXJyZW50TW9kZSl7aWYoIWlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkpey8vIE5vdCBpbiBhbiBhY3QgZW52aXJvbm1lbnQuIE5vIG5lZWQgdG8gd2Fybi5cbnJldHVybjt9fWVsc2V7Ly8gTGVnYWN5IG1vZGUgaGFzIGFkZGl0aW9uYWwgY2FzZXMgd2hlcmUgd2Ugc3VwcHJlc3MgYSB3YXJuaW5nLlxuaWYoIWlzTGVnYWN5QWN0RW52aXJvbm1lbnQoKSl7Ly8gTm90IGluIGFuIGFjdCBlbnZpcm9ubWVudC4gTm8gbmVlZCB0byB3YXJuLlxucmV0dXJuO31pZihleGVjdXRpb25Db250ZXh0IT09Tm9Db250ZXh0KXsvLyBMZWdhY3kgbW9kZSBkb2Vzbid0IHdhcm4gaWYgdGhlIHVwZGF0ZSBpcyBiYXRjaGVkLCBpLmUuXG4vLyBiYXRjaGVkVXBkYXRlcyBvciBmbHVzaFN5bmMuXG5yZXR1cm47fWlmKGZpYmVyLnRhZyE9PUZ1bmN0aW9uQ29tcG9uZW50JiZmaWJlci50YWchPT1Gb3J3YXJkUmVmJiZmaWJlci50YWchPT1TaW1wbGVNZW1vQ29tcG9uZW50KXsvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBwcmUtaG9va3MgY29kZSwgbGVnYWN5IG1vZGUgb25seVxuLy8gd2FybnMgZm9yIHVwZGF0ZXMgdGhhdCBvcmlnaW5hdGUgZnJvbSBhIGhvb2suXG5yZXR1cm47fX1pZihSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQ9PT1udWxsKXt2YXIgcHJldmlvdXNGaWJlcj1jdXJyZW50O3RyeXtzZXRDdXJyZW50RmliZXIoZmliZXIpO2Vycm9yKCdBbiB1cGRhdGUgdG8gJXMgaW5zaWRlIGEgdGVzdCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJysnV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgY2F1c2VzIFJlYWN0IHN0YXRlIHVwZGF0ZXMgc2hvdWxkIGJlICcrJ3dyYXBwZWQgaW50byBhY3QoLi4uKTpcXG5cXG4nKydhY3QoKCkgPT4ge1xcbicrJyAgLyogZmlyZSBldmVudHMgdGhhdCB1cGRhdGUgc3RhdGUgKi9cXG4nKyd9KTtcXG4nKycvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicrXCJUaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIFwiKydpbiB0aGUgYnJvd3Nlci4nKycgTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdCcsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikpO31maW5hbGx5e2lmKHByZXZpb3VzRmliZXIpe3NldEN1cnJlbnRGaWJlcihmaWJlcik7fWVsc2V7cmVzZXRDdXJyZW50RmliZXIoKTt9fX19fWZ1bmN0aW9uIHdhcm5JZlN1c3BlbnNlUmVzb2x1dGlvbk5vdFdyYXBwZWRXaXRoQWN0REVWKHJvb3Qpe3tpZihyb290LnRhZyE9PUxlZ2FjeVJvb3QmJmlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkmJlJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudD09PW51bGwpe2Vycm9yKCdBIHN1c3BlbmRlZCByZXNvdXJjZSBmaW5pc2hlZCBsb2FkaW5nIGluc2lkZSBhIHRlc3QsIGJ1dCB0aGUgZXZlbnQgJysnd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbicrJ1doZW4gdGVzdGluZywgY29kZSB0aGF0IHJlc29sdmVzIHN1c3BlbmRlZCBkYXRhIHNob3VsZCBiZSB3cmFwcGVkICcrJ2ludG8gYWN0KC4uLik6XFxuXFxuJysnYWN0KCgpID0+IHtcXG4nKycgIC8qIGZpbmlzaCBsb2FkaW5nIHN1c3BlbmRlZCBkYXRhICovXFxuJysnfSk7XFxuJysnLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG4nK1wiVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBcIisnaW4gdGhlIGJyb3dzZXIuJysnIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3QnKTt9fX1mdW5jdGlvbiBzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QoaXNSdW5uaW5nKXt7aXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0PWlzUnVubmluZzt9fS8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXMgKi92YXIgcmVzb2x2ZUZhbWlseT1udWxsOy8vICRGbG93Rml4TWUgRmxvdyBnZXRzIGNvbmZ1c2VkIGJ5IGEgV2Vha1NldCBmZWF0dXJlIGNoZWNrIGJlbG93LlxudmFyIGZhaWxlZEJvdW5kYXJpZXM9bnVsbDt2YXIgc2V0UmVmcmVzaEhhbmRsZXI9ZnVuY3Rpb24oaGFuZGxlcil7e3Jlc29sdmVGYW1pbHk9aGFuZGxlcjt9fTtmdW5jdGlvbiByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSl7e2lmKHJlc29sdmVGYW1pbHk9PT1udWxsKXsvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxucmV0dXJuIHR5cGU7fXZhciBmYW1pbHk9cmVzb2x2ZUZhbWlseSh0eXBlKTtpZihmYW1pbHk9PT11bmRlZmluZWQpe3JldHVybiB0eXBlO30vLyBVc2UgdGhlIGxhdGVzdCBrbm93biBpbXBsZW1lbnRhdGlvbi5cbnJldHVybiBmYW1pbHkuY3VycmVudDt9fWZ1bmN0aW9uIHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyh0eXBlKXsvLyBObyBpbXBsZW1lbnRhdGlvbiBkaWZmZXJlbmNlcy5cbnJldHVybiByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSk7fWZ1bmN0aW9uIHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHR5cGUpe3tpZihyZXNvbHZlRmFtaWx5PT09bnVsbCl7Ly8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbnJldHVybiB0eXBlO312YXIgZmFtaWx5PXJlc29sdmVGYW1pbHkodHlwZSk7aWYoZmFtaWx5PT09dW5kZWZpbmVkKXsvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSByZWFsIGZvcndhcmRSZWYuIERvbid0IHdhbnQgdG8gY3Jhc2ggZWFybHkuXG5pZih0eXBlIT09bnVsbCYmdHlwZSE9PXVuZGVmaW5lZCYmdHlwZW9mIHR5cGUucmVuZGVyPT09J2Z1bmN0aW9uJyl7Ly8gRm9yd2FyZFJlZiBpcyBzcGVjaWFsIGJlY2F1c2UgaXRzIHJlc29sdmVkIC50eXBlIGlzIGFuIG9iamVjdCxcbi8vIGJ1dCBpdCdzIHBvc3NpYmxlIHRoYXQgd2Ugb25seSBoYXZlIGl0cyBpbm5lciByZW5kZXIgZnVuY3Rpb24gaW4gdGhlIG1hcC5cbi8vIElmIHRoYXQgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGlzIGRpZmZlcmVudCwgd2UnbGwgYnVpbGQgYSBuZXcgZm9yd2FyZFJlZiB0eXBlLlxudmFyIGN1cnJlbnRSZW5kZXI9cmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUucmVuZGVyKTtpZih0eXBlLnJlbmRlciE9PWN1cnJlbnRSZW5kZXIpe3ZhciBzeW50aGV0aWNUeXBlPXskJHR5cGVvZjpSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLHJlbmRlcjpjdXJyZW50UmVuZGVyfTtpZih0eXBlLmRpc3BsYXlOYW1lIT09dW5kZWZpbmVkKXtzeW50aGV0aWNUeXBlLmRpc3BsYXlOYW1lPXR5cGUuZGlzcGxheU5hbWU7fXJldHVybiBzeW50aGV0aWNUeXBlO319cmV0dXJuIHR5cGU7fS8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxucmV0dXJuIGZhbWlseS5jdXJyZW50O319ZnVuY3Rpb24gaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGZpYmVyLGVsZW1lbnQpe3tpZihyZXNvbHZlRmFtaWx5PT09bnVsbCl7Ly8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbnJldHVybiBmYWxzZTt9dmFyIHByZXZUeXBlPWZpYmVyLmVsZW1lbnRUeXBlO3ZhciBuZXh0VHlwZT1lbGVtZW50LnR5cGU7Ly8gSWYgd2UgZ290IGhlcmUsIHdlIGtub3cgdHlwZXMgYXJlbid0ID09PSBlcXVhbC5cbnZhciBuZWVkc0NvbXBhcmVGYW1pbGllcz1mYWxzZTt2YXIgJCR0eXBlb2ZOZXh0VHlwZT10eXBlb2YgbmV4dFR5cGU9PT0nb2JqZWN0JyYmbmV4dFR5cGUhPT1udWxsP25leHRUeXBlLiQkdHlwZW9mOm51bGw7c3dpdGNoKGZpYmVyLnRhZyl7Y2FzZSBDbGFzc0NvbXBvbmVudDp7aWYodHlwZW9mIG5leHRUeXBlPT09J2Z1bmN0aW9uJyl7bmVlZHNDb21wYXJlRmFtaWxpZXM9dHJ1ZTt9YnJlYWs7fWNhc2UgRnVuY3Rpb25Db21wb25lbnQ6e2lmKHR5cGVvZiBuZXh0VHlwZT09PSdmdW5jdGlvbicpe25lZWRzQ29tcGFyZUZhbWlsaWVzPXRydWU7fWVsc2UgaWYoJCR0eXBlb2ZOZXh0VHlwZT09PVJFQUNUX0xBWllfVFlQRSl7Ly8gV2UgZG9uJ3Qga25vdyB0aGUgaW5uZXIgdHlwZSB5ZXQuXG4vLyBXZSdyZSBnb2luZyB0byBhc3N1bWUgdGhhdCB0aGUgbGF6eSBpbm5lciB0eXBlIGlzIHN0YWJsZSxcbi8vIGFuZCBzbyBpdCBpcyBzdWZmaWNpZW50IHRvIGF2b2lkIHJlY29uY2lsaW5nIGl0IGF3YXkuXG4vLyBXZSdyZSBub3QgZ29pbmcgdG8gdW53cmFwIG9yIGFjdHVhbGx5IHVzZSB0aGUgbmV3IGxhenkgdHlwZS5cbm5lZWRzQ29tcGFyZUZhbWlsaWVzPXRydWU7fWJyZWFrO31jYXNlIEZvcndhcmRSZWY6e2lmKCQkdHlwZW9mTmV4dFR5cGU9PT1SRUFDVF9GT1JXQVJEX1JFRl9UWVBFKXtuZWVkc0NvbXBhcmVGYW1pbGllcz10cnVlO31lbHNlIGlmKCQkdHlwZW9mTmV4dFR5cGU9PT1SRUFDVF9MQVpZX1RZUEUpe25lZWRzQ29tcGFyZUZhbWlsaWVzPXRydWU7fWJyZWFrO31jYXNlIE1lbW9Db21wb25lbnQ6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OntpZigkJHR5cGVvZk5leHRUeXBlPT09UkVBQ1RfTUVNT19UWVBFKXsvLyBUT0RPOiBpZiBpdCB3YXMgYnV0IGNhbiBubyBsb25nZXIgYmUgc2ltcGxlLFxuLy8gd2Ugc2hvdWxkbid0IHNldCB0aGlzLlxubmVlZHNDb21wYXJlRmFtaWxpZXM9dHJ1ZTt9ZWxzZSBpZigkJHR5cGVvZk5leHRUeXBlPT09UkVBQ1RfTEFaWV9UWVBFKXtuZWVkc0NvbXBhcmVGYW1pbGllcz10cnVlO31icmVhazt9ZGVmYXVsdDpyZXR1cm4gZmFsc2U7fS8vIENoZWNrIGlmIGJvdGggdHlwZXMgaGF2ZSBhIGZhbWlseSBhbmQgaXQncyB0aGUgc2FtZSBvbmUuXG5pZihuZWVkc0NvbXBhcmVGYW1pbGllcyl7Ly8gTm90ZTogbWVtbygpIGFuZCBmb3J3YXJkUmVmKCkgd2UnbGwgY29tcGFyZSBvdXRlciByYXRoZXIgdGhhbiBpbm5lciB0eXBlLlxuLy8gVGhpcyBtZWFucyBib3RoIG9mIHRoZW0gbmVlZCB0byBiZSByZWdpc3RlcmVkIHRvIHByZXNlcnZlIHN0YXRlLlxuLy8gSWYgd2UgdW53cmFwcGVkIGFuZCBjb21wYXJlZCB0aGUgaW5uZXIgdHlwZXMgZm9yIHdyYXBwZXJzIGluc3RlYWQsXG4vLyB0aGVuIHdlIHdvdWxkIHJpc2sgZmFsc2VseSBzYXlpbmcgdHdvIHNlcGFyYXRlIG1lbW8oRm9vKVxuLy8gY2FsbHMgYXJlIGVxdWl2YWxlbnQgYmVjYXVzZSB0aGV5IHdyYXAgdGhlIHNhbWUgRm9vIGZ1bmN0aW9uLlxudmFyIHByZXZGYW1pbHk9cmVzb2x2ZUZhbWlseShwcmV2VHlwZSk7aWYocHJldkZhbWlseSE9PXVuZGVmaW5lZCYmcHJldkZhbWlseT09PXJlc29sdmVGYW1pbHkobmV4dFR5cGUpKXtyZXR1cm4gdHJ1ZTt9fXJldHVybiBmYWxzZTt9fWZ1bmN0aW9uIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKXt7aWYocmVzb2x2ZUZhbWlseT09PW51bGwpey8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG5yZXR1cm47fWlmKHR5cGVvZiBXZWFrU2V0IT09J2Z1bmN0aW9uJyl7cmV0dXJuO31pZihmYWlsZWRCb3VuZGFyaWVzPT09bnVsbCl7ZmFpbGVkQm91bmRhcmllcz1uZXcgV2Vha1NldCgpO31mYWlsZWRCb3VuZGFyaWVzLmFkZChmaWJlcik7fX12YXIgc2NoZWR1bGVSZWZyZXNoPWZ1bmN0aW9uKHJvb3QsdXBkYXRlKXt7aWYocmVzb2x2ZUZhbWlseT09PW51bGwpey8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG5yZXR1cm47fXZhciBzdGFsZUZhbWlsaWVzPXVwZGF0ZS5zdGFsZUZhbWlsaWVzLHVwZGF0ZWRGYW1pbGllcz11cGRhdGUudXBkYXRlZEZhbWlsaWVzO2ZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtmbHVzaFN5bmMoZnVuY3Rpb24oKXtzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KHJvb3QuY3VycmVudCx1cGRhdGVkRmFtaWxpZXMsc3RhbGVGYW1pbGllcyk7fSk7fX07dmFyIHNjaGVkdWxlUm9vdD1mdW5jdGlvbihyb290LGVsZW1lbnQpe3tpZihyb290LmNvbnRleHQhPT1lbXB0eUNvbnRleHRPYmplY3Qpey8vIFN1cGVyIGVkZ2UgY2FzZTogcm9vdCBoYXMgYSBsZWdhY3kgX3JlbmRlclN1YnRyZWUgY29udGV4dFxuLy8gYnV0IHdlIGRvbid0IGtub3cgdGhlIHBhcmVudENvbXBvbmVudCBzbyB3ZSBjYW4ndCBwYXNzIGl0LlxuLy8gSnVzdCBpZ25vcmUuIFdlJ2xsIGRlbGV0ZSB0aGlzIHdpdGggX3JlbmRlclN1YnRyZWUgY29kZSBwYXRoIGxhdGVyLlxucmV0dXJuO31mbHVzaFBhc3NpdmVFZmZlY3RzKCk7Zmx1c2hTeW5jKGZ1bmN0aW9uKCl7dXBkYXRlQ29udGFpbmVyKGVsZW1lbnQscm9vdCxudWxsLG51bGwpO30pO319O2Z1bmN0aW9uIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoZmliZXIsdXBkYXRlZEZhbWlsaWVzLHN0YWxlRmFtaWxpZXMpe3t2YXIgYWx0ZXJuYXRlPWZpYmVyLmFsdGVybmF0ZSxjaGlsZD1maWJlci5jaGlsZCxzaWJsaW5nPWZpYmVyLnNpYmxpbmcsdGFnPWZpYmVyLnRhZyx0eXBlPWZpYmVyLnR5cGU7dmFyIGNhbmRpZGF0ZVR5cGU9bnVsbDtzd2l0Y2godGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpjYXNlIENsYXNzQ29tcG9uZW50OmNhbmRpZGF0ZVR5cGU9dHlwZTticmVhaztjYXNlIEZvcndhcmRSZWY6Y2FuZGlkYXRlVHlwZT10eXBlLnJlbmRlcjticmVhazt9aWYocmVzb2x2ZUZhbWlseT09PW51bGwpe3Rocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVzb2x2ZUZhbWlseSB0byBiZSBzZXQgZHVyaW5nIGhvdCByZWxvYWQuJyk7fXZhciBuZWVkc1JlbmRlcj1mYWxzZTt2YXIgbmVlZHNSZW1vdW50PWZhbHNlO2lmKGNhbmRpZGF0ZVR5cGUhPT1udWxsKXt2YXIgZmFtaWx5PXJlc29sdmVGYW1pbHkoY2FuZGlkYXRlVHlwZSk7aWYoZmFtaWx5IT09dW5kZWZpbmVkKXtpZihzdGFsZUZhbWlsaWVzLmhhcyhmYW1pbHkpKXtuZWVkc1JlbW91bnQ9dHJ1ZTt9ZWxzZSBpZih1cGRhdGVkRmFtaWxpZXMuaGFzKGZhbWlseSkpe2lmKHRhZz09PUNsYXNzQ29tcG9uZW50KXtuZWVkc1JlbW91bnQ9dHJ1ZTt9ZWxzZXtuZWVkc1JlbmRlcj10cnVlO319fX1pZihmYWlsZWRCb3VuZGFyaWVzIT09bnVsbCl7aWYoZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIpfHxhbHRlcm5hdGUhPT1udWxsJiZmYWlsZWRCb3VuZGFyaWVzLmhhcyhhbHRlcm5hdGUpKXtuZWVkc1JlbW91bnQ9dHJ1ZTt9fWlmKG5lZWRzUmVtb3VudCl7ZmliZXIuX2RlYnVnTmVlZHNSZW1vdW50PXRydWU7fWlmKG5lZWRzUmVtb3VudHx8bmVlZHNSZW5kZXIpe3ZhciBfcm9vdD1lbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsU3luY0xhbmUpO2lmKF9yb290IT09bnVsbCl7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKF9yb290LGZpYmVyLFN5bmNMYW5lLE5vVGltZXN0YW1wKTt9fWlmKGNoaWxkIT09bnVsbCYmIW5lZWRzUmVtb3VudCl7c2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShjaGlsZCx1cGRhdGVkRmFtaWxpZXMsc3RhbGVGYW1pbGllcyk7fWlmKHNpYmxpbmchPT1udWxsKXtzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsdXBkYXRlZEZhbWlsaWVzLHN0YWxlRmFtaWxpZXMpO319fXZhciBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2g9ZnVuY3Rpb24ocm9vdCxmYW1pbGllcyl7e3ZhciBob3N0SW5zdGFuY2VzPW5ldyBTZXQoKTt2YXIgdHlwZXM9bmV3IFNldChmYW1pbGllcy5tYXAoZnVuY3Rpb24oZmFtaWx5KXtyZXR1cm4gZmFtaWx5LmN1cnJlbnQ7fSkpO2ZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShyb290LmN1cnJlbnQsdHlwZXMsaG9zdEluc3RhbmNlcyk7cmV0dXJuIGhvc3RJbnN0YW5jZXM7fX07ZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KGZpYmVyLHR5cGVzLGhvc3RJbnN0YW5jZXMpe3t2YXIgY2hpbGQ9ZmliZXIuY2hpbGQsc2libGluZz1maWJlci5zaWJsaW5nLHRhZz1maWJlci50YWcsdHlwZT1maWJlci50eXBlO3ZhciBjYW5kaWRhdGVUeXBlPW51bGw7c3dpdGNoKHRhZyl7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6Y2FzZSBDbGFzc0NvbXBvbmVudDpjYW5kaWRhdGVUeXBlPXR5cGU7YnJlYWs7Y2FzZSBGb3J3YXJkUmVmOmNhbmRpZGF0ZVR5cGU9dHlwZS5yZW5kZXI7YnJlYWs7fXZhciBkaWRNYXRjaD1mYWxzZTtpZihjYW5kaWRhdGVUeXBlIT09bnVsbCl7aWYodHlwZXMuaGFzKGNhbmRpZGF0ZVR5cGUpKXtkaWRNYXRjaD10cnVlO319aWYoZGlkTWF0Y2gpey8vIFdlIGhhdmUgYSBtYXRjaC4gVGhpcyBvbmx5IGRyaWxscyBkb3duIHRvIHRoZSBjbG9zZXN0IGhvc3QgY29tcG9uZW50cy5cbi8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBzZWFyY2ggZGVlcGVyIGJlY2F1c2UgZm9yIHRoZSBwdXJwb3NlIG9mIGdpdmluZ1xuLy8gdmlzdWFsIGZlZWRiYWNrLCBcImZsYXNoaW5nXCIgb3V0ZXJtb3N0IHBhcmVudCByZWN0YW5nbGVzIGlzIHN1ZmZpY2llbnQuXG5maW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLGhvc3RJbnN0YW5jZXMpO31lbHNley8vIElmIHRoZXJlJ3Mgbm8gbWF0Y2gsIG1heWJlIHRoZXJlIHdpbGwgYmUgb25lIGZ1cnRoZXIgZG93biBpbiB0aGUgY2hpbGQgdHJlZS5cbmlmKGNoaWxkIT09bnVsbCl7ZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KGNoaWxkLHR5cGVzLGhvc3RJbnN0YW5jZXMpO319aWYoc2libGluZyE9PW51bGwpe2ZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShzaWJsaW5nLHR5cGVzLGhvc3RJbnN0YW5jZXMpO319fWZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsaG9zdEluc3RhbmNlcyl7e3ZhciBmb3VuZEhvc3RJbnN0YW5jZXM9ZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLGhvc3RJbnN0YW5jZXMpO2lmKGZvdW5kSG9zdEluc3RhbmNlcyl7cmV0dXJuO30vLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnkgaG9zdCBjaGlsZHJlbiwgZmFsbGJhY2sgdG8gY2xvc2VzdCBob3N0IHBhcmVudC5cbnZhciBub2RlPWZpYmVyO3doaWxlKHRydWUpe3N3aXRjaChub2RlLnRhZyl7Y2FzZSBIb3N0Q29tcG9uZW50Omhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTtyZXR1cm47Y2FzZSBIb3N0UG9ydGFsOmhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO3JldHVybjtjYXNlIEhvc3RSb290Omhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO3JldHVybjt9aWYobm9kZS5yZXR1cm49PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIHJlYWNoIHJvb3QgZmlyc3QuJyk7fW5vZGU9bm9kZS5yZXR1cm47fX19ZnVuY3Rpb24gZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLGhvc3RJbnN0YW5jZXMpe3t2YXIgbm9kZT1maWJlcjt2YXIgZm91bmRIb3N0SW5zdGFuY2VzPWZhbHNlO3doaWxlKHRydWUpe2lmKG5vZGUudGFnPT09SG9zdENvbXBvbmVudCl7Ly8gV2UgZ290IGEgbWF0Y2guXG5mb3VuZEhvc3RJbnN0YW5jZXM9dHJ1ZTtob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZSk7Ly8gVGhlcmUgbWF5IHN0aWxsIGJlIG1vcmUsIHNvIGtlZXAgc2VhcmNoaW5nLlxufWVsc2UgaWYobm9kZS5jaGlsZCE9PW51bGwpe25vZGUuY2hpbGQucmV0dXJuPW5vZGU7bm9kZT1ub2RlLmNoaWxkO2NvbnRpbnVlO31pZihub2RlPT09ZmliZXIpe3JldHVybiBmb3VuZEhvc3RJbnN0YW5jZXM7fXdoaWxlKG5vZGUuc2libGluZz09PW51bGwpe2lmKG5vZGUucmV0dXJuPT09bnVsbHx8bm9kZS5yZXR1cm49PT1maWJlcil7cmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlczt9bm9kZT1ub2RlLnJldHVybjt9bm9kZS5zaWJsaW5nLnJldHVybj1ub2RlLnJldHVybjtub2RlPW5vZGUuc2libGluZzt9fXJldHVybiBmYWxzZTt9dmFyIGhhc0JhZE1hcFBvbHlmaWxsO3toYXNCYWRNYXBQb2x5ZmlsbD1mYWxzZTt0cnl7dmFyIG5vbkV4dGVuc2libGVPYmplY3Q9T2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTsvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9uZXcgTWFwKFtbbm9uRXh0ZW5zaWJsZU9iamVjdCxudWxsXV0pO25ldyBTZXQoW25vbkV4dGVuc2libGVPYmplY3RdKTsvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL31jYXRjaChlKXsvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGFib3V0IGJhZCBwb2x5ZmlsbHNcbmhhc0JhZE1hcFBvbHlmaWxsPXRydWU7fX1mdW5jdGlvbiBGaWJlck5vZGUodGFnLHBlbmRpbmdQcm9wcyxrZXksbW9kZSl7Ly8gSW5zdGFuY2VcbnRoaXMudGFnPXRhZzt0aGlzLmtleT1rZXk7dGhpcy5lbGVtZW50VHlwZT1udWxsO3RoaXMudHlwZT1udWxsO3RoaXMuc3RhdGVOb2RlPW51bGw7Ly8gRmliZXJcbnRoaXMucmV0dXJuPW51bGw7dGhpcy5jaGlsZD1udWxsO3RoaXMuc2libGluZz1udWxsO3RoaXMuaW5kZXg9MDt0aGlzLnJlZj1udWxsO3RoaXMucGVuZGluZ1Byb3BzPXBlbmRpbmdQcm9wczt0aGlzLm1lbW9pemVkUHJvcHM9bnVsbDt0aGlzLnVwZGF0ZVF1ZXVlPW51bGw7dGhpcy5tZW1vaXplZFN0YXRlPW51bGw7dGhpcy5kZXBlbmRlbmNpZXM9bnVsbDt0aGlzLm1vZGU9bW9kZTsvLyBFZmZlY3RzXG50aGlzLmZsYWdzPU5vRmxhZ3M7dGhpcy5zdWJ0cmVlRmxhZ3M9Tm9GbGFnczt0aGlzLmRlbGV0aW9ucz1udWxsO3RoaXMubGFuZXM9Tm9MYW5lczt0aGlzLmNoaWxkTGFuZXM9Tm9MYW5lczt0aGlzLmFsdGVybmF0ZT1udWxsO3svLyBOb3RlOiBUaGUgZm9sbG93aW5nIGlzIGRvbmUgdG8gYXZvaWQgYSB2OCBwZXJmb3JtYW5jZSBjbGlmZi5cbi8vXG4vLyBJbml0aWFsaXppbmcgdGhlIGZpZWxkcyBiZWxvdyB0byBzbWlzIGFuZCBsYXRlciB1cGRhdGluZyB0aGVtIHdpdGhcbi8vIGRvdWJsZSB2YWx1ZXMgd2lsbCBjYXVzZSBGaWJlcnMgdG8gZW5kIHVwIGhhdmluZyBzZXBhcmF0ZSBzaGFwZXMuXG4vLyBUaGlzIGJlaGF2aW9yL2J1ZyBoYXMgc29tZXRoaW5nIHRvIGRvIHdpdGggT2JqZWN0LnByZXZlbnRFeHRlbnNpb24oKS5cbi8vIEZvcnR1bmF0ZWx5IHRoaXMgb25seSBpbXBhY3RzIERFViBidWlsZHMuXG4vLyBVbmZvcnR1bmF0ZWx5IGl0IG1ha2VzIFJlYWN0IHVudXNhYmx5IHNsb3cgZm9yIHNvbWUgYXBwbGljYXRpb25zLlxuLy8gVG8gd29yayBhcm91bmQgdGhpcywgaW5pdGlhbGl6ZSB0aGUgZmllbGRzIGJlbG93IHdpdGggZG91Ymxlcy5cbi8vXG4vLyBMZWFybiBtb3JlIGFib3V0IHRoaXMgaGVyZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQzNjVcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTg1MzhcbnRoaXMuYWN0dWFsRHVyYXRpb249TnVtYmVyLk5hTjt0aGlzLmFjdHVhbFN0YXJ0VGltZT1OdW1iZXIuTmFOO3RoaXMuc2VsZkJhc2VEdXJhdGlvbj1OdW1iZXIuTmFOO3RoaXMudHJlZUJhc2VEdXJhdGlvbj1OdW1iZXIuTmFOOy8vIEl0J3Mgb2theSB0byByZXBsYWNlIHRoZSBpbml0aWFsIGRvdWJsZXMgd2l0aCBzbWlzIGFmdGVyIGluaXRpYWxpemF0aW9uLlxuLy8gVGhpcyB3b24ndCB0cmlnZ2VyIHRoZSBwZXJmb3JtYW5jZSBjbGlmZiBtZW50aW9uZWQgYWJvdmUsXG4vLyBhbmQgaXQgc2ltcGxpZmllcyBvdGhlciBwcm9maWxlciBjb2RlIChpbmNsdWRpbmcgRGV2VG9vbHMpLlxudGhpcy5hY3R1YWxEdXJhdGlvbj0wO3RoaXMuYWN0dWFsU3RhcnRUaW1lPS0xO3RoaXMuc2VsZkJhc2VEdXJhdGlvbj0wO3RoaXMudHJlZUJhc2VEdXJhdGlvbj0wO317Ly8gVGhpcyBpc24ndCBkaXJlY3RseSB1c2VkIGJ1dCBpcyBoYW5keSBmb3IgZGVidWdnaW5nIGludGVybmFsczpcbnRoaXMuX2RlYnVnU291cmNlPW51bGw7dGhpcy5fZGVidWdPd25lcj1udWxsO3RoaXMuX2RlYnVnTmVlZHNSZW1vdW50PWZhbHNlO3RoaXMuX2RlYnVnSG9va1R5cGVzPW51bGw7aWYoIWhhc0JhZE1hcFBvbHlmaWxsJiZ0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zPT09J2Z1bmN0aW9uJyl7T2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO319fS8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxudmFyIGNyZWF0ZUZpYmVyPWZ1bmN0aW9uKHRhZyxwZW5kaW5nUHJvcHMsa2V5LG1vZGUpey8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xucmV0dXJuIG5ldyBGaWJlck5vZGUodGFnLHBlbmRpbmdQcm9wcyxrZXksbW9kZSk7fTtmdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QkMShDb21wb25lbnQpe3ZhciBwcm90b3R5cGU9Q29tcG9uZW50LnByb3RvdHlwZTtyZXR1cm4hIShwcm90b3R5cGUmJnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTt9ZnVuY3Rpb24gaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCh0eXBlKXtyZXR1cm4gdHlwZW9mIHR5cGU9PT0nZnVuY3Rpb24nJiYhc2hvdWxkQ29uc3RydWN0JDEodHlwZSkmJnR5cGUuZGVmYXVsdFByb3BzPT09dW5kZWZpbmVkO31mdW5jdGlvbiByZXNvbHZlTGF6eUNvbXBvbmVudFRhZyhDb21wb25lbnQpe2lmKHR5cGVvZiBDb21wb25lbnQ9PT0nZnVuY3Rpb24nKXtyZXR1cm4gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KT9DbGFzc0NvbXBvbmVudDpGdW5jdGlvbkNvbXBvbmVudDt9ZWxzZSBpZihDb21wb25lbnQhPT11bmRlZmluZWQmJkNvbXBvbmVudCE9PW51bGwpe3ZhciAkJHR5cGVvZj1Db21wb25lbnQuJCR0eXBlb2Y7aWYoJCR0eXBlb2Y9PT1SRUFDVF9GT1JXQVJEX1JFRl9UWVBFKXtyZXR1cm4gRm9yd2FyZFJlZjt9aWYoJCR0eXBlb2Y9PT1SRUFDVF9NRU1PX1RZUEUpe3JldHVybiBNZW1vQ29tcG9uZW50O319cmV0dXJuIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7fS8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgYW4gYWx0ZXJuYXRlIGZpYmVyIHRvIGRvIHdvcmsgb24uXG5mdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LHBlbmRpbmdQcm9wcyl7dmFyIHdvcmtJblByb2dyZXNzPWN1cnJlbnQuYWx0ZXJuYXRlO2lmKHdvcmtJblByb2dyZXNzPT09bnVsbCl7Ly8gV2UgdXNlIGEgZG91YmxlIGJ1ZmZlcmluZyBwb29saW5nIHRlY2huaXF1ZSBiZWNhdXNlIHdlIGtub3cgdGhhdCB3ZSdsbFxuLy8gb25seSBldmVyIG5lZWQgYXQgbW9zdCB0d28gdmVyc2lvbnMgb2YgYSB0cmVlLiBXZSBwb29sIHRoZSBcIm90aGVyXCIgdW51c2VkXG4vLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4vLyBleHRyYSBvYmplY3RzIGZvciB0aGluZ3MgdGhhdCBhcmUgbmV2ZXIgdXBkYXRlZC4gSXQgYWxzbyBhbGxvdyB1cyB0b1xuLy8gcmVjbGFpbSB0aGUgZXh0cmEgbWVtb3J5IGlmIG5lZWRlZC5cbndvcmtJblByb2dyZXNzPWNyZWF0ZUZpYmVyKGN1cnJlbnQudGFnLHBlbmRpbmdQcm9wcyxjdXJyZW50LmtleSxjdXJyZW50Lm1vZGUpO3dvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlPWN1cnJlbnQuZWxlbWVudFR5cGU7d29ya0luUHJvZ3Jlc3MudHlwZT1jdXJyZW50LnR5cGU7d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlPWN1cnJlbnQuc3RhdGVOb2RlO3svLyBERVYtb25seSBmaWVsZHNcbndvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZT1jdXJyZW50Ll9kZWJ1Z1NvdXJjZTt3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lcj1jdXJyZW50Ll9kZWJ1Z093bmVyO3dvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcz1jdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlczt9d29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlPWN1cnJlbnQ7Y3VycmVudC5hbHRlcm5hdGU9d29ya0luUHJvZ3Jlc3M7fWVsc2V7d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzPXBlbmRpbmdQcm9wczsvLyBOZWVkZWQgYmVjYXVzZSBCbG9ja3Mgc3RvcmUgZGF0YSBvbiB0eXBlLlxud29ya0luUHJvZ3Jlc3MudHlwZT1jdXJyZW50LnR5cGU7Ly8gV2UgYWxyZWFkeSBoYXZlIGFuIGFsdGVybmF0ZS5cbi8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3M9Tm9GbGFnczsvLyBUaGUgZWZmZWN0cyBhcmUgbm8gbG9uZ2VyIHZhbGlkLlxud29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzPU5vRmxhZ3M7d29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zPW51bGw7ey8vIFdlIGludGVudGlvbmFsbHkgcmVzZXQsIHJhdGhlciB0aGFuIGNvcHksIGFjdHVhbER1cmF0aW9uICYgYWN0dWFsU3RhcnRUaW1lLlxuLy8gVGhpcyBwcmV2ZW50cyB0aW1lIGZyb20gZW5kbGVzc2x5IGFjY3VtdWxhdGluZyBpbiBuZXcgY29tbWl0cy5cbi8vIFRoaXMgaGFzIHRoZSBkb3duc2lkZSBvZiByZXNldHRpbmcgdmFsdWVzIGZvciBkaWZmZXJlbnQgcHJpb3JpdHkgcmVuZGVycyxcbi8vIEJ1dCB3b3JrcyBmb3IgeWllbGRpbmcgKHRoZSBjb21tb24gY2FzZSkgYW5kIHNob3VsZCBzdXBwb3J0IHJlc3VtaW5nLlxud29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb249MDt3b3JrSW5Qcm9ncmVzcy5hY3R1YWxTdGFydFRpbWU9LTE7fX0vLyBSZXNldCBhbGwgZWZmZWN0cyBleGNlcHQgc3RhdGljIG9uZXMuXG4vLyBTdGF0aWMgZWZmZWN0cyBhcmUgbm90IHNwZWNpZmljIHRvIGEgcmVuZGVyLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3M9Y3VycmVudC5mbGFncyZTdGF0aWNNYXNrO3dvcmtJblByb2dyZXNzLmNoaWxkTGFuZXM9Y3VycmVudC5jaGlsZExhbmVzO3dvcmtJblByb2dyZXNzLmxhbmVzPWN1cnJlbnQubGFuZXM7d29ya0luUHJvZ3Jlc3MuY2hpbGQ9Y3VycmVudC5jaGlsZDt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzPWN1cnJlbnQubWVtb2l6ZWRQcm9wczt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPWN1cnJlbnQubWVtb2l6ZWRTdGF0ZTt3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT1jdXJyZW50LnVwZGF0ZVF1ZXVlOy8vIENsb25lIHRoZSBkZXBlbmRlbmNpZXMgb2JqZWN0LiBUaGlzIGlzIG11dGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvXG4vLyBpdCBjYW5ub3QgYmUgc2hhcmVkIHdpdGggdGhlIGN1cnJlbnQgZmliZXIuXG52YXIgY3VycmVudERlcGVuZGVuY2llcz1jdXJyZW50LmRlcGVuZGVuY2llczt3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM9Y3VycmVudERlcGVuZGVuY2llcz09PW51bGw/bnVsbDp7bGFuZXM6Y3VycmVudERlcGVuZGVuY2llcy5sYW5lcyxmaXJzdENvbnRleHQ6Y3VycmVudERlcGVuZGVuY2llcy5maXJzdENvbnRleHR9Oy8vIFRoZXNlIHdpbGwgYmUgb3ZlcnJpZGRlbiBkdXJpbmcgdGhlIHBhcmVudCdzIHJlY29uY2lsaWF0aW9uXG53b3JrSW5Qcm9ncmVzcy5zaWJsaW5nPWN1cnJlbnQuc2libGluZzt3b3JrSW5Qcm9ncmVzcy5pbmRleD1jdXJyZW50LmluZGV4O3dvcmtJblByb2dyZXNzLnJlZj1jdXJyZW50LnJlZjt7d29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbj1jdXJyZW50LnNlbGZCYXNlRHVyYXRpb247d29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbj1jdXJyZW50LnRyZWVCYXNlRHVyYXRpb247fXt3b3JrSW5Qcm9ncmVzcy5fZGVidWdOZWVkc1JlbW91bnQ9Y3VycmVudC5fZGVidWdOZWVkc1JlbW91bnQ7c3dpdGNoKHdvcmtJblByb2dyZXNzLnRhZyl7Y2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OmNhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OndvcmtJblByb2dyZXNzLnR5cGU9cmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7YnJlYWs7Y2FzZSBDbGFzc0NvbXBvbmVudDp3b3JrSW5Qcm9ncmVzcy50eXBlPXJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO2JyZWFrO2Nhc2UgRm9yd2FyZFJlZjp3b3JrSW5Qcm9ncmVzcy50eXBlPXJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7YnJlYWs7fX1yZXR1cm4gd29ya0luUHJvZ3Jlc3M7fS8vIFVzZWQgdG8gcmV1c2UgYSBGaWJlciBmb3IgYSBzZWNvbmQgcGFzcy5cbmZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3Mod29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpey8vIFRoaXMgcmVzZXRzIHRoZSBGaWJlciB0byB3aGF0IGNyZWF0ZUZpYmVyIG9yIGNyZWF0ZVdvcmtJblByb2dyZXNzIHdvdWxkXG4vLyBoYXZlIHNldCB0aGUgdmFsdWVzIHRvIGJlZm9yZSBkdXJpbmcgdGhlIGZpcnN0IHBhc3MuIElkZWFsbHkgdGhpcyB3b3VsZG4ndFxuLy8gYmUgbmVjZXNzYXJ5IGJ1dCB1bmZvcnR1bmF0ZWx5IG1hbnkgY29kZSBwYXRocyByZWFkcyBmcm9tIHRoZSB3b3JrSW5Qcm9ncmVzc1xuLy8gd2hlbiB0aGV5IHNob3VsZCBiZSByZWFkaW5nIGZyb20gY3VycmVudCBhbmQgd3JpdGluZyB0byB3b3JrSW5Qcm9ncmVzcy5cbi8vIFdlIGFzc3VtZSBwZW5kaW5nUHJvcHMsIGluZGV4LCBrZXksIHJlZiwgcmV0dXJuIGFyZSBzdGlsbCB1bnRvdWNoZWQgdG9cbi8vIGF2b2lkIGRvaW5nIGFub3RoZXIgcmVjb25jaWxpYXRpb24uXG4vLyBSZXNldCB0aGUgZWZmZWN0IGZsYWdzIGJ1dCBrZWVwIGFueSBQbGFjZW1lbnQgdGFncywgc2luY2UgdGhhdCdzIHNvbWV0aGluZ1xuLy8gdGhhdCBjaGlsZCBmaWJlciBpcyBzZXR0aW5nLCBub3QgdGhlIHJlY29uY2lsaWF0aW9uLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3MmPVN0YXRpY01hc2t8UGxhY2VtZW50Oy8vIFRoZSBlZmZlY3RzIGFyZSBubyBsb25nZXIgdmFsaWQuXG52YXIgY3VycmVudD13b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7aWYoY3VycmVudD09PW51bGwpey8vIFJlc2V0IHRvIGNyZWF0ZUZpYmVyJ3MgaW5pdGlhbCB2YWx1ZXMuXG53b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzPU5vTGFuZXM7d29ya0luUHJvZ3Jlc3MubGFuZXM9cmVuZGVyTGFuZXM7d29ya0luUHJvZ3Jlc3MuY2hpbGQ9bnVsbDt3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3M9Tm9GbGFnczt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzPW51bGw7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1udWxsO3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlPW51bGw7d29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzPW51bGw7d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlPW51bGw7ey8vIE5vdGU6IFdlIGRvbid0IHJlc2V0IHRoZSBhY3R1YWxUaW1lIGNvdW50cy4gSXQncyB1c2VmdWwgdG8gYWNjdW11bGF0ZVxuLy8gYWN0dWFsIHRpbWUgYWNyb3NzIG11bHRpcGxlIHJlbmRlciBwYXNzZXMuXG53b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uPTA7d29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbj0wO319ZWxzZXsvLyBSZXNldCB0byB0aGUgY2xvbmVkIHZhbHVlcyB0aGF0IGNyZWF0ZVdvcmtJblByb2dyZXNzIHdvdWxkJ3ZlLlxud29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcz1jdXJyZW50LmNoaWxkTGFuZXM7d29ya0luUHJvZ3Jlc3MubGFuZXM9Y3VycmVudC5sYW5lczt3b3JrSW5Qcm9ncmVzcy5jaGlsZD1jdXJyZW50LmNoaWxkO3dvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncz1Ob0ZsYWdzO3dvcmtJblByb2dyZXNzLmRlbGV0aW9ucz1udWxsO3dvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM9Y3VycmVudC5tZW1vaXplZFByb3BzO3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9Y3VycmVudC5tZW1vaXplZFN0YXRlO3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlPWN1cnJlbnQudXBkYXRlUXVldWU7Ly8gTmVlZGVkIGJlY2F1c2UgQmxvY2tzIHN0b3JlIGRhdGEgb24gdHlwZS5cbndvcmtJblByb2dyZXNzLnR5cGU9Y3VycmVudC50eXBlOy8vIENsb25lIHRoZSBkZXBlbmRlbmNpZXMgb2JqZWN0LiBUaGlzIGlzIG11dGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvXG4vLyBpdCBjYW5ub3QgYmUgc2hhcmVkIHdpdGggdGhlIGN1cnJlbnQgZmliZXIuXG52YXIgY3VycmVudERlcGVuZGVuY2llcz1jdXJyZW50LmRlcGVuZGVuY2llczt3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM9Y3VycmVudERlcGVuZGVuY2llcz09PW51bGw/bnVsbDp7bGFuZXM6Y3VycmVudERlcGVuZGVuY2llcy5sYW5lcyxmaXJzdENvbnRleHQ6Y3VycmVudERlcGVuZGVuY2llcy5maXJzdENvbnRleHR9O3svLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbi8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxud29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbj1jdXJyZW50LnNlbGZCYXNlRHVyYXRpb247d29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbj1jdXJyZW50LnRyZWVCYXNlRHVyYXRpb247fX1yZXR1cm4gd29ya0luUHJvZ3Jlc3M7fWZ1bmN0aW9uIGNyZWF0ZUhvc3RSb290RmliZXIodGFnLGlzU3RyaWN0TW9kZSxjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlKXt2YXIgbW9kZTtpZih0YWc9PT1Db25jdXJyZW50Um9vdCl7bW9kZT1Db25jdXJyZW50TW9kZTtpZihpc1N0cmljdE1vZGU9PT10cnVlKXttb2RlfD1TdHJpY3RMZWdhY3lNb2RlO3ttb2RlfD1TdHJpY3RFZmZlY3RzTW9kZTt9fX1lbHNle21vZGU9Tm9Nb2RlO31pZihpc0RldlRvb2xzUHJlc2VudCl7Ly8gQWx3YXlzIGNvbGxlY3QgcHJvZmlsZSB0aW1pbmdzIHdoZW4gRGV2VG9vbHMgYXJlIHByZXNlbnQuXG4vLyBUaGlzIGVuYWJsZXMgRGV2VG9vbHMgdG8gc3RhcnQgY2FwdHVyaW5nIHRpbWluZyBhdCBhbnkgcG9pbnTigJNcbi8vIFdpdGhvdXQgc29tZSBub2RlcyBpbiB0aGUgdHJlZSBoYXZpbmcgZW1wdHkgYmFzZSB0aW1lcy5cbm1vZGV8PVByb2ZpbGVNb2RlO31yZXR1cm4gY3JlYXRlRmliZXIoSG9zdFJvb3QsbnVsbCxudWxsLG1vZGUpO31mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHModHlwZSwvLyBSZWFjdCRFbGVtZW50VHlwZVxua2V5LHBlbmRpbmdQcm9wcyxvd25lcixtb2RlLGxhbmVzKXt2YXIgZmliZXJUYWc9SW5kZXRlcm1pbmF0ZUNvbXBvbmVudDsvLyBUaGUgcmVzb2x2ZWQgdHlwZSBpcyBzZXQgaWYgd2Uga25vdyB3aGF0IHRoZSBmaW5hbCB0eXBlIHdpbGwgYmUuIEkuZS4gaXQncyBub3QgbGF6eS5cbnZhciByZXNvbHZlZFR5cGU9dHlwZTtpZih0eXBlb2YgdHlwZT09PSdmdW5jdGlvbicpe2lmKHNob3VsZENvbnN0cnVjdCQxKHR5cGUpKXtmaWJlclRhZz1DbGFzc0NvbXBvbmVudDt7cmVzb2x2ZWRUeXBlPXJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO319ZWxzZXt7cmVzb2x2ZWRUeXBlPXJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO319fWVsc2UgaWYodHlwZW9mIHR5cGU9PT0nc3RyaW5nJyl7ZmliZXJUYWc9SG9zdENvbXBvbmVudDt9ZWxzZXtnZXRUYWc6c3dpdGNoKHR5cGUpe2Nhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpyZXR1cm4gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQocGVuZGluZ1Byb3BzLmNoaWxkcmVuLG1vZGUsbGFuZXMsa2V5KTtjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6ZmliZXJUYWc9TW9kZTttb2RlfD1TdHJpY3RMZWdhY3lNb2RlO2lmKChtb2RlJkNvbmN1cnJlbnRNb2RlKSE9PU5vTW9kZSl7Ly8gU3RyaWN0IGVmZmVjdHMgc2hvdWxkIG5ldmVyIHJ1biBvbiBsZWdhY3kgcm9vdHNcbm1vZGV8PVN0cmljdEVmZmVjdHNNb2RlO31icmVhaztjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6cmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcyxtb2RlLGxhbmVzLGtleSk7Y2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOnJldHVybiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZShwZW5kaW5nUHJvcHMsbW9kZSxsYW5lcyxrZXkpO2Nhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOnJldHVybiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QocGVuZGluZ1Byb3BzLG1vZGUsbGFuZXMsa2V5KTtjYXNlIFJFQUNUX09GRlNDUkVFTl9UWVBFOnJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLG1vZGUsbGFuZXMsa2V5KTtjYXNlIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTovLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbmNhc2UgUkVBQ1RfU0NPUEVfVFlQRTovLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbmNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTovLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbmNhc2UgUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRTovLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbmNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5kZWZhdWx0OntpZih0eXBlb2YgdHlwZT09PSdvYmplY3QnJiZ0eXBlIT09bnVsbCl7c3dpdGNoKHR5cGUuJCR0eXBlb2Ype2Nhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpmaWJlclRhZz1Db250ZXh0UHJvdmlkZXI7YnJlYWsgZ2V0VGFnO2Nhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOi8vIFRoaXMgaXMgYSBjb25zdW1lclxuZmliZXJUYWc9Q29udGV4dENvbnN1bWVyO2JyZWFrIGdldFRhZztjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6ZmliZXJUYWc9Rm9yd2FyZFJlZjt7cmVzb2x2ZWRUeXBlPXJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7fWJyZWFrIGdldFRhZztjYXNlIFJFQUNUX01FTU9fVFlQRTpmaWJlclRhZz1NZW1vQ29tcG9uZW50O2JyZWFrIGdldFRhZztjYXNlIFJFQUNUX0xBWllfVFlQRTpmaWJlclRhZz1MYXp5Q29tcG9uZW50O3Jlc29sdmVkVHlwZT1udWxsO2JyZWFrIGdldFRhZzt9fXZhciBpbmZvPScnO3tpZih0eXBlPT09dW5kZWZpbmVkfHx0eXBlb2YgdHlwZT09PSdvYmplY3QnJiZ0eXBlIT09bnVsbCYmT2JqZWN0LmtleXModHlwZSkubGVuZ3RoPT09MCl7aW5mbys9JyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnK1wiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBcIisnbmFtZWQgaW1wb3J0cy4nO312YXIgb3duZXJOYW1lPW93bmVyP2dldENvbXBvbmVudE5hbWVGcm9tRmliZXIob3duZXIpOm51bGw7aWYob3duZXJOYW1lKXtpbmZvKz0nXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcrb3duZXJOYW1lKydgLic7fX10aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluICcrJ2NvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgJysoXCJidXQgZ290OiBcIisodHlwZT09bnVsbD90eXBlOnR5cGVvZiB0eXBlKStcIi5cIitpbmZvKSk7fX19dmFyIGZpYmVyPWNyZWF0ZUZpYmVyKGZpYmVyVGFnLHBlbmRpbmdQcm9wcyxrZXksbW9kZSk7ZmliZXIuZWxlbWVudFR5cGU9dHlwZTtmaWJlci50eXBlPXJlc29sdmVkVHlwZTtmaWJlci5sYW5lcz1sYW5lczt7ZmliZXIuX2RlYnVnT3duZXI9b3duZXI7fXJldHVybiBmaWJlcjt9ZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LG1vZGUsbGFuZXMpe3ZhciBvd25lcj1udWxsO3tvd25lcj1lbGVtZW50Ll9vd25lcjt9dmFyIHR5cGU9ZWxlbWVudC50eXBlO3ZhciBrZXk9ZWxlbWVudC5rZXk7dmFyIHBlbmRpbmdQcm9wcz1lbGVtZW50LnByb3BzO3ZhciBmaWJlcj1jcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHModHlwZSxrZXkscGVuZGluZ1Byb3BzLG93bmVyLG1vZGUsbGFuZXMpO3tmaWJlci5fZGVidWdTb3VyY2U9ZWxlbWVudC5fc291cmNlO2ZpYmVyLl9kZWJ1Z093bmVyPWVsZW1lbnQuX293bmVyO31yZXR1cm4gZmliZXI7fWZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLG1vZGUsbGFuZXMsa2V5KXt2YXIgZmliZXI9Y3JlYXRlRmliZXIoRnJhZ21lbnQsZWxlbWVudHMsa2V5LG1vZGUpO2ZpYmVyLmxhbmVzPWxhbmVzO3JldHVybiBmaWJlcjt9ZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLG1vZGUsbGFuZXMsa2V5KXt7aWYodHlwZW9mIHBlbmRpbmdQcm9wcy5pZCE9PSdzdHJpbmcnKXtlcnJvcignUHJvZmlsZXIgbXVzdCBzcGVjaWZ5IGFuIFwiaWRcIiBvZiB0eXBlIGBzdHJpbmdgIGFzIGEgcHJvcC4gUmVjZWl2ZWQgdGhlIHR5cGUgYCVzYCBpbnN0ZWFkLicsdHlwZW9mIHBlbmRpbmdQcm9wcy5pZCk7fX12YXIgZmliZXI9Y3JlYXRlRmliZXIoUHJvZmlsZXIscGVuZGluZ1Byb3BzLGtleSxtb2RlfFByb2ZpbGVNb2RlKTtmaWJlci5lbGVtZW50VHlwZT1SRUFDVF9QUk9GSUxFUl9UWVBFO2ZpYmVyLmxhbmVzPWxhbmVzO3tmaWJlci5zdGF0ZU5vZGU9e2VmZmVjdER1cmF0aW9uOjAscGFzc2l2ZUVmZmVjdER1cmF0aW9uOjB9O31yZXR1cm4gZmliZXI7fWZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlKHBlbmRpbmdQcm9wcyxtb2RlLGxhbmVzLGtleSl7dmFyIGZpYmVyPWNyZWF0ZUZpYmVyKFN1c3BlbnNlQ29tcG9uZW50LHBlbmRpbmdQcm9wcyxrZXksbW9kZSk7ZmliZXIuZWxlbWVudFR5cGU9UkVBQ1RfU1VTUEVOU0VfVFlQRTtmaWJlci5sYW5lcz1sYW5lcztyZXR1cm4gZmliZXI7fWZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdChwZW5kaW5nUHJvcHMsbW9kZSxsYW5lcyxrZXkpe3ZhciBmaWJlcj1jcmVhdGVGaWJlcihTdXNwZW5zZUxpc3RDb21wb25lbnQscGVuZGluZ1Byb3BzLGtleSxtb2RlKTtmaWJlci5lbGVtZW50VHlwZT1SRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU7ZmliZXIubGFuZXM9bGFuZXM7cmV0dXJuIGZpYmVyO31mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLG1vZGUsbGFuZXMsa2V5KXt2YXIgZmliZXI9Y3JlYXRlRmliZXIoT2Zmc2NyZWVuQ29tcG9uZW50LHBlbmRpbmdQcm9wcyxrZXksbW9kZSk7ZmliZXIuZWxlbWVudFR5cGU9UkVBQ1RfT0ZGU0NSRUVOX1RZUEU7ZmliZXIubGFuZXM9bGFuZXM7dmFyIHByaW1hcnlDaGlsZEluc3RhbmNlPXtpc0hpZGRlbjpmYWxzZX07ZmliZXIuc3RhdGVOb2RlPXByaW1hcnlDaGlsZEluc3RhbmNlO3JldHVybiBmaWJlcjt9ZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LG1vZGUsbGFuZXMpe3ZhciBmaWJlcj1jcmVhdGVGaWJlcihIb3N0VGV4dCxjb250ZW50LG51bGwsbW9kZSk7ZmliZXIubGFuZXM9bGFuZXM7cmV0dXJuIGZpYmVyO31mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpe3ZhciBmaWJlcj1jcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LG51bGwsbnVsbCxOb01vZGUpO2ZpYmVyLmVsZW1lbnRUeXBlPSdERUxFVEVEJztyZXR1cm4gZmliZXI7fWZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbURlaHlkcmF0ZWRGcmFnbWVudChkZWh5ZHJhdGVkTm9kZSl7dmFyIGZpYmVyPWNyZWF0ZUZpYmVyKERlaHlkcmF0ZWRGcmFnbWVudCxudWxsLG51bGwsTm9Nb2RlKTtmaWJlci5zdGF0ZU5vZGU9ZGVoeWRyYXRlZE5vZGU7cmV0dXJuIGZpYmVyO31mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLG1vZGUsbGFuZXMpe3ZhciBwZW5kaW5nUHJvcHM9cG9ydGFsLmNoaWxkcmVuIT09bnVsbD9wb3J0YWwuY2hpbGRyZW46W107dmFyIGZpYmVyPWNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwscGVuZGluZ1Byb3BzLHBvcnRhbC5rZXksbW9kZSk7ZmliZXIubGFuZXM9bGFuZXM7ZmliZXIuc3RhdGVOb2RlPXtjb250YWluZXJJbmZvOnBvcnRhbC5jb250YWluZXJJbmZvLHBlbmRpbmdDaGlsZHJlbjpudWxsLC8vIFVzZWQgYnkgcGVyc2lzdGVudCB1cGRhdGVzXG5pbXBsZW1lbnRhdGlvbjpwb3J0YWwuaW1wbGVtZW50YXRpb259O3JldHVybiBmaWJlcjt9Ly8gVXNlZCBmb3Igc3Rhc2hpbmcgV0lQIHByb3BlcnRpZXMgdG8gcmVwbGF5IGZhaWxlZCB3b3JrIGluIERFVi5cbmZ1bmN0aW9uIGFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWKHRhcmdldCxzb3VyY2Upe2lmKHRhcmdldD09PW51bGwpey8vIFRoaXMgRmliZXIncyBpbml0aWFsIHByb3BlcnRpZXMgd2lsbCBhbHdheXMgYmUgb3ZlcndyaXR0ZW4uXG4vLyBXZSBvbmx5IHVzZSBhIEZpYmVyIHRvIGVuc3VyZSB0aGUgc2FtZSBoaWRkZW4gY2xhc3Mgc28gREVWIGlzbid0IHNsb3cuXG50YXJnZXQ9Y3JlYXRlRmliZXIoSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCxudWxsLG51bGwsTm9Nb2RlKTt9Ly8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHdyaXR0ZW4gYXMgYSBsaXN0IG9mIGFsbCBwcm9wZXJ0aWVzLlxuLy8gV2UgdHJpZWQgdG8gdXNlIE9iamVjdC5hc3NpZ24oKSBpbnN0ZWFkIGJ1dCB0aGlzIGlzIGNhbGxlZCBpblxuLy8gdGhlIGhvdHRlc3QgcGF0aCwgYW5kIE9iamVjdC5hc3NpZ24oKSB3YXMgdG9vIHNsb3c6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyNTAyXG4vLyBUaGlzIGNvZGUgaXMgREVWLW9ubHkgc28gc2l6ZSBpcyBub3QgYSBjb25jZXJuLlxudGFyZ2V0LnRhZz1zb3VyY2UudGFnO3RhcmdldC5rZXk9c291cmNlLmtleTt0YXJnZXQuZWxlbWVudFR5cGU9c291cmNlLmVsZW1lbnRUeXBlO3RhcmdldC50eXBlPXNvdXJjZS50eXBlO3RhcmdldC5zdGF0ZU5vZGU9c291cmNlLnN0YXRlTm9kZTt0YXJnZXQucmV0dXJuPXNvdXJjZS5yZXR1cm47dGFyZ2V0LmNoaWxkPXNvdXJjZS5jaGlsZDt0YXJnZXQuc2libGluZz1zb3VyY2Uuc2libGluZzt0YXJnZXQuaW5kZXg9c291cmNlLmluZGV4O3RhcmdldC5yZWY9c291cmNlLnJlZjt0YXJnZXQucGVuZGluZ1Byb3BzPXNvdXJjZS5wZW5kaW5nUHJvcHM7dGFyZ2V0Lm1lbW9pemVkUHJvcHM9c291cmNlLm1lbW9pemVkUHJvcHM7dGFyZ2V0LnVwZGF0ZVF1ZXVlPXNvdXJjZS51cGRhdGVRdWV1ZTt0YXJnZXQubWVtb2l6ZWRTdGF0ZT1zb3VyY2UubWVtb2l6ZWRTdGF0ZTt0YXJnZXQuZGVwZW5kZW5jaWVzPXNvdXJjZS5kZXBlbmRlbmNpZXM7dGFyZ2V0Lm1vZGU9c291cmNlLm1vZGU7dGFyZ2V0LmZsYWdzPXNvdXJjZS5mbGFnczt0YXJnZXQuc3VidHJlZUZsYWdzPXNvdXJjZS5zdWJ0cmVlRmxhZ3M7dGFyZ2V0LmRlbGV0aW9ucz1zb3VyY2UuZGVsZXRpb25zO3RhcmdldC5sYW5lcz1zb3VyY2UubGFuZXM7dGFyZ2V0LmNoaWxkTGFuZXM9c291cmNlLmNoaWxkTGFuZXM7dGFyZ2V0LmFsdGVybmF0ZT1zb3VyY2UuYWx0ZXJuYXRlO3t0YXJnZXQuYWN0dWFsRHVyYXRpb249c291cmNlLmFjdHVhbER1cmF0aW9uO3RhcmdldC5hY3R1YWxTdGFydFRpbWU9c291cmNlLmFjdHVhbFN0YXJ0VGltZTt0YXJnZXQuc2VsZkJhc2VEdXJhdGlvbj1zb3VyY2Uuc2VsZkJhc2VEdXJhdGlvbjt0YXJnZXQudHJlZUJhc2VEdXJhdGlvbj1zb3VyY2UudHJlZUJhc2VEdXJhdGlvbjt9dGFyZ2V0Ll9kZWJ1Z1NvdXJjZT1zb3VyY2UuX2RlYnVnU291cmNlO3RhcmdldC5fZGVidWdPd25lcj1zb3VyY2UuX2RlYnVnT3duZXI7dGFyZ2V0Ll9kZWJ1Z05lZWRzUmVtb3VudD1zb3VyY2UuX2RlYnVnTmVlZHNSZW1vdW50O3RhcmdldC5fZGVidWdIb29rVHlwZXM9c291cmNlLl9kZWJ1Z0hvb2tUeXBlcztyZXR1cm4gdGFyZ2V0O31mdW5jdGlvbiBGaWJlclJvb3ROb2RlKGNvbnRhaW5lckluZm8sdGFnLGh5ZHJhdGUsaWRlbnRpZmllclByZWZpeCxvblJlY292ZXJhYmxlRXJyb3Ipe3RoaXMudGFnPXRhZzt0aGlzLmNvbnRhaW5lckluZm89Y29udGFpbmVySW5mbzt0aGlzLnBlbmRpbmdDaGlsZHJlbj1udWxsO3RoaXMuY3VycmVudD1udWxsO3RoaXMucGluZ0NhY2hlPW51bGw7dGhpcy5maW5pc2hlZFdvcms9bnVsbDt0aGlzLnRpbWVvdXRIYW5kbGU9bm9UaW1lb3V0O3RoaXMuY29udGV4dD1udWxsO3RoaXMucGVuZGluZ0NvbnRleHQ9bnVsbDt0aGlzLmNhbGxiYWNrTm9kZT1udWxsO3RoaXMuY2FsbGJhY2tQcmlvcml0eT1Ob0xhbmU7dGhpcy5ldmVudFRpbWVzPWNyZWF0ZUxhbmVNYXAoTm9MYW5lcyk7dGhpcy5leHBpcmF0aW9uVGltZXM9Y3JlYXRlTGFuZU1hcChOb1RpbWVzdGFtcCk7dGhpcy5wZW5kaW5nTGFuZXM9Tm9MYW5lczt0aGlzLnN1c3BlbmRlZExhbmVzPU5vTGFuZXM7dGhpcy5waW5nZWRMYW5lcz1Ob0xhbmVzO3RoaXMuZXhwaXJlZExhbmVzPU5vTGFuZXM7dGhpcy5tdXRhYmxlUmVhZExhbmVzPU5vTGFuZXM7dGhpcy5maW5pc2hlZExhbmVzPU5vTGFuZXM7dGhpcy5lbnRhbmdsZWRMYW5lcz1Ob0xhbmVzO3RoaXMuZW50YW5nbGVtZW50cz1jcmVhdGVMYW5lTWFwKE5vTGFuZXMpO3RoaXMuaWRlbnRpZmllclByZWZpeD1pZGVudGlmaWVyUHJlZml4O3RoaXMub25SZWNvdmVyYWJsZUVycm9yPW9uUmVjb3ZlcmFibGVFcnJvcjt7dGhpcy5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhPW51bGw7fXt0aGlzLmVmZmVjdER1cmF0aW9uPTA7dGhpcy5wYXNzaXZlRWZmZWN0RHVyYXRpb249MDt9e3RoaXMubWVtb2l6ZWRVcGRhdGVycz1uZXcgU2V0KCk7dmFyIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXA9dGhpcy5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwPVtdO2Zvcih2YXIgX2k9MDtfaTxUb3RhbExhbmVzO19pKyspe3BlbmRpbmdVcGRhdGVyc0xhbmVNYXAucHVzaChuZXcgU2V0KCkpO319e3N3aXRjaCh0YWcpe2Nhc2UgQ29uY3VycmVudFJvb3Q6dGhpcy5fZGVidWdSb290VHlwZT1oeWRyYXRlPydoeWRyYXRlUm9vdCgpJzonY3JlYXRlUm9vdCgpJzticmVhaztjYXNlIExlZ2FjeVJvb3Q6dGhpcy5fZGVidWdSb290VHlwZT1oeWRyYXRlPydoeWRyYXRlKCknOidyZW5kZXIoKSc7YnJlYWs7fX19ZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sdGFnLGh5ZHJhdGUsaW5pdGlhbENoaWxkcmVuLGh5ZHJhdGlvbkNhbGxiYWNrcyxpc1N0cmljdE1vZGUsY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwvLyBUT0RPOiBXZSBoYXZlIHNldmVyYWwgb2YgdGhlc2UgYXJndW1lbnRzIHRoYXQgYXJlIGNvbmNlcHR1YWxseSBwYXJ0IG9mIHRoZVxuLy8gaG9zdCBjb25maWcsIGJ1dCBiZWNhdXNlIHRoZXkgYXJlIHBhc3NlZCBpbiBhdCBydW50aW1lLCB3ZSBoYXZlIHRvIHRocmVhZFxuLy8gdGhlbSB0aHJvdWdoIHRoZSByb290IGNvbnN0cnVjdG9yLiBQZXJoYXBzIHdlIHNob3VsZCBwdXQgdGhlbSBhbGwgaW50byBhXG4vLyBzaW5nbGUgdHlwZSwgbGlrZSBhIER5bmFtaWNIb3N0Q29uZmlnIHRoYXQgaXMgZGVmaW5lZCBieSB0aGUgcmVuZGVyZXIuXG5pZGVudGlmaWVyUHJlZml4LG9uUmVjb3ZlcmFibGVFcnJvcix0cmFuc2l0aW9uQ2FsbGJhY2tzKXt2YXIgcm9vdD1uZXcgRmliZXJSb290Tm9kZShjb250YWluZXJJbmZvLHRhZyxoeWRyYXRlLGlkZW50aWZpZXJQcmVmaXgsb25SZWNvdmVyYWJsZUVycm9yKTsvLyBzdGF0ZU5vZGUgaXMgYW55LlxudmFyIHVuaW5pdGlhbGl6ZWRGaWJlcj1jcmVhdGVIb3N0Um9vdEZpYmVyKHRhZyxpc1N0cmljdE1vZGUpO3Jvb3QuY3VycmVudD11bmluaXRpYWxpemVkRmliZXI7dW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZT1yb290O3t2YXIgX2luaXRpYWxTdGF0ZT17ZWxlbWVudDppbml0aWFsQ2hpbGRyZW4saXNEZWh5ZHJhdGVkOmh5ZHJhdGUsY2FjaGU6bnVsbCwvLyBub3QgZW5hYmxlZCB5ZXRcbnRyYW5zaXRpb25zOm51bGwscGVuZGluZ1N1c3BlbnNlQm91bmRhcmllczpudWxsfTt1bmluaXRpYWxpemVkRmliZXIubWVtb2l6ZWRTdGF0ZT1faW5pdGlhbFN0YXRlO31pbml0aWFsaXplVXBkYXRlUXVldWUodW5pbml0aWFsaXplZEZpYmVyKTtyZXR1cm4gcm9vdDt9dmFyIFJlYWN0VmVyc2lvbj0nMTguMy4xJztmdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sY29udGFpbmVySW5mbywvLyBUT0RPOiBmaWd1cmUgb3V0IHRoZSBBUEkgZm9yIGNyb3NzLXJlbmRlcmVyIGltcGxlbWVudGF0aW9uLlxuaW1wbGVtZW50YXRpb24pe3ZhciBrZXk9YXJndW1lbnRzLmxlbmd0aD4zJiZhcmd1bWVudHNbM10hPT11bmRlZmluZWQ/YXJndW1lbnRzWzNdOm51bGw7e2NoZWNrS2V5U3RyaW5nQ29lcmNpb24oa2V5KTt9cmV0dXJuey8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiQkdHlwZW9mOlJFQUNUX1BPUlRBTF9UWVBFLGtleTprZXk9PW51bGw/bnVsbDonJytrZXksY2hpbGRyZW46Y2hpbGRyZW4sY29udGFpbmVySW5mbzpjb250YWluZXJJbmZvLGltcGxlbWVudGF0aW9uOmltcGxlbWVudGF0aW9ufTt9dmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXM7dmFyIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlO3tkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzPWZhbHNlO2RpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlPXt9O31mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpe2lmKCFwYXJlbnRDb21wb25lbnQpe3JldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7fXZhciBmaWJlcj1nZXQocGFyZW50Q29tcG9uZW50KTt2YXIgcGFyZW50Q29udGV4dD1maW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcik7aWYoZmliZXIudGFnPT09Q2xhc3NDb21wb25lbnQpe3ZhciBDb21wb25lbnQ9ZmliZXIudHlwZTtpZihpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKXtyZXR1cm4gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlcixDb21wb25lbnQscGFyZW50Q29udGV4dCk7fX1yZXR1cm4gcGFyZW50Q29udGV4dDt9ZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nKGNvbXBvbmVudCxtZXRob2ROYW1lKXt7dmFyIGZpYmVyPWdldChjb21wb25lbnQpO2lmKGZpYmVyPT09dW5kZWZpbmVkKXtpZih0eXBlb2YgY29tcG9uZW50LnJlbmRlcj09PSdmdW5jdGlvbicpe3Rocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO31lbHNle3ZhciBrZXlzPU9iamVjdC5rZXlzKGNvbXBvbmVudCkuam9pbignLCcpO3Rocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IGFwcGVhcnMgdG8gbm90IGJlIGEgUmVhY3RDb21wb25lbnQuIEtleXM6IFwiK2tleXMpO319dmFyIGhvc3RGaWJlcj1maW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7aWYoaG9zdEZpYmVyPT09bnVsbCl7cmV0dXJuIG51bGw7fWlmKGhvc3RGaWJlci5tb2RlJlN0cmljdExlZ2FjeU1vZGUpe3ZhciBjb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpfHwnQ29tcG9uZW50JztpZighZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0pe2RpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdPXRydWU7dmFyIHByZXZpb3VzRmliZXI9Y3VycmVudDt0cnl7c2V0Q3VycmVudEZpYmVyKGhvc3RGaWJlcik7aWYoZmliZXIubW9kZSZTdHJpY3RMZWdhY3lNb2RlKXtlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnKyclcyB3YXMgcGFzc2VkIGFuIGluc3RhbmNlIG9mICVzIHdoaWNoIGlzIGluc2lkZSBTdHJpY3RNb2RlLiAnKydJbnN0ZWFkLCBhZGQgYSByZWYgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gcmVmZXJlbmNlLiAnKydMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGUnLG1ldGhvZE5hbWUsbWV0aG9kTmFtZSxjb21wb25lbnROYW1lKTt9ZWxzZXtlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnKyclcyB3YXMgcGFzc2VkIGFuIGluc3RhbmNlIG9mICVzIHdoaWNoIHJlbmRlcnMgU3RyaWN0TW9kZSBjaGlsZHJlbi4gJysnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJysnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnKydodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtZmluZC1ub2RlJyxtZXRob2ROYW1lLG1ldGhvZE5hbWUsY29tcG9uZW50TmFtZSk7fX1maW5hbGx5ey8vIElkZWFsbHkgdGhpcyBzaG91bGQgcmVzZXQgdG8gcHJldmlvdXMgYnV0IHRoaXMgc2hvdWxkbid0IGJlIGNhbGxlZCBpblxuLy8gcmVuZGVyIGFuZCB0aGVyZSdzIGFub3RoZXIgd2FybmluZyBmb3IgdGhhdCBhbnl3YXkuXG5pZihwcmV2aW91c0ZpYmVyKXtzZXRDdXJyZW50RmliZXIocHJldmlvdXNGaWJlcik7fWVsc2V7cmVzZXRDdXJyZW50RmliZXIoKTt9fX19cmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7fX1mdW5jdGlvbiBjcmVhdGVDb250YWluZXIoY29udGFpbmVySW5mbyx0YWcsaHlkcmF0aW9uQ2FsbGJhY2tzLGlzU3RyaWN0TW9kZSxjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLGlkZW50aWZpZXJQcmVmaXgsb25SZWNvdmVyYWJsZUVycm9yLHRyYW5zaXRpb25DYWxsYmFja3Mpe3ZhciBoeWRyYXRlPWZhbHNlO3ZhciBpbml0aWFsQ2hpbGRyZW49bnVsbDtyZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sdGFnLGh5ZHJhdGUsaW5pdGlhbENoaWxkcmVuLGh5ZHJhdGlvbkNhbGxiYWNrcyxpc1N0cmljdE1vZGUsY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSxpZGVudGlmaWVyUHJlZml4LG9uUmVjb3ZlcmFibGVFcnJvcik7fWZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lcihpbml0aWFsQ2hpbGRyZW4sLy8gVE9ETzogUmVtb3ZlIGBjYWxsYmFja2Agd2hlbiB3ZSBkZWxldGUgbGVnYWN5IG1vZGUuXG5jYWxsYmFjayxjb250YWluZXJJbmZvLHRhZyxoeWRyYXRpb25DYWxsYmFja3MsaXNTdHJpY3RNb2RlLGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsaWRlbnRpZmllclByZWZpeCxvblJlY292ZXJhYmxlRXJyb3IsdHJhbnNpdGlvbkNhbGxiYWNrcyl7dmFyIGh5ZHJhdGU9dHJ1ZTt2YXIgcm9vdD1jcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbyx0YWcsaHlkcmF0ZSxpbml0aWFsQ2hpbGRyZW4saHlkcmF0aW9uQ2FsbGJhY2tzLGlzU3RyaWN0TW9kZSxjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLGlkZW50aWZpZXJQcmVmaXgsb25SZWNvdmVyYWJsZUVycm9yKTsvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gRmliZXJSb290IGNvbnN0cnVjdG9yXG5yb290LmNvbnRleHQ9Z2V0Q29udGV4dEZvclN1YnRyZWUobnVsbCk7Ly8gU2NoZWR1bGUgdGhlIGluaXRpYWwgcmVuZGVyLiBJbiBhIGh5ZHJhdGlvbiByb290LCB0aGlzIGlzIGRpZmZlcmVudCBmcm9tXG4vLyBhIHJlZ3VsYXIgdXBkYXRlIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIG11c3QgbWF0Y2ggd2FzIHdhcyByZW5kZXJlZFxuLy8gb24gdGhlIHNlcnZlci5cbi8vIE5PVEU6IFRoaXMgdXBkYXRlIGludGVudGlvbmFsbHkgZG9lc24ndCBoYXZlIGEgcGF5bG9hZC4gV2UncmUgb25seSB1c2luZ1xuLy8gdGhlIHVwZGF0ZSB0byBzY2hlZHVsZSB3b3JrIG9uIHRoZSByb290IGZpYmVyIChhbmQsIGZvciBsZWdhY3kgcm9vdHMsIHRvXG4vLyBlbnF1ZXVlIHRoZSBjYWxsYmFjayBpZiBvbmUgaXMgcHJvdmlkZWQpLlxudmFyIGN1cnJlbnQ9cm9vdC5jdXJyZW50O3ZhciBldmVudFRpbWU9cmVxdWVzdEV2ZW50VGltZSgpO3ZhciBsYW5lPXJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQpO3ZhciB1cGRhdGU9Y3JlYXRlVXBkYXRlKGV2ZW50VGltZSxsYW5lKTt1cGRhdGUuY2FsbGJhY2s9Y2FsbGJhY2shPT11bmRlZmluZWQmJmNhbGxiYWNrIT09bnVsbD9jYWxsYmFjazpudWxsO2VucXVldWVVcGRhdGUoY3VycmVudCx1cGRhdGUsbGFuZSk7c2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290KHJvb3QsbGFuZSxldmVudFRpbWUpO3JldHVybiByb290O31mdW5jdGlvbiB1cGRhdGVDb250YWluZXIoZWxlbWVudCxjb250YWluZXIscGFyZW50Q29tcG9uZW50LGNhbGxiYWNrKXt7b25TY2hlZHVsZVJvb3QoY29udGFpbmVyLGVsZW1lbnQpO312YXIgY3VycmVudCQxPWNvbnRhaW5lci5jdXJyZW50O3ZhciBldmVudFRpbWU9cmVxdWVzdEV2ZW50VGltZSgpO3ZhciBsYW5lPXJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQkMSk7e21hcmtSZW5kZXJTY2hlZHVsZWQobGFuZSk7fXZhciBjb250ZXh0PWdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7aWYoY29udGFpbmVyLmNvbnRleHQ9PT1udWxsKXtjb250YWluZXIuY29udGV4dD1jb250ZXh0O31lbHNle2NvbnRhaW5lci5wZW5kaW5nQ29udGV4dD1jb250ZXh0O317aWYoaXNSZW5kZXJpbmcmJmN1cnJlbnQhPT1udWxsJiYhZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyl7ZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcz10cnVlO2Vycm9yKCdSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgJysndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcrJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJysnQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnQpfHwnVW5rbm93bicpO319dmFyIHVwZGF0ZT1jcmVhdGVVcGRhdGUoZXZlbnRUaW1lLGxhbmUpOy8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbi8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cbnVwZGF0ZS5wYXlsb2FkPXtlbGVtZW50OmVsZW1lbnR9O2NhbGxiYWNrPWNhbGxiYWNrPT09dW5kZWZpbmVkP251bGw6Y2FsbGJhY2s7aWYoY2FsbGJhY2shPT1udWxsKXt7aWYodHlwZW9mIGNhbGxiYWNrIT09J2Z1bmN0aW9uJyl7ZXJyb3IoJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJysnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsY2FsbGJhY2spO319dXBkYXRlLmNhbGxiYWNrPWNhbGxiYWNrO312YXIgcm9vdD1lbnF1ZXVlVXBkYXRlKGN1cnJlbnQkMSx1cGRhdGUsbGFuZSk7aWYocm9vdCE9PW51bGwpe3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGN1cnJlbnQkMSxsYW5lLGV2ZW50VGltZSk7ZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LGN1cnJlbnQkMSxsYW5lKTt9cmV0dXJuIGxhbmU7fWZ1bmN0aW9uIGdldFB1YmxpY1Jvb3RJbnN0YW5jZShjb250YWluZXIpe3ZhciBjb250YWluZXJGaWJlcj1jb250YWluZXIuY3VycmVudDtpZighY29udGFpbmVyRmliZXIuY2hpbGQpe3JldHVybiBudWxsO31zd2l0Y2goY29udGFpbmVyRmliZXIuY2hpbGQudGFnKXtjYXNlIEhvc3RDb21wb25lbnQ6cmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZSk7ZGVmYXVsdDpyZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO319ZnVuY3Rpb24gYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uJDEoZmliZXIpe3N3aXRjaChmaWJlci50YWcpe2Nhc2UgSG9zdFJvb3Q6e3ZhciByb290PWZpYmVyLnN0YXRlTm9kZTtpZihpc1Jvb3REZWh5ZHJhdGVkKHJvb3QpKXsvLyBGbHVzaCB0aGUgZmlyc3Qgc2NoZWR1bGVkIFwidXBkYXRlXCIuXG52YXIgbGFuZXM9Z2V0SGlnaGVzdFByaW9yaXR5UGVuZGluZ0xhbmVzKHJvb3QpO2ZsdXNoUm9vdChyb290LGxhbmVzKTt9YnJlYWs7fWNhc2UgU3VzcGVuc2VDb21wb25lbnQ6e2ZsdXNoU3luYyhmdW5jdGlvbigpe3ZhciByb290PWVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlcixTeW5jTGFuZSk7aWYocm9vdCE9PW51bGwpe3ZhciBldmVudFRpbWU9cmVxdWVzdEV2ZW50VGltZSgpO3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLFN5bmNMYW5lLGV2ZW50VGltZSk7fX0pOy8vIElmIHdlJ3JlIHN0aWxsIGJsb2NrZWQgYWZ0ZXIgdGhpcywgd2UgbmVlZCB0byBpbmNyZWFzZVxuLy8gdGhlIHByaW9yaXR5IG9mIGFueSBwcm9taXNlcyByZXNvbHZpbmcgd2l0aGluIHRoaXNcbi8vIGJvdW5kYXJ5IHNvIHRoYXQgdGhleSBuZXh0IGF0dGVtcHQgYWxzbyBoYXMgaGlnaGVyIHByaS5cbnZhciByZXRyeUxhbmU9U3luY0xhbmU7bWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIscmV0cnlMYW5lKTticmVhazt9fX1mdW5jdGlvbiBtYXJrUmV0cnlMYW5lSW1wbChmaWJlcixyZXRyeUxhbmUpe3ZhciBzdXNwZW5zZVN0YXRlPWZpYmVyLm1lbW9pemVkU3RhdGU7aWYoc3VzcGVuc2VTdGF0ZSE9PW51bGwmJnN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCE9PW51bGwpe3N1c3BlbnNlU3RhdGUucmV0cnlMYW5lPWhpZ2hlclByaW9yaXR5TGFuZShzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSxyZXRyeUxhbmUpO319Ly8gSW5jcmVhc2VzIHRoZSBwcmlvcml0eSBvZiB0aGVuYWJsZXMgd2hlbiB0aGV5IHJlc29sdmUgd2l0aGluIHRoaXMgYm91bmRhcnkuXG5mdW5jdGlvbiBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlcixyZXRyeUxhbmUpe21hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLHJldHJ5TGFuZSk7dmFyIGFsdGVybmF0ZT1maWJlci5hbHRlcm5hdGU7aWYoYWx0ZXJuYXRlKXttYXJrUmV0cnlMYW5lSW1wbChhbHRlcm5hdGUscmV0cnlMYW5lKTt9fWZ1bmN0aW9uIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uJDEoZmliZXIpe2lmKGZpYmVyLnRhZyE9PVN1c3BlbnNlQ29tcG9uZW50KXsvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuLy8gdGhlaXIgcHJpb3JpdHkgYW5kIHRoZXkgc2hvdWxkIG5vdCBzdXNwZW5kIG9uIEkvTyxcbi8vIHNpbmNlIHlvdSBoYXZlIHRvIHdyYXAgYW55dGhpbmcgdGhhdCBtaWdodCBzdXNwZW5kIGluXG4vLyBTdXNwZW5zZS5cbnJldHVybjt9dmFyIGxhbmU9U2VsZWN0aXZlSHlkcmF0aW9uTGFuZTt2YXIgcm9vdD1lbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsbGFuZSk7aWYocm9vdCE9PW51bGwpe3ZhciBldmVudFRpbWU9cmVxdWVzdEV2ZW50VGltZSgpO3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLGxhbmUsZXZlbnRUaW1lKTt9bWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsbGFuZSk7fWZ1bmN0aW9uIGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSQxKGZpYmVyKXtpZihmaWJlci50YWchPT1TdXNwZW5zZUNvbXBvbmVudCl7Ly8gV2UgaWdub3JlIEhvc3RSb290cyBoZXJlIGJlY2F1c2Ugd2UgY2FuJ3QgaW5jcmVhc2Vcbi8vIHRoZWlyIHByaW9yaXR5IG90aGVyIHRoYW4gc3luY2hyb25vdXNseSBmbHVzaCBpdC5cbnJldHVybjt9dmFyIGxhbmU9cmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO3ZhciByb290PWVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlcixsYW5lKTtpZihyb290IT09bnVsbCl7dmFyIGV2ZW50VGltZT1yZXF1ZXN0RXZlbnRUaW1lKCk7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsbGFuZSxldmVudFRpbWUpO31tYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlcixsYW5lKTt9ZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoZmliZXIpe3ZhciBob3N0RmliZXI9ZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtpZihob3N0RmliZXI9PT1udWxsKXtyZXR1cm4gbnVsbDt9cmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7fXZhciBzaG91bGRFcnJvckltcGw9ZnVuY3Rpb24oZmliZXIpe3JldHVybiBudWxsO307ZnVuY3Rpb24gc2hvdWxkRXJyb3IoZmliZXIpe3JldHVybiBzaG91bGRFcnJvckltcGwoZmliZXIpO312YXIgc2hvdWxkU3VzcGVuZEltcGw9ZnVuY3Rpb24oZmliZXIpe3JldHVybiBmYWxzZTt9O2Z1bmN0aW9uIHNob3VsZFN1c3BlbmQoZmliZXIpe3JldHVybiBzaG91bGRTdXNwZW5kSW1wbChmaWJlcik7fXZhciBvdmVycmlkZUhvb2tTdGF0ZT1udWxsO3ZhciBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGg9bnVsbDt2YXIgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoPW51bGw7dmFyIG92ZXJyaWRlUHJvcHM9bnVsbDt2YXIgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGg9bnVsbDt2YXIgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGg9bnVsbDt2YXIgc2NoZWR1bGVVcGRhdGU9bnVsbDt2YXIgc2V0RXJyb3JIYW5kbGVyPW51bGw7dmFyIHNldFN1c3BlbnNlSGFuZGxlcj1udWxsO3t2YXIgY29weVdpdGhEZWxldGVJbXBsPWZ1bmN0aW9uKG9iaixwYXRoLGluZGV4KXt2YXIga2V5PXBhdGhbaW5kZXhdO3ZhciB1cGRhdGVkPWlzQXJyYXkob2JqKT9vYmouc2xpY2UoKTphc3NpZ24oe30sb2JqKTtpZihpbmRleCsxPT09cGF0aC5sZW5ndGgpe2lmKGlzQXJyYXkodXBkYXRlZCkpe3VwZGF0ZWQuc3BsaWNlKGtleSwxKTt9ZWxzZXtkZWxldGUgdXBkYXRlZFtrZXldO31yZXR1cm4gdXBkYXRlZDt9Ly8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxudXBkYXRlZFtrZXldPWNvcHlXaXRoRGVsZXRlSW1wbChvYmpba2V5XSxwYXRoLGluZGV4KzEpO3JldHVybiB1cGRhdGVkO307dmFyIGNvcHlXaXRoRGVsZXRlPWZ1bmN0aW9uKG9iaixwYXRoKXtyZXR1cm4gY29weVdpdGhEZWxldGVJbXBsKG9iaixwYXRoLDApO307dmFyIGNvcHlXaXRoUmVuYW1lSW1wbD1mdW5jdGlvbihvYmosb2xkUGF0aCxuZXdQYXRoLGluZGV4KXt2YXIgb2xkS2V5PW9sZFBhdGhbaW5kZXhdO3ZhciB1cGRhdGVkPWlzQXJyYXkob2JqKT9vYmouc2xpY2UoKTphc3NpZ24oe30sb2JqKTtpZihpbmRleCsxPT09b2xkUGF0aC5sZW5ndGgpe3ZhciBuZXdLZXk9bmV3UGF0aFtpbmRleF07Ly8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxudXBkYXRlZFtuZXdLZXldPXVwZGF0ZWRbb2xkS2V5XTtpZihpc0FycmF5KHVwZGF0ZWQpKXt1cGRhdGVkLnNwbGljZShvbGRLZXksMSk7fWVsc2V7ZGVsZXRlIHVwZGF0ZWRbb2xkS2V5XTt9fWVsc2V7Ly8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxudXBkYXRlZFtvbGRLZXldPWNvcHlXaXRoUmVuYW1lSW1wbCgvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5vYmpbb2xkS2V5XSxvbGRQYXRoLG5ld1BhdGgsaW5kZXgrMSk7fXJldHVybiB1cGRhdGVkO307dmFyIGNvcHlXaXRoUmVuYW1lPWZ1bmN0aW9uKG9iaixvbGRQYXRoLG5ld1BhdGgpe2lmKG9sZFBhdGgubGVuZ3RoIT09bmV3UGF0aC5sZW5ndGgpe3dhcm4oJ2NvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyBvZiB0aGUgc2FtZSBsZW5ndGgnKTtyZXR1cm47fWVsc2V7Zm9yKHZhciBpPTA7aTxuZXdQYXRoLmxlbmd0aC0xO2krKyl7aWYob2xkUGF0aFtpXSE9PW5ld1BhdGhbaV0pe3dhcm4oJ2NvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyB0byBiZSB0aGUgc2FtZSBleGNlcHQgZm9yIHRoZSBkZWVwZXN0IGtleScpO3JldHVybjt9fX1yZXR1cm4gY29weVdpdGhSZW5hbWVJbXBsKG9iaixvbGRQYXRoLG5ld1BhdGgsMCk7fTt2YXIgY29weVdpdGhTZXRJbXBsPWZ1bmN0aW9uKG9iaixwYXRoLGluZGV4LHZhbHVlKXtpZihpbmRleD49cGF0aC5sZW5ndGgpe3JldHVybiB2YWx1ZTt9dmFyIGtleT1wYXRoW2luZGV4XTt2YXIgdXBkYXRlZD1pc0FycmF5KG9iaik/b2JqLnNsaWNlKCk6YXNzaWduKHt9LG9iaik7Ly8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxudXBkYXRlZFtrZXldPWNvcHlXaXRoU2V0SW1wbChvYmpba2V5XSxwYXRoLGluZGV4KzEsdmFsdWUpO3JldHVybiB1cGRhdGVkO307dmFyIGNvcHlXaXRoU2V0PWZ1bmN0aW9uKG9iaixwYXRoLHZhbHVlKXtyZXR1cm4gY29weVdpdGhTZXRJbXBsKG9iaixwYXRoLDAsdmFsdWUpO307dmFyIGZpbmRIb29rPWZ1bmN0aW9uKGZpYmVyLGlkKXsvLyBGb3Igbm93LCB0aGUgXCJpZFwiIG9mIHN0YXRlZnVsIGhvb2tzIGlzIGp1c3QgdGhlIHN0YXRlZnVsIGhvb2sgaW5kZXguXG4vLyBUaGlzIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSB3aXRoIGUuZy4gbmVzdGVkIGhvb2tzLlxudmFyIGN1cnJlbnRIb29rPWZpYmVyLm1lbW9pemVkU3RhdGU7d2hpbGUoY3VycmVudEhvb2shPT1udWxsJiZpZD4wKXtjdXJyZW50SG9vaz1jdXJyZW50SG9vay5uZXh0O2lkLS07fXJldHVybiBjdXJyZW50SG9vazt9Oy8vIFN1cHBvcnQgRGV2VG9vbHMgZWRpdGFibGUgdmFsdWVzIGZvciB1c2VTdGF0ZSBhbmQgdXNlUmVkdWNlci5cbm92ZXJyaWRlSG9va1N0YXRlPWZ1bmN0aW9uKGZpYmVyLGlkLHBhdGgsdmFsdWUpe3ZhciBob29rPWZpbmRIb29rKGZpYmVyLGlkKTtpZihob29rIT09bnVsbCl7dmFyIG5ld1N0YXRlPWNvcHlXaXRoU2V0KGhvb2subWVtb2l6ZWRTdGF0ZSxwYXRoLHZhbHVlKTtob29rLm1lbW9pemVkU3RhdGU9bmV3U3RhdGU7aG9vay5iYXNlU3RhdGU9bmV3U3RhdGU7Ly8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4vLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbi8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cbmZpYmVyLm1lbW9pemVkUHJvcHM9YXNzaWduKHt9LGZpYmVyLm1lbW9pemVkUHJvcHMpO3ZhciByb290PWVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlcixTeW5jTGFuZSk7aWYocm9vdCE9PW51bGwpe3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLFN5bmNMYW5lLE5vVGltZXN0YW1wKTt9fX07b3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoPWZ1bmN0aW9uKGZpYmVyLGlkLHBhdGgpe3ZhciBob29rPWZpbmRIb29rKGZpYmVyLGlkKTtpZihob29rIT09bnVsbCl7dmFyIG5ld1N0YXRlPWNvcHlXaXRoRGVsZXRlKGhvb2subWVtb2l6ZWRTdGF0ZSxwYXRoKTtob29rLm1lbW9pemVkU3RhdGU9bmV3U3RhdGU7aG9vay5iYXNlU3RhdGU9bmV3U3RhdGU7Ly8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4vLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbi8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cbmZpYmVyLm1lbW9pemVkUHJvcHM9YXNzaWduKHt9LGZpYmVyLm1lbW9pemVkUHJvcHMpO3ZhciByb290PWVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlcixTeW5jTGFuZSk7aWYocm9vdCE9PW51bGwpe3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLFN5bmNMYW5lLE5vVGltZXN0YW1wKTt9fX07b3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoPWZ1bmN0aW9uKGZpYmVyLGlkLG9sZFBhdGgsbmV3UGF0aCl7dmFyIGhvb2s9ZmluZEhvb2soZmliZXIsaWQpO2lmKGhvb2shPT1udWxsKXt2YXIgbmV3U3RhdGU9Y29weVdpdGhSZW5hbWUoaG9vay5tZW1vaXplZFN0YXRlLG9sZFBhdGgsbmV3UGF0aCk7aG9vay5tZW1vaXplZFN0YXRlPW5ld1N0YXRlO2hvb2suYmFzZVN0YXRlPW5ld1N0YXRlOy8vIFdlIGFyZW4ndCBhY3R1YWxseSBhZGRpbmcgYW4gdXBkYXRlIHRvIHRoZSBxdWV1ZSxcbi8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXBkYXRlIHdlIGNhbiBhZGQgZm9yIHVzZVJlZHVjZXIgaG9va3MgdGhhdCB3b24ndCB0cmlnZ2VyIGFuIGVycm9yLlxuLy8gKFRoZXJlJ3Mgbm8gYXBwcm9wcmlhdGUgYWN0aW9uIHR5cGUgZm9yIERldlRvb2xzIG92ZXJyaWRlcy4pXG4vLyBBcyBhIHJlc3VsdCB0aG91Z2gsIFJlYWN0IHdpbGwgc2VlIHRoZSBzY2hlZHVsZWQgdXBkYXRlIGFzIGEgbm9vcCBhbmQgYmFpbG91dC5cbi8vIFNoYWxsb3cgY2xvbmluZyBwcm9wcyB3b3JrcyBhcyBhIHdvcmthcm91bmQgZm9yIG5vdyB0byBieXBhc3MgdGhlIGJhaWxvdXQgY2hlY2suXG5maWJlci5tZW1vaXplZFByb3BzPWFzc2lnbih7fSxmaWJlci5tZW1vaXplZFByb3BzKTt2YXIgcm9vdD1lbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsU3luY0xhbmUpO2lmKHJvb3QhPT1udWxsKXtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxmaWJlcixTeW5jTGFuZSxOb1RpbWVzdGFtcCk7fX19Oy8vIFN1cHBvcnQgRGV2VG9vbHMgcHJvcHMgZm9yIGZ1bmN0aW9uIGNvbXBvbmVudHMsIGZvcndhcmRSZWYsIG1lbW8sIGhvc3QgY29tcG9uZW50cywgZXRjLlxub3ZlcnJpZGVQcm9wcz1mdW5jdGlvbihmaWJlcixwYXRoLHZhbHVlKXtmaWJlci5wZW5kaW5nUHJvcHM9Y29weVdpdGhTZXQoZmliZXIubWVtb2l6ZWRQcm9wcyxwYXRoLHZhbHVlKTtpZihmaWJlci5hbHRlcm5hdGUpe2ZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHM9ZmliZXIucGVuZGluZ1Byb3BzO312YXIgcm9vdD1lbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsU3luY0xhbmUpO2lmKHJvb3QhPT1udWxsKXtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxmaWJlcixTeW5jTGFuZSxOb1RpbWVzdGFtcCk7fX07b3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGg9ZnVuY3Rpb24oZmliZXIscGF0aCl7ZmliZXIucGVuZGluZ1Byb3BzPWNvcHlXaXRoRGVsZXRlKGZpYmVyLm1lbW9pemVkUHJvcHMscGF0aCk7aWYoZmliZXIuYWx0ZXJuYXRlKXtmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzPWZpYmVyLnBlbmRpbmdQcm9wczt9dmFyIHJvb3Q9ZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLFN5bmNMYW5lKTtpZihyb290IT09bnVsbCl7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsU3luY0xhbmUsTm9UaW1lc3RhbXApO319O292ZXJyaWRlUHJvcHNSZW5hbWVQYXRoPWZ1bmN0aW9uKGZpYmVyLG9sZFBhdGgsbmV3UGF0aCl7ZmliZXIucGVuZGluZ1Byb3BzPWNvcHlXaXRoUmVuYW1lKGZpYmVyLm1lbW9pemVkUHJvcHMsb2xkUGF0aCxuZXdQYXRoKTtpZihmaWJlci5hbHRlcm5hdGUpe2ZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHM9ZmliZXIucGVuZGluZ1Byb3BzO312YXIgcm9vdD1lbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsU3luY0xhbmUpO2lmKHJvb3QhPT1udWxsKXtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxmaWJlcixTeW5jTGFuZSxOb1RpbWVzdGFtcCk7fX07c2NoZWR1bGVVcGRhdGU9ZnVuY3Rpb24oZmliZXIpe3ZhciByb290PWVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlcixTeW5jTGFuZSk7aWYocm9vdCE9PW51bGwpe3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLFN5bmNMYW5lLE5vVGltZXN0YW1wKTt9fTtzZXRFcnJvckhhbmRsZXI9ZnVuY3Rpb24obmV3U2hvdWxkRXJyb3JJbXBsKXtzaG91bGRFcnJvckltcGw9bmV3U2hvdWxkRXJyb3JJbXBsO307c2V0U3VzcGVuc2VIYW5kbGVyPWZ1bmN0aW9uKG5ld1Nob3VsZFN1c3BlbmRJbXBsKXtzaG91bGRTdXNwZW5kSW1wbD1uZXdTaG91bGRTdXNwZW5kSW1wbDt9O31mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcihmaWJlcil7dmFyIGhvc3RGaWJlcj1maW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7aWYoaG9zdEZpYmVyPT09bnVsbCl7cmV0dXJuIG51bGw7fXJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO31mdW5jdGlvbiBlbXB0eUZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKGluc3RhbmNlKXtyZXR1cm4gbnVsbDt9ZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMoKXtyZXR1cm4gY3VycmVudDt9ZnVuY3Rpb24gaW5qZWN0SW50b0RldlRvb2xzKGRldlRvb2xzQ29uZmlnKXt2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U9ZGV2VG9vbHNDb25maWcuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7dmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXI9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtyZXR1cm4gaW5qZWN0SW50ZXJuYWxzKHtidW5kbGVUeXBlOmRldlRvb2xzQ29uZmlnLmJ1bmRsZVR5cGUsdmVyc2lvbjpkZXZUb29sc0NvbmZpZy52ZXJzaW9uLHJlbmRlcmVyUGFja2FnZU5hbWU6ZGV2VG9vbHNDb25maWcucmVuZGVyZXJQYWNrYWdlTmFtZSxyZW5kZXJlckNvbmZpZzpkZXZUb29sc0NvbmZpZy5yZW5kZXJlckNvbmZpZyxvdmVycmlkZUhvb2tTdGF0ZTpvdmVycmlkZUhvb2tTdGF0ZSxvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGg6b3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoLG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aDpvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgsb3ZlcnJpZGVQcm9wczpvdmVycmlkZVByb3BzLG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoOm92ZXJyaWRlUHJvcHNEZWxldGVQYXRoLG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoOm92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoLHNldEVycm9ySGFuZGxlcjpzZXRFcnJvckhhbmRsZXIsc2V0U3VzcGVuc2VIYW5kbGVyOnNldFN1c3BlbnNlSGFuZGxlcixzY2hlZHVsZVVwZGF0ZTpzY2hlZHVsZVVwZGF0ZSxjdXJyZW50RGlzcGF0Y2hlclJlZjpSZWFjdEN1cnJlbnREaXNwYXRjaGVyLGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOmZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyLGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlfHxlbXB0eUZpbmRGaWJlckJ5SG9zdEluc3RhbmNlLC8vIFJlYWN0IFJlZnJlc2hcbmZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaDpmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2gsc2NoZWR1bGVSZWZyZXNoOnNjaGVkdWxlUmVmcmVzaCxzY2hlZHVsZVJvb3Q6c2NoZWR1bGVSb290LHNldFJlZnJlc2hIYW5kbGVyOnNldFJlZnJlc2hIYW5kbGVyLC8vIEVuYWJsZXMgRGV2VG9vbHMgdG8gYXBwZW5kIG93bmVyIHN0YWNrcyB0byBlcnJvciBtZXNzYWdlcyBpbiBERVYgbW9kZS5cbmdldEN1cnJlbnRGaWJlcjpnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scywvLyBFbmFibGVzIERldlRvb2xzIHRvIGRldGVjdCByZWNvbmNpbGVyIHZlcnNpb24gcmF0aGVyIHRoYW4gcmVuZGVyZXIgdmVyc2lvblxuLy8gd2hpY2ggbWF5IG5vdCBtYXRjaCBmb3IgdGhpcmQgcGFydHkgcmVuZGVyZXJzLlxucmVjb25jaWxlclZlcnNpb246UmVhY3RWZXJzaW9ufSk7fS8qIGdsb2JhbCByZXBvcnRFcnJvciAqL3ZhciBkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yPXR5cGVvZiByZXBvcnRFcnJvcj09PSdmdW5jdGlvbic/Ly8gSW4gbW9kZXJuIGJyb3dzZXJzLCByZXBvcnRFcnJvciB3aWxsIGRpc3BhdGNoIGFuIGVycm9yIGV2ZW50LFxuLy8gZW11bGF0aW5nIGFuIHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3IuXG5yZXBvcnRFcnJvcjpmdW5jdGlvbihlcnJvcil7Ly8gSW4gb2xkZXIgYnJvd3NlcnMgYW5kIHRlc3QgZW52aXJvbm1lbnRzLCBmYWxsYmFjayB0byBjb25zb2xlLmVycm9yLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuY29uc29sZVsnZXJyb3InXShlcnJvcik7fTtmdW5jdGlvbiBSZWFjdERPTVJvb3QoaW50ZXJuYWxSb290KXt0aGlzLl9pbnRlcm5hbFJvb3Q9aW50ZXJuYWxSb290O31SZWFjdERPTUh5ZHJhdGlvblJvb3QucHJvdG90eXBlLnJlbmRlcj1SZWFjdERPTVJvb3QucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihjaGlsZHJlbil7dmFyIHJvb3Q9dGhpcy5faW50ZXJuYWxSb290O2lmKHJvb3Q9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1cGRhdGUgYW4gdW5tb3VudGVkIHJvb3QuJyk7fXtpZih0eXBlb2YgYXJndW1lbnRzWzFdPT09J2Z1bmN0aW9uJyl7ZXJyb3IoJ3JlbmRlciguLi4pOiBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuICcrJ1RvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciByZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gYSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO31lbHNlIGlmKGlzVmFsaWRDb250YWluZXIoYXJndW1lbnRzWzFdKSl7ZXJyb3IoJ1lvdSBwYXNzZWQgYSBjb250YWluZXIgdG8gdGhlIHNlY29uZCBhcmd1bWVudCBvZiByb290LnJlbmRlciguLi4pLiAnK1wiWW91IGRvbid0IG5lZWQgdG8gcGFzcyBpdCBhZ2FpbiBzaW5jZSB5b3UgYWxyZWFkeSBwYXNzZWQgaXQgdG8gY3JlYXRlIHRoZSByb290LlwiKTt9ZWxzZSBpZih0eXBlb2YgYXJndW1lbnRzWzFdIT09J3VuZGVmaW5lZCcpe2Vycm9yKCdZb3UgcGFzc2VkIGEgc2Vjb25kIGFyZ3VtZW50IHRvIHJvb3QucmVuZGVyKC4uLikgYnV0IGl0IG9ubHkgYWNjZXB0cyAnKydvbmUgYXJndW1lbnQuJyk7fXZhciBjb250YWluZXI9cm9vdC5jb250YWluZXJJbmZvO2lmKGNvbnRhaW5lci5ub2RlVHlwZSE9PUNPTU1FTlRfTk9ERSl7dmFyIGhvc3RJbnN0YW5jZT1maW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhyb290LmN1cnJlbnQpO2lmKGhvc3RJbnN0YW5jZSl7aWYoaG9zdEluc3RhbmNlLnBhcmVudE5vZGUhPT1jb250YWluZXIpe2Vycm9yKCdyZW5kZXIoLi4uKTogSXQgbG9va3MgbGlrZSB0aGUgUmVhY3QtcmVuZGVyZWQgY29udGVudCBvZiB0aGUgJysncm9vdCBjb250YWluZXIgd2FzIHJlbW92ZWQgd2l0aG91dCB1c2luZyBSZWFjdC4gVGhpcyBpcyBub3QgJysnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnK1wicm9vdC51bm1vdW50KCkgdG8gZW1wdHkgYSByb290J3MgY29udGFpbmVyLlwiKTt9fX19dXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLHJvb3QsbnVsbCxudWxsKTt9O1JlYWN0RE9NSHlkcmF0aW9uUm9vdC5wcm90b3R5cGUudW5tb3VudD1SZWFjdERPTVJvb3QucHJvdG90eXBlLnVubW91bnQ9ZnVuY3Rpb24oKXt7aWYodHlwZW9mIGFyZ3VtZW50c1swXT09PSdmdW5jdGlvbicpe2Vycm9yKCd1bm1vdW50KC4uLik6IGRvZXMgbm90IHN1cHBvcnQgYSBjYWxsYmFjayBhcmd1bWVudC4gJysnVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyIHJlbmRlcmluZywgZGVjbGFyZSBpdCBpbiBhIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7fX12YXIgcm9vdD10aGlzLl9pbnRlcm5hbFJvb3Q7aWYocm9vdCE9PW51bGwpe3RoaXMuX2ludGVybmFsUm9vdD1udWxsO3ZhciBjb250YWluZXI9cm9vdC5jb250YWluZXJJbmZvO3tpZihpc0FscmVhZHlSZW5kZXJpbmcoKSl7ZXJyb3IoJ0F0dGVtcHRlZCB0byBzeW5jaHJvbm91c2x5IHVubW91bnQgYSByb290IHdoaWxlIFJlYWN0IHdhcyBhbHJlYWR5ICcrJ3JlbmRlcmluZy4gUmVhY3QgY2Fubm90IGZpbmlzaCB1bm1vdW50aW5nIHRoZSByb290IHVudGlsIHRoZSAnKydjdXJyZW50IHJlbmRlciBoYXMgY29tcGxldGVkLCB3aGljaCBtYXkgbGVhZCB0byBhIHJhY2UgY29uZGl0aW9uLicpO319Zmx1c2hTeW5jKGZ1bmN0aW9uKCl7dXBkYXRlQ29udGFpbmVyKG51bGwscm9vdCxudWxsLG51bGwpO30pO3VubWFya0NvbnRhaW5lckFzUm9vdChjb250YWluZXIpO319O2Z1bmN0aW9uIGNyZWF0ZVJvb3QoY29udGFpbmVyLG9wdGlvbnMpe2lmKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpe3Rocm93IG5ldyBFcnJvcignY3JlYXRlUm9vdCguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpO313YXJuSWZSZWFjdERPTUNvbnRhaW5lckluREVWKGNvbnRhaW5lcik7dmFyIGlzU3RyaWN0TW9kZT1mYWxzZTt2YXIgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZT1mYWxzZTt2YXIgaWRlbnRpZmllclByZWZpeD0nJzt2YXIgb25SZWNvdmVyYWJsZUVycm9yPWRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3I7dmFyIHRyYW5zaXRpb25DYWxsYmFja3M9bnVsbDtpZihvcHRpb25zIT09bnVsbCYmb3B0aW9ucyE9PXVuZGVmaW5lZCl7e2lmKG9wdGlvbnMuaHlkcmF0ZSl7d2FybignaHlkcmF0ZSB0aHJvdWdoIGNyZWF0ZVJvb3QgaXMgZGVwcmVjYXRlZC4gVXNlIFJlYWN0RE9NQ2xpZW50Lmh5ZHJhdGVSb290KGNvbnRhaW5lciwgPEFwcCAvPikgaW5zdGVhZC4nKTt9ZWxzZXtpZih0eXBlb2Ygb3B0aW9ucz09PSdvYmplY3QnJiZvcHRpb25zIT09bnVsbCYmb3B0aW9ucy4kJHR5cGVvZj09PVJFQUNUX0VMRU1FTlRfVFlQRSl7ZXJyb3IoJ1lvdSBwYXNzZWQgYSBKU1ggZWxlbWVudCB0byBjcmVhdGVSb290LiBZb3UgcHJvYmFibHkgbWVhbnQgdG8gJysnY2FsbCByb290LnJlbmRlciBpbnN0ZWFkLiAnKydFeGFtcGxlIHVzYWdlOlxcblxcbicrJyAgbGV0IHJvb3QgPSBjcmVhdGVSb290KGRvbUNvbnRhaW5lcik7XFxuJysnICByb290LnJlbmRlcig8QXBwIC8+KTsnKTt9fX1pZihvcHRpb25zLnVuc3RhYmxlX3N0cmljdE1vZGU9PT10cnVlKXtpc1N0cmljdE1vZGU9dHJ1ZTt9aWYob3B0aW9ucy5pZGVudGlmaWVyUHJlZml4IT09dW5kZWZpbmVkKXtpZGVudGlmaWVyUHJlZml4PW9wdGlvbnMuaWRlbnRpZmllclByZWZpeDt9aWYob3B0aW9ucy5vblJlY292ZXJhYmxlRXJyb3IhPT11bmRlZmluZWQpe29uUmVjb3ZlcmFibGVFcnJvcj1vcHRpb25zLm9uUmVjb3ZlcmFibGVFcnJvcjt9aWYob3B0aW9ucy50cmFuc2l0aW9uQ2FsbGJhY2tzIT09dW5kZWZpbmVkKXt0cmFuc2l0aW9uQ2FsbGJhY2tzPW9wdGlvbnMudHJhbnNpdGlvbkNhbGxiYWNrczt9fXZhciByb290PWNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsQ29uY3VycmVudFJvb3QsbnVsbCxpc1N0cmljdE1vZGUsY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSxpZGVudGlmaWVyUHJlZml4LG9uUmVjb3ZlcmFibGVFcnJvcik7bWFya0NvbnRhaW5lckFzUm9vdChyb290LmN1cnJlbnQsY29udGFpbmVyKTt2YXIgcm9vdENvbnRhaW5lckVsZW1lbnQ9Y29udGFpbmVyLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFP2NvbnRhaW5lci5wYXJlbnROb2RlOmNvbnRhaW5lcjtsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhyb290Q29udGFpbmVyRWxlbWVudCk7cmV0dXJuIG5ldyBSZWFjdERPTVJvb3Qocm9vdCk7fWZ1bmN0aW9uIFJlYWN0RE9NSHlkcmF0aW9uUm9vdChpbnRlcm5hbFJvb3Qpe3RoaXMuX2ludGVybmFsUm9vdD1pbnRlcm5hbFJvb3Q7fWZ1bmN0aW9uIHNjaGVkdWxlSHlkcmF0aW9uKHRhcmdldCl7aWYodGFyZ2V0KXtxdWV1ZUV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KHRhcmdldCk7fX1SZWFjdERPTUh5ZHJhdGlvblJvb3QucHJvdG90eXBlLnVuc3RhYmxlX3NjaGVkdWxlSHlkcmF0aW9uPXNjaGVkdWxlSHlkcmF0aW9uO2Z1bmN0aW9uIGh5ZHJhdGVSb290KGNvbnRhaW5lcixpbml0aWFsQ2hpbGRyZW4sb3B0aW9ucyl7aWYoIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSl7dGhyb3cgbmV3IEVycm9yKCdoeWRyYXRlUm9vdCguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpO313YXJuSWZSZWFjdERPTUNvbnRhaW5lckluREVWKGNvbnRhaW5lcik7e2lmKGluaXRpYWxDaGlsZHJlbj09PXVuZGVmaW5lZCl7ZXJyb3IoJ011c3QgcHJvdmlkZSBpbml0aWFsIGNoaWxkcmVuIGFzIHNlY29uZCBhcmd1bWVudCB0byBoeWRyYXRlUm9vdC4gJysnRXhhbXBsZSB1c2FnZTogaHlkcmF0ZVJvb3QoZG9tQ29udGFpbmVyLCA8QXBwIC8+KScpO319Ly8gRm9yIG5vdyB3ZSByZXVzZSB0aGUgd2hvbGUgYmFnIG9mIG9wdGlvbnMgc2luY2UgdGhleSBjb250YWluXG4vLyB0aGUgaHlkcmF0aW9uIGNhbGxiYWNrcy5cbnZhciBoeWRyYXRpb25DYWxsYmFja3M9b3B0aW9ucyE9bnVsbD9vcHRpb25zOm51bGw7Ly8gVE9ETzogRGVsZXRlIHRoaXMgb3B0aW9uXG52YXIgbXV0YWJsZVNvdXJjZXM9b3B0aW9ucyE9bnVsbCYmb3B0aW9ucy5oeWRyYXRlZFNvdXJjZXN8fG51bGw7dmFyIGlzU3RyaWN0TW9kZT1mYWxzZTt2YXIgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZT1mYWxzZTt2YXIgaWRlbnRpZmllclByZWZpeD0nJzt2YXIgb25SZWNvdmVyYWJsZUVycm9yPWRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3I7aWYob3B0aW9ucyE9PW51bGwmJm9wdGlvbnMhPT11bmRlZmluZWQpe2lmKG9wdGlvbnMudW5zdGFibGVfc3RyaWN0TW9kZT09PXRydWUpe2lzU3RyaWN0TW9kZT10cnVlO31pZihvcHRpb25zLmlkZW50aWZpZXJQcmVmaXghPT11bmRlZmluZWQpe2lkZW50aWZpZXJQcmVmaXg9b3B0aW9ucy5pZGVudGlmaWVyUHJlZml4O31pZihvcHRpb25zLm9uUmVjb3ZlcmFibGVFcnJvciE9PXVuZGVmaW5lZCl7b25SZWNvdmVyYWJsZUVycm9yPW9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yO319dmFyIHJvb3Q9Y3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyKGluaXRpYWxDaGlsZHJlbixudWxsLGNvbnRhaW5lcixDb25jdXJyZW50Um9vdCxoeWRyYXRpb25DYWxsYmFja3MsaXNTdHJpY3RNb2RlLGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsaWRlbnRpZmllclByZWZpeCxvblJlY292ZXJhYmxlRXJyb3IpO21hcmtDb250YWluZXJBc1Jvb3Qocm9vdC5jdXJyZW50LGNvbnRhaW5lcik7Ly8gVGhpcyBjYW4ndCBiZSBhIGNvbW1lbnQgbm9kZSBzaW5jZSBoeWRyYXRpb24gZG9lc24ndCB3b3JrIG9uIGNvbW1lbnQgbm9kZXMgYW55d2F5LlxubGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMoY29udGFpbmVyKTtpZihtdXRhYmxlU291cmNlcyl7Zm9yKHZhciBpPTA7aTxtdXRhYmxlU291cmNlcy5sZW5ndGg7aSsrKXt2YXIgbXV0YWJsZVNvdXJjZT1tdXRhYmxlU291cmNlc1tpXTtyZWdpc3Rlck11dGFibGVTb3VyY2VGb3JIeWRyYXRpb24ocm9vdCxtdXRhYmxlU291cmNlKTt9fXJldHVybiBuZXcgUmVhY3RET01IeWRyYXRpb25Sb290KHJvb3QpO31mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpe3JldHVybiEhKG5vZGUmJihub2RlLm5vZGVUeXBlPT09RUxFTUVOVF9OT0RFfHxub2RlLm5vZGVUeXBlPT09RE9DVU1FTlRfTk9ERXx8bm9kZS5ub2RlVHlwZT09PURPQ1VNRU5UX0ZSQUdNRU5UX05PREV8fCFkaXNhYmxlQ29tbWVudHNBc0RPTUNvbnRhaW5lcnMpKTt9Ly8gVE9ETzogUmVtb3ZlIHRoaXMgZnVuY3Rpb24gd2hpY2ggYWxzbyBpbmNsdWRlcyBjb21tZW50IG5vZGVzLlxuLy8gV2Ugb25seSB1c2UgaXQgaW4gcGxhY2VzIHRoYXQgYXJlIGN1cnJlbnRseSBtb3JlIHJlbGF4ZWQuXG5mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyTGVnYWN5KG5vZGUpe3JldHVybiEhKG5vZGUmJihub2RlLm5vZGVUeXBlPT09RUxFTUVOVF9OT0RFfHxub2RlLm5vZGVUeXBlPT09RE9DVU1FTlRfTk9ERXx8bm9kZS5ub2RlVHlwZT09PURPQ1VNRU5UX0ZSQUdNRU5UX05PREV8fG5vZGUubm9kZVR5cGU9PT1DT01NRU5UX05PREUmJm5vZGUubm9kZVZhbHVlPT09JyByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSAnKSk7fWZ1bmN0aW9uIHdhcm5JZlJlYWN0RE9NQ29udGFpbmVySW5ERVYoY29udGFpbmVyKXt7aWYoY29udGFpbmVyLm5vZGVUeXBlPT09RUxFTUVOVF9OT0RFJiZjb250YWluZXIudGFnTmFtZSYmY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKT09PSdCT0RZJyl7ZXJyb3IoJ2NyZWF0ZVJvb3QoKTogQ3JlYXRpbmcgcm9vdHMgZGlyZWN0bHkgd2l0aCBkb2N1bWVudC5ib2R5IGlzICcrJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcrJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJysncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgdXNpbmcgYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcrJ2ZvciB5b3VyIGFwcC4nKTt9aWYoaXNDb250YWluZXJNYXJrZWRBc1Jvb3QoY29udGFpbmVyKSl7aWYoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIpe2Vycm9yKCdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET01DbGllbnQuY3JlYXRlUm9vdCgpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJysncGFzc2VkIHRvIFJlYWN0RE9NLnJlbmRlcigpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7fWVsc2V7ZXJyb3IoJ1lvdSBhcmUgY2FsbGluZyBSZWFjdERPTUNsaWVudC5jcmVhdGVSb290KCkgb24gYSBjb250YWluZXIgdGhhdCAnKydoYXMgYWxyZWFkeSBiZWVuIHBhc3NlZCB0byBjcmVhdGVSb290KCkgYmVmb3JlLiBJbnN0ZWFkLCBjYWxsICcrJ3Jvb3QucmVuZGVyKCkgb24gdGhlIGV4aXN0aW5nIHJvb3QgaW5zdGVhZCBpZiB5b3Ugd2FudCB0byB1cGRhdGUgaXQuJyk7fX19fXZhciBSZWFjdEN1cnJlbnRPd25lciQzPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO3ZhciB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzO3t0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzPWZ1bmN0aW9uKGNvbnRhaW5lcil7aWYoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXImJmNvbnRhaW5lci5ub2RlVHlwZSE9PUNPTU1FTlRfTk9ERSl7dmFyIGhvc3RJbnN0YW5jZT1maW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lci5jdXJyZW50KTtpZihob3N0SW5zdGFuY2Upe2lmKGhvc3RJbnN0YW5jZS5wYXJlbnROb2RlIT09Y29udGFpbmVyKXtlcnJvcigncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhpcyAnKydjb250YWluZXIgd2FzIHJlbW92ZWQgd2l0aG91dCB1c2luZyBSZWFjdC4gVGhpcyBpcyBub3QgJysnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnKydSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlIHRvIGVtcHR5IGEgY29udGFpbmVyLicpO319fXZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0PSEhY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7dmFyIHJvb3RFbD1nZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTt2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQ9ISEocm9vdEVsJiZnZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCkpO2lmKGhhc05vblJvb3RSZWFjdENoaWxkJiYhaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCl7ZXJyb3IoJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcrJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnKyd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcrJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJyk7fWlmKGNvbnRhaW5lci5ub2RlVHlwZT09PUVMRU1FTlRfTk9ERSYmY29udGFpbmVyLnRhZ05hbWUmJmNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCk9PT0nQk9EWScpe2Vycm9yKCdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcrJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcrJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJysncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcrJ2ZvciB5b3VyIGFwcC4nKTt9fTt9ZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcil7aWYoIWNvbnRhaW5lcil7cmV0dXJuIG51bGw7fWlmKGNvbnRhaW5lci5ub2RlVHlwZT09PURPQ1VNRU5UX05PREUpe3JldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O31lbHNle3JldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDt9fWZ1bmN0aW9uIG5vb3BPblJlY292ZXJhYmxlRXJyb3IoKXsvLyBUaGlzIGlzbid0IHJlYWNoYWJsZSBiZWNhdXNlIG9uUmVjb3ZlcmFibGVFcnJvciBpc24ndCBjYWxsZWQgaW4gdGhlXG4vLyBsZWdhY3kgQVBJLlxufWZ1bmN0aW9uIGxlZ2FjeUNyZWF0ZVJvb3RGcm9tRE9NQ29udGFpbmVyKGNvbnRhaW5lcixpbml0aWFsQ2hpbGRyZW4scGFyZW50Q29tcG9uZW50LGNhbGxiYWNrLGlzSHlkcmF0aW9uQ29udGFpbmVyKXtpZihpc0h5ZHJhdGlvbkNvbnRhaW5lcil7aWYodHlwZW9mIGNhbGxiYWNrPT09J2Z1bmN0aW9uJyl7dmFyIG9yaWdpbmFsQ2FsbGJhY2s9Y2FsbGJhY2s7Y2FsbGJhY2s9ZnVuY3Rpb24oKXt2YXIgaW5zdGFuY2U9Z2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QpO29yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7fTt9dmFyIHJvb3Q9Y3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyKGluaXRpYWxDaGlsZHJlbixjYWxsYmFjayxjb250YWluZXIsTGVnYWN5Um9vdCxudWxsLC8vIGh5ZHJhdGlvbkNhbGxiYWNrc1xuZmFsc2UsLy8gaXNTdHJpY3RNb2RlXG5mYWxzZSwvLyBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLFxuJycsLy8gaWRlbnRpZmllclByZWZpeFxubm9vcE9uUmVjb3ZlcmFibGVFcnJvcik7Y29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI9cm9vdDttYXJrQ29udGFpbmVyQXNSb290KHJvb3QuY3VycmVudCxjb250YWluZXIpO3ZhciByb290Q29udGFpbmVyRWxlbWVudD1jb250YWluZXIubm9kZVR5cGU9PT1DT01NRU5UX05PREU/Y29udGFpbmVyLnBhcmVudE5vZGU6Y29udGFpbmVyO2xpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHJvb3RDb250YWluZXJFbGVtZW50KTtmbHVzaFN5bmMoKTtyZXR1cm4gcm9vdDt9ZWxzZXsvLyBGaXJzdCBjbGVhciBhbnkgZXhpc3RpbmcgY29udGVudC5cbnZhciByb290U2libGluZzt3aGlsZShyb290U2libGluZz1jb250YWluZXIubGFzdENoaWxkKXtjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO31pZih0eXBlb2YgY2FsbGJhY2s9PT0nZnVuY3Rpb24nKXt2YXIgX29yaWdpbmFsQ2FsbGJhY2s9Y2FsbGJhY2s7Y2FsbGJhY2s9ZnVuY3Rpb24oKXt2YXIgaW5zdGFuY2U9Z2V0UHVibGljUm9vdEluc3RhbmNlKF9yb290KTtfb3JpZ2luYWxDYWxsYmFjay5jYWxsKGluc3RhbmNlKTt9O312YXIgX3Jvb3Q9Y3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lcixMZWdhY3lSb290LG51bGwsLy8gaHlkcmF0aW9uQ2FsbGJhY2tzXG5mYWxzZSwvLyBpc1N0cmljdE1vZGVcbmZhbHNlLC8vIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsXG4nJywvLyBpZGVudGlmaWVyUHJlZml4XG5ub29wT25SZWNvdmVyYWJsZUVycm9yKTtjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcj1fcm9vdDttYXJrQ29udGFpbmVyQXNSb290KF9yb290LmN1cnJlbnQsY29udGFpbmVyKTt2YXIgX3Jvb3RDb250YWluZXJFbGVtZW50PWNvbnRhaW5lci5ub2RlVHlwZT09PUNPTU1FTlRfTk9ERT9jb250YWluZXIucGFyZW50Tm9kZTpjb250YWluZXI7bGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMoX3Jvb3RDb250YWluZXJFbGVtZW50KTsvLyBJbml0aWFsIG1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbmZsdXNoU3luYyhmdW5jdGlvbigpe3VwZGF0ZUNvbnRhaW5lcihpbml0aWFsQ2hpbGRyZW4sX3Jvb3QscGFyZW50Q29tcG9uZW50LGNhbGxiYWNrKTt9KTtyZXR1cm4gX3Jvb3Q7fX1mdW5jdGlvbiB3YXJuT25JbnZhbGlkQ2FsbGJhY2skMShjYWxsYmFjayxjYWxsZXJOYW1lKXt7aWYoY2FsbGJhY2shPT1udWxsJiZ0eXBlb2YgY2FsbGJhY2shPT0nZnVuY3Rpb24nKXtlcnJvcignJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcrJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLGNhbGxlck5hbWUsY2FsbGJhY2spO319fWZ1bmN0aW9uIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCxjaGlsZHJlbixjb250YWluZXIsZm9yY2VIeWRyYXRlLGNhbGxiYWNrKXt7dG9wTGV2ZWxVcGRhdGVXYXJuaW5ncyhjb250YWluZXIpO3dhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrPT09dW5kZWZpbmVkP251bGw6Y2FsbGJhY2ssJ3JlbmRlcicpO312YXIgbWF5YmVSb290PWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO3ZhciByb290O2lmKCFtYXliZVJvb3Qpey8vIEluaXRpYWwgbW91bnRcbnJvb3Q9bGVnYWN5Q3JlYXRlUm9vdEZyb21ET01Db250YWluZXIoY29udGFpbmVyLGNoaWxkcmVuLHBhcmVudENvbXBvbmVudCxjYWxsYmFjayxmb3JjZUh5ZHJhdGUpO31lbHNle3Jvb3Q9bWF5YmVSb290O2lmKHR5cGVvZiBjYWxsYmFjaz09PSdmdW5jdGlvbicpe3ZhciBvcmlnaW5hbENhbGxiYWNrPWNhbGxiYWNrO2NhbGxiYWNrPWZ1bmN0aW9uKCl7dmFyIGluc3RhbmNlPWdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290KTtvcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO307fS8vIFVwZGF0ZVxudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLHJvb3QscGFyZW50Q29tcG9uZW50LGNhbGxiYWNrKTt9cmV0dXJuIGdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290KTt9dmFyIGRpZFdhcm5BYm91dEZpbmRET01Ob2RlPWZhbHNlO2Z1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCl7e2lmKCFkaWRXYXJuQWJvdXRGaW5kRE9NTm9kZSl7ZGlkV2FybkFib3V0RmluZERPTU5vZGU9dHJ1ZTtlcnJvcignZmluZERPTU5vZGUgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yICcrJ3JlbGVhc2UuIEluc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCAnKyd0byByZWZlcmVuY2UuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJysnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScpO312YXIgb3duZXI9UmVhY3RDdXJyZW50T3duZXIkMy5jdXJyZW50O2lmKG93bmVyIT09bnVsbCYmb3duZXIuc3RhdGVOb2RlIT09bnVsbCl7dmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyPW93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXI7aWYoIXdhcm5lZEFib3V0UmVmc0luUmVuZGVyKXtlcnJvcignJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcrJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJysnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJysncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJysnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJyxnZXRDb21wb25lbnROYW1lRnJvbVR5cGUob3duZXIudHlwZSl8fCdBIGNvbXBvbmVudCcpO31vd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyPXRydWU7fX1pZihjb21wb25lbnRPckVsZW1lbnQ9PW51bGwpe3JldHVybiBudWxsO31pZihjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGU9PT1FTEVNRU5UX05PREUpe3JldHVybiBjb21wb25lbnRPckVsZW1lbnQ7fXtyZXR1cm4gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nKGNvbXBvbmVudE9yRWxlbWVudCwnZmluZERPTU5vZGUnKTt9fWZ1bmN0aW9uIGh5ZHJhdGUoZWxlbWVudCxjb250YWluZXIsY2FsbGJhY2spe3tlcnJvcignUmVhY3RET00uaHlkcmF0ZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGluIFJlYWN0IDE4LiBVc2UgaHlkcmF0ZVJvb3QgJysnaW5zdGVhZC4gVW50aWwgeW91IHN3aXRjaCB0byB0aGUgbmV3IEFQSSwgeW91ciBhcHAgd2lsbCBiZWhhdmUgYXMgJytcImlmIGl0J3MgcnVubmluZyBSZWFjdCAxNy4gTGVhcm4gXCIrJ21vcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zd2l0Y2gtdG8tY3JlYXRlcm9vdCcpO31pZighaXNWYWxpZENvbnRhaW5lckxlZ2FjeShjb250YWluZXIpKXt0aHJvdyBuZXcgRXJyb3IoJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyk7fXt2YXIgaXNNb2Rlcm5Sb290PWlzQ29udGFpbmVyTWFya2VkQXNSb290KGNvbnRhaW5lcikmJmNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyPT09dW5kZWZpbmVkO2lmKGlzTW9kZXJuUm9vdCl7ZXJyb3IoJ1lvdSBhcmUgY2FsbGluZyBSZWFjdERPTS5oeWRyYXRlKCkgb24gYSBjb250YWluZXIgdGhhdCB3YXMgcHJldmlvdXNseSAnKydwYXNzZWQgdG8gUmVhY3RET01DbGllbnQuY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcrJ0RpZCB5b3UgbWVhbiB0byBjYWxsIGh5ZHJhdGVSb290KGNvbnRhaW5lciwgZWxlbWVudCk/Jyk7fX0vLyBUT0RPOiB0aHJvdyBvciB3YXJuIGlmIHdlIGNvdWxkbid0IGh5ZHJhdGU/XG5yZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCxlbGVtZW50LGNvbnRhaW5lcix0cnVlLGNhbGxiYWNrKTt9ZnVuY3Rpb24gcmVuZGVyKGVsZW1lbnQsY29udGFpbmVyLGNhbGxiYWNrKXt7ZXJyb3IoJ1JlYWN0RE9NLnJlbmRlciBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGluIFJlYWN0IDE4LiBVc2UgY3JlYXRlUm9vdCAnKydpbnN0ZWFkLiBVbnRpbCB5b3Ugc3dpdGNoIHRvIHRoZSBuZXcgQVBJLCB5b3VyIGFwcCB3aWxsIGJlaGF2ZSBhcyAnK1wiaWYgaXQncyBydW5uaW5nIFJlYWN0IDE3LiBMZWFybiBcIisnbW9yZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N3aXRjaC10by1jcmVhdGVyb290Jyk7fWlmKCFpc1ZhbGlkQ29udGFpbmVyTGVnYWN5KGNvbnRhaW5lcikpe3Rocm93IG5ldyBFcnJvcignVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKTt9e3ZhciBpc01vZGVyblJvb3Q9aXNDb250YWluZXJNYXJrZWRBc1Jvb3QoY29udGFpbmVyKSYmY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI9PT11bmRlZmluZWQ7aWYoaXNNb2Rlcm5Sb290KXtlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJysncGFzc2VkIHRvIFJlYWN0RE9NQ2xpZW50LmNyZWF0ZVJvb3QoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiAnKydEaWQgeW91IG1lYW4gdG8gY2FsbCByb290LnJlbmRlcihlbGVtZW50KT8nKTt9fXJldHVybiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLGVsZW1lbnQsY29udGFpbmVyLGZhbHNlLGNhbGxiYWNrKTt9ZnVuY3Rpb24gdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LGVsZW1lbnQsY29udGFpbmVyTm9kZSxjYWxsYmFjayl7e2Vycm9yKCdSZWFjdERPTS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcigpIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgJysnaW4gUmVhY3QgMTguIENvbnNpZGVyIHVzaW5nIGEgcG9ydGFsIGluc3RlYWQuIFVudGlsIHlvdSBzd2l0Y2ggdG8gJytcInRoZSBjcmVhdGVSb290IEFQSSwgeW91ciBhcHAgd2lsbCBiZWhhdmUgYXMgaWYgaXQncyBydW5uaW5nIFJlYWN0IFwiKycxNy4gTGVhcm4gbW9yZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N3aXRjaC10by1jcmVhdGVyb290Jyk7fWlmKCFpc1ZhbGlkQ29udGFpbmVyTGVnYWN5KGNvbnRhaW5lck5vZGUpKXt0aHJvdyBuZXcgRXJyb3IoJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyk7fWlmKHBhcmVudENvbXBvbmVudD09bnVsbHx8IWhhcyhwYXJlbnRDb21wb25lbnQpKXt0aHJvdyBuZXcgRXJyb3IoJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50Jyk7fXJldHVybiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsZWxlbWVudCxjb250YWluZXJOb2RlLGZhbHNlLGNhbGxiYWNrKTt9dmFyIGRpZFdhcm5BYm91dFVubW91bnRDb21wb25lbnRBdE5vZGU9ZmFsc2U7ZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXIpe3tpZighZGlkV2FybkFib3V0VW5tb3VudENvbXBvbmVudEF0Tm9kZSl7ZGlkV2FybkFib3V0VW5tb3VudENvbXBvbmVudEF0Tm9kZT10cnVlO2Vycm9yKCd1bm1vdW50Q29tcG9uZW50QXROb2RlIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgJysnbmV4dCBtYWpvciByZWxlYXNlLiBTd2l0Y2ggdG8gdGhlIGNyZWF0ZVJvb3QgQVBJLiBMZWFybiAnKydtb3JlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3dpdGNoLXRvLWNyZWF0ZXJvb3QnKTt9fWlmKCFpc1ZhbGlkQ29udGFpbmVyTGVnYWN5KGNvbnRhaW5lcikpe3Rocm93IG5ldyBFcnJvcigndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpO317dmFyIGlzTW9kZXJuUm9vdD1pc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpJiZjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcj09PXVuZGVmaW5lZDtpZihpc01vZGVyblJvb3Qpe2Vycm9yKCdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSgpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJysncGFzc2VkIHRvIFJlYWN0RE9NQ2xpZW50LmNyZWF0ZVJvb3QoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBEaWQgeW91IG1lYW4gdG8gY2FsbCByb290LnVubW91bnQoKT8nKTt9fWlmKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyKXt7dmFyIHJvb3RFbD1nZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTt2YXIgcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0PXJvb3RFbCYmIWdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKTtpZihyZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3Qpe2Vycm9yKFwidW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3UncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50IFwiKyd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpO319Ly8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG5mbHVzaFN5bmMoZnVuY3Rpb24oKXtsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLG51bGwsY29udGFpbmVyLGZhbHNlLGZ1bmN0aW9uKCl7Ly8gJEZsb3dGaXhNZSBUaGlzIHNob3VsZCBwcm9iYWJseSB1c2UgYGRlbGV0ZSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcmBcbmNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyPW51bGw7dW5tYXJrQ29udGFpbmVyQXNSb290KGNvbnRhaW5lcik7fSk7fSk7Ly8gSWYgeW91IGNhbGwgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB0d2ljZSBpbiBxdWljayBzdWNjZXNzaW9uLCB5b3UnbGxcbi8vIGdldCBgdHJ1ZWAgdHdpY2UuIFRoYXQncyBwcm9iYWJseSBmaW5lP1xucmV0dXJuIHRydWU7fWVsc2V7e3ZhciBfcm9vdEVsPWdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO3ZhciBoYXNOb25Sb290UmVhY3RDaGlsZD0hIShfcm9vdEVsJiZnZXRJbnN0YW5jZUZyb21Ob2RlKF9yb290RWwpKTsvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbnZhciBpc0NvbnRhaW5lclJlYWN0Um9vdD1jb250YWluZXIubm9kZVR5cGU9PT1FTEVNRU5UX05PREUmJmlzVmFsaWRDb250YWluZXJMZWdhY3koY29udGFpbmVyLnBhcmVudE5vZGUpJiYhIWNvbnRhaW5lci5wYXJlbnROb2RlLl9yZWFjdFJvb3RDb250YWluZXI7aWYoaGFzTm9uUm9vdFJlYWN0Q2hpbGQpe2Vycm9yKFwidW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3UncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50IFwiKyd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJyxpc0NvbnRhaW5lclJlYWN0Um9vdD8nWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnKydvZiBpdHMgY29udGFpbmVyLic6J0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJysncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpO319cmV0dXJuIGZhbHNlO319c2V0QXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uKGF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiQxKTtzZXRBdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbihhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiQxKTtzZXRBdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5JDEpO3NldEdldEN1cnJlbnRVcGRhdGVQcmlvcml0eShnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkpO3NldEF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5KHJ1bldpdGhQcmlvcml0eSk7e2lmKHR5cGVvZiBNYXAhPT0nZnVuY3Rpb24nfHwvLyAkRmxvd0lzc3VlIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIE1hcCBoYXMgbm8gcHJvdG90eXBlXG5NYXAucHJvdG90eXBlPT1udWxsfHx0eXBlb2YgTWFwLnByb3RvdHlwZS5mb3JFYWNoIT09J2Z1bmN0aW9uJ3x8dHlwZW9mIFNldCE9PSdmdW5jdGlvbid8fC8vICRGbG93SXNzdWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgU2V0IGhhcyBubyBwcm90b3R5cGVcblNldC5wcm90b3R5cGU9PW51bGx8fHR5cGVvZiBTZXQucHJvdG90eXBlLmNsZWFyIT09J2Z1bmN0aW9uJ3x8dHlwZW9mIFNldC5wcm90b3R5cGUuZm9yRWFjaCE9PSdmdW5jdGlvbicpe2Vycm9yKCdSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcrJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtcG9seWZpbGxzJyk7fX1zZXRSZXN0b3JlSW1wbGVtZW50YXRpb24ocmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKTtzZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uKGJhdGNoZWRVcGRhdGVzJDEsZGlzY3JldGVVcGRhdGVzLGZsdXNoU3luYyk7ZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sY29udGFpbmVyKXt2YXIga2V5PWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1syXTpudWxsO2lmKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpe3Rocm93IG5ldyBFcnJvcignVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKTt9Ly8gVE9ETzogcGFzcyBSZWFjdERPTSBwb3J0YWwgaW1wbGVtZW50YXRpb24gYXMgdGhpcmQgYXJndW1lbnRcbi8vICRGbG93Rml4TWUgVGhlIEZsb3cgdHlwZSBpcyBvcGFxdWUgYnV0IHRoZXJlJ3Mgbm8gd2F5IHRvIGFjdHVhbGx5IGNyZWF0ZSBpdC5cbnJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sY29udGFpbmVyLG51bGwsa2V5KTt9ZnVuY3Rpb24gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LGVsZW1lbnQsY29udGFpbmVyTm9kZSxjYWxsYmFjayl7cmV0dXJuIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCxlbGVtZW50LGNvbnRhaW5lck5vZGUsY2FsbGJhY2spO312YXIgSW50ZXJuYWxzPXt1c2luZ0NsaWVudEVudHJ5UG9pbnQ6ZmFsc2UsLy8gS2VlcCBpbiBzeW5jIHdpdGggUmVhY3RUZXN0VXRpbHMuanMuXG4vLyBUaGlzIGlzIGFuIGFycmF5IGZvciBiZXR0ZXIgbWluaWZpY2F0aW9uLlxuRXZlbnRzOltnZXRJbnN0YW5jZUZyb21Ob2RlLGdldE5vZGVGcm9tSW5zdGFuY2UsZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSxlbnF1ZXVlU3RhdGVSZXN0b3JlLHJlc3RvcmVTdGF0ZUlmTmVlZGVkLGJhdGNoZWRVcGRhdGVzJDFdfTtmdW5jdGlvbiBjcmVhdGVSb290JDEoY29udGFpbmVyLG9wdGlvbnMpe3tpZighSW50ZXJuYWxzLnVzaW5nQ2xpZW50RW50cnlQb2ludCYmIWZhbHNlKXtlcnJvcignWW91IGFyZSBpbXBvcnRpbmcgY3JlYXRlUm9vdCBmcm9tIFwicmVhY3QtZG9tXCIgd2hpY2ggaXMgbm90IHN1cHBvcnRlZC4gJysnWW91IHNob3VsZCBpbnN0ZWFkIGltcG9ydCBpdCBmcm9tIFwicmVhY3QtZG9tL2NsaWVudFwiLicpO319cmV0dXJuIGNyZWF0ZVJvb3QoY29udGFpbmVyLG9wdGlvbnMpO31mdW5jdGlvbiBoeWRyYXRlUm9vdCQxKGNvbnRhaW5lcixpbml0aWFsQ2hpbGRyZW4sb3B0aW9ucyl7e2lmKCFJbnRlcm5hbHMudXNpbmdDbGllbnRFbnRyeVBvaW50JiYhZmFsc2Upe2Vycm9yKCdZb3UgYXJlIGltcG9ydGluZyBoeWRyYXRlUm9vdCBmcm9tIFwicmVhY3QtZG9tXCIgd2hpY2ggaXMgbm90IHN1cHBvcnRlZC4gJysnWW91IHNob3VsZCBpbnN0ZWFkIGltcG9ydCBpdCBmcm9tIFwicmVhY3QtZG9tL2NsaWVudFwiLicpO319cmV0dXJuIGh5ZHJhdGVSb290KGNvbnRhaW5lcixpbml0aWFsQ2hpbGRyZW4sb3B0aW9ucyk7fS8vIE92ZXJsb2FkIHRoZSBkZWZpbml0aW9uIHRvIHRoZSB0d28gdmFsaWQgc2lnbmF0dXJlcy5cbi8vIFdhcm5pbmcsIHRoaXMgb3B0cy1vdXQgb2YgY2hlY2tpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5mdW5jdGlvbiBmbHVzaFN5bmMkMShmbil7e2lmKGlzQWxyZWFkeVJlbmRlcmluZygpKXtlcnJvcignZmx1c2hTeW5jIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSBsaWZlY3ljbGUgbWV0aG9kLiBSZWFjdCBjYW5ub3QgJysnZmx1c2ggd2hlbiBSZWFjdCBpcyBhbHJlYWR5IHJlbmRlcmluZy4gQ29uc2lkZXIgbW92aW5nIHRoaXMgY2FsbCB0byAnKydhIHNjaGVkdWxlciB0YXNrIG9yIG1pY3JvIHRhc2suJyk7fX1yZXR1cm4gZmx1c2hTeW5jKGZuKTt9dmFyIGZvdW5kRGV2VG9vbHM9aW5qZWN0SW50b0RldlRvb2xzKHtmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTpnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxidW5kbGVUeXBlOjEsdmVyc2lvbjpSZWFjdFZlcnNpb24scmVuZGVyZXJQYWNrYWdlTmFtZToncmVhY3QtZG9tJ30pO3tpZighZm91bmREZXZUb29scyYmY2FuVXNlRE9NJiZ3aW5kb3cudG9wPT09d2luZG93LnNlbGYpey8vIElmIHdlJ3JlIGluIENocm9tZSBvciBGaXJlZm94LCBwcm92aWRlIGEgZG93bmxvYWQgbGluayBpZiBub3QgaW5zdGFsbGVkLlxuaWYobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKT4tMSYmbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJyk9PT0tMXx8bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94Jyk+LTEpe3ZhciBwcm90b2NvbD13aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7Ly8gRG9uJ3Qgd2FybiBpbiBleG90aWMgY2FzZXMgbGlrZSBjaHJvbWUtZXh0ZW5zaW9uOi8vLlxuaWYoL14oaHR0cHM/fGZpbGUpOiQvLnRlc3QocHJvdG9jb2wpKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5jb25zb2xlLmluZm8oJyVjRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcrJ2ZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnKydodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMnKyhwcm90b2NvbD09PSdmaWxlOic/J1xcbllvdSBtaWdodCBuZWVkIHRvIHVzZSBhIGxvY2FsIEhUVFAgc2VydmVyIChpbnN0ZWFkIG9mIGZpbGU6Ly8pOiAnKydodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMtZmFxJzonJyksJ2ZvbnQtd2VpZ2h0OmJvbGQnKTt9fX19ZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRD1JbnRlcm5hbHM7ZXhwb3J0cy5jcmVhdGVQb3J0YWw9Y3JlYXRlUG9ydGFsJDE7ZXhwb3J0cy5jcmVhdGVSb290PWNyZWF0ZVJvb3QkMTtleHBvcnRzLmZpbmRET01Ob2RlPWZpbmRET01Ob2RlO2V4cG9ydHMuZmx1c2hTeW5jPWZsdXNoU3luYyQxO2V4cG9ydHMuaHlkcmF0ZT1oeWRyYXRlO2V4cG9ydHMuaHlkcmF0ZVJvb3Q9aHlkcmF0ZVJvb3QkMTtleHBvcnRzLnJlbmRlcj1yZW5kZXI7ZXhwb3J0cy51bm1vdW50Q29tcG9uZW50QXROb2RlPXVubW91bnRDb21wb25lbnRBdE5vZGU7ZXhwb3J0cy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcz1iYXRjaGVkVXBkYXRlcyQxO2V4cG9ydHMudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI9cmVuZGVyU3VidHJlZUludG9Db250YWluZXI7ZXhwb3J0cy52ZXJzaW9uPVJlYWN0VmVyc2lvbjsvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovaWYodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyE9PSd1bmRlZmluZWQnJiZ0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wPT09J2Z1bmN0aW9uJyl7X19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTt9fSkoKTt9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-dom/cjs/react-dom.development.js\n");

/***/ }),

/***/ "./node_modules/react-dom/client.js":
/*!******************************************!*\
  !*** ./node_modules/react-dom/client.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar m = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\nif (false) {} else {\n  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  exports.createRoot = function (c, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.createRoot(c, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n  exports.hydrateRoot = function (c, h, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.hydrateRoot(c, h, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMsb0RBQVc7QUFDM0IsSUFBSSxLQUFxQyxFQUFFLEVBRzFDLENBQUM7QUFDRjtBQUNBLEVBQUUsa0JBQWtCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1CQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teV9hcHAvLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2NsaWVudC5qcz8wZTEyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIG0gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGV4cG9ydHMuY3JlYXRlUm9vdCA9IG0uY3JlYXRlUm9vdDtcbiAgZXhwb3J0cy5oeWRyYXRlUm9vdCA9IG0uaHlkcmF0ZVJvb3Q7XG59IGVsc2Uge1xuICB2YXIgaSA9IG0uX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG4gIGV4cG9ydHMuY3JlYXRlUm9vdCA9IGZ1bmN0aW9uIChjLCBvKSB7XG4gICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbS5jcmVhdGVSb290KGMsIG8pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpLnVzaW5nQ2xpZW50RW50cnlQb2ludCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5oeWRyYXRlUm9vdCA9IGZ1bmN0aW9uIChjLCBoLCBvKSB7XG4gICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbS5oeWRyYXRlUm9vdChjLCBoLCBvKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-dom/client.js\n");

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"./node_modules/react-dom/cjs/react-dom.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQyxFQUFFLEVBSzFDLENBQUM7QUFDRixFQUFFLG1JQUEwRDtBQUM1RCIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanM/NTEyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-dom/index.js\n");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n    var ReactVersion = '18.3.1';\n\n    // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types.\n    var REACT_ELEMENT_TYPE = Symbol.for('react.element');\n    var REACT_PORTAL_TYPE = Symbol.for('react.portal');\n    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\n    var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\n    var REACT_PROFILER_TYPE = Symbol.for('react.profiler');\n    var REACT_PROVIDER_TYPE = Symbol.for('react.provider');\n    var REACT_CONTEXT_TYPE = Symbol.for('react.context');\n    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\n    var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\n    var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\n    var REACT_MEMO_TYPE = Symbol.for('react.memo');\n    var REACT_LAZY_TYPE = Symbol.for('react.lazy');\n    var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable !== 'object') {\n        return null;\n      }\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n      return null;\n    }\n\n    /**\n     * Keeps track of the current dispatcher.\n     */\n    var ReactCurrentDispatcher = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n\n    /**\n     * Keeps track of the current batch's configuration such as how long an update\n     * should suspend for if it needs to.\n     */\n    var ReactCurrentBatchConfig = {\n      transition: null\n    };\n    var ReactCurrentActQueue = {\n      current: null,\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n      isBatchingLegacy: false,\n      didScheduleLegacyUpdate: false\n    };\n\n    /**\n     * Keeps track of the current owner.\n     *\n     * The current owner is the component who should own any components that are\n     * currently being constructed.\n     */\n    var ReactCurrentOwner = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n    var ReactDebugCurrentFrame = {};\n    var currentExtraStackFrame = null;\n    function setExtraStackFrame(stack) {\n      {\n        currentExtraStackFrame = stack;\n      }\n    }\n    {\n      ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\n        {\n          currentExtraStackFrame = stack;\n        }\n      }; // Stack implementation injected by the current renderer.\n\n      ReactDebugCurrentFrame.getCurrentStack = null;\n      ReactDebugCurrentFrame.getStackAddendum = function () {\n        var stack = ''; // Add an extra top frame while an element is being validated\n\n        if (currentExtraStackFrame) {\n          stack += currentExtraStackFrame;\n        } // Delegate to the injected renderer-specific implementation\n\n        var impl = ReactDebugCurrentFrame.getCurrentStack;\n        if (impl) {\n          stack += impl() || '';\n        }\n        return stack;\n      };\n    }\n\n    // -----------------------------------------------------------------------------\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n    var enableCacheElement = false;\n    var enableTransitionTracing = false; // No known bugs, but needs performance testing\n\n    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n    // stuff. Intended to enable React core members to more easily debug scheduling\n    // issues in DEV builds.\n\n    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\n    var ReactSharedInternals = {\n      ReactCurrentDispatcher: ReactCurrentDispatcher,\n      ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n      ReactCurrentOwner: ReactCurrentOwner\n    };\n    {\n      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n      ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n    }\n\n    // by calls to these methods by a Babel plugin.\n    //\n    // In PROD (or in packages without access to React internals),\n    // they are left as they are instead.\n\n    function warn(format) {\n      {\n        {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n          printWarning('warn', format, args);\n        }\n      }\n    }\n    function error(format) {\n      {\n        {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n          printWarning('error', format, args);\n        }\n      }\n    }\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        } // eslint-disable-next-line react-internal/safe-string-coercion\n\n        var argsWithFormat = args.map(function (item) {\n          return String(item);\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    }\n    var didWarnStateUpdateForUnmountedComponent = {};\n    function warnNoop(publicInstance, callerName) {\n      {\n        var _constructor = publicInstance.constructor;\n        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n        var warningKey = componentName + \".\" + callerName;\n        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n          return;\n        }\n        error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n        didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n      }\n    }\n    /**\n     * This is the abstract API for an update queue.\n     */\n\n    var ReactNoopUpdateQueue = {\n      /**\n       * Checks whether or not this composite component is mounted.\n       * @param {ReactClass} publicInstance The instance we want to test.\n       * @return {boolean} True if mounted, false otherwise.\n       * @protected\n       * @final\n       */\n      isMounted: function (publicInstance) {\n        return false;\n      },\n      /**\n       * Forces an update. This should only be invoked when it is known with\n       * certainty that we are **not** in a DOM transaction.\n       *\n       * You may want to call this when you know that some deeper aspect of the\n       * component's state has changed but `setState` was not called.\n       *\n       * This will not invoke `shouldComponentUpdate`, but it will invoke\n       * `componentWillUpdate` and `componentDidUpdate`.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueForceUpdate: function (publicInstance, callback, callerName) {\n        warnNoop(publicInstance, 'forceUpdate');\n      },\n      /**\n       * Replaces all of the state. Always use this or `setState` to mutate state.\n       * You should treat `this.state` as immutable.\n       *\n       * There is no guarantee that `this.state` will be immediately updated, so\n       * accessing `this.state` after calling this method may return the old value.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} completeState Next state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n        warnNoop(publicInstance, 'replaceState');\n      },\n      /**\n       * Sets a subset of the state. This only exists because _pendingState is\n       * internal. This provides a merging strategy that is not available to deep\n       * properties which is confusing. TODO: Expose pendingState or don't use it\n       * during the merge.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} partialState Next partial state to be merged with state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} Name of the calling function in the public API.\n       * @internal\n       */\n      enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n        warnNoop(publicInstance, 'setState');\n      }\n    };\n    var assign = Object.assign;\n    var emptyObject = {};\n    {\n      Object.freeze(emptyObject);\n    }\n    /**\n     * Base class helpers for the updating state of a component.\n     */\n\n    function Component(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n      // renderer.\n\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    Component.prototype.isReactComponent = {};\n    /**\n     * Sets a subset of the state. Always use this to mutate\n     * state. You should treat `this.state` as immutable.\n     *\n     * There is no guarantee that `this.state` will be immediately updated, so\n     * accessing `this.state` after calling this method may return the old value.\n     *\n     * There is no guarantee that calls to `setState` will run synchronously,\n     * as they may eventually be batched together.  You can provide an optional\n     * callback that will be executed when the call to setState is actually\n     * completed.\n     *\n     * When a function is provided to setState, it will be called at some point in\n     * the future (not synchronously). It will be called with the up to date\n     * component arguments (state, props, context). These values can be different\n     * from this.* because your function may be called after receiveProps but before\n     * shouldComponentUpdate, and this new state, props, and context will not yet be\n     * assigned to this.\n     *\n     * @param {object|function} partialState Next partial state or function to\n     *        produce next partial state to be merged with current state.\n     * @param {?function} callback Called after state is updated.\n     * @final\n     * @protected\n     */\n\n    Component.prototype.setState = function (partialState, callback) {\n      if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {\n        throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');\n      }\n      this.updater.enqueueSetState(this, partialState, callback, 'setState');\n    };\n    /**\n     * Forces an update. This should only be invoked when it is known with\n     * certainty that we are **not** in a DOM transaction.\n     *\n     * You may want to call this when you know that some deeper aspect of the\n     * component's state has changed but `setState` was not called.\n     *\n     * This will not invoke `shouldComponentUpdate`, but it will invoke\n     * `componentWillUpdate` and `componentDidUpdate`.\n     *\n     * @param {?function} callback Called after update is complete.\n     * @final\n     * @protected\n     */\n\n    Component.prototype.forceUpdate = function (callback) {\n      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n    };\n    /**\n     * Deprecated APIs. These APIs used to exist on classic React classes but since\n     * we would like to deprecate them, we're not going to move them over to this\n     * modern base class. Instead, we define a getter that warns if it's accessed.\n     */\n\n    {\n      var deprecatedAPIs = {\n        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n      };\n      var defineDeprecationWarning = function (methodName, info) {\n        Object.defineProperty(Component.prototype, methodName, {\n          get: function () {\n            warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n            return undefined;\n          }\n        });\n      };\n      for (var fnName in deprecatedAPIs) {\n        if (deprecatedAPIs.hasOwnProperty(fnName)) {\n          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n        }\n      }\n    }\n    function ComponentDummy() {}\n    ComponentDummy.prototype = Component.prototype;\n    /**\n     * Convenience component with default shallow equality check for sCU.\n     */\n\n    function PureComponent(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\n    assign(pureComponentPrototype, Component.prototype);\n    pureComponentPrototype.isPureReactComponent = true;\n\n    // an immutable object with a single mutable value\n    function createRef() {\n      var refObject = {\n        current: null\n      };\n      {\n        Object.seal(refObject);\n      }\n      return refObject;\n    }\n    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\n    function isArray(a) {\n      return isArrayImpl(a);\n    }\n\n    /*\n     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n     *\n     * The functions in this module will throw an easier-to-understand,\n     * easier-to-debug exception with a clear errors message message explaining the\n     * problem. (Instead of a confusing exception thrown inside the implementation\n     * of the `value` object).\n     */\n    // $FlowFixMe only called in DEV, so void return is not possible.\n    function typeName(value) {\n      {\n        // toStringTag is needed for namespaced types like Temporal.Instant\n        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n        return type;\n      }\n    } // $FlowFixMe only called in DEV, so void return is not possible.\n\n    function willCoercionThrow(value) {\n      {\n        try {\n          testStringCoercion(value);\n          return false;\n        } catch (e) {\n          return true;\n        }\n      }\n    }\n    function testStringCoercion(value) {\n      // If you ended up here by following an exception call stack, here's what's\n      // happened: you supplied an object or symbol value to React (as a prop, key,\n      // DOM attribute, CSS property, string ref, etc.) and when React tried to\n      // coerce it to a string using `'' + value`, an exception was thrown.\n      //\n      // The most common types that will cause this exception are `Symbol` instances\n      // and Temporal objects like `Temporal.Instant`. But any object that has a\n      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n      // exception. (Library authors do this to prevent users from using built-in\n      // numeric operators like `+` or comparison operators like `>=` because custom\n      // methods are needed to perform accurate arithmetic or comparison.)\n      //\n      // To fix the problem, coerce this object or symbol value to a string before\n      // passing it to React. The most reliable way is usually `String(value)`.\n      //\n      // To find which value is throwing, check the browser or debugger console.\n      // Before this exception was thrown, there should be `console.error` output\n      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n      // problem and how that type was used: key, atrribute, input value prop, etc.\n      // In most cases, this console output also shows the component and its\n      // ancestor components where the exception happened.\n      //\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      return '' + value;\n    }\n    function checkKeyStringCoercion(value) {\n      {\n        if (willCoercionThrow(value)) {\n          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n        }\n      }\n    }\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var displayName = outerType.displayName;\n      if (displayName) {\n        return displayName;\n      }\n      var functionName = innerType.displayName || innerType.name || '';\n      return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n    } // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n    function getComponentNameFromType(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n      if (typeof type === 'string') {\n        return type;\n      }\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return 'Fragment';\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n          case REACT_MEMO_TYPE:\n            var outerName = type.displayName || null;\n            if (outerName !== null) {\n              return outerName;\n            }\n            return getComponentNameFromType(type.type) || 'Memo';\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                return getComponentNameFromType(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n\n          // eslint-disable-next-line no-fallthrough\n        }\n      }\n      return null;\n    }\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      var warnAboutAccessingKey = function () {\n        {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n      warnAboutAccessingKey.isReactWarning = true;\n      Object.defineProperty(props, 'key', {\n        get: warnAboutAccessingKey,\n        configurable: true\n      });\n    }\n    function defineRefPropWarningGetter(props, displayName) {\n      var warnAboutAccessingRef = function () {\n        {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n    function warnIfStringRefCannotBeAutoConverted(config) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, instanceof check\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} props\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} owner\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @internal\n     */\n\n    var ReactElement = function (type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\n     * Create and return a new ReactElement of the given type.\n     * See https://reactjs.org/docs/react-api.html#createelement\n     */\n\n    function createElement(type, config, children) {\n      var propName; // Reserved names are extracted\n\n      var props = {};\n      var key = null;\n      var ref = null;\n      var self = null;\n      var source = null;\n      if (config != null) {\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          {\n            warnIfStringRefCannotBeAutoConverted(config);\n          }\n        }\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        }\n        self = config.__self === undefined ? null : config.__self;\n        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        {\n          if (Object.freeze) {\n            Object.freeze(childArray);\n          }\n        }\n        props.children = childArray;\n      } // Resolve default props\n\n      if (type && type.defaultProps) {\n        var defaultProps = type.defaultProps;\n        for (propName in defaultProps) {\n          if (props[propName] === undefined) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n      }\n      {\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n      }\n      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n    }\n    function cloneAndReplaceKey(oldElement, newKey) {\n      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n      return newElement;\n    }\n    /**\n     * Clone and return a new ReactElement using element as the starting point.\n     * See https://reactjs.org/docs/react-api.html#cloneelement\n     */\n\n    function cloneElement(element, config, children) {\n      if (element === null || element === undefined) {\n        throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n      }\n      var propName; // Original props are copied\n\n      var props = assign({}, element.props); // Reserved names are extracted\n\n      var key = element.key;\n      var ref = element.ref; // Self is preserved since the owner is preserved.\n\n      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n      // transpiler, and the original source is probably a better indicator of the\n      // true owner.\n\n      var source = element._source; // Owner will be preserved, unless ref is overridden\n\n      var owner = element._owner;\n      if (config != null) {\n        if (hasValidRef(config)) {\n          // Silently steal the ref from the parent.\n          ref = config.ref;\n          owner = ReactCurrentOwner.current;\n        }\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        } // Remaining properties override existing props\n\n        var defaultProps;\n        if (element.type && element.type.defaultProps) {\n          defaultProps = element.type.defaultProps;\n        }\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            if (config[propName] === undefined && defaultProps !== undefined) {\n              // Resolve default props\n              props[propName] = defaultProps[propName];\n            } else {\n              props[propName] = config[propName];\n            }\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        props.children = childArray;\n      }\n      return ReactElement(element.type, key, ref, self, source, owner, props);\n    }\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a ReactElement.\n     * @final\n     */\n\n    function isValidElement(object) {\n      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n    }\n    var SEPARATOR = '.';\n    var SUBSEPARATOR = ':';\n    /**\n     * Escape and wrap key so it is safe to use as a reactid\n     *\n     * @param {string} key to be escaped.\n     * @return {string} the escaped key.\n     */\n\n    function escape(key) {\n      var escapeRegex = /[=:]/g;\n      var escaperLookup = {\n        '=': '=0',\n        ':': '=2'\n      };\n      var escapedString = key.replace(escapeRegex, function (match) {\n        return escaperLookup[match];\n      });\n      return '$' + escapedString;\n    }\n    /**\n     * TODO: Test that a single child and an array with one item have the same key\n     * pattern.\n     */\n\n    var didWarnAboutMaps = false;\n    var userProvidedKeyEscapeRegex = /\\/+/g;\n    function escapeUserProvidedKey(text) {\n      return text.replace(userProvidedKeyEscapeRegex, '$&/');\n    }\n    /**\n     * Generate a key string that identifies a element within a set.\n     *\n     * @param {*} element A element that could contain a manual key.\n     * @param {number} index Index that is used if a manual key is not provided.\n     * @return {string}\n     */\n\n    function getElementKey(element, index) {\n      // Do some typechecking here since we call this blindly. We want to ensure\n      // that we don't block potential future ES APIs.\n      if (typeof element === 'object' && element !== null && element.key != null) {\n        // Explicit key\n        {\n          checkKeyStringCoercion(element.key);\n        }\n        return escape('' + element.key);\n      } // Implicit key determined by the index in the set\n\n      return index.toString(36);\n    }\n    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n      var type = typeof children;\n      if (type === 'undefined' || type === 'boolean') {\n        // All of the above are perceived as null.\n        children = null;\n      }\n      var invokeCallback = false;\n      if (children === null) {\n        invokeCallback = true;\n      } else {\n        switch (type) {\n          case 'string':\n          case 'number':\n            invokeCallback = true;\n            break;\n          case 'object':\n            switch (children.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n              case REACT_PORTAL_TYPE:\n                invokeCallback = true;\n            }\n        }\n      }\n      if (invokeCallback) {\n        var _child = children;\n        var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n        // so that it's consistent if the number of children grows:\n\n        var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n        if (isArray(mappedChild)) {\n          var escapedChildKey = '';\n          if (childKey != null) {\n            escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n          }\n          mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\n            return c;\n          });\n        } else if (mappedChild != null) {\n          if (isValidElement(mappedChild)) {\n            {\n              // The `if` statement here prevents auto-disabling of the safe\n              // coercion ESLint rule, so we must manually disable it below.\n              // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n              if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n                checkKeyStringCoercion(mappedChild.key);\n              }\n            }\n            mappedChild = cloneAndReplaceKey(mappedChild,\n            // Keep both the (mapped) and old keys if they differ, just as\n            // traverseAllChildren used to do for objects as children\n            escapedPrefix + (\n            // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n            mappedChild.key && (!_child || _child.key !== mappedChild.key) ?\n            // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n          }\n          array.push(mappedChild);\n        }\n        return 1;\n      }\n      var child;\n      var nextName;\n      var subtreeCount = 0; // Count of children found in the current subtree.\n\n      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n      if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          child = children[i];\n          nextName = nextNamePrefix + getElementKey(child, i);\n          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n        }\n      } else {\n        var iteratorFn = getIteratorFn(children);\n        if (typeof iteratorFn === 'function') {\n          var iterableChildren = children;\n          {\n            // Warn about using Maps as children\n            if (iteratorFn === iterableChildren.entries) {\n              if (!didWarnAboutMaps) {\n                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n              }\n              didWarnAboutMaps = true;\n            }\n          }\n          var iterator = iteratorFn.call(iterableChildren);\n          var step;\n          var ii = 0;\n          while (!(step = iterator.next()).done) {\n            child = step.value;\n            nextName = nextNamePrefix + getElementKey(child, ii++);\n            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n          }\n        } else if (type === 'object') {\n          // eslint-disable-next-line react-internal/safe-string-coercion\n          var childrenString = String(children);\n          throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n        }\n      }\n      return subtreeCount;\n    }\n\n    /**\n     * Maps children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n     *\n     * The provided mapFunction(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} func The map function.\n     * @param {*} context Context for mapFunction.\n     * @return {object} Object containing the ordered map of results.\n     */\n    function mapChildren(children, func, context) {\n      if (children == null) {\n        return children;\n      }\n      var result = [];\n      var count = 0;\n      mapIntoArray(children, result, '', '', function (child) {\n        return func.call(context, child, count++);\n      });\n      return result;\n    }\n    /**\n     * Count the number of children that are typically specified as\n     * `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrencount\n     *\n     * @param {?*} children Children tree container.\n     * @return {number} The number of children.\n     */\n\n    function countChildren(children) {\n      var n = 0;\n      mapChildren(children, function () {\n        n++; // Don't return anything\n      });\n      return n;\n    }\n\n    /**\n     * Iterates through children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n     *\n     * The provided forEachFunc(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} forEachFunc\n     * @param {*} forEachContext Context for forEachContext.\n     */\n    function forEachChildren(children, forEachFunc, forEachContext) {\n      mapChildren(children, function () {\n        forEachFunc.apply(this, arguments); // Don't return anything.\n      }, forEachContext);\n    }\n    /**\n     * Flatten a children object (typically specified as `props.children`) and\n     * return an array with appropriately re-keyed children.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n     */\n\n    function toArray(children) {\n      return mapChildren(children, function (child) {\n        return child;\n      }) || [];\n    }\n    /**\n     * Returns the first child in a collection of children and verifies that there\n     * is only one child in the collection.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n     *\n     * The current implementation of this function assumes that a single child gets\n     * passed without a wrapper, but the purpose of this helper function is to\n     * abstract away the particular structure of children.\n     *\n     * @param {?object} children Child collection structure.\n     * @return {ReactElement} The first and only `ReactElement` contained in the\n     * structure.\n     */\n\n    function onlyChild(children) {\n      if (!isValidElement(children)) {\n        throw new Error('React.Children.only expected to receive a single React element child.');\n      }\n      return children;\n    }\n    function createContext(defaultValue) {\n      // TODO: Second argument used to be an optional `calculateChangedBits`\n      // function. Warn to reserve for future use?\n      var context = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        // As a workaround to support multiple concurrent renderers, we categorize\n        // some renderers as primary and others as secondary. We only expect\n        // there to be two concurrent renderers at most: React Native (primary) and\n        // Fabric (secondary); React DOM (primary) and React ART (secondary).\n        // Secondary renderers store their context values on separate fields.\n        _currentValue: defaultValue,\n        _currentValue2: defaultValue,\n        // Used to track how many concurrent renderers this context currently\n        // supports within in a single renderer. Such as parallel server rendering.\n        _threadCount: 0,\n        // These are circular\n        Provider: null,\n        Consumer: null,\n        // Add these to use same hidden class in VM as ServerContext\n        _defaultValue: null,\n        _globalName: null\n      };\n      context.Provider = {\n        $$typeof: REACT_PROVIDER_TYPE,\n        _context: context\n      };\n      var hasWarnedAboutUsingNestedContextConsumers = false;\n      var hasWarnedAboutUsingConsumerProvider = false;\n      var hasWarnedAboutDisplayNameOnConsumer = false;\n      {\n        // A separate object, but proxies back to the original context object for\n        // backwards compatibility. It has a different $$typeof, so we can properly\n        // warn for the incorrect usage of Context as a Consumer.\n        var Consumer = {\n          $$typeof: REACT_CONTEXT_TYPE,\n          _context: context\n        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n        Object.defineProperties(Consumer, {\n          Provider: {\n            get: function () {\n              if (!hasWarnedAboutUsingConsumerProvider) {\n                hasWarnedAboutUsingConsumerProvider = true;\n                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n              }\n              return context.Provider;\n            },\n            set: function (_Provider) {\n              context.Provider = _Provider;\n            }\n          },\n          _currentValue: {\n            get: function () {\n              return context._currentValue;\n            },\n            set: function (_currentValue) {\n              context._currentValue = _currentValue;\n            }\n          },\n          _currentValue2: {\n            get: function () {\n              return context._currentValue2;\n            },\n            set: function (_currentValue2) {\n              context._currentValue2 = _currentValue2;\n            }\n          },\n          _threadCount: {\n            get: function () {\n              return context._threadCount;\n            },\n            set: function (_threadCount) {\n              context._threadCount = _threadCount;\n            }\n          },\n          Consumer: {\n            get: function () {\n              if (!hasWarnedAboutUsingNestedContextConsumers) {\n                hasWarnedAboutUsingNestedContextConsumers = true;\n                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n              }\n              return context.Consumer;\n            }\n          },\n          displayName: {\n            get: function () {\n              return context.displayName;\n            },\n            set: function (displayName) {\n              if (!hasWarnedAboutDisplayNameOnConsumer) {\n                warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n                hasWarnedAboutDisplayNameOnConsumer = true;\n              }\n            }\n          }\n        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n        context.Consumer = Consumer;\n      }\n      {\n        context._currentRenderer = null;\n        context._currentRenderer2 = null;\n      }\n      return context;\n    }\n    var Uninitialized = -1;\n    var Pending = 0;\n    var Resolved = 1;\n    var Rejected = 2;\n    function lazyInitializer(payload) {\n      if (payload._status === Uninitialized) {\n        var ctor = payload._result;\n        var thenable = ctor(); // Transition to the next state.\n        // This might throw either because it's missing or throws. If so, we treat it\n        // as still uninitialized and try again next time. Which is the same as what\n        // happens if the ctor or any wrappers processing the ctor throws. This might\n        // end up fixing it if the resolution was a concurrency bug.\n\n        thenable.then(function (moduleObject) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var resolved = payload;\n            resolved._status = Resolved;\n            resolved._result = moduleObject;\n          }\n        }, function (error) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var rejected = payload;\n            rejected._status = Rejected;\n            rejected._result = error;\n          }\n        });\n        if (payload._status === Uninitialized) {\n          // In case, we're still uninitialized, then we're waiting for the thenable\n          // to resolve. Set it as pending in the meantime.\n          var pending = payload;\n          pending._status = Pending;\n          pending._result = thenable;\n        }\n      }\n      if (payload._status === Resolved) {\n        var moduleObject = payload._result;\n        {\n          if (moduleObject === undefined) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n          }\n        }\n        {\n          if (!('default' in moduleObject)) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n          }\n        }\n        return moduleObject.default;\n      } else {\n        throw payload._result;\n      }\n    }\n    function lazy(ctor) {\n      var payload = {\n        // We use these fields to store the result.\n        _status: Uninitialized,\n        _result: ctor\n      };\n      var lazyType = {\n        $$typeof: REACT_LAZY_TYPE,\n        _payload: payload,\n        _init: lazyInitializer\n      };\n      {\n        // In production, this would just set it on the object.\n        var defaultProps;\n        var propTypes; // $FlowFixMe\n\n        Object.defineProperties(lazyType, {\n          defaultProps: {\n            configurable: true,\n            get: function () {\n              return defaultProps;\n            },\n            set: function (newDefaultProps) {\n              error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              defaultProps = newDefaultProps; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'defaultProps', {\n                enumerable: true\n              });\n            }\n          },\n          propTypes: {\n            configurable: true,\n            get: function () {\n              return propTypes;\n            },\n            set: function (newPropTypes) {\n              error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              propTypes = newPropTypes; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'propTypes', {\n                enumerable: true\n              });\n            }\n          }\n        });\n      }\n      return lazyType;\n    }\n    function forwardRef(render) {\n      {\n        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n          error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n        } else if (typeof render !== 'function') {\n          error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n        } else {\n          if (render.length !== 0 && render.length !== 2) {\n            error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n          }\n        }\n        if (render != null) {\n          if (render.defaultProps != null || render.propTypes != null) {\n            error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n          }\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_FORWARD_REF_TYPE,\n        render: render\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function () {\n            return ownName;\n          },\n          set: function (name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.forwardRef((props, ref) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!render.name && !render.displayName) {\n              render.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    }\n    var REACT_MODULE_REFERENCE;\n    {\n      REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n    }\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n        return true;\n      }\n      if (typeof type === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||\n        // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function memo(type, compare) {\n      {\n        if (!isValidElementType(type)) {\n          error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_MEMO_TYPE,\n        type: type,\n        compare: compare === undefined ? null : compare\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function () {\n            return ownName;\n          },\n          set: function (name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.memo((props) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!type.name && !type.displayName) {\n              type.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    }\n    function resolveDispatcher() {\n      var dispatcher = ReactCurrentDispatcher.current;\n      {\n        if (dispatcher === null) {\n          error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n        }\n      } // Will result in a null access error if accessed outside render phase. We\n      // intentionally don't throw our own error because this is in a hot path.\n      // Also helps ensure this is inlined.\n\n      return dispatcher;\n    }\n    function useContext(Context) {\n      var dispatcher = resolveDispatcher();\n      {\n        // TODO: add a more generic warning for invalid values.\n        if (Context._context !== undefined) {\n          var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n          // and nobody should be using this in existing code.\n\n          if (realContext.Consumer === Context) {\n            error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n          } else if (realContext.Provider === Context) {\n            error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n          }\n        }\n      }\n      return dispatcher.useContext(Context);\n    }\n    function useState(initialState) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useState(initialState);\n    }\n    function useReducer(reducer, initialArg, init) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useReducer(reducer, initialArg, init);\n    }\n    function useRef(initialValue) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useRef(initialValue);\n    }\n    function useEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useEffect(create, deps);\n    }\n    function useInsertionEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useInsertionEffect(create, deps);\n    }\n    function useLayoutEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useLayoutEffect(create, deps);\n    }\n    function useCallback(callback, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useCallback(callback, deps);\n    }\n    function useMemo(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useMemo(create, deps);\n    }\n    function useImperativeHandle(ref, create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useImperativeHandle(ref, create, deps);\n    }\n    function useDebugValue(value, formatterFn) {\n      {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useDebugValue(value, formatterFn);\n      }\n    }\n    function useTransition() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useTransition();\n    }\n    function useDeferredValue(value) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useDeferredValue(value);\n    }\n    function useId() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useId();\n    }\n    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    }\n\n    // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n    function disabledLog() {}\n    disabledLog.__reactDisabledLog = true;\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n        disabledDepth++;\n      }\n    }\n    function reenableLogs() {\n      {\n        disabledDepth--;\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: assign({}, props, {\n              value: prevLog\n            }),\n            info: assign({}, props, {\n              value: prevInfo\n            }),\n            warn: assign({}, props, {\n              value: prevWarn\n            }),\n            error: assign({}, props, {\n              value: prevError\n            }),\n            group: assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n        return '\\n' + prefix + name;\n      }\n    }\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n      {\n        var frame = componentFrameCache.get(fn);\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher$1.current = null;\n        disableLogs();\n      }\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                    // but we have a user-provided \"displayName\"\n                    // splice it in to make the stack more readable.\n\n                    if (fn.displayName && _frame.includes('<anonymous>')) {\n                      _frame = _frame.replace('<anonymous>', fn.displayName);\n                    }\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher$1.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n      return '';\n    }\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(hasOwnProperty);\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n              setCurrentlyValidatingElement(null);\n            }\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          setExtraStackFrame(stack);\n        } else {\n          setExtraStackFrame(null);\n        }\n      }\n    }\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n    function getDeclarationErrorAddendum() {\n      if (ReactCurrentOwner.current) {\n        var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n        if (name) {\n          return '\\n\\nCheck the render method of `' + name + '`.';\n        }\n      }\n      return '';\n    }\n    function getSourceInfoErrorAddendum(source) {\n      if (source !== undefined) {\n        var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n        var lineNumber = source.lineNumber;\n        return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n      }\n      return '';\n    }\n    function getSourceInfoErrorAddendumForProps(elementProps) {\n      if (elementProps !== null && elementProps !== undefined) {\n        return getSourceInfoErrorAddendum(elementProps.__source);\n      }\n      return '';\n    }\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n\n    var ownerHasKeyUseWarning = {};\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = getDeclarationErrorAddendum();\n      if (!info) {\n        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n        if (parentName) {\n          info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n        }\n      }\n      return info;\n    }\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n\n    function validateExplicitKey(element, parentType) {\n      if (!element._store || element._store.validated || element.key != null) {\n        return;\n      }\n      element._store.validated = true;\n      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n        return;\n      }\n      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n      // property, it may be the creator of the child that's responsible for\n      // assigning it a key.\n\n      var childOwner = '';\n      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n        // Give the component that originally created this child.\n        childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n      }\n      {\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n\n    function validateChildKeys(node, parentType) {\n      if (typeof node !== 'object') {\n        return;\n      }\n      if (isArray(node)) {\n        for (var i = 0; i < node.length; i++) {\n          var child = node[i];\n          if (isValidElement(child)) {\n            validateExplicitKey(child, parentType);\n          }\n        }\n      } else if (isValidElement(node)) {\n        // This element was passed in a valid location.\n        if (node._store) {\n          node._store.validated = true;\n        }\n      } else if (node) {\n        var iteratorFn = getIteratorFn(node);\n        if (typeof iteratorFn === 'function') {\n          // Entry iterators used to provide implicit keys,\n          // but now we print a separate warning for them later.\n          if (iteratorFn !== node.entries) {\n            var iterator = iteratorFn.call(node);\n            var step;\n            while (!(step = iterator.next()).done) {\n              if (isValidElement(step.value)) {\n                validateExplicitKey(step.value, parentType);\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n        var propTypes;\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||\n        // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentNameFromType(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentNameFromType(type);\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n    function createElementWithValidation(type, props, children) {\n      var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n\n      if (!validType) {\n        var info = '';\n        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n          info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n        }\n        var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n        if (sourceInfo) {\n          info += sourceInfo;\n        } else {\n          info += getDeclarationErrorAddendum();\n        }\n        var typeString;\n        if (type === null) {\n          typeString = 'null';\n        } else if (isArray(type)) {\n          typeString = 'array';\n        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n          typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n          info = ' Did you accidentally export a JSX literal instead of a component?';\n        } else {\n          typeString = typeof type;\n        }\n        {\n          error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n      }\n      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n      // TODO: Drop this when these are no longer allowed as the type argument.\n\n      if (element == null) {\n        return element;\n      } // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing errors.\n      // We don't want exception behavior to differ between dev and prod.\n      // (Rendering will throw with a helpful message and as soon as the type is\n      // fixed, the key warnings will appear.)\n\n      if (validType) {\n        for (var i = 2; i < arguments.length; i++) {\n          validateChildKeys(arguments[i], type);\n        }\n      }\n      if (type === REACT_FRAGMENT_TYPE) {\n        validateFragmentProps(element);\n      } else {\n        validatePropTypes(element);\n      }\n      return element;\n    }\n    var didWarnAboutDeprecatedCreateFactory = false;\n    function createFactoryWithValidation(type) {\n      var validatedFactory = createElementWithValidation.bind(null, type);\n      validatedFactory.type = type;\n      {\n        if (!didWarnAboutDeprecatedCreateFactory) {\n          didWarnAboutDeprecatedCreateFactory = true;\n          warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n        } // Legacy hook: remove it\n\n        Object.defineProperty(validatedFactory, 'type', {\n          enumerable: false,\n          get: function () {\n            warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n            Object.defineProperty(this, 'type', {\n              value: type\n            });\n            return type;\n          }\n        });\n      }\n      return validatedFactory;\n    }\n    function cloneElementWithValidation(element, props, children) {\n      var newElement = cloneElement.apply(this, arguments);\n      for (var i = 2; i < arguments.length; i++) {\n        validateChildKeys(arguments[i], newElement.type);\n      }\n      validatePropTypes(newElement);\n      return newElement;\n    }\n    function startTransition(scope, options) {\n      var prevTransition = ReactCurrentBatchConfig.transition;\n      ReactCurrentBatchConfig.transition = {};\n      var currentTransition = ReactCurrentBatchConfig.transition;\n      {\n        ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n      }\n      try {\n        scope();\n      } finally {\n        ReactCurrentBatchConfig.transition = prevTransition;\n        {\n          if (prevTransition === null && currentTransition._updatedFibers) {\n            var updatedFibersCount = currentTransition._updatedFibers.size;\n            if (updatedFibersCount > 10) {\n              warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n            }\n            currentTransition._updatedFibers.clear();\n          }\n        }\n      }\n    }\n    var didWarnAboutMessageChannel = false;\n    var enqueueTaskImpl = null;\n    function enqueueTask(task) {\n      if (enqueueTaskImpl === null) {\n        try {\n          // read require off the module object to get around the bundlers.\n          // we don't want them to detect a require and bundle a Node polyfill.\n          var requireString = ('require' + Math.random()).slice(0, 7);\n          var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n          // version of setImmediate, bypassing fake timers if any.\n\n          enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;\n        } catch (_err) {\n          // we're in a browser\n          // we can't use regular timers because they may still be faked\n          // so we try MessageChannel+postMessage instead\n          enqueueTaskImpl = function (callback) {\n            {\n              if (didWarnAboutMessageChannel === false) {\n                didWarnAboutMessageChannel = true;\n                if (typeof MessageChannel === 'undefined') {\n                  error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');\n                }\n              }\n            }\n            var channel = new MessageChannel();\n            channel.port1.onmessage = callback;\n            channel.port2.postMessage(undefined);\n          };\n        }\n      }\n      return enqueueTaskImpl(task);\n    }\n    var actScopeDepth = 0;\n    var didWarnNoAwaitAct = false;\n    function act(callback) {\n      {\n        // `act` calls can be nested, so we track the depth. This represents the\n        // number of `act` scopes on the stack.\n        var prevActScopeDepth = actScopeDepth;\n        actScopeDepth++;\n        if (ReactCurrentActQueue.current === null) {\n          // This is the outermost `act` scope. Initialize the queue. The reconciler\n          // will detect the queue and use it instead of Scheduler.\n          ReactCurrentActQueue.current = [];\n        }\n        var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n        var result;\n        try {\n          // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n          // set to `true` while the given callback is executed, not for updates\n          // triggered during an async event, because this is how the legacy\n          // implementation of `act` behaved.\n          ReactCurrentActQueue.isBatchingLegacy = true;\n          result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n          // which flushed updates immediately after the scope function exits, even\n          // if it's an async function.\n\n          if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n            var queue = ReactCurrentActQueue.current;\n            if (queue !== null) {\n              ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n              flushActQueue(queue);\n            }\n          }\n        } catch (error) {\n          popActScope(prevActScopeDepth);\n          throw error;\n        } finally {\n          ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n        }\n        if (result !== null && typeof result === 'object' && typeof result.then === 'function') {\n          var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n          // for it to resolve before exiting the current scope.\n\n          var wasAwaited = false;\n          var thenable = {\n            then: function (resolve, reject) {\n              wasAwaited = true;\n              thenableResult.then(function (returnValue) {\n                popActScope(prevActScopeDepth);\n                if (actScopeDepth === 0) {\n                  // We've exited the outermost act scope. Recursively flush the\n                  // queue until there's no remaining work.\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }, function (error) {\n                // The callback threw an error.\n                popActScope(prevActScopeDepth);\n                reject(error);\n              });\n            }\n          };\n          {\n            if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n              // eslint-disable-next-line no-undef\n              Promise.resolve().then(function () {}).then(function () {\n                if (!wasAwaited) {\n                  didWarnNoAwaitAct = true;\n                  error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n                }\n              });\n            }\n          }\n          return thenable;\n        } else {\n          var returnValue = result; // The callback is not an async function. Exit the current scope\n          // immediately, without awaiting.\n\n          popActScope(prevActScopeDepth);\n          if (actScopeDepth === 0) {\n            // Exiting the outermost act scope. Flush the queue.\n            var _queue = ReactCurrentActQueue.current;\n            if (_queue !== null) {\n              flushActQueue(_queue);\n              ReactCurrentActQueue.current = null;\n            } // Return a thenable. If the user awaits it, we'll flush again in\n            // case additional work was scheduled by a microtask.\n\n            var _thenable = {\n              then: function (resolve, reject) {\n                // Confirm we haven't re-entered another `act` scope, in case\n                // the user does something weird like await the thenable\n                // multiple times.\n                if (ReactCurrentActQueue.current === null) {\n                  // Recursively flush the queue until there's no remaining work.\n                  ReactCurrentActQueue.current = [];\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }\n            };\n            return _thenable;\n          } else {\n            // Since we're inside a nested `act` scope, the returned thenable\n            // immediately resolves. The outer scope will flush the queue.\n            var _thenable2 = {\n              then: function (resolve, reject) {\n                resolve(returnValue);\n              }\n            };\n            return _thenable2;\n          }\n        }\n      }\n    }\n    function popActScope(prevActScopeDepth) {\n      {\n        if (prevActScopeDepth !== actScopeDepth - 1) {\n          error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n        }\n        actScopeDepth = prevActScopeDepth;\n      }\n    }\n    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n      {\n        var queue = ReactCurrentActQueue.current;\n        if (queue !== null) {\n          try {\n            flushActQueue(queue);\n            enqueueTask(function () {\n              if (queue.length === 0) {\n                // No additional work was scheduled. Finish.\n                ReactCurrentActQueue.current = null;\n                resolve(returnValue);\n              } else {\n                // Keep flushing work until there's none left.\n                recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n              }\n            });\n          } catch (error) {\n            reject(error);\n          }\n        } else {\n          resolve(returnValue);\n        }\n      }\n    }\n    var isFlushing = false;\n    function flushActQueue(queue) {\n      {\n        if (!isFlushing) {\n          // Prevent re-entrance.\n          isFlushing = true;\n          var i = 0;\n          try {\n            for (; i < queue.length; i++) {\n              var callback = queue[i];\n              do {\n                callback = callback(true);\n              } while (callback !== null);\n            }\n            queue.length = 0;\n          } catch (error) {\n            // If something throws, leave the remaining callbacks on the queue.\n            queue = queue.slice(i + 1);\n            throw error;\n          } finally {\n            isFlushing = false;\n          }\n        }\n      }\n    }\n    var createElement$1 = createElementWithValidation;\n    var cloneElement$1 = cloneElementWithValidation;\n    var createFactory = createFactoryWithValidation;\n    var Children = {\n      map: mapChildren,\n      forEach: forEachChildren,\n      count: countChildren,\n      toArray: toArray,\n      only: onlyChild\n    };\n    exports.Children = Children;\n    exports.Component = Component;\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.Profiler = REACT_PROFILER_TYPE;\n    exports.PureComponent = PureComponent;\n    exports.StrictMode = REACT_STRICT_MODE_TYPE;\n    exports.Suspense = REACT_SUSPENSE_TYPE;\n    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n    exports.act = act;\n    exports.cloneElement = cloneElement$1;\n    exports.createContext = createContext;\n    exports.createElement = createElement$1;\n    exports.createFactory = createFactory;\n    exports.createRef = createRef;\n    exports.forwardRef = forwardRef;\n    exports.isValidElement = isValidElement;\n    exports.lazy = lazy;\n    exports.memo = memo;\n    exports.startTransition = startTransition;\n    exports.unstable_act = act;\n    exports.useCallback = useCallback;\n    exports.useContext = useContext;\n    exports.useDebugValue = useDebugValue;\n    exports.useDeferredValue = useDeferredValue;\n    exports.useEffect = useEffect;\n    exports.useId = useId;\n    exports.useImperativeHandle = useImperativeHandle;\n    exports.useInsertionEffect = useInsertionEffect;\n    exports.useLayoutEffect = useLayoutEffect;\n    exports.useMemo = useMemo;\n    exports.useReducer = useReducer;\n    exports.useRef = useRef;\n    exports.useState = useState;\n    exports.useSyncExternalStore = useSyncExternalStore;\n    exports.useTransition = useTransition;\n    exports.version = ReactVersion;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBLHlDQUF5Qzs7QUFFekMsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGFBQWE7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLGVBQWU7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsU0FBUyxHQUFHOztBQUVaLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtOQUFrTjtBQUNsTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0Isa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCLGlCQUFpQixXQUFXO0FBQzVCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0IsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFdBQVc7QUFDNUIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0IsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFdBQVc7QUFDNUIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QiwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixlQUFlLGVBQWU7QUFDOUIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRzs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZC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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSEFBK0g7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxHQUFHO0FBQ2xCOztBQUVBO0FBQ0E7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LElBQUksMERBQTBEO0FBQzlELElBQUksV0FBVztBQUNmLElBQUksb0JBQW9CO0FBQ3hCLElBQUkscUJBQXFCO0FBQ3pCLElBQUkscUJBQXFCO0FBQ3pCLElBQUkscUJBQXFCO0FBQ3pCLElBQUksaUJBQWlCO0FBQ3JCLElBQUksa0JBQWtCO0FBQ3RCLElBQUksc0JBQXNCO0FBQzFCLElBQUksWUFBWTtBQUNoQixJQUFJLFlBQVk7QUFDaEIsSUFBSSx1QkFBdUI7QUFDM0IsSUFBSSxvQkFBb0I7QUFDeEIsSUFBSSxtQkFBbUI7QUFDdkIsSUFBSSxrQkFBa0I7QUFDdEIsSUFBSSxxQkFBcUI7QUFDekIsSUFBSSx3QkFBd0I7QUFDNUIsSUFBSSxpQkFBaUI7QUFDckIsSUFBSSxhQUFhO0FBQ2pCLElBQUksMkJBQTJCO0FBQy9CLElBQUksMEJBQTBCO0FBQzlCLElBQUksdUJBQXVCO0FBQzNCLElBQUksZUFBZTtBQUNuQixJQUFJLGtCQUFrQjtBQUN0QixJQUFJLGNBQWM7QUFDbEIsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSw0QkFBNEI7QUFDaEMsSUFBSSxxQkFBcUI7QUFDekIsSUFBSSxlQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlfYXBwLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcz84N2YwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICAgIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChuZXcgRXJyb3IoKSk7XG4gICAgfVxuICAgIHZhciBSZWFjdFZlcnNpb24gPSAnMTguMy4xJztcblxuICAgIC8vIEFUVEVOVElPTlxuICAgIC8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbiAgICAvLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4gICAgLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG4gICAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgICB2YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgICB2YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gICAgdmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICAgIHZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgICB2YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gICAgdmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgICB2YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gICAgdmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICAgIHZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gICAgdmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgICB2YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xuICAgIHZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICAgIHZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG4gICAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgICAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICAgICAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hlci5cbiAgICAgKi9cbiAgICB2YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcbiAgICAgIC8qKlxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAgICAgKi9cbiAgICAgIGN1cnJlbnQ6IG51bGxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgYmF0Y2gncyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgaG93IGxvbmcgYW4gdXBkYXRlXG4gICAgICogc2hvdWxkIHN1c3BlbmQgZm9yIGlmIGl0IG5lZWRzIHRvLlxuICAgICAqL1xuICAgIHZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgICAgIHRyYW5zaXRpb246IG51bGxcbiAgICB9O1xuICAgIHZhciBSZWFjdEN1cnJlbnRBY3RRdWV1ZSA9IHtcbiAgICAgIGN1cnJlbnQ6IG51bGwsXG4gICAgICAvLyBVc2VkIHRvIHJlcHJvZHVjZSBiZWhhdmlvciBvZiBgYmF0Y2hlZFVwZGF0ZXNgIGluIGxlZ2FjeSBtb2RlLlxuICAgICAgaXNCYXRjaGluZ0xlZ2FjeTogZmFsc2UsXG4gICAgICBkaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZTogZmFsc2VcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gICAgICpcbiAgICAgKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gICAgICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICAgICAqL1xuICAgIHZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgICAgIC8qKlxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAgICAgKi9cbiAgICAgIGN1cnJlbnQ6IG51bGxcbiAgICB9O1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG4gICAgdmFyIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBudWxsO1xuICAgIGZ1bmN0aW9uIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjaykge1xuICAgICAge1xuICAgICAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gICAgICAgIH1cbiAgICAgIH07IC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGFjayA9ICcnOyAvLyBBZGQgYW4gZXh0cmEgdG9wIGZyYW1lIHdoaWxlIGFuIGVsZW1lbnQgaXMgYmVpbmcgdmFsaWRhdGVkXG5cbiAgICAgICAgaWYgKGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUpIHtcbiAgICAgICAgICBzdGFjayArPSBjdXJyZW50RXh0cmFTdGFja0ZyYW1lO1xuICAgICAgICB9IC8vIERlbGVnYXRlIHRvIHRoZSBpbmplY3RlZCByZW5kZXJlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuXG4gICAgICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIGlmIChpbXBsKSB7XG4gICAgICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG4gICAgdmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xuICAgIHZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xuXG4gICAgdmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbiAgICAvLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4gICAgLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbiAgICB2YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG4gICAgdmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lclxuICAgIH07XG4gICAge1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRBY3RRdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlO1xuICAgIH1cblxuICAgIC8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4gICAgLy9cbiAgICAvLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuICAgIC8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuICAgIGZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAgICAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gICAgICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAgICAgIHtcbiAgICAgICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgICAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuICAgICAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgICAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG4gICAgZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcbiAgICAgICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAgICAgKi9cblxuICAgIHZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgICAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKiBAZmluYWxcbiAgICAgICAqL1xuICAgICAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgICAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgICAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAgICAgKlxuICAgICAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgICAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICovXG4gICAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgICAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgICAgICpcbiAgICAgICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAgICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICovXG4gICAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICAgICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgICAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAgICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAgICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKi9cbiAgICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuICAgIHZhciBlbXB0eU9iamVjdCA9IHt9O1xuICAgIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAgICAgLy8gcmVuZGVyZXIuXG5cbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG4gICAgfVxuICAgIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuICAgIC8qKlxuICAgICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gICAgICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICAgKlxuICAgICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAgICAgKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAgICAgKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICAgICAqIGNvbXBsZXRlZC5cbiAgICAgKlxuICAgICAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICAgICAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICAgICAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gICAgICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAgICAgKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICAgICAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICAgICAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG5cbiAgICBDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGFydGlhbFN0YXRlICE9PSAnZnVuY3Rpb24nICYmIHBhcnRpYWxTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSAnICsgJ2Z1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cblxuICAgIENvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICAgICAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gICAgICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gICAgICovXG5cbiAgICB7XG4gICAgICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICAgICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgICAgIH07XG4gICAgICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdhcm4oJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuICAgIENvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuICAgIH1cbiAgICB2YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG4gICAgcHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7IC8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuXG4gICAgYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuICAgIHB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4gICAgLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbiAgICBmdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG4gICAgICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgICAgICBjdXJyZW50OiBudWxsXG4gICAgICB9O1xuICAgICAge1xuICAgICAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZk9iamVjdDtcbiAgICB9XG4gICAgdmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG4gICAgZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAgICAgKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICAgICAqXG4gICAgICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICAgICAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAgICAgKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICAgICAqL1xuICAgIC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG4gICAgZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgICAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICAgICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuICAgIGZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gICAgICB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAgICAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgICAgIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgICAgIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAgICAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgICAgIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAgICAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gICAgICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgICAgIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gICAgICAvL1xuICAgICAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAgICAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAgICAgLy9cbiAgICAgIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gICAgICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgICAgIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgICAgIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gICAgICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gICAgICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gICAgICAvL1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAge1xuICAgICAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcbiAgICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgIGlmIChkaXNwbGF5TmFtZSkge1xuICAgICAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gICAgICB9XG4gICAgICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbiAgICB9IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xuICAgIH0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAgICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiAnUG9ydGFsJztcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gICAgICBrZXk6IHRydWUsXG4gICAgICByZWY6IHRydWUsXG4gICAgICBfX3NlbGY6IHRydWUsXG4gICAgICBfX3NvdXJjZTogdHJ1ZVxuICAgIH07XG4gICAgdmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcbiAgICB7XG4gICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICAgICAge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZykge1xuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgY29uZmlnLl9fc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gY29uZmlnLl9fc2VsZikge1xuICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBjb25maWcucmVmKTtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICAgICAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gICAgICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gICAgICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdHlwZVxuICAgICAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAgICAgKiBAcGFyYW0geyp9IGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gICAgICogQHBhcmFtIHsqfSBvd25lclxuICAgICAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICAgICAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAgICAgKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICAgICAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAgICAgKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gICAgICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cblxuICAgIHZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHJlZjogcmVmLFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgICAgIF9vd25lcjogb3duZXJcbiAgICAgIH07XG4gICAgICB7XG4gICAgICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAgICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAgICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgICAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICAgICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAgICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgICAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgICAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IHNlbGZcbiAgICAgICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogc291cmNlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAgICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgIHZhciBrZXkgPSBudWxsO1xuICAgICAgdmFyIHJlZiA9IG51bGw7XG4gICAgICB2YXIgc2VsZiA9IG51bGw7XG4gICAgICB2YXIgc291cmNlID0gbnVsbDtcbiAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICAgICAge1xuICAgICAgICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgICAgICB9XG4gICAgICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICAgICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlOyAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gICAgICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuICAgICAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cbiAgICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB7XG4gICAgICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICAgICAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcbiAgICAgIHJldHVybiBuZXdFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAgICAgKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGVsZW1lbnQgKyBcIi5cIik7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcE5hbWU7IC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcblxuICAgICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gICAgICB2YXIgcmVmID0gZWxlbWVudC5yZWY7IC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG5cbiAgICAgIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAgICAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAgICAgLy8gdHJ1ZSBvd25lci5cblxuICAgICAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgICAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG5cbiAgICAgICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICAgICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gICAgICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuICAgICAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAgICAgKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICAgICAqIEBmaW5hbFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICAgIH1cbiAgICB2YXIgU0VQQVJBVE9SID0gJy4nO1xuICAgIHZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG4gICAgLyoqXG4gICAgICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgICAgIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gICAgICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAgICAgJz0nOiAnPTAnLFxuICAgICAgICAnOic6ICc9MidcbiAgICAgIH07XG4gICAgICB2YXIgZXNjYXBlZFN0cmluZyA9IGtleS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gICAgICogcGF0dGVybi5cbiAgICAgKi9cblxuICAgIHZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG4gICAgdmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbiAgICBmdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgZWxlbWVudCB3aXRoaW4gYSBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGVsZW1lbnQgQSBlbGVtZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICAgIC8vIEV4cGxpY2l0IGtleVxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihlbGVtZW50LmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVzY2FwZSgnJyArIGVsZW1lbnQua2V5KTtcbiAgICAgIH0gLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcblxuICAgICAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG4gICAgICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgICAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW47XG4gICAgICAgIHZhciBtYXBwZWRDaGlsZCA9IGNhbGxiYWNrKF9jaGlsZCk7IC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3M6XG5cbiAgICAgICAgdmFyIGNoaWxkS2V5ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldEVsZW1lbnRLZXkoX2NoaWxkLCAwKSA6IG5hbWVTb0ZhcjtcbiAgICAgICAgaWYgKGlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9ICcnO1xuICAgICAgICAgIGlmIChjaGlsZEtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBJbnRvQXJyYXkobWFwcGVkQ2hpbGQsIGFycmF5LCBlc2NhcGVkQ2hpbGRLZXksICcnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gVGhlIGBpZmAgc3RhdGVtZW50IGhlcmUgcHJldmVudHMgYXV0by1kaXNhYmxpbmcgb2YgdGhlIHNhZmVcbiAgICAgICAgICAgICAgLy8gY29lcmNpb24gRVNMaW50IHJ1bGUsIHNvIHdlIG11c3QgbWFudWFsbHkgZGlzYWJsZSBpdCBiZWxvdy5cbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgICAgICAgIGlmIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSkge1xuICAgICAgICAgICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWFwcGVkQ2hpbGQua2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAgICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICAgICAgICBlc2NhcGVkUHJlZml4ICsgKFxuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgICAgICBtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIGV4aXN0aW5nIGVsZW1lbnQncyBrZXkgY2FuIGJlIGEgbnVtYmVyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgICAgICAgIGVzY2FwZVVzZXJQcm92aWRlZEtleSgnJyArIG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFycmF5LnB1c2gobWFwcGVkQ2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkO1xuICAgICAgdmFyIG5leHROYW1lO1xuICAgICAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG5cbiAgICAgIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG4gICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgaXRlcmFibGVDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGl0ZXJhYmxlQ2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlQ2hpbGRyZW4pO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZykgKyBcIikuIFwiICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VidHJlZUNvdW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICAgICAqXG4gICAgICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gICAgICpcbiAgICAgKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICAgICAqIGxlYWYgY2hpbGQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICAgICAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCAnJywgJycsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gICAgICogYHByb3BzLmNoaWxkcmVuYC5cbiAgICAgKlxuICAgICAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmNvdW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgICB2YXIgbiA9IDA7XG4gICAgICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBuKys7IC8vIERvbid0IHJldHVybiBhbnl0aGluZ1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAgICAgKlxuICAgICAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmZvcmVhY2hcbiAgICAgKlxuICAgICAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gICAgICogbGVhZiBjaGlsZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAgICAgKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gICAgICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3JFYWNoRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmcuXG4gICAgICB9LCBmb3JFYWNoQ29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gICAgICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH0pIHx8IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAgICAgKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAgICAgKlxuICAgICAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAgICAgKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICAgICAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAgICAgKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gICAgICogc3RydWN0dXJlLlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkge1xuICAgICAgLy8gVE9ETzogU2Vjb25kIGFyZ3VtZW50IHVzZWQgdG8gYmUgYW4gb3B0aW9uYWwgYGNhbGN1bGF0ZUNoYW5nZWRCaXRzYFxuICAgICAgLy8gZnVuY3Rpb24uIFdhcm4gdG8gcmVzZXJ2ZSBmb3IgZnV0dXJlIHVzZT9cbiAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgICAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgICAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAgICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgICAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgICAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cbiAgICAgICAgX3RocmVhZENvdW50OiAwLFxuICAgICAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICAgICAgUHJvdmlkZXI6IG51bGwsXG4gICAgICAgIENvbnN1bWVyOiBudWxsLFxuICAgICAgICAvLyBBZGQgdGhlc2UgdG8gdXNlIHNhbWUgaGlkZGVuIGNsYXNzIGluIFZNIGFzIFNlcnZlckNvbnRleHRcbiAgICAgICAgX2RlZmF1bHRWYWx1ZTogbnVsbCxcbiAgICAgICAgX2dsb2JhbE5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgICBjb250ZXh0LlByb3ZpZGVyID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICAgICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgICAgIH07XG4gICAgICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgICAgIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IGZhbHNlO1xuICAgICAgdmFyIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gZmFsc2U7XG4gICAgICB7XG4gICAgICAgIC8vIEEgc2VwYXJhdGUgb2JqZWN0LCBidXQgcHJveGllcyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBjb250ZXh0IG9iamVjdCBmb3JcbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IGhhcyBhIGRpZmZlcmVudCAkJHR5cGVvZiwgc28gd2UgY2FuIHByb3Blcmx5XG4gICAgICAgIC8vIHdhcm4gZm9yIHRoZSBpbmNvcnJlY3QgdXNhZ2Ugb2YgQ29udGV4dCBhcyBhIENvbnN1bWVyLlxuICAgICAgICB2YXIgQ29uc3VtZXIgPSB7XG4gICAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgICAgICBfY29udGV4dDogY29udGV4dFxuICAgICAgICB9OyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBub3Qgc2V0dGluZyBhIHZhbHVlLCB3aGljaCBpcyBpbnRlbnRpb25hbCBoZXJlXG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29uc3VtZXIsIHtcbiAgICAgICAgICBQcm92aWRlcjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Qcm92aWRlcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Qcm92aWRlcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5Qcm92aWRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgY29udGV4dC5Qcm92aWRlciA9IF9Qcm92aWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIF9jdXJyZW50VmFsdWU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIF9jdXJyZW50VmFsdWUyOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZTIpIHtcbiAgICAgICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuX3RocmVhZENvdW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKF90aHJlYWRDb3VudCkge1xuICAgICAgICAgICAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IF90aHJlYWRDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycykge1xuICAgICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLkNvbnN1bWVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LkNvbnN1bWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlzcGxheU5hbWU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyKSB7XG4gICAgICAgICAgICAgICAgd2FybignU2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIENvbnRleHQuQ29uc3VtZXIgaGFzIG5vIGVmZmVjdC4gJyArIFwiWW91IHNob3VsZCBzZXQgaXQgZGlyZWN0bHkgb24gdGhlIGNvbnRleHQgd2l0aCBDb250ZXh0LmRpc3BsYXlOYW1lID0gJyVzJy5cIiwgZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG1pc3NpbmcgcHJvcGVydGllcyBiZWNhdXNlIGl0IGRvZXNuJ3QgdW5kZXJzdGFuZCBkZWZpbmVQcm9wZXJ0eVxuXG4gICAgICAgIGNvbnRleHQuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiAgICAgIH1cbiAgICAgIHtcbiAgICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgdmFyIFVuaW5pdGlhbGl6ZWQgPSAtMTtcbiAgICB2YXIgUGVuZGluZyA9IDA7XG4gICAgdmFyIFJlc29sdmVkID0gMTtcbiAgICB2YXIgUmVqZWN0ZWQgPSAyO1xuICAgIGZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgICAgICB2YXIgdGhlbmFibGUgPSBjdG9yKCk7IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgICAgIC8vIFRoaXMgbWlnaHQgdGhyb3cgZWl0aGVyIGJlY2F1c2UgaXQncyBtaXNzaW5nIG9yIHRocm93cy4gSWYgc28sIHdlIHRyZWF0IGl0XG4gICAgICAgIC8vIGFzIHN0aWxsIHVuaW5pdGlhbGl6ZWQgYW5kIHRyeSBhZ2FpbiBuZXh0IHRpbWUuIFdoaWNoIGlzIHRoZSBzYW1lIGFzIHdoYXRcbiAgICAgICAgLy8gaGFwcGVucyBpZiB0aGUgY3RvciBvciBhbnkgd3JhcHBlcnMgcHJvY2Vzc2luZyB0aGUgY3RvciB0aHJvd3MuIFRoaXMgbWlnaHRcbiAgICAgICAgLy8gZW5kIHVwIGZpeGluZyBpdCBpZiB0aGUgcmVzb2x1dGlvbiB3YXMgYSBjb25jdXJyZW5jeSBidWcuXG5cbiAgICAgICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZyB8fCBwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgICAgICAgICB2YXIgcmVzb2x2ZWQgPSBwYXlsb2FkO1xuICAgICAgICAgICAgcmVzb2x2ZWQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICAgICAgcmVzb2x2ZWQuX3Jlc3VsdCA9IG1vZHVsZU9iamVjdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcgfHwgcGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICAgICAgdmFyIHJlamVjdGVkID0gcGF5bG9hZDtcbiAgICAgICAgICAgIHJlamVjdGVkLl9zdGF0dXMgPSBSZWplY3RlZDtcbiAgICAgICAgICAgIHJlamVjdGVkLl9yZXN1bHQgPSBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgLy8gSW4gY2FzZSwgd2UncmUgc3RpbGwgdW5pbml0aWFsaXplZCwgdGhlbiB3ZSdyZSB3YWl0aW5nIGZvciB0aGUgdGhlbmFibGVcbiAgICAgICAgICAvLyB0byByZXNvbHZlLiBTZXQgaXQgYXMgcGVuZGluZyBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICAgICAgdmFyIHBlbmRpbmcgPSBwYXlsb2FkO1xuICAgICAgICAgIHBlbmRpbmcuX3N0YXR1cyA9IFBlbmRpbmc7XG4gICAgICAgICAgcGVuZGluZy5fcmVzdWx0ID0gdGhlbmFibGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFJlc29sdmVkKSB7XG4gICAgICAgIHZhciBtb2R1bGVPYmplY3QgPSBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobW9kdWxlT2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXAnICsgJ29ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICtcbiAgICAgICAgICAgIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVxcblxcblwiICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHB1dCBjdXJseSBicmFjZXMgYXJvdW5kIHRoZSBpbXBvcnQ/JywgbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIGlmICghKCdkZWZhdWx0JyBpbiBtb2R1bGVPYmplY3QpKSB7XG4gICAgICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wJyArICdvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArXG4gICAgICAgICAgICAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZU9iamVjdC5kZWZhdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcGF5bG9hZC5fcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsYXp5KGN0b3IpIHtcbiAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICAvLyBXZSB1c2UgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgICAgIF9zdGF0dXM6IFVuaW5pdGlhbGl6ZWQsXG4gICAgICAgIF9yZXN1bHQ6IGN0b3JcbiAgICAgIH07XG4gICAgICB2YXIgbGF6eVR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICBfaW5pdDogbGF6eUluaXRpYWxpemVyXG4gICAgICB9O1xuICAgICAge1xuICAgICAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgICAgIHZhciBwcm9wVHlwZXM7IC8vICRGbG93Rml4TWVcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5VHlwZSwge1xuICAgICAgICAgIGRlZmF1bHRQcm9wczoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0UHJvcHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG4gICAgICAgICAgICAgIGRlZmF1bHRQcm9wcyA9IG5ld0RlZmF1bHRQcm9wczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdkZWZhdWx0UHJvcHMnLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BUeXBlczoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UHJvcFR5cGVzKSB7XG4gICAgICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBwcm9wVHlwZXNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG4gICAgICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdwcm9wVHlwZXMnLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhenlUeXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICAgICAge1xuICAgICAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArICdjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgJyArICdtZW1vKGZvcndhcmRSZWYoLi4uKSkuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJlbmRlci5sZW5ndGggIT09IDAgJiYgcmVuZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLCByZW5kZXIubGVuZ3RoID09PSAxID8gJ0RpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj8nIDogJ0FueSBhZGRpdGlvbmFsIHBhcmFtZXRlciB3aWxsIGJlIHVuZGVmaW5lZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHJlbmRlci5kZWZhdWx0UHJvcHMgIT0gbnVsbCB8fCByZW5kZXIucHJvcFR5cGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICAgICAgcmVuZGVyOiByZW5kZXJcbiAgICAgIH07XG4gICAgICB7XG4gICAgICAgIHZhciBvd25OYW1lO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIG93bk5hbWUgPSBuYW1lOyAvLyBUaGUgaW5uZXIgY29tcG9uZW50IHNob3VsZG4ndCBpbmhlcml0IHRoaXMgZGlzcGxheSBuYW1lIGluIG1vc3QgY2FzZXMsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBjb21wb25lbnQgbWF5IGJlIHVzZWQgZWxzZXdoZXJlLlxuICAgICAgICAgICAgLy8gQnV0IGl0J3MgbmljZSBmb3IgYW5vbnltb3VzIGZ1bmN0aW9ucyB0byBpbmhlcml0IHRoZSBuYW1lLFxuICAgICAgICAgICAgLy8gc28gdGhhdCBvdXIgY29tcG9uZW50LXN0YWNrIGdlbmVyYXRpb24gbG9naWMgd2lsbCBkaXNwbGF5IHRoZWlyIGZyYW1lcy5cbiAgICAgICAgICAgIC8vIEFuIGFub255bW91cyBmdW5jdGlvbiBnZW5lcmFsbHkgc3VnZ2VzdHMgYSBwYXR0ZXJuIGxpa2U6XG4gICAgICAgICAgICAvLyAgIFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHsuLi59KTtcbiAgICAgICAgICAgIC8vIFRoaXMga2luZCBvZiBpbm5lciBmdW5jdGlvbiBpcyBub3QgdXNlZCBlbHNld2hlcmUgc28gdGhlIHNpZGUgZWZmZWN0IGlzIG9rYXkuXG5cbiAgICAgICAgICAgIGlmICghcmVuZGVyLm5hbWUgJiYgIXJlbmRlci5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICByZW5kZXIuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudFR5cGU7XG4gICAgfVxuICAgIHZhciBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFO1xuICAgIHtcbiAgICAgIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5tb2R1bGUucmVmZXJlbmNlJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSB8fCBlbmFibGVDYWNoZUVsZW1lbnQgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAgICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgICAgIC8vIHdpdGguXG4gICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVtbyh0eXBlLCBjb21wYXJlKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgZXJyb3IoJ21lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkICcgKyAncmVjZWl2ZWQ6ICVzJywgdHlwZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBjb21wYXJlOiBjb21wYXJlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcGFyZVxuICAgICAgfTtcbiAgICAgIHtcbiAgICAgICAgdmFyIG93bk5hbWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgb3duTmFtZSA9IG5hbWU7IC8vIFRoZSBpbm5lciBjb21wb25lbnQgc2hvdWxkbid0IGluaGVyaXQgdGhpcyBkaXNwbGF5IG5hbWUgaW4gbW9zdCBjYXNlcyxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBtYXkgYmUgdXNlZCBlbHNld2hlcmUuXG4gICAgICAgICAgICAvLyBCdXQgaXQncyBuaWNlIGZvciBhbm9ueW1vdXMgZnVuY3Rpb25zIHRvIGluaGVyaXQgdGhlIG5hbWUsXG4gICAgICAgICAgICAvLyBzbyB0aGF0IG91ciBjb21wb25lbnQtc3RhY2sgZ2VuZXJhdGlvbiBsb2dpYyB3aWxsIGRpc3BsYXkgdGhlaXIgZnJhbWVzLlxuICAgICAgICAgICAgLy8gQW4gYW5vbnltb3VzIGZ1bmN0aW9uIGdlbmVyYWxseSBzdWdnZXN0cyBhIHBhdHRlcm4gbGlrZTpcbiAgICAgICAgICAgIC8vICAgUmVhY3QubWVtbygocHJvcHMpID0+IHsuLi59KTtcbiAgICAgICAgICAgIC8vIFRoaXMga2luZCBvZiBpbm5lciBmdW5jdGlvbiBpcyBub3QgdXNlZCBlbHNld2hlcmUgc28gdGhlIHNpZGUgZWZmZWN0IGlzIG9rYXkuXG5cbiAgICAgICAgICAgIGlmICghdHlwZS5uYW1lICYmICF0eXBlLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudFR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG4gICAgICB7XG4gICAgICAgIGlmIChkaXNwYXRjaGVyID09PSBudWxsKSB7XG4gICAgICAgICAgZXJyb3IoJ0ludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3InICsgJyBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbicgKyAnMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuJyArICcyLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuJyArICczLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS4nKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXaWxsIHJlc3VsdCBpbiBhIG51bGwgYWNjZXNzIGVycm9yIGlmIGFjY2Vzc2VkIG91dHNpZGUgcmVuZGVyIHBoYXNlLiBXZVxuICAgICAgLy8gaW50ZW50aW9uYWxseSBkb24ndCB0aHJvdyBvdXIgb3duIGVycm9yIGJlY2F1c2UgdGhpcyBpcyBpbiBhIGhvdCBwYXRoLlxuICAgICAgLy8gQWxzbyBoZWxwcyBlbnN1cmUgdGhpcyBpcyBpbmxpbmVkLlxuXG4gICAgICByZXR1cm4gZGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlQ29udGV4dChDb250ZXh0KSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cbiAgICAgICAgaWYgKENvbnRleHQuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciByZWFsQ29udGV4dCA9IENvbnRleHQuX2NvbnRleHQ7IC8vIERvbid0IGRlZHVwbGljYXRlIGJlY2F1c2UgdGhpcyBsZWdpdGltYXRlbHkgY2F1c2VzIGJ1Z3NcbiAgICAgICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgICAgICBpZiAocmVhbENvbnRleHQuQ29uc3VtZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCwgbWF5IGNhdXNlIGJ1Z3MsIGFuZCB3aWxsIGJlICcgKyAncmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LlByb3ZpZGVyKSBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VUcmFuc2l0aW9uKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlVHJhbnNpdGlvbigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlSWQoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VJZCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIH1cblxuICAgIC8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbiAgICAvLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuICAgIC8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbiAgICAvLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbiAgICB2YXIgZGlzYWJsZWREZXB0aCA9IDA7XG4gICAgdmFyIHByZXZMb2c7XG4gICAgdmFyIHByZXZJbmZvO1xuICAgIHZhciBwcmV2V2FybjtcbiAgICB2YXIgcHJldkVycm9yO1xuICAgIHZhciBwcmV2R3JvdXA7XG4gICAgdmFyIHByZXZHcm91cENvbGxhcHNlZDtcbiAgICB2YXIgcHJldkdyb3VwRW5kO1xuICAgIGZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cbiAgICBkaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICAgICAge1xuICAgICAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc2FibGVkRGVwdGgrKztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICAgICAge1xuICAgICAgICBkaXNhYmxlZERlcHRoLS07XG4gICAgICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xuICAgIHZhciBwcmVmaXg7XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG4gICAgICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZWVudHJ5ID0gZmFsc2U7XG4gICAgdmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG4gICAge1xuICAgICAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gICAgICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAge1xuICAgICAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG4gICAgICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY29udHJvbDtcbiAgICAgIHJlZW50cnkgPSB0cnVlO1xuICAgICAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHtcbiAgICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgICAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBkaXNhYmxlTG9ncygpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgICBjLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlZW50cnkgPSBmYWxzZTtcbiAgICAgICAge1xuICAgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgICAgICB9XG4gICAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG4gICAgICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICAgICAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3ludGhldGljRnJhbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gICAgICB7XG4gICAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgICAgIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAgICAgIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICAgICAge1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgICAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcbiAgICAgICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcbiAgICAgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICAgICAge1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuICAgIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gICAgICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMuX19zb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gICAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAgICogdXBkYXRlcy5cbiAgICAgKi9cblxuICAgIHZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICBpZiAoIWluZm8pIHtcbiAgICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICAgICAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICAgICAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICAgICAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICAgICAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICAgICAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICAgICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICAgICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgICAgfVxuICAgICAge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuICAgICAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICAgICAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICAgICAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gICAgICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAgICAgKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gICAgICB7XG4gICAgICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wVHlwZXM7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuICAgICAgICAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gICAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG4gICAgICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG4gICAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcbiAgICAgICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKHByb3BzKTtcbiAgICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZVN0cmluZztcbiAgICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cbiAgICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICB2YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICAgICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG4gICAgICB7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IHRydWU7XG4gICAgICAgICAgd2FybignUmVhY3QuY3JlYXRlRmFjdG9yeSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIENvbnNpZGVyIHVzaW5nIEpTWCAnICsgJ29yIHVzZSBSZWFjdC5jcmVhdGVFbGVtZW50KCkgZGlyZWN0bHkgaW5zdGVhZC4nKTtcbiAgICAgICAgfSAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2FybignRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICAgICAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICAgICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihzY29wZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbjtcbiAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24gPSB7fTtcbiAgICAgIHZhciBjdXJyZW50VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb247XG4gICAgICB7XG4gICAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBzY29wZSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHByZXZUcmFuc2l0aW9uID09PSBudWxsICYmIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlZEZpYmVyc0NvdW50ID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkRmliZXJzQ291bnQgPiAxMCkge1xuICAgICAgICAgICAgICB3YXJuKCdEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uICcgKyAnSWYgdGhpcyBpcyBkdWUgdG8gYSBzdWJzY3JpcHRpb24gcGxlYXNlIHJlLXdyaXRlIGl0IHRvIHVzZSBSZWFjdCBwcm92aWRlZCBob29rcy4gJyArICdPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgPSBmYWxzZTtcbiAgICB2YXIgZW5xdWV1ZVRhc2tJbXBsID0gbnVsbDtcbiAgICBmdW5jdGlvbiBlbnF1ZXVlVGFzayh0YXNrKSB7XG4gICAgICBpZiAoZW5xdWV1ZVRhc2tJbXBsID09PSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gcmVhZCByZXF1aXJlIG9mZiB0aGUgbW9kdWxlIG9iamVjdCB0byBnZXQgYXJvdW5kIHRoZSBidW5kbGVycy5cbiAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoZW0gdG8gZGV0ZWN0IGEgcmVxdWlyZSBhbmQgYnVuZGxlIGEgTm9kZSBwb2x5ZmlsbC5cbiAgICAgICAgICB2YXIgcmVxdWlyZVN0cmluZyA9ICgncmVxdWlyZScgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgwLCA3KTtcbiAgICAgICAgICB2YXIgbm9kZVJlcXVpcmUgPSBtb2R1bGUgJiYgbW9kdWxlW3JlcXVpcmVTdHJpbmddOyAvLyBhc3N1bWluZyB3ZSdyZSBpbiBub2RlLCBsZXQncyB0cnkgdG8gZ2V0IG5vZGUnc1xuICAgICAgICAgIC8vIHZlcnNpb24gb2Ygc2V0SW1tZWRpYXRlLCBieXBhc3NpbmcgZmFrZSB0aW1lcnMgaWYgYW55LlxuXG4gICAgICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gbm9kZVJlcXVpcmUuY2FsbChtb2R1bGUsICd0aW1lcnMnKS5zZXRJbW1lZGlhdGU7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAvLyB3ZSdyZSBpbiBhIGJyb3dzZXJcbiAgICAgICAgICAvLyB3ZSBjYW4ndCB1c2UgcmVndWxhciB0aW1lcnMgYmVjYXVzZSB0aGV5IG1heSBzdGlsbCBiZSBmYWtlZFxuICAgICAgICAgIC8vIHNvIHdlIHRyeSBNZXNzYWdlQ2hhbm5lbCtwb3N0TWVzc2FnZSBpbnN0ZWFkXG4gICAgICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdUaGlzIGJyb3dzZXIgZG9lcyBub3QgaGF2ZSBhIE1lc3NhZ2VDaGFubmVsIGltcGxlbWVudGF0aW9uLCAnICsgJ3NvIGVucXVldWluZyB0YXNrcyB2aWEgYXdhaXQgYWN0KGFzeW5jICgpID0+IC4uLikgd2lsbCBmYWlsLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMgJyArICdpZiB5b3UgZW5jb3VudGVyIHRoaXMgd2FybmluZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSh1bmRlZmluZWQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbnF1ZXVlVGFza0ltcGwodGFzayk7XG4gICAgfVxuICAgIHZhciBhY3RTY29wZURlcHRoID0gMDtcbiAgICB2YXIgZGlkV2Fybk5vQXdhaXRBY3QgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBhY3QoY2FsbGJhY2spIHtcbiAgICAgIHtcbiAgICAgICAgLy8gYGFjdGAgY2FsbHMgY2FuIGJlIG5lc3RlZCwgc28gd2UgdHJhY2sgdGhlIGRlcHRoLiBUaGlzIHJlcHJlc2VudHMgdGhlXG4gICAgICAgIC8vIG51bWJlciBvZiBgYWN0YCBzY29wZXMgb24gdGhlIHN0YWNrLlxuICAgICAgICB2YXIgcHJldkFjdFNjb3BlRGVwdGggPSBhY3RTY29wZURlcHRoO1xuICAgICAgICBhY3RTY29wZURlcHRoKys7XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb3V0ZXJtb3N0IGBhY3RgIHNjb3BlLiBJbml0aWFsaXplIHRoZSBxdWV1ZS4gVGhlIHJlY29uY2lsZXJcbiAgICAgICAgICAvLyB3aWxsIGRldGVjdCB0aGUgcXVldWUgYW5kIHVzZSBpdCBpbnN0ZWFkIG9mIFNjaGVkdWxlci5cbiAgICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZJc0JhdGNoaW5nTGVnYWN5ID0gUmVhY3RDdXJyZW50QWN0UXVldWUuaXNCYXRjaGluZ0xlZ2FjeTtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBVc2VkIHRvIHJlcHJvZHVjZSBiZWhhdmlvciBvZiBgYmF0Y2hlZFVwZGF0ZXNgIGluIGxlZ2FjeSBtb2RlLiBPbmx5XG4gICAgICAgICAgLy8gc2V0IHRvIGB0cnVlYCB3aGlsZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgaXMgZXhlY3V0ZWQsIG5vdCBmb3IgdXBkYXRlc1xuICAgICAgICAgIC8vIHRyaWdnZXJlZCBkdXJpbmcgYW4gYXN5bmMgZXZlbnQsIGJlY2F1c2UgdGhpcyBpcyBob3cgdGhlIGxlZ2FjeVxuICAgICAgICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIGBhY3RgIGJlaGF2ZWQuXG4gICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuaXNCYXRjaGluZ0xlZ2FjeSA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2soKTsgLy8gUmVwbGljYXRlIGJlaGF2aW9yIG9mIG9yaWdpbmFsIGBhY3RgIGltcGxlbWVudGF0aW9uIGluIGxlZ2FjeSBtb2RlLFxuICAgICAgICAgIC8vIHdoaWNoIGZsdXNoZWQgdXBkYXRlcyBpbW1lZGlhdGVseSBhZnRlciB0aGUgc2NvcGUgZnVuY3Rpb24gZXhpdHMsIGV2ZW5cbiAgICAgICAgICAvLyBpZiBpdCdzIGFuIGFzeW5jIGZ1bmN0aW9uLlxuXG4gICAgICAgICAgaWYgKCFwcmV2SXNCYXRjaGluZ0xlZ2FjeSAmJiBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5kaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHF1ZXVlID0gUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChxdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5kaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFNjb3BlRGVwdGgpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmlzQmF0Y2hpbmdMZWdhY3kgPSBwcmV2SXNCYXRjaGluZ0xlZ2FjeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB0aGVuYWJsZVJlc3VsdCA9IHJlc3VsdDsgLy8gVGhlIGNhbGxiYWNrIGlzIGFuIGFzeW5jIGZ1bmN0aW9uIChpLmUuIHJldHVybmVkIGEgcHJvbWlzZSkuIFdhaXRcbiAgICAgICAgICAvLyBmb3IgaXQgdG8gcmVzb2x2ZSBiZWZvcmUgZXhpdGluZyB0aGUgY3VycmVudCBzY29wZS5cblxuICAgICAgICAgIHZhciB3YXNBd2FpdGVkID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHRoZW5hYmxlID0ge1xuICAgICAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICB3YXNBd2FpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhlbmFibGVSZXN1bHQudGhlbihmdW5jdGlvbiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGFjdFNjb3BlRGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGV4aXRlZCB0aGUgb3V0ZXJtb3N0IGFjdCBzY29wZS4gUmVjdXJzaXZlbHkgZmx1c2ggdGhlXG4gICAgICAgICAgICAgICAgICAvLyBxdWV1ZSB1bnRpbCB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLlxuICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFNjb3BlRGVwdGgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFkaWRXYXJuTm9Bd2FpdEFjdCAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge30pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghd2FzQXdhaXRlZCkge1xuICAgICAgICAgICAgICAgICAgZGlkV2Fybk5vQXdhaXRBY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ1lvdSBjYWxsZWQgYWN0KGFzeW5jICgpID0+IC4uLikgd2l0aG91dCBhd2FpdC4gJyArICdUaGlzIGNvdWxkIGxlYWQgdG8gdW5leHBlY3RlZCB0ZXN0aW5nIGJlaGF2aW91ciwgJyArICdpbnRlcmxlYXZpbmcgbXVsdGlwbGUgYWN0IGNhbGxzIGFuZCBtaXhpbmcgdGhlaXIgJyArICdzY29wZXMuICcgKyAnWW91IHNob3VsZCAtIGF3YWl0IGFjdChhc3luYyAoKSA9PiAuLi4pOycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSByZXN1bHQ7IC8vIFRoZSBjYWxsYmFjayBpcyBub3QgYW4gYXN5bmMgZnVuY3Rpb24uIEV4aXQgdGhlIGN1cnJlbnQgc2NvcGVcbiAgICAgICAgICAvLyBpbW1lZGlhdGVseSwgd2l0aG91dCBhd2FpdGluZy5cblxuICAgICAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgICAgICBpZiAoYWN0U2NvcGVEZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRXhpdGluZyB0aGUgb3V0ZXJtb3N0IGFjdCBzY29wZS4gRmx1c2ggdGhlIHF1ZXVlLlxuICAgICAgICAgICAgdmFyIF9xdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoX3F1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGZsdXNoQWN0UXVldWUoX3F1ZXVlKTtcbiAgICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9IC8vIFJldHVybiBhIHRoZW5hYmxlLiBJZiB0aGUgdXNlciBhd2FpdHMgaXQsIHdlJ2xsIGZsdXNoIGFnYWluIGluXG4gICAgICAgICAgICAvLyBjYXNlIGFkZGl0aW9uYWwgd29yayB3YXMgc2NoZWR1bGVkIGJ5IGEgbWljcm90YXNrLlxuXG4gICAgICAgICAgICB2YXIgX3RoZW5hYmxlID0ge1xuICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gQ29uZmlybSB3ZSBoYXZlbid0IHJlLWVudGVyZWQgYW5vdGhlciBgYWN0YCBzY29wZSwgaW4gY2FzZVxuICAgICAgICAgICAgICAgIC8vIHRoZSB1c2VyIGRvZXMgc29tZXRoaW5nIHdlaXJkIGxpa2UgYXdhaXQgdGhlIHRoZW5hYmxlXG4gICAgICAgICAgICAgICAgLy8gbXVsdGlwbGUgdGltZXMuXG4gICAgICAgICAgICAgICAgaWYgKFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsdXNoIHRoZSBxdWV1ZSB1bnRpbCB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLlxuICAgICAgICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IFtdO1xuICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIF90aGVuYWJsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2luY2Ugd2UncmUgaW5zaWRlIGEgbmVzdGVkIGBhY3RgIHNjb3BlLCB0aGUgcmV0dXJuZWQgdGhlbmFibGVcbiAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHJlc29sdmVzLiBUaGUgb3V0ZXIgc2NvcGUgd2lsbCBmbHVzaCB0aGUgcXVldWUuXG4gICAgICAgICAgICB2YXIgX3RoZW5hYmxlMiA9IHtcbiAgICAgICAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIF90aGVuYWJsZTI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChwcmV2QWN0U2NvcGVEZXB0aCAhPT0gYWN0U2NvcGVEZXB0aCAtIDEpIHtcbiAgICAgICAgICBlcnJvcignWW91IHNlZW0gdG8gaGF2ZSBvdmVybGFwcGluZyBhY3QoKSBjYWxscywgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0JlIHN1cmUgdG8gYXdhaXQgcHJldmlvdXMgYWN0KCkgY2FsbHMgYmVmb3JlIG1ha2luZyBhIG5ldyBvbmUuICcpO1xuICAgICAgICB9XG4gICAgICAgIGFjdFNjb3BlRGVwdGggPSBwcmV2QWN0U2NvcGVEZXB0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG4gICAgICAgIGlmIChxdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKTtcbiAgICAgICAgICAgIGVucXVldWVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIGFkZGl0aW9uYWwgd29yayB3YXMgc2NoZWR1bGVkLiBGaW5pc2guXG4gICAgICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gS2VlcCBmbHVzaGluZyB3b3JrIHVudGlsIHRoZXJlJ3Mgbm9uZSBsZWZ0LlxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaXNGbHVzaGluZyA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGZsdXNoQWN0UXVldWUocXVldWUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFpc0ZsdXNoaW5nKSB7XG4gICAgICAgICAgLy8gUHJldmVudCByZS1lbnRyYW5jZS5cbiAgICAgICAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICB9IHdoaWxlIChjYWxsYmFjayAhPT0gbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgdGhyb3dzLCBsZWF2ZSB0aGUgcmVtYWluaW5nIGNhbGxiYWNrcyBvbiB0aGUgcXVldWUuXG4gICAgICAgICAgICBxdWV1ZSA9IHF1ZXVlLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjcmVhdGVFbGVtZW50JDEgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb247XG4gICAgdmFyIGNsb25lRWxlbWVudCQxID0gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb247XG4gICAgdmFyIGNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb247XG4gICAgdmFyIENoaWxkcmVuID0ge1xuICAgICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgICAgIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICAgICAgdG9BcnJheTogdG9BcnJheSxcbiAgICAgIG9ubHk6IG9ubHlDaGlsZFxuICAgIH07XG4gICAgZXhwb3J0cy5DaGlsZHJlbiA9IENoaWxkcmVuO1xuICAgIGV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIGV4cG9ydHMuUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICAgIGV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG4gICAgZXhwb3J0cy5TdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbiAgICBleHBvcnRzLlN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbiAgICBleHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG4gICAgZXhwb3J0cy5hY3QgPSBhY3Q7XG4gICAgZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQkMTtcbiAgICBleHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuICAgIGV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbiAgICBleHBvcnRzLmNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5O1xuICAgIGV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuICAgIGV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG4gICAgZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuICAgIGV4cG9ydHMubGF6eSA9IGxhenk7XG4gICAgZXhwb3J0cy5tZW1vID0gbWVtbztcbiAgICBleHBvcnRzLnN0YXJ0VHJhbnNpdGlvbiA9IHN0YXJ0VHJhbnNpdGlvbjtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2FjdCA9IGFjdDtcbiAgICBleHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG4gICAgZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbiAgICBleHBvcnRzLnVzZURlYnVnVmFsdWUgPSB1c2VEZWJ1Z1ZhbHVlO1xuICAgIGV4cG9ydHMudXNlRGVmZXJyZWRWYWx1ZSA9IHVzZURlZmVycmVkVmFsdWU7XG4gICAgZXhwb3J0cy51c2VFZmZlY3QgPSB1c2VFZmZlY3Q7XG4gICAgZXhwb3J0cy51c2VJZCA9IHVzZUlkO1xuICAgIGV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG4gICAgZXhwb3J0cy51c2VJbnNlcnRpb25FZmZlY3QgPSB1c2VJbnNlcnRpb25FZmZlY3Q7XG4gICAgZXhwb3J0cy51c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3Q7XG4gICAgZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbiAgICBleHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuICAgIGV4cG9ydHMudXNlUmVmID0gdXNlUmVmO1xuICAgIGV4cG9ydHMudXNlU3RhdGUgPSB1c2VTdGF0ZTtcbiAgICBleHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmU7XG4gICAgZXhwb3J0cy51c2VUcmFuc2l0aW9uID0gdXNlVHJhbnNpdGlvbjtcbiAgICBleHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICAgIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xuICAgIH1cbiAgfSkoKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react.development.js\n");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHVIQUFzRDtBQUN4RCIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcz85Y2VjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/index.js\n");

/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n    var enableSchedulerDebugging = false;\n    var enableProfiling = false;\n    var frameYieldMs = 5;\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      siftUp(heap, node, index);\n    }\n    function peek(heap) {\n      return heap.length === 0 ? null : heap[0];\n    }\n    function pop(heap) {\n      if (heap.length === 0) {\n        return null;\n      }\n      var first = heap[0];\n      var last = heap.pop();\n      if (last !== first) {\n        heap[0] = last;\n        siftDown(heap, last, 0);\n      }\n      return first;\n    }\n    function siftUp(heap, node, i) {\n      var index = i;\n      while (index > 0) {\n        var parentIndex = index - 1 >>> 1;\n        var parent = heap[parentIndex];\n        if (compare(parent, node) > 0) {\n          // The parent is larger. Swap positions.\n          heap[parentIndex] = node;\n          heap[index] = parent;\n          index = parentIndex;\n        } else {\n          // The parent is smaller. Exit.\n          return;\n        }\n      }\n    }\n    function siftDown(heap, node, i) {\n      var index = i;\n      var length = heap.length;\n      var halfLength = length >>> 1;\n      while (index < halfLength) {\n        var leftIndex = (index + 1) * 2 - 1;\n        var left = heap[leftIndex];\n        var rightIndex = leftIndex + 1;\n        var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n\n        if (compare(left, node) < 0) {\n          if (rightIndex < length && compare(right, left) < 0) {\n            heap[index] = right;\n            heap[rightIndex] = node;\n            index = rightIndex;\n          } else {\n            heap[index] = left;\n            heap[leftIndex] = node;\n            index = leftIndex;\n          }\n        } else if (rightIndex < length && compare(right, node) < 0) {\n          heap[index] = right;\n          heap[rightIndex] = node;\n          index = rightIndex;\n        } else {\n          // Neither child is smaller. Exit.\n          return;\n        }\n      }\n    }\n    function compare(a, b) {\n      // Compare sort index first, then task id.\n      var diff = a.sortIndex - b.sortIndex;\n      return diff !== 0 ? diff : a.id - b.id;\n    }\n\n    // TODO: Use symbols?\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var LowPriority = 4;\n    var IdlePriority = 5;\n    function markTaskErrored(task, ms) {}\n\n    /* eslint-disable no-var */\n\n    var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n    if (hasPerformanceNow) {\n      var localPerformance = performance;\n      exports.unstable_now = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date;\n      var initialTime = localDate.now();\n      exports.unstable_now = function () {\n        return localDate.now() - initialTime;\n      };\n    } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n\n    var maxSigned31BitInt = 1073741823; // Times out immediately\n\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\n    var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\n    var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n\n    var taskQueue = [];\n    var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\n    var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n    var currentTask = null;\n    var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n\n    var isPerformingWork = false;\n    var isHostCallbackScheduled = false;\n    var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;\n    var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom\n\n    var isInputPending = typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n    function advanceTimers(currentTime) {\n      // Check for tasks that are no longer delayed and add them to the queue.\n      var timer = peek(timerQueue);\n      while (timer !== null) {\n        if (timer.callback === null) {\n          // Timer was cancelled.\n          pop(timerQueue);\n        } else if (timer.startTime <= currentTime) {\n          // Timer fired. Transfer to the task queue.\n          pop(timerQueue);\n          timer.sortIndex = timer.expirationTime;\n          push(taskQueue, timer);\n        } else {\n          // Remaining timers are pending.\n          return;\n        }\n        timer = peek(timerQueue);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = false;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled) {\n        if (peek(taskQueue) !== null) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        } else {\n          var firstTimer = peek(timerQueue);\n          if (firstTimer !== null) {\n            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n          }\n        }\n      }\n    }\n    function flushWork(hasTimeRemaining, initialTime) {\n      isHostCallbackScheduled = false;\n      if (isHostTimeoutScheduled) {\n        // We scheduled a timeout but it's no longer needed. Cancel it.\n        isHostTimeoutScheduled = false;\n        cancelHostTimeout();\n      }\n      isPerformingWork = true;\n      var previousPriorityLevel = currentPriorityLevel;\n      try {\n        if (enableProfiling) {\n          try {\n            return workLoop(hasTimeRemaining, initialTime);\n          } catch (error) {\n            if (currentTask !== null) {\n              var currentTime = exports.unstable_now();\n              markTaskErrored(currentTask, currentTime);\n              currentTask.isQueued = false;\n            }\n            throw error;\n          }\n        } else {\n          // No catch in prod code path.\n          return workLoop(hasTimeRemaining, initialTime);\n        }\n      } finally {\n        currentTask = null;\n        currentPriorityLevel = previousPriorityLevel;\n        isPerformingWork = false;\n      }\n    }\n    function workLoop(hasTimeRemaining, initialTime) {\n      var currentTime = initialTime;\n      advanceTimers(currentTime);\n      currentTask = peek(taskQueue);\n      while (currentTask !== null && !enableSchedulerDebugging) {\n        if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n          // This currentTask hasn't expired, and we've reached the deadline.\n          break;\n        }\n        var callback = currentTask.callback;\n        if (typeof callback === 'function') {\n          currentTask.callback = null;\n          currentPriorityLevel = currentTask.priorityLevel;\n          var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n          var continuationCallback = callback(didUserCallbackTimeout);\n          currentTime = exports.unstable_now();\n          if (typeof continuationCallback === 'function') {\n            currentTask.callback = continuationCallback;\n          } else {\n            if (currentTask === peek(taskQueue)) {\n              pop(taskQueue);\n            }\n          }\n          advanceTimers(currentTime);\n        } else {\n          pop(taskQueue);\n        }\n        currentTask = peek(taskQueue);\n      } // Return whether there's additional work\n\n      if (currentTask !== null) {\n        return true;\n      } else {\n        var firstTimer = peek(timerQueue);\n        if (firstTimer !== null) {\n          requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n        }\n        return false;\n      }\n    }\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case LowPriority:\n        case IdlePriority:\n          break;\n        default:\n          priorityLevel = NormalPriority;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_next(eventHandler) {\n      var priorityLevel;\n      switch (currentPriorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n          // Shift down to normal priority\n          priorityLevel = NormalPriority;\n          break;\n        default:\n          // Anything lower than normal priority should remain at the current level.\n          priorityLevel = currentPriorityLevel;\n          break;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    }\n    function unstable_scheduleCallback(priorityLevel, callback, options) {\n      var currentTime = exports.unstable_now();\n      var startTime;\n      if (typeof options === 'object' && options !== null) {\n        var delay = options.delay;\n        if (typeof delay === 'number' && delay > 0) {\n          startTime = currentTime + delay;\n        } else {\n          startTime = currentTime;\n        }\n      } else {\n        startTime = currentTime;\n      }\n      var timeout;\n      switch (priorityLevel) {\n        case ImmediatePriority:\n          timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n          break;\n        case UserBlockingPriority:\n          timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n          break;\n        case IdlePriority:\n          timeout = IDLE_PRIORITY_TIMEOUT;\n          break;\n        case LowPriority:\n          timeout = LOW_PRIORITY_TIMEOUT;\n          break;\n        case NormalPriority:\n        default:\n          timeout = NORMAL_PRIORITY_TIMEOUT;\n          break;\n      }\n      var expirationTime = startTime + timeout;\n      var newTask = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: startTime,\n        expirationTime: expirationTime,\n        sortIndex: -1\n      };\n      if (startTime > currentTime) {\n        // This is a delayed task.\n        newTask.sortIndex = startTime;\n        push(timerQueue, newTask);\n        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n          // All tasks are delayed, and this is the task with the earliest delay.\n          if (isHostTimeoutScheduled) {\n            // Cancel an existing timeout.\n            cancelHostTimeout();\n          } else {\n            isHostTimeoutScheduled = true;\n          } // Schedule a timeout.\n\n          requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n      } else {\n        newTask.sortIndex = expirationTime;\n        push(taskQueue, newTask);\n        // wait until the next time we yield.\n\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        }\n      }\n      return newTask;\n    }\n    function unstable_pauseExecution() {}\n    function unstable_continueExecution() {\n      if (!isHostCallbackScheduled && !isPerformingWork) {\n        isHostCallbackScheduled = true;\n        requestHostCallback(flushWork);\n      }\n    }\n    function unstable_getFirstCallbackNode() {\n      return peek(taskQueue);\n    }\n    function unstable_cancelCallback(task) {\n      // remove from the queue because you can't remove arbitrary nodes from an\n      // array based heap, only the first one.)\n\n      task.callback = null;\n    }\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n    var isMessageLoopRunning = false;\n    var scheduledHostCallback = null;\n    var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n    // thread, like user events. By default, it yields multiple times per frame.\n    // It does not attempt to align with frame boundaries, since most tasks don't\n    // need to be frame aligned; for those that do, use requestAnimationFrame.\n\n    var frameInterval = frameYieldMs;\n    var startTime = -1;\n    function shouldYieldToHost() {\n      var timeElapsed = exports.unstable_now() - startTime;\n      if (timeElapsed < frameInterval) {\n        // The main thread has only been blocked for a really short amount of time;\n        // smaller than a single frame. Don't yield yet.\n        return false;\n      } // The main thread has been blocked for a non-negligible amount of time. We\n\n      return true;\n    }\n    function requestPaint() {}\n    function forceFrameRate(fps) {\n      if (fps < 0 || fps > 125) {\n        // Using console['error'] to evade Babel and ESLint\n        console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\n        return;\n      }\n      if (fps > 0) {\n        frameInterval = Math.floor(1000 / fps);\n      } else {\n        // reset the framerate\n        frameInterval = frameYieldMs;\n      }\n    }\n    var performWorkUntilDeadline = function () {\n      if (scheduledHostCallback !== null) {\n        var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n        // has been blocked.\n\n        startTime = currentTime;\n        var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n        // error can be observed.\n        //\n        // Intentionally not using a try-catch, since that makes some debugging\n        // techniques harder. Instead, if `scheduledHostCallback` errors, then\n        // `hasMoreWork` will remain true, and we'll continue the work loop.\n\n        var hasMoreWork = true;\n        try {\n          hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n        } finally {\n          if (hasMoreWork) {\n            // If there's more work, schedule the next message event at the end\n            // of the preceding one.\n            schedulePerformWorkUntilDeadline();\n          } else {\n            isMessageLoopRunning = false;\n            scheduledHostCallback = null;\n          }\n        }\n      } else {\n        isMessageLoopRunning = false;\n      } // Yielding to the browser will give it a chance to paint, so we can\n    };\n    var schedulePerformWorkUntilDeadline;\n    if (typeof localSetImmediate === 'function') {\n      // Node.js and old IE.\n      // There's a few reasons for why we prefer setImmediate.\n      //\n      // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n      // (Even though this is a DOM fork of the Scheduler, you could get here\n      // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n      // https://github.com/facebook/react/issues/20756\n      //\n      // But also, it runs earlier which is the semantic we want.\n      // If other browsers ever implement it, it's better to use it.\n      // Although both of these would be inferior to native scheduling.\n      schedulePerformWorkUntilDeadline = function () {\n        localSetImmediate(performWorkUntilDeadline);\n      };\n    } else if (typeof MessageChannel !== 'undefined') {\n      // DOM and Worker environments.\n      // We prefer MessageChannel because of the 4ms setTimeout clamping.\n      var channel = new MessageChannel();\n      var port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      schedulePerformWorkUntilDeadline = function () {\n        port.postMessage(null);\n      };\n    } else {\n      // We should only fallback here in non-browser environments.\n      schedulePerformWorkUntilDeadline = function () {\n        localSetTimeout(performWorkUntilDeadline, 0);\n      };\n    }\n    function requestHostCallback(callback) {\n      scheduledHostCallback = callback;\n      if (!isMessageLoopRunning) {\n        isMessageLoopRunning = true;\n        schedulePerformWorkUntilDeadline();\n      }\n    }\n    function requestHostTimeout(callback, ms) {\n      taskTimeoutID = localSetTimeout(function () {\n        callback(exports.unstable_now());\n      }, ms);\n    }\n    function cancelHostTimeout() {\n      localClearTimeout(taskTimeoutID);\n      taskTimeoutID = -1;\n    }\n    var unstable_requestPaint = requestPaint;\n    var unstable_Profiling = null;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_LowPriority = LowPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_Profiling = unstable_Profiling;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_continueExecution = unstable_continueExecution;\n    exports.unstable_forceFrameRate = forceFrameRate;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n    exports.unstable_next = unstable_next;\n    exports.unstable_pauseExecution = unstable_pauseExecution;\n    exports.unstable_requestPaint = unstable_requestPaint;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_shouldYield = shouldYieldToHost;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvQkFBb0I7QUFDMUI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTSxvQkFBb0I7QUFDMUI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLHdDQUF3Qzs7QUFFeEMseUNBQXlDOztBQUV6QztBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QyxtREFBbUQ7O0FBRW5EO0FBQ0EseUJBQXlCOztBQUV6QiwyQkFBMkI7QUFDM0I7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQSx1RkFBdUY7O0FBRXZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZCQUE2QjtBQUNqQyxJQUFJLGtDQUFrQztBQUN0QyxJQUFJLDRCQUE0QjtBQUNoQyxJQUFJLCtCQUErQjtBQUNuQyxJQUFJLDBCQUEwQjtBQUM5QixJQUFJLHFDQUFxQztBQUN6QyxJQUFJLCtCQUErQjtBQUNuQyxJQUFJLGtDQUFrQztBQUN0QyxJQUFJLCtCQUErQjtBQUNuQyxJQUFJLHdDQUF3QztBQUM1QyxJQUFJLHFDQUFxQztBQUN6QyxJQUFJLHFCQUFxQjtBQUN6QixJQUFJLCtCQUErQjtBQUNuQyxJQUFJLDZCQUE2QjtBQUNqQyxJQUFJLGdDQUFnQztBQUNwQyxJQUFJLGlDQUFpQztBQUNyQyxJQUFJLDRCQUE0QjtBQUNoQyxJQUFJLDZCQUE2QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcz84NjUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHNjaGVkdWxlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xuICAgIH1cbiAgICB2YXIgZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nID0gZmFsc2U7XG4gICAgdmFyIGVuYWJsZVByb2ZpbGluZyA9IGZhbHNlO1xuICAgIHZhciBmcmFtZVlpZWxkTXMgPSA1O1xuICAgIGZ1bmN0aW9uIHB1c2goaGVhcCwgbm9kZSkge1xuICAgICAgdmFyIGluZGV4ID0gaGVhcC5sZW5ndGg7XG4gICAgICBoZWFwLnB1c2gobm9kZSk7XG4gICAgICBzaWZ0VXAoaGVhcCwgbm9kZSwgaW5kZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZWVrKGhlYXApIHtcbiAgICAgIHJldHVybiBoZWFwLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBoZWFwWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3AoaGVhcCkge1xuICAgICAgaWYgKGhlYXAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGZpcnN0ID0gaGVhcFswXTtcbiAgICAgIHZhciBsYXN0ID0gaGVhcC5wb3AoKTtcbiAgICAgIGlmIChsYXN0ICE9PSBmaXJzdCkge1xuICAgICAgICBoZWFwWzBdID0gbGFzdDtcbiAgICAgICAgc2lmdERvd24oaGVhcCwgbGFzdCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpZnRVcChoZWFwLCBub2RlLCBpKSB7XG4gICAgICB2YXIgaW5kZXggPSBpO1xuICAgICAgd2hpbGUgKGluZGV4ID4gMCkge1xuICAgICAgICB2YXIgcGFyZW50SW5kZXggPSBpbmRleCAtIDEgPj4+IDE7XG4gICAgICAgIHZhciBwYXJlbnQgPSBoZWFwW3BhcmVudEluZGV4XTtcbiAgICAgICAgaWYgKGNvbXBhcmUocGFyZW50LCBub2RlKSA+IDApIHtcbiAgICAgICAgICAvLyBUaGUgcGFyZW50IGlzIGxhcmdlci4gU3dhcCBwb3NpdGlvbnMuXG4gICAgICAgICAgaGVhcFtwYXJlbnRJbmRleF0gPSBub2RlO1xuICAgICAgICAgIGhlYXBbaW5kZXhdID0gcGFyZW50O1xuICAgICAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlIHBhcmVudCBpcyBzbWFsbGVyLiBFeGl0LlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzaWZ0RG93bihoZWFwLCBub2RlLCBpKSB7XG4gICAgICB2YXIgaW5kZXggPSBpO1xuICAgICAgdmFyIGxlbmd0aCA9IGhlYXAubGVuZ3RoO1xuICAgICAgdmFyIGhhbGZMZW5ndGggPSBsZW5ndGggPj4+IDE7XG4gICAgICB3aGlsZSAoaW5kZXggPCBoYWxmTGVuZ3RoKSB7XG4gICAgICAgIHZhciBsZWZ0SW5kZXggPSAoaW5kZXggKyAxKSAqIDIgLSAxO1xuICAgICAgICB2YXIgbGVmdCA9IGhlYXBbbGVmdEluZGV4XTtcbiAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSBsZWZ0SW5kZXggKyAxO1xuICAgICAgICB2YXIgcmlnaHQgPSBoZWFwW3JpZ2h0SW5kZXhdOyAvLyBJZiB0aGUgbGVmdCBvciByaWdodCBub2RlIGlzIHNtYWxsZXIsIHN3YXAgd2l0aCB0aGUgc21hbGxlciBvZiB0aG9zZS5cblxuICAgICAgICBpZiAoY29tcGFyZShsZWZ0LCBub2RlKSA8IDApIHtcbiAgICAgICAgICBpZiAocmlnaHRJbmRleCA8IGxlbmd0aCAmJiBjb21wYXJlKHJpZ2h0LCBsZWZ0KSA8IDApIHtcbiAgICAgICAgICAgIGhlYXBbaW5kZXhdID0gcmlnaHQ7XG4gICAgICAgICAgICBoZWFwW3JpZ2h0SW5kZXhdID0gbm9kZTtcbiAgICAgICAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVhcFtpbmRleF0gPSBsZWZ0O1xuICAgICAgICAgICAgaGVhcFtsZWZ0SW5kZXhdID0gbm9kZTtcbiAgICAgICAgICAgIGluZGV4ID0gbGVmdEluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIGNvbXBhcmUocmlnaHQsIG5vZGUpIDwgMCkge1xuICAgICAgICAgIGhlYXBbaW5kZXhdID0gcmlnaHQ7XG4gICAgICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICAgICAgaW5kZXggPSByaWdodEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5laXRoZXIgY2hpbGQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICAvLyBDb21wYXJlIHNvcnQgaW5kZXggZmlyc3QsIHRoZW4gdGFzayBpZC5cbiAgICAgIHZhciBkaWZmID0gYS5zb3J0SW5kZXggLSBiLnNvcnRJbmRleDtcbiAgICAgIHJldHVybiBkaWZmICE9PSAwID8gZGlmZiA6IGEuaWQgLSBiLmlkO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBzeW1ib2xzP1xuICAgIHZhciBJbW1lZGlhdGVQcmlvcml0eSA9IDE7XG4gICAgdmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gMjtcbiAgICB2YXIgTm9ybWFsUHJpb3JpdHkgPSAzO1xuICAgIHZhciBMb3dQcmlvcml0eSA9IDQ7XG4gICAgdmFyIElkbGVQcmlvcml0eSA9IDU7XG4gICAgZnVuY3Rpb24gbWFya1Rhc2tFcnJvcmVkKHRhc2ssIG1zKSB7fVxuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdmFyICovXG5cbiAgICB2YXIgaGFzUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG4gICAgaWYgKGhhc1BlcmZvcm1hbmNlTm93KSB7XG4gICAgICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuICAgICAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2FsRGF0ZSA9IERhdGU7XG4gICAgICB2YXIgaW5pdGlhbFRpbWUgPSBsb2NhbERhdGUubm93KCk7XG4gICAgICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsRGF0ZS5ub3coKSAtIGluaXRpYWxUaW1lO1xuICAgICAgfTtcbiAgICB9IC8vIE1heCAzMSBiaXQgaW50ZWdlci4gVGhlIG1heCBpbnRlZ2VyIHNpemUgaW4gVjggZm9yIDMyLWJpdCBzeXN0ZW1zLlxuICAgIC8vIE1hdGgucG93KDIsIDMwKSAtIDFcbiAgICAvLyAwYjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVxuXG4gICAgdmFyIG1heFNpZ25lZDMxQml0SW50ID0gMTA3Mzc0MTgyMzsgLy8gVGltZXMgb3V0IGltbWVkaWF0ZWx5XG5cbiAgICB2YXIgSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQgPSAtMTsgLy8gRXZlbnR1YWxseSB0aW1lcyBvdXRcblxuICAgIHZhciBVU0VSX0JMT0NLSU5HX1BSSU9SSVRZX1RJTUVPVVQgPSAyNTA7XG4gICAgdmFyIE5PUk1BTF9QUklPUklUWV9USU1FT1VUID0gNTAwMDtcbiAgICB2YXIgTE9XX1BSSU9SSVRZX1RJTUVPVVQgPSAxMDAwMDsgLy8gTmV2ZXIgdGltZXMgb3V0XG5cbiAgICB2YXIgSURMRV9QUklPUklUWV9USU1FT1VUID0gbWF4U2lnbmVkMzFCaXRJbnQ7IC8vIFRhc2tzIGFyZSBzdG9yZWQgb24gYSBtaW4gaGVhcFxuXG4gICAgdmFyIHRhc2tRdWV1ZSA9IFtdO1xuICAgIHZhciB0aW1lclF1ZXVlID0gW107IC8vIEluY3JlbWVudGluZyBpZCBjb3VudGVyLiBVc2VkIHRvIG1haW50YWluIGluc2VydGlvbiBvcmRlci5cblxuICAgIHZhciB0YXNrSWRDb3VudGVyID0gMTsgLy8gUGF1c2luZyB0aGUgc2NoZWR1bGVyIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICAgIHZhciBjdXJyZW50VGFzayA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRQcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7IC8vIFRoaXMgaXMgc2V0IHdoaWxlIHBlcmZvcm1pbmcgd29yaywgdG8gcHJldmVudCByZS1lbnRyYW5jZS5cblxuICAgIHZhciBpc1BlcmZvcm1pbmdXb3JrID0gZmFsc2U7XG4gICAgdmFyIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdmFyIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTsgLy8gQ2FwdHVyZSBsb2NhbCByZWZlcmVuY2VzIHRvIG5hdGl2ZSBBUElzLCBpbiBjYXNlIGEgcG9seWZpbGwgb3ZlcnJpZGVzIHRoZW0uXG5cbiAgICB2YXIgbG9jYWxTZXRUaW1lb3V0ID0gdHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBzZXRUaW1lb3V0IDogbnVsbDtcbiAgICB2YXIgbG9jYWxDbGVhclRpbWVvdXQgPSB0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gY2xlYXJUaW1lb3V0IDogbnVsbDtcbiAgICB2YXIgbG9jYWxTZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyA/IHNldEltbWVkaWF0ZSA6IG51bGw7IC8vIElFIGFuZCBOb2RlLmpzICsganNkb21cblxuICAgIHZhciBpc0lucHV0UGVuZGluZyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5zY2hlZHVsaW5nICE9PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcgIT09IHVuZGVmaW5lZCA/IG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nLmJpbmQobmF2aWdhdG9yLnNjaGVkdWxpbmcpIDogbnVsbDtcbiAgICBmdW5jdGlvbiBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBDaGVjayBmb3IgdGFza3MgdGhhdCBhcmUgbm8gbG9uZ2VyIGRlbGF5ZWQgYW5kIGFkZCB0aGVtIHRvIHRoZSBxdWV1ZS5cbiAgICAgIHZhciB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gICAgICB3aGlsZSAodGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHRpbWVyLmNhbGxiYWNrID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGltZXIgd2FzIGNhbmNlbGxlZC5cbiAgICAgICAgICBwb3AodGltZXJRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZXIuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgLy8gVGltZXIgZmlyZWQuIFRyYW5zZmVyIHRvIHRoZSB0YXNrIHF1ZXVlLlxuICAgICAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICAgICAgICB0aW1lci5zb3J0SW5kZXggPSB0aW1lci5leHBpcmF0aW9uVGltZTtcbiAgICAgICAgICBwdXNoKHRhc2tRdWV1ZSwgdGltZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbWFpbmluZyB0aW1lcnMgYXJlIHBlbmRpbmcuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVGltZW91dChjdXJyZW50VGltZSkge1xuICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkKSB7XG4gICAgICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgIT09IG51bGwpIHtcbiAgICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgICAgICAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFdvcmsoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xuICAgICAgICAvLyBXZSBzY2hlZHVsZWQgYSB0aW1lb3V0IGJ1dCBpdCdzIG5vIGxvbmdlciBuZWVkZWQuIENhbmNlbCBpdC5cbiAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICAgICAgfVxuICAgICAgaXNQZXJmb3JtaW5nV29yayA9IHRydWU7XG4gICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGFzayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICAgICAgICBtYXJrVGFza0Vycm9yZWQoY3VycmVudFRhc2ssIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgY3VycmVudFRhc2suaXNRdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBjYXRjaCBpbiBwcm9kIGNvZGUgcGF0aC5cbiAgICAgICAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50VGFzayA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgICAgICBpc1BlcmZvcm1pbmdXb3JrID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBpbml0aWFsVGltZTtcbiAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gICAgICB3aGlsZSAoY3VycmVudFRhc2sgIT09IG51bGwgJiYgIWVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZykge1xuICAgICAgICBpZiAoY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPiBjdXJyZW50VGltZSAmJiAoIWhhc1RpbWVSZW1haW5pbmcgfHwgc2hvdWxkWWllbGRUb0hvc3QoKSkpIHtcbiAgICAgICAgICAvLyBUaGlzIGN1cnJlbnRUYXNrIGhhc24ndCBleHBpcmVkLCBhbmQgd2UndmUgcmVhY2hlZCB0aGUgZGVhZGxpbmUuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY3VycmVudFRhc2suY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50VGFzay5wcmlvcml0eUxldmVsO1xuICAgICAgICAgIHZhciBkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0ID0gY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWU7XG4gICAgICAgICAgdmFyIGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soZGlkVXNlckNhbGxiYWNrVGltZW91dCk7XG4gICAgICAgICAgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICAgIGlmICh0eXBlb2YgY29udGludWF0aW9uQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gY29udGludWF0aW9uQ2FsbGJhY2s7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGFzayA9PT0gcGVlayh0YXNrUXVldWUpKSB7XG4gICAgICAgICAgICAgIHBvcCh0YXNrUXVldWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcbiAgICAgIH0gLy8gUmV0dXJuIHdoZXRoZXIgdGhlcmUncyBhZGRpdGlvbmFsIHdvcmtcblxuICAgICAgaWYgKGN1cnJlbnRUYXNrICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eShwcmlvcml0eUxldmVsLCBldmVudEhhbmRsZXIpIHtcbiAgICAgIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgICAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgICAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgICAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gICAgICB9XG4gICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdGFibGVfbmV4dChldmVudEhhbmRsZXIpIHtcbiAgICAgIHZhciBwcmlvcml0eUxldmVsO1xuICAgICAgc3dpdGNoIChjdXJyZW50UHJpb3JpdHlMZXZlbCkge1xuICAgICAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgICAgICAgIC8vIFNoaWZ0IGRvd24gdG8gbm9ybWFsIHByaW9yaXR5XG4gICAgICAgICAgcHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEFueXRoaW5nIGxvd2VyIHRoYW4gbm9ybWFsIHByaW9yaXR5IHNob3VsZCByZW1haW4gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgICAgICAgcHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuc3RhYmxlX3dyYXBDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgdmFyIHBhcmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBmb3JrIG9mIHJ1bldpdGhQcmlvcml0eSwgaW5saW5lZCBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwYXJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgdmFyIHN0YXJ0VGltZTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuICAgICAgICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJyAmJiBkZWxheSA+IDApIHtcbiAgICAgICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZSArIGRlbGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICAgIHZhciB0aW1lb3V0O1xuICAgICAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICAgICAgdGltZW91dCA9IElNTUVESUFURV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgICAgIHRpbWVvdXQgPSBVU0VSX0JMT0NLSU5HX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgICAgIHRpbWVvdXQgPSBJRExFX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgICAgICAgdGltZW91dCA9IExPV19QUklPUklUWV9USU1FT1VUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRpbWVvdXQgPSBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHN0YXJ0VGltZSArIHRpbWVvdXQ7XG4gICAgICB2YXIgbmV3VGFzayA9IHtcbiAgICAgICAgaWQ6IHRhc2tJZENvdW50ZXIrKyxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsLFxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBzb3J0SW5kZXg6IC0xXG4gICAgICB9O1xuICAgICAgaWYgKHN0YXJ0VGltZSA+IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBkZWxheWVkIHRhc2suXG4gICAgICAgIG5ld1Rhc2suc29ydEluZGV4ID0gc3RhcnRUaW1lO1xuICAgICAgICBwdXNoKHRpbWVyUXVldWUsIG5ld1Rhc2spO1xuICAgICAgICBpZiAocGVlayh0YXNrUXVldWUpID09PSBudWxsICYmIG5ld1Rhc2sgPT09IHBlZWsodGltZXJRdWV1ZSkpIHtcbiAgICAgICAgICAvLyBBbGwgdGFza3MgYXJlIGRlbGF5ZWQsIGFuZCB0aGlzIGlzIHRoZSB0YXNrIHdpdGggdGhlIGVhcmxpZXN0IGRlbGF5LlxuICAgICAgICAgIGlmIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkKSB7XG4gICAgICAgICAgICAvLyBDYW5jZWwgYW4gZXhpc3RpbmcgdGltZW91dC5cbiAgICAgICAgICAgIGNhbmNlbEhvc3RUaW1lb3V0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgIH0gLy8gU2NoZWR1bGUgYSB0aW1lb3V0LlxuXG4gICAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIHN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VGFzay5zb3J0SW5kZXggPSBleHBpcmF0aW9uVGltZTtcbiAgICAgICAgcHVzaCh0YXNrUXVldWUsIG5ld1Rhc2spO1xuICAgICAgICAvLyB3YWl0IHVudGlsIHRoZSBuZXh0IHRpbWUgd2UgeWllbGQuXG5cbiAgICAgICAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCAmJiAhaXNQZXJmb3JtaW5nV29yaykge1xuICAgICAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdUYXNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbigpIHt9XG4gICAgZnVuY3Rpb24gdW5zdGFibGVfY29udGludWVFeGVjdXRpb24oKSB7XG4gICAgICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkICYmICFpc1BlcmZvcm1pbmdXb3JrKSB7XG4gICAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSgpIHtcbiAgICAgIHJldHVybiBwZWVrKHRhc2tRdWV1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrKHRhc2spIHtcbiAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBxdWV1ZSBiZWNhdXNlIHlvdSBjYW4ndCByZW1vdmUgYXJiaXRyYXJ5IG5vZGVzIGZyb20gYW5cbiAgICAgIC8vIGFycmF5IGJhc2VkIGhlYXAsIG9ubHkgdGhlIGZpcnN0IG9uZS4pXG5cbiAgICAgIHRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICB9XG4gICAgdmFyIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgdmFyIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG4gICAgdmFyIHRhc2tUaW1lb3V0SUQgPSAtMTsgLy8gU2NoZWR1bGVyIHBlcmlvZGljYWxseSB5aWVsZHMgaW4gY2FzZSB0aGVyZSBpcyBvdGhlciB3b3JrIG9uIHRoZSBtYWluXG4gICAgLy8gdGhyZWFkLCBsaWtlIHVzZXIgZXZlbnRzLiBCeSBkZWZhdWx0LCBpdCB5aWVsZHMgbXVsdGlwbGUgdGltZXMgcGVyIGZyYW1lLlxuICAgIC8vIEl0IGRvZXMgbm90IGF0dGVtcHQgdG8gYWxpZ24gd2l0aCBmcmFtZSBib3VuZGFyaWVzLCBzaW5jZSBtb3N0IHRhc2tzIGRvbid0XG4gICAgLy8gbmVlZCB0byBiZSBmcmFtZSBhbGlnbmVkOyBmb3IgdGhvc2UgdGhhdCBkbywgdXNlIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cblxuICAgIHZhciBmcmFtZUludGVydmFsID0gZnJhbWVZaWVsZE1zO1xuICAgIHZhciBzdGFydFRpbWUgPSAtMTtcbiAgICBmdW5jdGlvbiBzaG91bGRZaWVsZFRvSG9zdCgpIHtcbiAgICAgIHZhciB0aW1lRWxhcHNlZCA9IGV4cG9ydHMudW5zdGFibGVfbm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBpZiAodGltZUVsYXBzZWQgPCBmcmFtZUludGVydmFsKSB7XG4gICAgICAgIC8vIFRoZSBtYWluIHRocmVhZCBoYXMgb25seSBiZWVuIGJsb2NrZWQgZm9yIGEgcmVhbGx5IHNob3J0IGFtb3VudCBvZiB0aW1lO1xuICAgICAgICAvLyBzbWFsbGVyIHRoYW4gYSBzaW5nbGUgZnJhbWUuIERvbid0IHlpZWxkIHlldC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBUaGUgbWFpbiB0aHJlYWQgaGFzIGJlZW4gYmxvY2tlZCBmb3IgYSBub24tbmVnbGlnaWJsZSBhbW91bnQgb2YgdGltZS4gV2VcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RQYWludCgpIHt9XG4gICAgZnVuY3Rpb24gZm9yY2VGcmFtZVJhdGUoZnBzKSB7XG4gICAgICBpZiAoZnBzIDwgMCB8fCBmcHMgPiAxMjUpIHtcbiAgICAgICAgLy8gVXNpbmcgY29uc29sZVsnZXJyb3InXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG4gICAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oJ2ZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCAnICsgJ2ZvcmNpbmcgZnJhbWUgcmF0ZXMgaGlnaGVyIHRoYW4gMTI1IGZwcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmcHMgPiAwKSB7XG4gICAgICAgIGZyYW1lSW50ZXJ2YWwgPSBNYXRoLmZsb29yKDEwMDAgLyBmcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVzZXQgdGhlIGZyYW1lcmF0ZVxuICAgICAgICBmcmFtZUludGVydmFsID0gZnJhbWVZaWVsZE1zO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNjaGVkdWxlZEhvc3RDYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBzdGFydCB0aW1lIHNvIHdlIGNhbiBtZWFzdXJlIGhvdyBsb25nIHRoZSBtYWluIHRocmVhZFxuICAgICAgICAvLyBoYXMgYmVlbiBibG9ja2VkLlxuXG4gICAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgaGFzVGltZVJlbWFpbmluZyA9IHRydWU7IC8vIElmIGEgc2NoZWR1bGVyIHRhc2sgdGhyb3dzLCBleGl0IHRoZSBjdXJyZW50IGJyb3dzZXIgdGFzayBzbyB0aGVcbiAgICAgICAgLy8gZXJyb3IgY2FuIGJlIG9ic2VydmVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBhIHRyeS1jYXRjaCwgc2luY2UgdGhhdCBtYWtlcyBzb21lIGRlYnVnZ2luZ1xuICAgICAgICAvLyB0ZWNobmlxdWVzIGhhcmRlci4gSW5zdGVhZCwgaWYgYHNjaGVkdWxlZEhvc3RDYWxsYmFja2AgZXJyb3JzLCB0aGVuXG4gICAgICAgIC8vIGBoYXNNb3JlV29ya2Agd2lsbCByZW1haW4gdHJ1ZSwgYW5kIHdlJ2xsIGNvbnRpbnVlIHRoZSB3b3JrIGxvb3AuXG5cbiAgICAgICAgdmFyIGhhc01vcmVXb3JrID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBoYXNNb3JlV29yayA9IHNjaGVkdWxlZEhvc3RDYWxsYmFjayhoYXNUaW1lUmVtYWluaW5nLCBjdXJyZW50VGltZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGhhc01vcmVXb3JrKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG1vcmUgd29yaywgc2NoZWR1bGUgdGhlIG5leHQgbWVzc2FnZSBldmVudCBhdCB0aGUgZW5kXG4gICAgICAgICAgICAvLyBvZiB0aGUgcHJlY2VkaW5nIG9uZS5cbiAgICAgICAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIH0gLy8gWWllbGRpbmcgdG8gdGhlIGJyb3dzZXIgd2lsbCBnaXZlIGl0IGEgY2hhbmNlIHRvIHBhaW50LCBzbyB3ZSBjYW5cbiAgICB9O1xuICAgIHZhciBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcbiAgICBpZiAodHlwZW9mIGxvY2FsU2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBOb2RlLmpzIGFuZCBvbGQgSUUuXG4gICAgICAvLyBUaGVyZSdzIGEgZmV3IHJlYXNvbnMgZm9yIHdoeSB3ZSBwcmVmZXIgc2V0SW1tZWRpYXRlLlxuICAgICAgLy9cbiAgICAgIC8vIFVubGlrZSBNZXNzYWdlQ2hhbm5lbCwgaXQgZG9lc24ndCBwcmV2ZW50IGEgTm9kZS5qcyBwcm9jZXNzIGZyb20gZXhpdGluZy5cbiAgICAgIC8vIChFdmVuIHRob3VnaCB0aGlzIGlzIGEgRE9NIGZvcmsgb2YgdGhlIFNjaGVkdWxlciwgeW91IGNvdWxkIGdldCBoZXJlXG4gICAgICAvLyB3aXRoIGEgbWl4IG9mIE5vZGUuanMgMTUrLCB3aGljaCBoYXMgYSBNZXNzYWdlQ2hhbm5lbCwgYW5kIGpzZG9tLilcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjA3NTZcbiAgICAgIC8vXG4gICAgICAvLyBCdXQgYWxzbywgaXQgcnVucyBlYXJsaWVyIHdoaWNoIGlzIHRoZSBzZW1hbnRpYyB3ZSB3YW50LlxuICAgICAgLy8gSWYgb3RoZXIgYnJvd3NlcnMgZXZlciBpbXBsZW1lbnQgaXQsIGl0J3MgYmV0dGVyIHRvIHVzZSBpdC5cbiAgICAgIC8vIEFsdGhvdWdoIGJvdGggb2YgdGhlc2Ugd291bGQgYmUgaW5mZXJpb3IgdG8gbmF0aXZlIHNjaGVkdWxpbmcuXG4gICAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9jYWxTZXRJbW1lZGlhdGUocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBET00gYW5kIFdvcmtlciBlbnZpcm9ubWVudHMuXG4gICAgICAvLyBXZSBwcmVmZXIgTWVzc2FnZUNoYW5uZWwgYmVjYXVzZSBvZiB0aGUgNG1zIHNldFRpbWVvdXQgY2xhbXBpbmcuXG4gICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG4gICAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHNob3VsZCBvbmx5IGZhbGxiYWNrIGhlcmUgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICAgICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2FsU2V0VGltZW91dChwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUsIDApO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdEhvc3RDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICBpZiAoIWlzTWVzc2FnZUxvb3BSdW5uaW5nKSB7XG4gICAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdEhvc3RUaW1lb3V0KGNhbGxiYWNrLCBtcykge1xuICAgICAgdGFza1RpbWVvdXRJRCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICAgICAgfSwgbXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWxIb3N0VGltZW91dCgpIHtcbiAgICAgIGxvY2FsQ2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpO1xuICAgICAgdGFza1RpbWVvdXRJRCA9IC0xO1xuICAgIH1cbiAgICB2YXIgdW5zdGFibGVfcmVxdWVzdFBhaW50ID0gcmVxdWVzdFBhaW50O1xuICAgIHZhciB1bnN0YWJsZV9Qcm9maWxpbmcgPSBudWxsO1xuICAgIGV4cG9ydHMudW5zdGFibGVfSWRsZVByaW9yaXR5ID0gSWRsZVByaW9yaXR5O1xuICAgIGV4cG9ydHMudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX0xvd1ByaW9yaXR5ID0gTG93UHJpb3JpdHk7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuICAgIGV4cG9ydHMudW5zdGFibGVfUHJvZmlsaW5nID0gdW5zdGFibGVfUHJvZmlsaW5nO1xuICAgIGV4cG9ydHMudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHkgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uO1xuICAgIGV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmb3JjZUZyYW1lUmF0ZTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSA9IHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlO1xuICAgIGV4cG9ydHMudW5zdGFibGVfbmV4dCA9IHVuc3RhYmxlX25leHQ7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uO1xuICAgIGV4cG9ydHMudW5zdGFibGVfcmVxdWVzdFBhaW50ID0gdW5zdGFibGVfcmVxdWVzdFBhaW50O1xuICAgIGV4cG9ydHMudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5ID0gdW5zdGFibGVfcnVuV2l0aFByaW9yaXR5O1xuICAgIGV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayA9IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZCA9IHNob3VsZFlpZWxkVG9Ib3N0O1xuICAgIGV4cG9ydHMudW5zdGFibGVfd3JhcENhbGxiYWNrID0gdW5zdGFibGVfd3JhcENhbGxiYWNrO1xuICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbiAgICB9XG4gIH0pKCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"./node_modules/scheduler/cjs/scheduler.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxtSUFBMEQ7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teV9hcHAvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzPzgxMmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/scheduler/index.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/clients/WebSocketClient.js":
/*!***************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/clients/WebSocketClient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WebSocketClient)\n/* harmony export */ });\n/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/log.js */ \"./node_modules/webpack-dev-server/client/utils/log.js\");\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nvar WebSocketClient = /*#__PURE__*/function () {\n  /**\n   * @param {string} url\n   */\n  function WebSocketClient(url) {\n    _classCallCheck(this, WebSocketClient);\n    this.client = new WebSocket(url);\n    this.client.onerror = function (error) {\n      _utils_log_js__WEBPACK_IMPORTED_MODULE_0__.log.error(error);\n    };\n  }\n\n  /**\n   * @param {(...args: any[]) => void} f\n   */\n  _createClass(WebSocketClient, [{\n    key: \"onOpen\",\n    value: function onOpen(f) {\n      this.client.onopen = f;\n    }\n\n    /**\n     * @param {(...args: any[]) => void} f\n     */\n  }, {\n    key: \"onClose\",\n    value: function onClose(f) {\n      this.client.onclose = f;\n    }\n\n    // call f with the message string as the first argument\n    /**\n     * @param {(...args: any[]) => void} f\n     */\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(f) {\n      this.client.onmessage = function (e) {\n        f(e.data);\n      };\n    }\n  }]);\n  return WebSocketClient;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL1dlYlNvY2tldENsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NDO0FBQ3RDO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOENBQUc7QUFDVDtBQUNBOztBQUVBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teV9hcHAvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL1dlYlNvY2tldENsaWVudC5qcz9lZjU3Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cbmltcG9ydCB7IGxvZyB9IGZyb20gXCIuLi91dGlscy9sb2cuanNcIjtcbnZhciBXZWJTb2NrZXRDbGllbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKi9cbiAgZnVuY3Rpb24gV2ViU29ja2V0Q2xpZW50KHVybCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJTb2NrZXRDbGllbnQpO1xuICAgIHRoaXMuY2xpZW50ID0gbmV3IFdlYlNvY2tldCh1cmwpO1xuICAgIHRoaXMuY2xpZW50Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gZlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFdlYlNvY2tldENsaWVudCwgW3tcbiAgICBrZXk6IFwib25PcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uT3BlbihmKSB7XG4gICAgICB0aGlzLmNsaWVudC5vbm9wZW4gPSBmO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBmXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwib25DbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsb3NlKGYpIHtcbiAgICAgIHRoaXMuY2xpZW50Lm9uY2xvc2UgPSBmO1xuICAgIH1cblxuICAgIC8vIGNhbGwgZiB3aXRoIHRoZSBtZXNzYWdlIHN0cmluZyBhcyB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gZlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9uTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lc3NhZ2UoZikge1xuICAgICAgdGhpcy5jbGllbnQub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZihlLmRhdGEpO1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFdlYlNvY2tldENsaWVudDtcbn0oKTtcbmV4cG9ydCB7IFdlYlNvY2tldENsaWVudCBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/clients/WebSocketClient.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=3000&pathname=%2Fws&logging=none&overlay=true&reconnect=10&hot=true&live-reload=true":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=3000&pathname=%2Fws&logging=none&overlay=true&reconnect=10&hot=true&live-reload=true ***!
  \***********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("var __resourceQuery = \"?protocol=ws%3A&hostname=0.0.0.0&port=3000&pathname=%2Fws&logging=none&overlay=true&reconnect=10&hot=true&live-reload=true\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webpack/hot/log.js */ \"./node_modules/webpack/hot/log.js\");\n/* harmony import */ var webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_stripAnsi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/stripAnsi.js */ \"./node_modules/webpack-dev-server/client/utils/stripAnsi.js\");\n/* harmony import */ var _utils_parseURL_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/parseURL.js */ \"./node_modules/webpack-dev-server/client/utils/parseURL.js\");\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./socket.js */ \"./node_modules/webpack-dev-server/client/socket.js\");\n/* harmony import */ var _overlay_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./overlay.js */ \"./node_modules/webpack-dev-server/client/overlay.js\");\n/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/log.js */ \"./node_modules/webpack-dev-server/client/utils/log.js\");\n/* harmony import */ var _utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/sendMessage.js */ \"./node_modules/webpack-dev-server/client/utils/sendMessage.js\");\n/* harmony import */ var _utils_reloadApp_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/reloadApp.js */ \"./node_modules/webpack-dev-server/client/utils/reloadApp.js\");\n/* harmony import */ var _utils_createSocketURL_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/createSocketURL.js */ \"./node_modules/webpack-dev-server/client/utils/createSocketURL.js\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n/* global __resourceQuery, __webpack_hash__ */\n/// <reference types=\"webpack/module\" />\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} OverlayOptions\n * @property {boolean | (error: Error) => boolean} [warnings]\n * @property {boolean | (error: Error) => boolean} [errors]\n * @property {boolean | (error: Error) => boolean} [runtimeErrors]\n * @property {string} [trustedTypesPolicyName]\n */\n\n/**\n * @typedef {Object} Options\n * @property {boolean} hot\n * @property {boolean} liveReload\n * @property {boolean} progress\n * @property {boolean | OverlayOptions} overlay\n * @property {string} [logging]\n * @property {number} [reconnect]\n */\n\n/**\n * @typedef {Object} Status\n * @property {boolean} isUnloading\n * @property {string} currentHash\n * @property {string} [previousHash]\n */\n\n/**\n * @param {boolean | { warnings?: boolean | string; errors?: boolean | string; runtimeErrors?: boolean | string; }} overlayOptions\n */\nvar decodeOverlayOptions = function decodeOverlayOptions(overlayOptions) {\n  if (typeof overlayOptions === \"object\") {\n    [\"warnings\", \"errors\", \"runtimeErrors\"].forEach(function (property) {\n      if (typeof overlayOptions[property] === \"string\") {\n        var overlayFilterFunctionString = decodeURIComponent(overlayOptions[property]);\n\n        // eslint-disable-next-line no-new-func\n        var overlayFilterFunction = new Function(\"message\", \"var callback = \".concat(overlayFilterFunctionString, \"\\n        return callback(message)\"));\n        overlayOptions[property] = overlayFilterFunction;\n      }\n    });\n  }\n};\n\n/**\n * @type {Status}\n */\nvar status = {\n  isUnloading: false,\n  // TODO Workaround for webpack v4, `__webpack_hash__` is not replaced without HotModuleReplacement\n  // eslint-disable-next-line camelcase\n  currentHash:  true ? __webpack_require__.h() : 0\n};\n\n/** @type {Options} */\nvar options = {\n  hot: false,\n  liveReload: false,\n  progress: false,\n  overlay: false\n};\nvar parsedResourceQuery = (0,_utils_parseURL_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(__resourceQuery);\nvar enabledFeatures = {\n  \"Hot Module Replacement\": false,\n  \"Live Reloading\": false,\n  Progress: false,\n  Overlay: false\n};\nif (parsedResourceQuery.hot === \"true\") {\n  options.hot = true;\n  enabledFeatures[\"Hot Module Replacement\"] = true;\n}\nif (parsedResourceQuery[\"live-reload\"] === \"true\") {\n  options.liveReload = true;\n  enabledFeatures[\"Live Reloading\"] = true;\n}\nif (parsedResourceQuery.progress === \"true\") {\n  options.progress = true;\n  enabledFeatures.Progress = true;\n}\nif (parsedResourceQuery.overlay) {\n  try {\n    options.overlay = JSON.parse(parsedResourceQuery.overlay);\n  } catch (e) {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error(\"Error parsing overlay options from resource query:\", e);\n  }\n\n  // Fill in default \"true\" params for partially-specified objects.\n  if (typeof options.overlay === \"object\") {\n    options.overlay = _objectSpread({\n      errors: true,\n      warnings: true,\n      runtimeErrors: true\n    }, options.overlay);\n    decodeOverlayOptions(options.overlay);\n  }\n  enabledFeatures.Overlay = true;\n}\nif (parsedResourceQuery.logging) {\n  options.logging = parsedResourceQuery.logging;\n}\nif (typeof parsedResourceQuery.reconnect !== \"undefined\") {\n  options.reconnect = Number(parsedResourceQuery.reconnect);\n}\n\n/**\n * @param {string} level\n */\nfunction setAllLogLevel(level) {\n  // This is needed because the HMR logger operate separately from dev server logger\n  webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0___default().setLogLevel(level === \"verbose\" || level === \"log\" ? \"info\" : level);\n  (0,_utils_log_js__WEBPACK_IMPORTED_MODULE_5__.setLogLevel)(level);\n}\nif (options.logging) {\n  setAllLogLevel(options.logging);\n}\n(0,_utils_log_js__WEBPACK_IMPORTED_MODULE_5__.logEnabledFeatures)(enabledFeatures);\nself.addEventListener(\"beforeunload\", function () {\n  status.isUnloading = true;\n});\nvar overlay = typeof window !== \"undefined\" ? (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.createOverlay)(typeof options.overlay === \"object\" ? {\n  trustedTypesPolicyName: options.overlay.trustedTypesPolicyName,\n  catchRuntimeError: options.overlay.runtimeErrors\n} : {\n  trustedTypesPolicyName: false,\n  catchRuntimeError: options.overlay\n}) : {\n  send: function send() {}\n};\nvar onSocketMessage = {\n  hot: function hot() {\n    if (parsedResourceQuery.hot === \"false\") {\n      return;\n    }\n    options.hot = true;\n  },\n  liveReload: function liveReload() {\n    if (parsedResourceQuery[\"live-reload\"] === \"false\") {\n      return;\n    }\n    options.liveReload = true;\n  },\n  invalid: function invalid() {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info(\"App updated. Recompiling...\");\n\n    // Fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.\n    if (options.overlay) {\n      overlay.send({\n        type: \"DISMISS\"\n      });\n    }\n    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"Invalid\");\n  },\n  /**\n   * @param {string} hash\n   */\n  hash: function hash(_hash) {\n    status.previousHash = status.currentHash;\n    status.currentHash = _hash;\n  },\n  logging: setAllLogLevel,\n  /**\n   * @param {boolean} value\n   */\n  overlay: function overlay(value) {\n    if (typeof document === \"undefined\") {\n      return;\n    }\n    options.overlay = value;\n    decodeOverlayOptions(options.overlay);\n  },\n  /**\n   * @param {number} value\n   */\n  reconnect: function reconnect(value) {\n    if (parsedResourceQuery.reconnect === \"false\") {\n      return;\n    }\n    options.reconnect = value;\n  },\n  /**\n   * @param {boolean} value\n   */\n  progress: function progress(value) {\n    options.progress = value;\n  },\n  /**\n   * @param {{ pluginName?: string, percent: number, msg: string }} data\n   */\n  \"progress-update\": function progressUpdate(data) {\n    if (options.progress) {\n      _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info(\"\".concat(data.pluginName ? \"[\".concat(data.pluginName, \"] \") : \"\").concat(data.percent, \"% - \").concat(data.msg, \".\"));\n    }\n    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"Progress\", data);\n  },\n  \"still-ok\": function stillOk() {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info(\"Nothing changed.\");\n    if (options.overlay) {\n      overlay.send({\n        type: \"DISMISS\"\n      });\n    }\n    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"StillOk\");\n  },\n  ok: function ok() {\n    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"Ok\");\n    if (options.overlay) {\n      overlay.send({\n        type: \"DISMISS\"\n      });\n    }\n    (0,_utils_reloadApp_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(options, status);\n  },\n  // TODO: remove in v5 in favor of 'static-changed'\n  /**\n   * @param {string} file\n   */\n  \"content-changed\": function contentChanged(file) {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info(\"\".concat(file ? \"\\\"\".concat(file, \"\\\"\") : \"Content\", \" from static directory was changed. Reloading...\"));\n    self.location.reload();\n  },\n  /**\n   * @param {string} file\n   */\n  \"static-changed\": function staticChanged(file) {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info(\"\".concat(file ? \"\\\"\".concat(file, \"\\\"\") : \"Content\", \" from static directory was changed. Reloading...\"));\n    self.location.reload();\n  },\n  /**\n   * @param {Error[]} warnings\n   * @param {any} params\n   */\n  warnings: function warnings(_warnings, params) {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.warn(\"Warnings while compiling.\");\n    var printableWarnings = _warnings.map(function (error) {\n      var _formatProblem = (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.formatProblem)(\"warning\", error),\n        header = _formatProblem.header,\n        body = _formatProblem.body;\n      return \"\".concat(header, \"\\n\").concat((0,_utils_stripAnsi_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(body));\n    });\n    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"Warnings\", printableWarnings);\n    for (var i = 0; i < printableWarnings.length; i++) {\n      _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.warn(printableWarnings[i]);\n    }\n    var overlayWarningsSetting = typeof options.overlay === \"boolean\" ? options.overlay : options.overlay && options.overlay.warnings;\n    if (overlayWarningsSetting) {\n      var warningsToDisplay = typeof overlayWarningsSetting === \"function\" ? _warnings.filter(overlayWarningsSetting) : _warnings;\n      if (warningsToDisplay.length) {\n        overlay.send({\n          type: \"BUILD_ERROR\",\n          level: \"warning\",\n          messages: _warnings\n        });\n      }\n    }\n    if (params && params.preventReloading) {\n      return;\n    }\n    (0,_utils_reloadApp_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(options, status);\n  },\n  /**\n   * @param {Error[]} errors\n   */\n  errors: function errors(_errors) {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error(\"Errors while compiling. Reload prevented.\");\n    var printableErrors = _errors.map(function (error) {\n      var _formatProblem2 = (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.formatProblem)(\"error\", error),\n        header = _formatProblem2.header,\n        body = _formatProblem2.body;\n      return \"\".concat(header, \"\\n\").concat((0,_utils_stripAnsi_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(body));\n    });\n    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"Errors\", printableErrors);\n    for (var i = 0; i < printableErrors.length; i++) {\n      _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error(printableErrors[i]);\n    }\n    var overlayErrorsSettings = typeof options.overlay === \"boolean\" ? options.overlay : options.overlay && options.overlay.errors;\n    if (overlayErrorsSettings) {\n      var errorsToDisplay = typeof overlayErrorsSettings === \"function\" ? _errors.filter(overlayErrorsSettings) : _errors;\n      if (errorsToDisplay.length) {\n        overlay.send({\n          type: \"BUILD_ERROR\",\n          level: \"error\",\n          messages: _errors\n        });\n      }\n    }\n  },\n  /**\n   * @param {Error} error\n   */\n  error: function error(_error) {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error(_error);\n  },\n  close: function close() {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info(\"Disconnected!\");\n    if (options.overlay) {\n      overlay.send({\n        type: \"DISMISS\"\n      });\n    }\n    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"Close\");\n  }\n};\nvar socketURL = (0,_utils_createSocketURL_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(parsedResourceQuery);\n(0,_socket_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(socketURL, onSocketMessage, options.reconnect);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9pbmRleC5qcz9wcm90b2NvbD13cyUzQSZob3N0bmFtZT0wLjAuMC4wJnBvcnQ9MzAwMCZwYXRobmFtZT0lMkZ3cyZsb2dnaW5nPW5vbmUmb3ZlcmxheT10cnVlJnJlY29ubmVjdD0xMCZob3Q9dHJ1ZSZsaXZlLXJlbG9hZD10cnVlIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0M7QUFDRjtBQUNGO0FBQ1Y7QUFDMkI7QUFDVTtBQUNyQjtBQUNKO0FBQ1k7O0FBRXpEO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMscUNBQXFDO0FBQ25ELGNBQWMscUNBQXFDO0FBQ25ELGNBQWMscUNBQXFDO0FBQ25ELGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLDBCQUEwQjtBQUN4QyxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0EsV0FBVyxZQUFZLDZCQUE2QiwyQkFBMkIscUNBQXFD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QUs7QUFDTCxJQUFJLGlFQUFXO0FBQ2Ysb0JBQW9CLDRCQUE0QjtBQUNoRCxNQUFNLDhDQUFHO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLElBQUksOENBQUc7QUFDUCxHQUFHO0FBQ0g7QUFDQSxJQUFJLDhDQUFHO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSSxpRUFBVztBQUNmO0FBQ0E7QUFDQSxnQkFBZ0IscUVBQWU7QUFDL0Isc0RBQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teV9hcHAvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9pbmRleC5qcz8zZTY2Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG4vKiBnbG9iYWwgX19yZXNvdXJjZVF1ZXJ5LCBfX3dlYnBhY2tfaGFzaF9fICovXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cIndlYnBhY2svbW9kdWxlXCIgLz5cbmltcG9ydCB3ZWJwYWNrSG90TG9nIGZyb20gXCJ3ZWJwYWNrL2hvdC9sb2cuanNcIjtcbmltcG9ydCBzdHJpcEFuc2kgZnJvbSBcIi4vdXRpbHMvc3RyaXBBbnNpLmpzXCI7XG5pbXBvcnQgcGFyc2VVUkwgZnJvbSBcIi4vdXRpbHMvcGFyc2VVUkwuanNcIjtcbmltcG9ydCBzb2NrZXQgZnJvbSBcIi4vc29ja2V0LmpzXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9ibGVtLCBjcmVhdGVPdmVybGF5IH0gZnJvbSBcIi4vb3ZlcmxheS5qc1wiO1xuaW1wb3J0IHsgbG9nLCBsb2dFbmFibGVkRmVhdHVyZXMsIHNldExvZ0xldmVsIH0gZnJvbSBcIi4vdXRpbHMvbG9nLmpzXCI7XG5pbXBvcnQgc2VuZE1lc3NhZ2UgZnJvbSBcIi4vdXRpbHMvc2VuZE1lc3NhZ2UuanNcIjtcbmltcG9ydCByZWxvYWRBcHAgZnJvbSBcIi4vdXRpbHMvcmVsb2FkQXBwLmpzXCI7XG5pbXBvcnQgY3JlYXRlU29ja2V0VVJMIGZyb20gXCIuL3V0aWxzL2NyZWF0ZVNvY2tldFVSTC5qc1wiO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE92ZXJsYXlPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCAoZXJyb3I6IEVycm9yKSA9PiBib29sZWFufSBbd2FybmluZ3NdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCAoZXJyb3I6IEVycm9yKSA9PiBib29sZWFufSBbZXJyb3JzXVxuICogQHByb3BlcnR5IHtib29sZWFuIHwgKGVycm9yOiBFcnJvcikgPT4gYm9vbGVhbn0gW3J1bnRpbWVFcnJvcnNdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RydXN0ZWRUeXBlc1BvbGljeU5hbWVdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhvdFxuICogQHByb3BlcnR5IHtib29sZWFufSBsaXZlUmVsb2FkXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHByb2dyZXNzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBPdmVybGF5T3B0aW9uc30gb3ZlcmxheVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsb2dnaW5nXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZWNvbm5lY3RdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0dXNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNVbmxvYWRpbmdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjdXJyZW50SGFzaFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwcmV2aW91c0hhc2hdXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCB7IHdhcm5pbmdzPzogYm9vbGVhbiB8IHN0cmluZzsgZXJyb3JzPzogYm9vbGVhbiB8IHN0cmluZzsgcnVudGltZUVycm9ycz86IGJvb2xlYW4gfCBzdHJpbmc7IH19IG92ZXJsYXlPcHRpb25zXG4gKi9cbnZhciBkZWNvZGVPdmVybGF5T3B0aW9ucyA9IGZ1bmN0aW9uIGRlY29kZU92ZXJsYXlPcHRpb25zKG92ZXJsYXlPcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3ZlcmxheU9wdGlvbnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBbXCJ3YXJuaW5nc1wiLCBcImVycm9yc1wiLCBcInJ1bnRpbWVFcnJvcnNcIl0uZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3ZlcmxheU9wdGlvbnNbcHJvcGVydHldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBvdmVybGF5RmlsdGVyRnVuY3Rpb25TdHJpbmcgPSBkZWNvZGVVUklDb21wb25lbnQob3ZlcmxheU9wdGlvbnNbcHJvcGVydHldKTtcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgICAgdmFyIG92ZXJsYXlGaWx0ZXJGdW5jdGlvbiA9IG5ldyBGdW5jdGlvbihcIm1lc3NhZ2VcIiwgXCJ2YXIgY2FsbGJhY2sgPSBcIi5jb25jYXQob3ZlcmxheUZpbHRlckZ1bmN0aW9uU3RyaW5nLCBcIlxcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpXCIpKTtcbiAgICAgICAgb3ZlcmxheU9wdGlvbnNbcHJvcGVydHldID0gb3ZlcmxheUZpbHRlckZ1bmN0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlIHtTdGF0dXN9XG4gKi9cbnZhciBzdGF0dXMgPSB7XG4gIGlzVW5sb2FkaW5nOiBmYWxzZSxcbiAgLy8gVE9ETyBXb3JrYXJvdW5kIGZvciB3ZWJwYWNrIHY0LCBgX193ZWJwYWNrX2hhc2hfX2AgaXMgbm90IHJlcGxhY2VkIHdpdGhvdXQgSG90TW9kdWxlUmVwbGFjZW1lbnRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICBjdXJyZW50SGFzaDogdHlwZW9mIF9fd2VicGFja19oYXNoX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfaGFzaF9fIDogXCJcIlxufTtcblxuLyoqIEB0eXBlIHtPcHRpb25zfSAqL1xudmFyIG9wdGlvbnMgPSB7XG4gIGhvdDogZmFsc2UsXG4gIGxpdmVSZWxvYWQ6IGZhbHNlLFxuICBwcm9ncmVzczogZmFsc2UsXG4gIG92ZXJsYXk6IGZhbHNlXG59O1xudmFyIHBhcnNlZFJlc291cmNlUXVlcnkgPSBwYXJzZVVSTChfX3Jlc291cmNlUXVlcnkpO1xudmFyIGVuYWJsZWRGZWF0dXJlcyA9IHtcbiAgXCJIb3QgTW9kdWxlIFJlcGxhY2VtZW50XCI6IGZhbHNlLFxuICBcIkxpdmUgUmVsb2FkaW5nXCI6IGZhbHNlLFxuICBQcm9ncmVzczogZmFsc2UsXG4gIE92ZXJsYXk6IGZhbHNlXG59O1xuaWYgKHBhcnNlZFJlc291cmNlUXVlcnkuaG90ID09PSBcInRydWVcIikge1xuICBvcHRpb25zLmhvdCA9IHRydWU7XG4gIGVuYWJsZWRGZWF0dXJlc1tcIkhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcIl0gPSB0cnVlO1xufVxuaWYgKHBhcnNlZFJlc291cmNlUXVlcnlbXCJsaXZlLXJlbG9hZFwiXSA9PT0gXCJ0cnVlXCIpIHtcbiAgb3B0aW9ucy5saXZlUmVsb2FkID0gdHJ1ZTtcbiAgZW5hYmxlZEZlYXR1cmVzW1wiTGl2ZSBSZWxvYWRpbmdcIl0gPSB0cnVlO1xufVxuaWYgKHBhcnNlZFJlc291cmNlUXVlcnkucHJvZ3Jlc3MgPT09IFwidHJ1ZVwiKSB7XG4gIG9wdGlvbnMucHJvZ3Jlc3MgPSB0cnVlO1xuICBlbmFibGVkRmVhdHVyZXMuUHJvZ3Jlc3MgPSB0cnVlO1xufVxuaWYgKHBhcnNlZFJlc291cmNlUXVlcnkub3ZlcmxheSkge1xuICB0cnkge1xuICAgIG9wdGlvbnMub3ZlcmxheSA9IEpTT04ucGFyc2UocGFyc2VkUmVzb3VyY2VRdWVyeS5vdmVybGF5KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvcihcIkVycm9yIHBhcnNpbmcgb3ZlcmxheSBvcHRpb25zIGZyb20gcmVzb3VyY2UgcXVlcnk6XCIsIGUpO1xuICB9XG5cbiAgLy8gRmlsbCBpbiBkZWZhdWx0IFwidHJ1ZVwiIHBhcmFtcyBmb3IgcGFydGlhbGx5LXNwZWNpZmllZCBvYmplY3RzLlxuICBpZiAodHlwZW9mIG9wdGlvbnMub3ZlcmxheSA9PT0gXCJvYmplY3RcIikge1xuICAgIG9wdGlvbnMub3ZlcmxheSA9IF9vYmplY3RTcHJlYWQoe1xuICAgICAgZXJyb3JzOiB0cnVlLFxuICAgICAgd2FybmluZ3M6IHRydWUsXG4gICAgICBydW50aW1lRXJyb3JzOiB0cnVlXG4gICAgfSwgb3B0aW9ucy5vdmVybGF5KTtcbiAgICBkZWNvZGVPdmVybGF5T3B0aW9ucyhvcHRpb25zLm92ZXJsYXkpO1xuICB9XG4gIGVuYWJsZWRGZWF0dXJlcy5PdmVybGF5ID0gdHJ1ZTtcbn1cbmlmIChwYXJzZWRSZXNvdXJjZVF1ZXJ5LmxvZ2dpbmcpIHtcbiAgb3B0aW9ucy5sb2dnaW5nID0gcGFyc2VkUmVzb3VyY2VRdWVyeS5sb2dnaW5nO1xufVxuaWYgKHR5cGVvZiBwYXJzZWRSZXNvdXJjZVF1ZXJ5LnJlY29ubmVjdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBvcHRpb25zLnJlY29ubmVjdCA9IE51bWJlcihwYXJzZWRSZXNvdXJjZVF1ZXJ5LnJlY29ubmVjdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGxldmVsXG4gKi9cbmZ1bmN0aW9uIHNldEFsbExvZ0xldmVsKGxldmVsKSB7XG4gIC8vIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIEhNUiBsb2dnZXIgb3BlcmF0ZSBzZXBhcmF0ZWx5IGZyb20gZGV2IHNlcnZlciBsb2dnZXJcbiAgd2VicGFja0hvdExvZy5zZXRMb2dMZXZlbChsZXZlbCA9PT0gXCJ2ZXJib3NlXCIgfHwgbGV2ZWwgPT09IFwibG9nXCIgPyBcImluZm9cIiA6IGxldmVsKTtcbiAgc2V0TG9nTGV2ZWwobGV2ZWwpO1xufVxuaWYgKG9wdGlvbnMubG9nZ2luZykge1xuICBzZXRBbGxMb2dMZXZlbChvcHRpb25zLmxvZ2dpbmcpO1xufVxubG9nRW5hYmxlZEZlYXR1cmVzKGVuYWJsZWRGZWF0dXJlcyk7XG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICBzdGF0dXMuaXNVbmxvYWRpbmcgPSB0cnVlO1xufSk7XG52YXIgb3ZlcmxheSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBjcmVhdGVPdmVybGF5KHR5cGVvZiBvcHRpb25zLm92ZXJsYXkgPT09IFwib2JqZWN0XCIgPyB7XG4gIHRydXN0ZWRUeXBlc1BvbGljeU5hbWU6IG9wdGlvbnMub3ZlcmxheS50cnVzdGVkVHlwZXNQb2xpY3lOYW1lLFxuICBjYXRjaFJ1bnRpbWVFcnJvcjogb3B0aW9ucy5vdmVybGF5LnJ1bnRpbWVFcnJvcnNcbn0gOiB7XG4gIHRydXN0ZWRUeXBlc1BvbGljeU5hbWU6IGZhbHNlLFxuICBjYXRjaFJ1bnRpbWVFcnJvcjogb3B0aW9ucy5vdmVybGF5XG59KSA6IHtcbiAgc2VuZDogZnVuY3Rpb24gc2VuZCgpIHt9XG59O1xudmFyIG9uU29ja2V0TWVzc2FnZSA9IHtcbiAgaG90OiBmdW5jdGlvbiBob3QoKSB7XG4gICAgaWYgKHBhcnNlZFJlc291cmNlUXVlcnkuaG90ID09PSBcImZhbHNlXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3B0aW9ucy5ob3QgPSB0cnVlO1xuICB9LFxuICBsaXZlUmVsb2FkOiBmdW5jdGlvbiBsaXZlUmVsb2FkKCkge1xuICAgIGlmIChwYXJzZWRSZXNvdXJjZVF1ZXJ5W1wibGl2ZS1yZWxvYWRcIl0gPT09IFwiZmFsc2VcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvcHRpb25zLmxpdmVSZWxvYWQgPSB0cnVlO1xuICB9LFxuICBpbnZhbGlkOiBmdW5jdGlvbiBpbnZhbGlkKCkge1xuICAgIGxvZy5pbmZvKFwiQXBwIHVwZGF0ZWQuIFJlY29tcGlsaW5nLi4uXCIpO1xuXG4gICAgLy8gRml4ZXMgIzEwNDIuIG92ZXJsYXkgZG9lc24ndCBjbGVhciBpZiBlcnJvcnMgYXJlIGZpeGVkIGJ1dCB3YXJuaW5ncyByZW1haW4uXG4gICAgaWYgKG9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJESVNNSVNTXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZShcIkludmFsaWRcIik7XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuICAgKi9cbiAgaGFzaDogZnVuY3Rpb24gaGFzaChfaGFzaCkge1xuICAgIHN0YXR1cy5wcmV2aW91c0hhc2ggPSBzdGF0dXMuY3VycmVudEhhc2g7XG4gICAgc3RhdHVzLmN1cnJlbnRIYXNoID0gX2hhc2g7XG4gIH0sXG4gIGxvZ2dpbmc6IHNldEFsbExvZ0xldmVsLFxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICAgKi9cbiAgb3ZlcmxheTogZnVuY3Rpb24gb3ZlcmxheSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3B0aW9ucy5vdmVybGF5ID0gdmFsdWU7XG4gICAgZGVjb2RlT3ZlcmxheU9wdGlvbnMob3B0aW9ucy5vdmVybGF5KTtcbiAgfSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVjb25uZWN0OiBmdW5jdGlvbiByZWNvbm5lY3QodmFsdWUpIHtcbiAgICBpZiAocGFyc2VkUmVzb3VyY2VRdWVyeS5yZWNvbm5lY3QgPT09IFwiZmFsc2VcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvcHRpb25zLnJlY29ubmVjdCA9IHZhbHVlO1xuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICAgKi9cbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKHZhbHVlKSB7XG4gICAgb3B0aW9ucy5wcm9ncmVzcyA9IHZhbHVlO1xuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHt7IHBsdWdpbk5hbWU/OiBzdHJpbmcsIHBlcmNlbnQ6IG51bWJlciwgbXNnOiBzdHJpbmcgfX0gZGF0YVxuICAgKi9cbiAgXCJwcm9ncmVzcy11cGRhdGVcIjogZnVuY3Rpb24gcHJvZ3Jlc3NVcGRhdGUoZGF0YSkge1xuICAgIGlmIChvcHRpb25zLnByb2dyZXNzKSB7XG4gICAgICBsb2cuaW5mbyhcIlwiLmNvbmNhdChkYXRhLnBsdWdpbk5hbWUgPyBcIltcIi5jb25jYXQoZGF0YS5wbHVnaW5OYW1lLCBcIl0gXCIpIDogXCJcIikuY29uY2F0KGRhdGEucGVyY2VudCwgXCIlIC0gXCIpLmNvbmNhdChkYXRhLm1zZywgXCIuXCIpKTtcbiAgICB9XG4gICAgc2VuZE1lc3NhZ2UoXCJQcm9ncmVzc1wiLCBkYXRhKTtcbiAgfSxcbiAgXCJzdGlsbC1va1wiOiBmdW5jdGlvbiBzdGlsbE9rKCkge1xuICAgIGxvZy5pbmZvKFwiTm90aGluZyBjaGFuZ2VkLlwiKTtcbiAgICBpZiAob3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICBvdmVybGF5LnNlbmQoe1xuICAgICAgICB0eXBlOiBcIkRJU01JU1NcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlKFwiU3RpbGxPa1wiKTtcbiAgfSxcbiAgb2s6IGZ1bmN0aW9uIG9rKCkge1xuICAgIHNlbmRNZXNzYWdlKFwiT2tcIik7XG4gICAgaWYgKG9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJESVNNSVNTXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZWxvYWRBcHAob3B0aW9ucywgc3RhdHVzKTtcbiAgfSxcbiAgLy8gVE9ETzogcmVtb3ZlIGluIHY1IGluIGZhdm9yIG9mICdzdGF0aWMtY2hhbmdlZCdcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlXG4gICAqL1xuICBcImNvbnRlbnQtY2hhbmdlZFwiOiBmdW5jdGlvbiBjb250ZW50Q2hhbmdlZChmaWxlKSB7XG4gICAgbG9nLmluZm8oXCJcIi5jb25jYXQoZmlsZSA/IFwiXFxcIlwiLmNvbmNhdChmaWxlLCBcIlxcXCJcIikgOiBcIkNvbnRlbnRcIiwgXCIgZnJvbSBzdGF0aWMgZGlyZWN0b3J5IHdhcyBjaGFuZ2VkLiBSZWxvYWRpbmcuLi5cIikpO1xuICAgIHNlbGYubG9jYXRpb24ucmVsb2FkKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZVxuICAgKi9cbiAgXCJzdGF0aWMtY2hhbmdlZFwiOiBmdW5jdGlvbiBzdGF0aWNDaGFuZ2VkKGZpbGUpIHtcbiAgICBsb2cuaW5mbyhcIlwiLmNvbmNhdChmaWxlID8gXCJcXFwiXCIuY29uY2F0KGZpbGUsIFwiXFxcIlwiKSA6IFwiQ29udGVudFwiLCBcIiBmcm9tIHN0YXRpYyBkaXJlY3Rvcnkgd2FzIGNoYW5nZWQuIFJlbG9hZGluZy4uLlwiKSk7XG4gICAgc2VsZi5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7RXJyb3JbXX0gd2FybmluZ3NcbiAgICogQHBhcmFtIHthbnl9IHBhcmFtc1xuICAgKi9cbiAgd2FybmluZ3M6IGZ1bmN0aW9uIHdhcm5pbmdzKF93YXJuaW5ncywgcGFyYW1zKSB7XG4gICAgbG9nLndhcm4oXCJXYXJuaW5ncyB3aGlsZSBjb21waWxpbmcuXCIpO1xuICAgIHZhciBwcmludGFibGVXYXJuaW5ncyA9IF93YXJuaW5ncy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICB2YXIgX2Zvcm1hdFByb2JsZW0gPSBmb3JtYXRQcm9ibGVtKFwid2FybmluZ1wiLCBlcnJvciksXG4gICAgICAgIGhlYWRlciA9IF9mb3JtYXRQcm9ibGVtLmhlYWRlcixcbiAgICAgICAgYm9keSA9IF9mb3JtYXRQcm9ibGVtLmJvZHk7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQoaGVhZGVyLCBcIlxcblwiKS5jb25jYXQoc3RyaXBBbnNpKGJvZHkpKTtcbiAgICB9KTtcbiAgICBzZW5kTWVzc2FnZShcIldhcm5pbmdzXCIsIHByaW50YWJsZVdhcm5pbmdzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW50YWJsZVdhcm5pbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cud2FybihwcmludGFibGVXYXJuaW5nc1tpXSk7XG4gICAgfVxuICAgIHZhciBvdmVybGF5V2FybmluZ3NTZXR0aW5nID0gdHlwZW9mIG9wdGlvbnMub3ZlcmxheSA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zLm92ZXJsYXkgOiBvcHRpb25zLm92ZXJsYXkgJiYgb3B0aW9ucy5vdmVybGF5Lndhcm5pbmdzO1xuICAgIGlmIChvdmVybGF5V2FybmluZ3NTZXR0aW5nKSB7XG4gICAgICB2YXIgd2FybmluZ3NUb0Rpc3BsYXkgPSB0eXBlb2Ygb3ZlcmxheVdhcm5pbmdzU2V0dGluZyA9PT0gXCJmdW5jdGlvblwiID8gX3dhcm5pbmdzLmZpbHRlcihvdmVybGF5V2FybmluZ3NTZXR0aW5nKSA6IF93YXJuaW5ncztcbiAgICAgIGlmICh3YXJuaW5nc1RvRGlzcGxheS5sZW5ndGgpIHtcbiAgICAgICAgb3ZlcmxheS5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIkJVSUxEX0VSUk9SXCIsXG4gICAgICAgICAgbGV2ZWw6IFwid2FybmluZ1wiLFxuICAgICAgICAgIG1lc3NhZ2VzOiBfd2FybmluZ3NcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLnByZXZlbnRSZWxvYWRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Vycm9yW119IGVycm9yc1xuICAgKi9cbiAgZXJyb3JzOiBmdW5jdGlvbiBlcnJvcnMoX2Vycm9ycykge1xuICAgIGxvZy5lcnJvcihcIkVycm9ycyB3aGlsZSBjb21waWxpbmcuIFJlbG9hZCBwcmV2ZW50ZWQuXCIpO1xuICAgIHZhciBwcmludGFibGVFcnJvcnMgPSBfZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHZhciBfZm9ybWF0UHJvYmxlbTIgPSBmb3JtYXRQcm9ibGVtKFwiZXJyb3JcIiwgZXJyb3IpLFxuICAgICAgICBoZWFkZXIgPSBfZm9ybWF0UHJvYmxlbTIuaGVhZGVyLFxuICAgICAgICBib2R5ID0gX2Zvcm1hdFByb2JsZW0yLmJvZHk7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQoaGVhZGVyLCBcIlxcblwiKS5jb25jYXQoc3RyaXBBbnNpKGJvZHkpKTtcbiAgICB9KTtcbiAgICBzZW5kTWVzc2FnZShcIkVycm9yc1wiLCBwcmludGFibGVFcnJvcnMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpbnRhYmxlRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cuZXJyb3IocHJpbnRhYmxlRXJyb3JzW2ldKTtcbiAgICB9XG4gICAgdmFyIG92ZXJsYXlFcnJvcnNTZXR0aW5ncyA9IHR5cGVvZiBvcHRpb25zLm92ZXJsYXkgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucy5vdmVybGF5IDogb3B0aW9ucy5vdmVybGF5ICYmIG9wdGlvbnMub3ZlcmxheS5lcnJvcnM7XG4gICAgaWYgKG92ZXJsYXlFcnJvcnNTZXR0aW5ncykge1xuICAgICAgdmFyIGVycm9yc1RvRGlzcGxheSA9IHR5cGVvZiBvdmVybGF5RXJyb3JzU2V0dGluZ3MgPT09IFwiZnVuY3Rpb25cIiA/IF9lcnJvcnMuZmlsdGVyKG92ZXJsYXlFcnJvcnNTZXR0aW5ncykgOiBfZXJyb3JzO1xuICAgICAgaWYgKGVycm9yc1RvRGlzcGxheS5sZW5ndGgpIHtcbiAgICAgICAgb3ZlcmxheS5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIkJVSUxEX0VSUk9SXCIsXG4gICAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgICBtZXNzYWdlczogX2Vycm9yc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICAgKi9cbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKF9lcnJvcikge1xuICAgIGxvZy5lcnJvcihfZXJyb3IpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgbG9nLmluZm8oXCJEaXNjb25uZWN0ZWQhXCIpO1xuICAgIGlmIChvcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiRElTTUlTU1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgc2VuZE1lc3NhZ2UoXCJDbG9zZVwiKTtcbiAgfVxufTtcbnZhciBzb2NrZXRVUkwgPSBjcmVhdGVTb2NrZXRVUkwocGFyc2VkUmVzb3VyY2VRdWVyeSk7XG5zb2NrZXQoc29ja2V0VVJMLCBvblNvY2tldE1lc3NhZ2UsIG9wdGlvbnMucmVjb25uZWN0KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=3000&pathname=%2Fws&logging=none&overlay=true&reconnect=10&hot=true&live-reload=true\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/modules/logger/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/modules/logger/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/******/(function () {\n  // webpackBootstrap\n  /******/\n  \"use strict\";\n\n  /******/\n  var __webpack_modules__ = {\n    /***/\"./client-src/modules/logger/SyncBailHookFake.js\": (\n    /*!*******************************************************!*\\\n      !*** ./client-src/modules/logger/SyncBailHookFake.js ***!\n      \\*******************************************************/\n    /***/\n    function (module) {\n      /**\n       * Client stub for tapable SyncBailHook\n       */\n      module.exports = function clientTapableSyncBailHook() {\n        return {\n          call: function call() {}\n        };\n      };\n\n      /***/\n    }),\n    /***/\"./node_modules/webpack/lib/logging/Logger.js\": (\n    /*!****************************************************!*\\\n      !*** ./node_modules/webpack/lib/logging/Logger.js ***!\n      \\****************************************************/\n    /***/\n    function (__unused_webpack_module, exports) {\n      /*\n      \tMIT License http://www.opensource.org/licenses/mit-license.php\n      \tAuthor Tobias Koppers @sokra\n      */\n\n      function _toConsumableArray(arr) {\n        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n      }\n      function _nonIterableSpread() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }\n      function _unsupportedIterableToArray(o, minLen) {\n        if (!o) return;\n        if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n        var n = Object.prototype.toString.call(o).slice(8, -1);\n        if (n === \"Object\" && o.constructor) n = o.constructor.name;\n        if (n === \"Map\" || n === \"Set\") return Array.from(o);\n        if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n      }\n      function _iterableToArray(iter) {\n        if (typeof (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }) !== \"undefined\" && iter[(typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }).iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n      }\n      function _arrayWithoutHoles(arr) {\n        if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n      }\n      function _arrayLikeToArray(arr, len) {\n        if (len == null || len > arr.length) len = arr.length;\n        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n        return arr2;\n      }\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n        }\n      }\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        Object.defineProperty(Constructor, \"prototype\", {\n          writable: false\n        });\n        return Constructor;\n      }\n      function _toPropertyKey(arg) {\n        var key = _toPrimitive(arg, \"string\");\n        return typeof key === \"symbol\" ? key : String(key);\n      }\n      function _toPrimitive(input, hint) {\n        if (typeof input !== \"object\" || input === null) return input;\n        var prim = input[(typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }).toPrimitive];\n        if (prim !== undefined) {\n          var res = prim.call(input, hint || \"default\");\n          if (typeof res !== \"object\") return res;\n          throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return (hint === \"string\" ? String : Number)(input);\n      }\n      var LogType = Object.freeze({\n        error: /** @type {\"error\"} */\"error\",\n        // message, c style arguments\n        warn: /** @type {\"warn\"} */\"warn\",\n        // message, c style arguments\n        info: /** @type {\"info\"} */\"info\",\n        // message, c style arguments\n        log: /** @type {\"log\"} */\"log\",\n        // message, c style arguments\n        debug: /** @type {\"debug\"} */\"debug\",\n        // message, c style arguments\n\n        trace: /** @type {\"trace\"} */\"trace\",\n        // no arguments\n\n        group: /** @type {\"group\"} */\"group\",\n        // [label]\n        groupCollapsed: /** @type {\"groupCollapsed\"} */\"groupCollapsed\",\n        // [label]\n        groupEnd: /** @type {\"groupEnd\"} */\"groupEnd\",\n        // [label]\n\n        profile: /** @type {\"profile\"} */\"profile\",\n        // [profileName]\n        profileEnd: /** @type {\"profileEnd\"} */\"profileEnd\",\n        // [profileName]\n\n        time: /** @type {\"time\"} */\"time\",\n        // name, time as [seconds, nanoseconds]\n\n        clear: /** @type {\"clear\"} */\"clear\",\n        // no arguments\n        status: /** @type {\"status\"} */\"status\" // message, arguments\n      });\n      exports.LogType = LogType;\n\n      /** @typedef {typeof LogType[keyof typeof LogType]} LogTypeEnum */\n\n      var LOG_SYMBOL = (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n        return i;\n      })(\"webpack logger raw log method\");\n      var TIMERS_SYMBOL = (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n        return i;\n      })(\"webpack logger times\");\n      var TIMERS_AGGREGATES_SYMBOL = (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n        return i;\n      })(\"webpack logger aggregated times\");\n      var WebpackLogger = /*#__PURE__*/function () {\n        /**\n         * @param {function(LogTypeEnum, any[]=): void} log log function\n         * @param {function(string | function(): string): WebpackLogger} getChildLogger function to create child logger\n         */\n        function WebpackLogger(log, getChildLogger) {\n          _classCallCheck(this, WebpackLogger);\n          this[LOG_SYMBOL] = log;\n          this.getChildLogger = getChildLogger;\n        }\n        _createClass(WebpackLogger, [{\n          key: \"error\",\n          value: function error() {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            this[LOG_SYMBOL](LogType.error, args);\n          }\n        }, {\n          key: \"warn\",\n          value: function warn() {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n            this[LOG_SYMBOL](LogType.warn, args);\n          }\n        }, {\n          key: \"info\",\n          value: function info() {\n            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n              args[_key3] = arguments[_key3];\n            }\n            this[LOG_SYMBOL](LogType.info, args);\n          }\n        }, {\n          key: \"log\",\n          value: function log() {\n            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n              args[_key4] = arguments[_key4];\n            }\n            this[LOG_SYMBOL](LogType.log, args);\n          }\n        }, {\n          key: \"debug\",\n          value: function debug() {\n            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n              args[_key5] = arguments[_key5];\n            }\n            this[LOG_SYMBOL](LogType.debug, args);\n          }\n        }, {\n          key: \"assert\",\n          value: function assert(assertion) {\n            if (!assertion) {\n              for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n                args[_key6 - 1] = arguments[_key6];\n              }\n              this[LOG_SYMBOL](LogType.error, args);\n            }\n          }\n        }, {\n          key: \"trace\",\n          value: function trace() {\n            this[LOG_SYMBOL](LogType.trace, [\"Trace\"]);\n          }\n        }, {\n          key: \"clear\",\n          value: function clear() {\n            this[LOG_SYMBOL](LogType.clear);\n          }\n        }, {\n          key: \"status\",\n          value: function status() {\n            for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n              args[_key7] = arguments[_key7];\n            }\n            this[LOG_SYMBOL](LogType.status, args);\n          }\n        }, {\n          key: \"group\",\n          value: function group() {\n            for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n              args[_key8] = arguments[_key8];\n            }\n            this[LOG_SYMBOL](LogType.group, args);\n          }\n        }, {\n          key: \"groupCollapsed\",\n          value: function groupCollapsed() {\n            for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n              args[_key9] = arguments[_key9];\n            }\n            this[LOG_SYMBOL](LogType.groupCollapsed, args);\n          }\n        }, {\n          key: \"groupEnd\",\n          value: function groupEnd() {\n            for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n              args[_key10] = arguments[_key10];\n            }\n            this[LOG_SYMBOL](LogType.groupEnd, args);\n          }\n        }, {\n          key: \"profile\",\n          value: function profile(label) {\n            this[LOG_SYMBOL](LogType.profile, [label]);\n          }\n        }, {\n          key: \"profileEnd\",\n          value: function profileEnd(label) {\n            this[LOG_SYMBOL](LogType.profileEnd, [label]);\n          }\n        }, {\n          key: \"time\",\n          value: function time(label) {\n            this[TIMERS_SYMBOL] = this[TIMERS_SYMBOL] || new Map();\n            this[TIMERS_SYMBOL].set(label, process.hrtime());\n          }\n        }, {\n          key: \"timeLog\",\n          value: function timeLog(label) {\n            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);\n            if (!prev) {\n              throw new Error(\"No such label '\".concat(label, \"' for WebpackLogger.timeLog()\"));\n            }\n            var time = process.hrtime(prev);\n            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));\n          }\n        }, {\n          key: \"timeEnd\",\n          value: function timeEnd(label) {\n            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);\n            if (!prev) {\n              throw new Error(\"No such label '\".concat(label, \"' for WebpackLogger.timeEnd()\"));\n            }\n            var time = process.hrtime(prev);\n            this[TIMERS_SYMBOL].delete(label);\n            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));\n          }\n        }, {\n          key: \"timeAggregate\",\n          value: function timeAggregate(label) {\n            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);\n            if (!prev) {\n              throw new Error(\"No such label '\".concat(label, \"' for WebpackLogger.timeAggregate()\"));\n            }\n            var time = process.hrtime(prev);\n            this[TIMERS_SYMBOL].delete(label);\n            this[TIMERS_AGGREGATES_SYMBOL] = this[TIMERS_AGGREGATES_SYMBOL] || new Map();\n            var current = this[TIMERS_AGGREGATES_SYMBOL].get(label);\n            if (current !== undefined) {\n              if (time[1] + current[1] > 1e9) {\n                time[0] += current[0] + 1;\n                time[1] = time[1] - 1e9 + current[1];\n              } else {\n                time[0] += current[0];\n                time[1] += current[1];\n              }\n            }\n            this[TIMERS_AGGREGATES_SYMBOL].set(label, time);\n          }\n        }, {\n          key: \"timeAggregateEnd\",\n          value: function timeAggregateEnd(label) {\n            if (this[TIMERS_AGGREGATES_SYMBOL] === undefined) return;\n            var time = this[TIMERS_AGGREGATES_SYMBOL].get(label);\n            if (time === undefined) return;\n            this[TIMERS_AGGREGATES_SYMBOL].delete(label);\n            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));\n          }\n        }]);\n        return WebpackLogger;\n      }();\n      exports.Logger = WebpackLogger;\n\n      /***/\n    }),\n    /***/\"./node_modules/webpack/lib/logging/createConsoleLogger.js\": (\n    /*!*****************************************************************!*\\\n      !*** ./node_modules/webpack/lib/logging/createConsoleLogger.js ***!\n      \\*****************************************************************/\n    /***/\n    function (module, __unused_webpack_exports, __nested_webpack_require_13160__) {\n      /*\n      \tMIT License http://www.opensource.org/licenses/mit-license.php\n      \tAuthor Tobias Koppers @sokra\n      */\n\n      function _toConsumableArray(arr) {\n        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n      }\n      function _nonIterableSpread() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }\n      function _unsupportedIterableToArray(o, minLen) {\n        if (!o) return;\n        if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n        var n = Object.prototype.toString.call(o).slice(8, -1);\n        if (n === \"Object\" && o.constructor) n = o.constructor.name;\n        if (n === \"Map\" || n === \"Set\") return Array.from(o);\n        if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n      }\n      function _iterableToArray(iter) {\n        if (typeof (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }) !== \"undefined\" && iter[(typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }).iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n      }\n      function _arrayWithoutHoles(arr) {\n        if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n      }\n      function _arrayLikeToArray(arr, len) {\n        if (len == null || len > arr.length) len = arr.length;\n        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n        return arr2;\n      }\n      var _require = __nested_webpack_require_13160__(/*! ./Logger */\"./node_modules/webpack/lib/logging/Logger.js\"),\n        LogType = _require.LogType;\n\n      /** @typedef {import(\"../../declarations/WebpackOptions\").FilterItemTypes} FilterItemTypes */\n      /** @typedef {import(\"../../declarations/WebpackOptions\").FilterTypes} FilterTypes */\n      /** @typedef {import(\"./Logger\").LogTypeEnum} LogTypeEnum */\n\n      /** @typedef {function(string): boolean} FilterFunction */\n\n      /**\n       * @typedef {Object} LoggerConsole\n       * @property {function(): void} clear\n       * @property {function(): void} trace\n       * @property {(...args: any[]) => void} info\n       * @property {(...args: any[]) => void} log\n       * @property {(...args: any[]) => void} warn\n       * @property {(...args: any[]) => void} error\n       * @property {(...args: any[]) => void=} debug\n       * @property {(...args: any[]) => void=} group\n       * @property {(...args: any[]) => void=} groupCollapsed\n       * @property {(...args: any[]) => void=} groupEnd\n       * @property {(...args: any[]) => void=} status\n       * @property {(...args: any[]) => void=} profile\n       * @property {(...args: any[]) => void=} profileEnd\n       * @property {(...args: any[]) => void=} logTime\n       */\n\n      /**\n       * @typedef {Object} LoggerOptions\n       * @property {false|true|\"none\"|\"error\"|\"warn\"|\"info\"|\"log\"|\"verbose\"} level loglevel\n       * @property {FilterTypes|boolean} debug filter for debug logging\n       * @property {LoggerConsole} console the console to log to\n       */\n\n      /**\n       * @param {FilterItemTypes} item an input item\n       * @returns {FilterFunction} filter function\n       */\n      var filterToFunction = function filterToFunction(item) {\n        if (typeof item === \"string\") {\n          var regExp = new RegExp(\"[\\\\\\\\/]\".concat(item.replace(\n          // eslint-disable-next-line no-useless-escape\n          /[-[\\]{}()*+?.\\\\^$|]/g, \"\\\\$&\"), \"([\\\\\\\\/]|$|!|\\\\?)\"));\n          return function (ident) {\n            return regExp.test(ident);\n          };\n        }\n        if (item && typeof item === \"object\" && typeof item.test === \"function\") {\n          return function (ident) {\n            return item.test(ident);\n          };\n        }\n        if (typeof item === \"function\") {\n          return item;\n        }\n        if (typeof item === \"boolean\") {\n          return function () {\n            return item;\n          };\n        }\n      };\n\n      /**\n       * @enum {number}\n       */\n      var LogLevel = {\n        none: 6,\n        false: 6,\n        error: 5,\n        warn: 4,\n        info: 3,\n        log: 2,\n        true: 2,\n        verbose: 1\n      };\n\n      /**\n       * @param {LoggerOptions} options options object\n       * @returns {function(string, LogTypeEnum, any[]): void} logging function\n       */\n      module.exports = function (_ref) {\n        var _ref$level = _ref.level,\n          level = _ref$level === void 0 ? \"info\" : _ref$level,\n          _ref$debug = _ref.debug,\n          debug = _ref$debug === void 0 ? false : _ref$debug,\n          console = _ref.console;\n        var debugFilters = typeof debug === \"boolean\" ? [function () {\n          return debug;\n        }] : /** @type {FilterItemTypes[]} */[].concat(debug).map(filterToFunction);\n        /** @type {number} */\n        var loglevel = LogLevel[\"\".concat(level)] || 0;\n\n        /**\n         * @param {string} name name of the logger\n         * @param {LogTypeEnum} type type of the log entry\n         * @param {any[]} args arguments of the log entry\n         * @returns {void}\n         */\n        var logger = function logger(name, type, args) {\n          var labeledArgs = function labeledArgs() {\n            if (Array.isArray(args)) {\n              if (args.length > 0 && typeof args[0] === \"string\") {\n                return [\"[\".concat(name, \"] \").concat(args[0])].concat(_toConsumableArray(args.slice(1)));\n              } else {\n                return [\"[\".concat(name, \"]\")].concat(_toConsumableArray(args));\n              }\n            } else {\n              return [];\n            }\n          };\n          var debug = debugFilters.some(function (f) {\n            return f(name);\n          });\n          switch (type) {\n            case LogType.debug:\n              if (!debug) return;\n              // eslint-disable-next-line node/no-unsupported-features/node-builtins\n              if (typeof console.debug === \"function\") {\n                // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                console.debug.apply(console, _toConsumableArray(labeledArgs()));\n              } else {\n                console.log.apply(console, _toConsumableArray(labeledArgs()));\n              }\n              break;\n            case LogType.log:\n              if (!debug && loglevel > LogLevel.log) return;\n              console.log.apply(console, _toConsumableArray(labeledArgs()));\n              break;\n            case LogType.info:\n              if (!debug && loglevel > LogLevel.info) return;\n              console.info.apply(console, _toConsumableArray(labeledArgs()));\n              break;\n            case LogType.warn:\n              if (!debug && loglevel > LogLevel.warn) return;\n              console.warn.apply(console, _toConsumableArray(labeledArgs()));\n              break;\n            case LogType.error:\n              if (!debug && loglevel > LogLevel.error) return;\n              console.error.apply(console, _toConsumableArray(labeledArgs()));\n              break;\n            case LogType.trace:\n              if (!debug) return;\n              console.trace();\n              break;\n            case LogType.groupCollapsed:\n              if (!debug && loglevel > LogLevel.log) return;\n              if (!debug && loglevel > LogLevel.verbose) {\n                // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                if (typeof console.groupCollapsed === \"function\") {\n                  // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                  console.groupCollapsed.apply(console, _toConsumableArray(labeledArgs()));\n                } else {\n                  console.log.apply(console, _toConsumableArray(labeledArgs()));\n                }\n                break;\n              }\n            // falls through\n            case LogType.group:\n              if (!debug && loglevel > LogLevel.log) return;\n              // eslint-disable-next-line node/no-unsupported-features/node-builtins\n              if (typeof console.group === \"function\") {\n                // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                console.group.apply(console, _toConsumableArray(labeledArgs()));\n              } else {\n                console.log.apply(console, _toConsumableArray(labeledArgs()));\n              }\n              break;\n            case LogType.groupEnd:\n              if (!debug && loglevel > LogLevel.log) return;\n              // eslint-disable-next-line node/no-unsupported-features/node-builtins\n              if (typeof console.groupEnd === \"function\") {\n                // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                console.groupEnd();\n              }\n              break;\n            case LogType.time:\n              {\n                if (!debug && loglevel > LogLevel.log) return;\n                var ms = args[1] * 1000 + args[2] / 1000000;\n                var msg = \"[\".concat(name, \"] \").concat(args[0], \": \").concat(ms, \" ms\");\n                if (typeof console.logTime === \"function\") {\n                  console.logTime(msg);\n                } else {\n                  console.log(msg);\n                }\n                break;\n              }\n            case LogType.profile:\n              // eslint-disable-next-line node/no-unsupported-features/node-builtins\n              if (typeof console.profile === \"function\") {\n                // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                console.profile.apply(console, _toConsumableArray(labeledArgs()));\n              }\n              break;\n            case LogType.profileEnd:\n              // eslint-disable-next-line node/no-unsupported-features/node-builtins\n              if (typeof console.profileEnd === \"function\") {\n                // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                console.profileEnd.apply(console, _toConsumableArray(labeledArgs()));\n              }\n              break;\n            case LogType.clear:\n              if (!debug && loglevel > LogLevel.log) return;\n              // eslint-disable-next-line node/no-unsupported-features/node-builtins\n              if (typeof console.clear === \"function\") {\n                // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                console.clear();\n              }\n              break;\n            case LogType.status:\n              if (!debug && loglevel > LogLevel.info) return;\n              if (typeof console.status === \"function\") {\n                if (args.length === 0) {\n                  console.status();\n                } else {\n                  console.status.apply(console, _toConsumableArray(labeledArgs()));\n                }\n              } else {\n                if (args.length !== 0) {\n                  console.info.apply(console, _toConsumableArray(labeledArgs()));\n                }\n              }\n              break;\n            default:\n              throw new Error(\"Unexpected LogType \".concat(type));\n          }\n        };\n        return logger;\n      };\n\n      /***/\n    }),\n    /***/\"./node_modules/webpack/lib/logging/runtime.js\": (\n    /*!*****************************************************!*\\\n      !*** ./node_modules/webpack/lib/logging/runtime.js ***!\n      \\*****************************************************/\n    /***/\n    function (__unused_webpack_module, exports, __nested_webpack_require_24775__) {\n      /*\n      \tMIT License http://www.opensource.org/licenses/mit-license.php\n      \tAuthor Tobias Koppers @sokra\n      */\n\n      function _extends() {\n        _extends = Object.assign ? Object.assign.bind() : function (target) {\n          for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i];\n            for (var key in source) {\n              if (Object.prototype.hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n              }\n            }\n          }\n          return target;\n        };\n        return _extends.apply(this, arguments);\n      }\n      var SyncBailHook = __nested_webpack_require_24775__(/*! tapable/lib/SyncBailHook */\"./client-src/modules/logger/SyncBailHookFake.js\");\n      var _require = __nested_webpack_require_24775__(/*! ./Logger */\"./node_modules/webpack/lib/logging/Logger.js\"),\n        Logger = _require.Logger;\n      var createConsoleLogger = __nested_webpack_require_24775__(/*! ./createConsoleLogger */\"./node_modules/webpack/lib/logging/createConsoleLogger.js\");\n\n      /** @type {createConsoleLogger.LoggerOptions} */\n      var currentDefaultLoggerOptions = {\n        level: \"info\",\n        debug: false,\n        console: console\n      };\n      var currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);\n\n      /**\n       * @param {string} name name of the logger\n       * @returns {Logger} a logger\n       */\n      exports.getLogger = function (name) {\n        return new Logger(function (type, args) {\n          if (exports.hooks.log.call(name, type, args) === undefined) {\n            currentDefaultLogger(name, type, args);\n          }\n        }, function (childName) {\n          return exports.getLogger(\"\".concat(name, \"/\").concat(childName));\n        });\n      };\n\n      /**\n       * @param {createConsoleLogger.LoggerOptions} options new options, merge with old options\n       * @returns {void}\n       */\n      exports.configureDefaultLogger = function (options) {\n        _extends(currentDefaultLoggerOptions, options);\n        currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);\n      };\n      exports.hooks = {\n        log: new SyncBailHook([\"origin\", \"type\", \"args\"])\n      };\n\n      /***/\n    })\n\n    /******/\n  };\n  /************************************************************************/\n  /******/ // The module cache\n  /******/\n  var __webpack_module_cache__ = {};\n  /******/\n  /******/ // The require function\n  /******/\n  function __nested_webpack_require_27238__(moduleId) {\n    /******/ // Check if module is in cache\n    /******/var cachedModule = __webpack_module_cache__[moduleId];\n    /******/\n    if (cachedModule !== undefined) {\n      /******/return cachedModule.exports;\n      /******/\n    }\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = __webpack_module_cache__[moduleId] = {\n      /******/ // no module.id needed\n      /******/ // no module.loaded needed\n      /******/exports: {}\n      /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_27238__);\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  }\n  /******/\n  /************************************************************************/\n  /******/ /* webpack/runtime/define property getters */\n  /******/\n  !function () {\n    /******/ // define getter functions for harmony exports\n    /******/__nested_webpack_require_27238__.d = function (exports, definition) {\n      /******/for (var key in definition) {\n        /******/if (__nested_webpack_require_27238__.o(definition, key) && !__nested_webpack_require_27238__.o(exports, key)) {\n          /******/Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: definition[key]\n          });\n          /******/\n        }\n        /******/\n      }\n      /******/\n    };\n    /******/\n  }();\n  /******/\n  /******/ /* webpack/runtime/hasOwnProperty shorthand */\n  /******/\n  !function () {\n    /******/__nested_webpack_require_27238__.o = function (obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    };\n    /******/\n  }();\n  /******/\n  /******/ /* webpack/runtime/make namespace object */\n  /******/\n  !function () {\n    /******/ // define __esModule on exports\n    /******/__nested_webpack_require_27238__.r = function (exports) {\n      /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n        /******/Object.defineProperty(exports, Symbol.toStringTag, {\n          value: 'Module'\n        });\n        /******/\n      }\n      /******/\n      Object.defineProperty(exports, '__esModule', {\n        value: true\n      });\n      /******/\n    };\n    /******/\n  }();\n  /******/\n  /************************************************************************/\n  var __nested_webpack_exports__ = {};\n  // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n  !function () {\n    /*!********************************************!*\\\n      !*** ./client-src/modules/logger/index.js ***!\n      \\********************************************/\n    __nested_webpack_require_27238__.r(__nested_webpack_exports__);\n    /* harmony export */\n    __nested_webpack_require_27238__.d(__nested_webpack_exports__, {\n      /* harmony export */\"default\": function () {\n        return /* reexport default export from named module */webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__;\n      }\n      /* harmony export */\n    });\n    /* harmony import */\n    var webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_27238__(/*! webpack/lib/logging/runtime.js */\"./node_modules/webpack/lib/logging/runtime.js\");\n  }();\n  var __webpack_export_target__ = exports;\n  for (var i in __nested_webpack_exports__) __webpack_export_target__[i] = __nested_webpack_exports__[i];\n  if (__nested_webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, \"__esModule\", {\n    value: true\n  });\n  /******/\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9tb2R1bGVzL2xvZ2dlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQSwwQkFBMEIsU0FBUztBQUNuQzs7QUFFQSwwQkFBMEIsU0FBUztBQUNuQzs7QUFFQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQSw2QkFBNkIsWUFBWTtBQUN6Qzs7QUFFQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBLCtCQUEr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QW1CO0FBQ3ZGLE1BQU0sMEJBQW1CO0FBQ3pCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L21vZHVsZXMvbG9nZ2VyL2luZGV4LmpzPzYyZWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKi8oZnVuY3Rpb24gKCkge1xuICAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4gIC8qKioqKiovXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8qKioqKiovXG4gIHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0ge1xuICAgIC8qKiovXCIuL2NsaWVudC1zcmMvbW9kdWxlcy9sb2dnZXIvU3luY0JhaWxIb29rRmFrZS5qc1wiOiAoXG4gICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICEqKiogLi9jbGllbnQtc3JjL21vZHVsZXMvbG9nZ2VyL1N5bmNCYWlsSG9va0Zha2UuanMgKioqIVxuICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qKiovXG4gICAgZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgLyoqXG4gICAgICAgKiBDbGllbnQgc3R1YiBmb3IgdGFwYWJsZSBTeW5jQmFpbEhvb2tcbiAgICAgICAqL1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjbGllbnRUYXBhYmxlU3luY0JhaWxIb29rKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNhbGw6IGZ1bmN0aW9uIGNhbGwoKSB7fVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgLyoqKi9cbiAgICB9KSxcbiAgICAvKioqL1wiLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9Mb2dnZXIuanNcIjogKFxuICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvTG9nZ2VyLmpzICoqKiFcbiAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKioqL1xuICAgIGZ1bmN0aW9uIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuICAgICAgLypcbiAgICAgIFx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgICAgIFx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgICAgICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICAgICAgaWYgKCFvKSByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICAgICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gICAgICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICAgICAgICBpZiAodHlwZW9mICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSkgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlclsodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbCA6IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0pLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gICAgICAgIHJldHVybiBhcnIyO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgICAgICAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgICAgICAgdmFyIHByaW0gPSBpbnB1dFsodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbCA6IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0pLnRvUHJpbWl0aXZlXTtcbiAgICAgICAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHZhciBMb2dUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGVycm9yOiAvKiogQHR5cGUge1wiZXJyb3JcIn0gKi9cImVycm9yXCIsXG4gICAgICAgIC8vIG1lc3NhZ2UsIGMgc3R5bGUgYXJndW1lbnRzXG4gICAgICAgIHdhcm46IC8qKiBAdHlwZSB7XCJ3YXJuXCJ9ICovXCJ3YXJuXCIsXG4gICAgICAgIC8vIG1lc3NhZ2UsIGMgc3R5bGUgYXJndW1lbnRzXG4gICAgICAgIGluZm86IC8qKiBAdHlwZSB7XCJpbmZvXCJ9ICovXCJpbmZvXCIsXG4gICAgICAgIC8vIG1lc3NhZ2UsIGMgc3R5bGUgYXJndW1lbnRzXG4gICAgICAgIGxvZzogLyoqIEB0eXBlIHtcImxvZ1wifSAqL1wibG9nXCIsXG4gICAgICAgIC8vIG1lc3NhZ2UsIGMgc3R5bGUgYXJndW1lbnRzXG4gICAgICAgIGRlYnVnOiAvKiogQHR5cGUge1wiZGVidWdcIn0gKi9cImRlYnVnXCIsXG4gICAgICAgIC8vIG1lc3NhZ2UsIGMgc3R5bGUgYXJndW1lbnRzXG5cbiAgICAgICAgdHJhY2U6IC8qKiBAdHlwZSB7XCJ0cmFjZVwifSAqL1widHJhY2VcIixcbiAgICAgICAgLy8gbm8gYXJndW1lbnRzXG5cbiAgICAgICAgZ3JvdXA6IC8qKiBAdHlwZSB7XCJncm91cFwifSAqL1wiZ3JvdXBcIixcbiAgICAgICAgLy8gW2xhYmVsXVxuICAgICAgICBncm91cENvbGxhcHNlZDogLyoqIEB0eXBlIHtcImdyb3VwQ29sbGFwc2VkXCJ9ICovXCJncm91cENvbGxhcHNlZFwiLFxuICAgICAgICAvLyBbbGFiZWxdXG4gICAgICAgIGdyb3VwRW5kOiAvKiogQHR5cGUge1wiZ3JvdXBFbmRcIn0gKi9cImdyb3VwRW5kXCIsXG4gICAgICAgIC8vIFtsYWJlbF1cblxuICAgICAgICBwcm9maWxlOiAvKiogQHR5cGUge1wicHJvZmlsZVwifSAqL1wicHJvZmlsZVwiLFxuICAgICAgICAvLyBbcHJvZmlsZU5hbWVdXG4gICAgICAgIHByb2ZpbGVFbmQ6IC8qKiBAdHlwZSB7XCJwcm9maWxlRW5kXCJ9ICovXCJwcm9maWxlRW5kXCIsXG4gICAgICAgIC8vIFtwcm9maWxlTmFtZV1cblxuICAgICAgICB0aW1lOiAvKiogQHR5cGUge1widGltZVwifSAqL1widGltZVwiLFxuICAgICAgICAvLyBuYW1lLCB0aW1lIGFzIFtzZWNvbmRzLCBuYW5vc2Vjb25kc11cblxuICAgICAgICBjbGVhcjogLyoqIEB0eXBlIHtcImNsZWFyXCJ9ICovXCJjbGVhclwiLFxuICAgICAgICAvLyBubyBhcmd1bWVudHNcbiAgICAgICAgc3RhdHVzOiAvKiogQHR5cGUge1wic3RhdHVzXCJ9ICovXCJzdGF0dXNcIiAvLyBtZXNzYWdlLCBhcmd1bWVudHNcbiAgICAgIH0pO1xuICAgICAgZXhwb3J0cy5Mb2dUeXBlID0gTG9nVHlwZTtcblxuICAgICAgLyoqIEB0eXBlZGVmIHt0eXBlb2YgTG9nVHlwZVtrZXlvZiB0eXBlb2YgTG9nVHlwZV19IExvZ1R5cGVFbnVtICovXG5cbiAgICAgIHZhciBMT0dfU1lNQk9MID0gKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wgOiBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0pKFwid2VicGFjayBsb2dnZXIgcmF3IGxvZyBtZXRob2RcIik7XG4gICAgICB2YXIgVElNRVJTX1NZTUJPTCA9ICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9KShcIndlYnBhY2sgbG9nZ2VyIHRpbWVzXCIpO1xuICAgICAgdmFyIFRJTUVSU19BR0dSRUdBVEVTX1NZTUJPTCA9ICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9KShcIndlYnBhY2sgbG9nZ2VyIGFnZ3JlZ2F0ZWQgdGltZXNcIik7XG4gICAgICB2YXIgV2VicGFja0xvZ2dlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKExvZ1R5cGVFbnVtLCBhbnlbXT0pOiB2b2lkfSBsb2cgbG9nIGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nIHwgZnVuY3Rpb24oKTogc3RyaW5nKTogV2VicGFja0xvZ2dlcn0gZ2V0Q2hpbGRMb2dnZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGNoaWxkIGxvZ2dlclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gV2VicGFja0xvZ2dlcihsb2csIGdldENoaWxkTG9nZ2VyKSB7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYnBhY2tMb2dnZXIpO1xuICAgICAgICAgIHRoaXNbTE9HX1NZTUJPTF0gPSBsb2c7XG4gICAgICAgICAgdGhpcy5nZXRDaGlsZExvZ2dlciA9IGdldENoaWxkTG9nZ2VyO1xuICAgICAgICB9XG4gICAgICAgIF9jcmVhdGVDbGFzcyhXZWJwYWNrTG9nZ2VyLCBbe1xuICAgICAgICAgIGtleTogXCJlcnJvclwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLmVycm9yLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwid2FyblwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3YXJuKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS53YXJuLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiaW5mb1wiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZvKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS5pbmZvLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwibG9nXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvZygpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUubG9nLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZGVidWdcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLmRlYnVnLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiYXNzZXJ0XCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFzc2VydChhc3NlcnRpb24pIHtcbiAgICAgICAgICAgIGlmICghYXNzZXJ0aW9uKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiA+IDEgPyBfbGVuNiAtIDEgOiAwKSwgX2tleTYgPSAxOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5NiAtIDFdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuZXJyb3IsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJ0cmFjZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFjZSgpIHtcbiAgICAgICAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS50cmFjZSwgW1wiVHJhY2VcIl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjbGVhclwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS5jbGVhcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInN0YXR1c1wiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGF0dXMoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcpLCBfa2V5NyA9IDA7IF9rZXk3IDwgX2xlbjc7IF9rZXk3KyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5N10gPSBhcmd1bWVudHNbX2tleTddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLnN0YXR1cywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImdyb3VwXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdyb3VwKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2xlbjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW44KSwgX2tleTggPSAwOyBfa2V5OCA8IF9sZW44OyBfa2V5OCsrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2tleThdID0gYXJndW1lbnRzW19rZXk4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS5ncm91cCwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImdyb3VwQ29sbGFwc2VkXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdyb3VwQ29sbGFwc2VkKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2xlbjkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW45KSwgX2tleTkgPSAwOyBfa2V5OSA8IF9sZW45OyBfa2V5OSsrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2tleTldID0gYXJndW1lbnRzW19rZXk5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS5ncm91cENvbGxhcHNlZCwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImdyb3VwRW5kXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdyb3VwRW5kKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2xlbjEwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTApLCBfa2V5MTAgPSAwOyBfa2V5MTAgPCBfbGVuMTA7IF9rZXkxMCsrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2tleTEwXSA9IGFyZ3VtZW50c1tfa2V5MTBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLmdyb3VwRW5kLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwicHJvZmlsZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9maWxlKGxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUucHJvZmlsZSwgW2xhYmVsXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInByb2ZpbGVFbmRcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvZmlsZUVuZChsYWJlbCkge1xuICAgICAgICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLnByb2ZpbGVFbmQsIFtsYWJlbF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJ0aW1lXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWUobGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXNbVElNRVJTX1NZTUJPTF0gPSB0aGlzW1RJTUVSU19TWU1CT0xdIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXNbVElNRVJTX1NZTUJPTF0uc2V0KGxhYmVsLCBwcm9jZXNzLmhydGltZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwidGltZUxvZ1wiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lTG9nKGxhYmVsKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHRoaXNbVElNRVJTX1NZTUJPTF0gJiYgdGhpc1tUSU1FUlNfU1lNQk9MXS5nZXQobGFiZWwpO1xuICAgICAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggbGFiZWwgJ1wiLmNvbmNhdChsYWJlbCwgXCInIGZvciBXZWJwYWNrTG9nZ2VyLnRpbWVMb2coKVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGltZSA9IHByb2Nlc3MuaHJ0aW1lKHByZXYpO1xuICAgICAgICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLnRpbWUsIFtsYWJlbF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aW1lKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJ0aW1lRW5kXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVFbmQobGFiZWwpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpc1tUSU1FUlNfU1lNQk9MXSAmJiB0aGlzW1RJTUVSU19TWU1CT0xdLmdldChsYWJlbCk7XG4gICAgICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBsYWJlbCAnXCIuY29uY2F0KGxhYmVsLCBcIicgZm9yIFdlYnBhY2tMb2dnZXIudGltZUVuZCgpXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0aW1lID0gcHJvY2Vzcy5ocnRpbWUocHJldik7XG4gICAgICAgICAgICB0aGlzW1RJTUVSU19TWU1CT0xdLmRlbGV0ZShsYWJlbCk7XG4gICAgICAgICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUudGltZSwgW2xhYmVsXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRpbWUpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInRpbWVBZ2dyZWdhdGVcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdGltZUFnZ3JlZ2F0ZShsYWJlbCkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSB0aGlzW1RJTUVSU19TWU1CT0xdICYmIHRoaXNbVElNRVJTX1NZTUJPTF0uZ2V0KGxhYmVsKTtcbiAgICAgICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsICdcIi5jb25jYXQobGFiZWwsIFwiJyBmb3IgV2VicGFja0xvZ2dlci50aW1lQWdncmVnYXRlKClcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRpbWUgPSBwcm9jZXNzLmhydGltZShwcmV2KTtcbiAgICAgICAgICAgIHRoaXNbVElNRVJTX1NZTUJPTF0uZGVsZXRlKGxhYmVsKTtcbiAgICAgICAgICAgIHRoaXNbVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MXSA9IHRoaXNbVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MXSB8fCBuZXcgTWFwKCk7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXNbVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MXS5nZXQobGFiZWwpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAodGltZVsxXSArIGN1cnJlbnRbMV0gPiAxZTkpIHtcbiAgICAgICAgICAgICAgICB0aW1lWzBdICs9IGN1cnJlbnRbMF0gKyAxO1xuICAgICAgICAgICAgICAgIHRpbWVbMV0gPSB0aW1lWzFdIC0gMWU5ICsgY3VycmVudFsxXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lWzBdICs9IGN1cnJlbnRbMF07XG4gICAgICAgICAgICAgICAgdGltZVsxXSArPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW1RJTUVSU19BR0dSRUdBVEVTX1NZTUJPTF0uc2V0KGxhYmVsLCB0aW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwidGltZUFnZ3JlZ2F0ZUVuZFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lQWdncmVnYXRlRW5kKGxhYmVsKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tUSU1FUlNfQUdHUkVHQVRFU19TWU1CT0xdID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgICAgIHZhciB0aW1lID0gdGhpc1tUSU1FUlNfQUdHUkVHQVRFU19TWU1CT0xdLmdldChsYWJlbCk7XG4gICAgICAgICAgICBpZiAodGltZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzW1RJTUVSU19BR0dSRUdBVEVTX1NZTUJPTF0uZGVsZXRlKGxhYmVsKTtcbiAgICAgICAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS50aW1lLCBbbGFiZWxdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGltZSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgICAgcmV0dXJuIFdlYnBhY2tMb2dnZXI7XG4gICAgICB9KCk7XG4gICAgICBleHBvcnRzLkxvZ2dlciA9IFdlYnBhY2tMb2dnZXI7XG5cbiAgICAgIC8qKiovXG4gICAgfSksXG4gICAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvY3JlYXRlQ29uc29sZUxvZ2dlci5qc1wiOiAoXG4gICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvY3JlYXRlQ29uc29sZUxvZ2dlci5qcyAqKiohXG4gICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qKiovXG4gICAgZnVuY3Rpb24gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAvKlxuICAgICAgXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICAgICAgXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gICAgICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICAgICAgICBpZiAoIW8pIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgICAgICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgICAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgICAgICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wgOiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9KSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyWyh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSkuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgICAgICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcbiAgICAgICAgcmV0dXJuIGFycjI7XG4gICAgICB9XG4gICAgICB2YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0xvZ2dlciAqL1wiLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9Mb2dnZXIuanNcIiksXG4gICAgICAgIExvZ1R5cGUgPSBfcmVxdWlyZS5Mb2dUeXBlO1xuXG4gICAgICAvKiogQHR5cGVkZWYge2ltcG9ydChcIi4uLy4uL2RlY2xhcmF0aW9ucy9XZWJwYWNrT3B0aW9uc1wiKS5GaWx0ZXJJdGVtVHlwZXN9IEZpbHRlckl0ZW1UeXBlcyAqL1xuICAgICAgLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi8uLi9kZWNsYXJhdGlvbnMvV2VicGFja09wdGlvbnNcIikuRmlsdGVyVHlwZXN9IEZpbHRlclR5cGVzICovXG4gICAgICAvKiogQHR5cGVkZWYge2ltcG9ydChcIi4vTG9nZ2VyXCIpLkxvZ1R5cGVFbnVtfSBMb2dUeXBlRW51bSAqL1xuXG4gICAgICAvKiogQHR5cGVkZWYge2Z1bmN0aW9uKHN0cmluZyk6IGJvb2xlYW59IEZpbHRlckZ1bmN0aW9uICovXG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGVkZWYge09iamVjdH0gTG9nZ2VyQ29uc29sZVxuICAgICAgICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiB2b2lkfSBjbGVhclxuICAgICAgICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiB2b2lkfSB0cmFjZVxuICAgICAgICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWR9IGluZm9cbiAgICAgICAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBsb2dcbiAgICAgICAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSB3YXJuXG4gICAgICAgKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gZXJyb3JcbiAgICAgICAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gZGVidWdcbiAgICAgICAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gZ3JvdXBcbiAgICAgICAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gZ3JvdXBDb2xsYXBzZWRcbiAgICAgICAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gZ3JvdXBFbmRcbiAgICAgICAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gc3RhdHVzXG4gICAgICAgKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZD19IHByb2ZpbGVcbiAgICAgICAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gcHJvZmlsZUVuZFxuICAgICAgICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWQ9fSBsb2dUaW1lXG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBMb2dnZXJPcHRpb25zXG4gICAgICAgKiBAcHJvcGVydHkge2ZhbHNlfHRydWV8XCJub25lXCJ8XCJlcnJvclwifFwid2FyblwifFwiaW5mb1wifFwibG9nXCJ8XCJ2ZXJib3NlXCJ9IGxldmVsIGxvZ2xldmVsXG4gICAgICAgKiBAcHJvcGVydHkge0ZpbHRlclR5cGVzfGJvb2xlYW59IGRlYnVnIGZpbHRlciBmb3IgZGVidWcgbG9nZ2luZ1xuICAgICAgICogQHByb3BlcnR5IHtMb2dnZXJDb25zb2xlfSBjb25zb2xlIHRoZSBjb25zb2xlIHRvIGxvZyB0b1xuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtGaWx0ZXJJdGVtVHlwZXN9IGl0ZW0gYW4gaW5wdXQgaXRlbVxuICAgICAgICogQHJldHVybnMge0ZpbHRlckZ1bmN0aW9ufSBmaWx0ZXIgZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgdmFyIGZpbHRlclRvRnVuY3Rpb24gPSBmdW5jdGlvbiBmaWx0ZXJUb0Z1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdmFyIHJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJbXFxcXFxcXFwvXVwiLmNvbmNhdChpdGVtLnJlcGxhY2UoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgICAgICAgL1stW1xcXXt9KCkqKz8uXFxcXF4kfF0vZywgXCJcXFxcJCZcIiksIFwiKFtcXFxcXFxcXC9dfCR8IXxcXFxcPylcIikpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdFeHAudGVzdChpZGVudCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgaXRlbS50ZXN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGlkZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS50ZXN0KGlkZW50KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEBlbnVtIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHZhciBMb2dMZXZlbCA9IHtcbiAgICAgICAgbm9uZTogNixcbiAgICAgICAgZmFsc2U6IDYsXG4gICAgICAgIGVycm9yOiA1LFxuICAgICAgICB3YXJuOiA0LFxuICAgICAgICBpbmZvOiAzLFxuICAgICAgICBsb2c6IDIsXG4gICAgICAgIHRydWU6IDIsXG4gICAgICAgIHZlcmJvc2U6IDFcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtMb2dnZXJPcHRpb25zfSBvcHRpb25zIG9wdGlvbnMgb2JqZWN0XG4gICAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBMb2dUeXBlRW51bSwgYW55W10pOiB2b2lkfSBsb2dnaW5nIGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIF9yZWYkbGV2ZWwgPSBfcmVmLmxldmVsLFxuICAgICAgICAgIGxldmVsID0gX3JlZiRsZXZlbCA9PT0gdm9pZCAwID8gXCJpbmZvXCIgOiBfcmVmJGxldmVsLFxuICAgICAgICAgIF9yZWYkZGVidWcgPSBfcmVmLmRlYnVnLFxuICAgICAgICAgIGRlYnVnID0gX3JlZiRkZWJ1ZyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGRlYnVnLFxuICAgICAgICAgIGNvbnNvbGUgPSBfcmVmLmNvbnNvbGU7XG4gICAgICAgIHZhciBkZWJ1Z0ZpbHRlcnMgPSB0eXBlb2YgZGVidWcgPT09IFwiYm9vbGVhblwiID8gW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZGVidWc7XG4gICAgICAgIH1dIDogLyoqIEB0eXBlIHtGaWx0ZXJJdGVtVHlwZXNbXX0gKi9bXS5jb25jYXQoZGVidWcpLm1hcChmaWx0ZXJUb0Z1bmN0aW9uKTtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHZhciBsb2dsZXZlbCA9IExvZ0xldmVsW1wiXCIuY29uY2F0KGxldmVsKV0gfHwgMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbG9nZ2VyXG4gICAgICAgICAqIEBwYXJhbSB7TG9nVHlwZUVudW19IHR5cGUgdHlwZSBvZiB0aGUgbG9nIGVudHJ5XG4gICAgICAgICAqIEBwYXJhbSB7YW55W119IGFyZ3MgYXJndW1lbnRzIG9mIHRoZSBsb2cgZW50cnlcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgbG9nZ2VyID0gZnVuY3Rpb24gbG9nZ2VyKG5hbWUsIHR5cGUsIGFyZ3MpIHtcbiAgICAgICAgICB2YXIgbGFiZWxlZEFyZ3MgPSBmdW5jdGlvbiBsYWJlbGVkQXJncygpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiW1wiLmNvbmNhdChuYW1lLCBcIl0gXCIpLmNvbmNhdChhcmdzWzBdKV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhcmdzLnNsaWNlKDEpKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIltcIi5jb25jYXQobmFtZSwgXCJdXCIpXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGRlYnVnID0gZGVidWdGaWx0ZXJzLnNvbWUoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmKG5hbWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBMb2dUeXBlLmRlYnVnOlxuICAgICAgICAgICAgICBpZiAoIWRlYnVnKSByZXR1cm47XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmRlYnVnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1Zy5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ1R5cGUubG9nOlxuICAgICAgICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwubG9nKSByZXR1cm47XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMb2dUeXBlLmluZm86XG4gICAgICAgICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5pbmZvKSByZXR1cm47XG4gICAgICAgICAgICAgIGNvbnNvbGUuaW5mby5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTG9nVHlwZS53YXJuOlxuICAgICAgICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwud2FybikgcmV0dXJuO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ1R5cGUuZXJyb3I6XG4gICAgICAgICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5lcnJvcikgcmV0dXJuO1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMb2dUeXBlLnRyYWNlOlxuICAgICAgICAgICAgICBpZiAoIWRlYnVnKSByZXR1cm47XG4gICAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ1R5cGUuZ3JvdXBDb2xsYXBzZWQ6XG4gICAgICAgICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5sb2cpIHJldHVybjtcbiAgICAgICAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmdyb3VwQ29sbGFwc2VkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQuYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgTG9nVHlwZS5ncm91cDpcbiAgICAgICAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmxvZykgcmV0dXJuO1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZS5ncm91cCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXAuYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMb2dUeXBlLmdyb3VwRW5kOlxuICAgICAgICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwubG9nKSByZXR1cm47XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmdyb3VwRW5kID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMb2dUeXBlLnRpbWU6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwubG9nKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIG1zID0gYXJnc1sxXSAqIDEwMDAgKyBhcmdzWzJdIC8gMTAwMDAwMDtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gXCJbXCIuY29uY2F0KG5hbWUsIFwiXSBcIikuY29uY2F0KGFyZ3NbMF0sIFwiOiBcIikuY29uY2F0KG1zLCBcIiBtc1wiKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUubG9nVGltZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZ1RpbWUobXNnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTG9nVHlwZS5wcm9maWxlOlxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZS5wcm9maWxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgICAgICAgY29uc29sZS5wcm9maWxlLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ1R5cGUucHJvZmlsZUVuZDpcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUucHJvZmlsZUVuZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgICAgICAgIGNvbnNvbGUucHJvZmlsZUVuZC5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMb2dUeXBlLmNsZWFyOlxuICAgICAgICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwubG9nKSByZXR1cm47XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmNsZWFyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgICAgICAgY29uc29sZS5jbGVhcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMb2dUeXBlLnN0YXR1czpcbiAgICAgICAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmluZm8pIHJldHVybjtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnN0YXR1cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLnN0YXR1cygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLnN0YXR1cy5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mby5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgTG9nVHlwZSBcIi5jb25jYXQodHlwZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICAgIH07XG5cbiAgICAgIC8qKiovXG4gICAgfSksXG4gICAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvcnVudGltZS5qc1wiOiAoXG4gICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAhKioqIC4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvcnVudGltZS5qcyAqKiohXG4gICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qKiovXG4gICAgZnVuY3Rpb24gKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAvKlxuICAgICAgXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICAgICAgXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgICAgICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHZhciBTeW5jQmFpbEhvb2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0YXBhYmxlL2xpYi9TeW5jQmFpbEhvb2sgKi9cIi4vY2xpZW50LXNyYy9tb2R1bGVzL2xvZ2dlci9TeW5jQmFpbEhvb2tGYWtlLmpzXCIpO1xuICAgICAgdmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Mb2dnZXIgKi9cIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvTG9nZ2VyLmpzXCIpLFxuICAgICAgICBMb2dnZXIgPSBfcmVxdWlyZS5Mb2dnZXI7XG4gICAgICB2YXIgY3JlYXRlQ29uc29sZUxvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY3JlYXRlQ29uc29sZUxvZ2dlciAqL1wiLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9jcmVhdGVDb25zb2xlTG9nZ2VyLmpzXCIpO1xuXG4gICAgICAvKiogQHR5cGUge2NyZWF0ZUNvbnNvbGVMb2dnZXIuTG9nZ2VyT3B0aW9uc30gKi9cbiAgICAgIHZhciBjdXJyZW50RGVmYXVsdExvZ2dlck9wdGlvbnMgPSB7XG4gICAgICAgIGxldmVsOiBcImluZm9cIixcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBjb25zb2xlOiBjb25zb2xlXG4gICAgICB9O1xuICAgICAgdmFyIGN1cnJlbnREZWZhdWx0TG9nZ2VyID0gY3JlYXRlQ29uc29sZUxvZ2dlcihjdXJyZW50RGVmYXVsdExvZ2dlck9wdGlvbnMpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGxvZ2dlclxuICAgICAgICogQHJldHVybnMge0xvZ2dlcn0gYSBsb2dnZXJcbiAgICAgICAqL1xuICAgICAgZXhwb3J0cy5nZXRMb2dnZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IExvZ2dlcihmdW5jdGlvbiAodHlwZSwgYXJncykge1xuICAgICAgICAgIGlmIChleHBvcnRzLmhvb2tzLmxvZy5jYWxsKG5hbWUsIHR5cGUsIGFyZ3MpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnREZWZhdWx0TG9nZ2VyKG5hbWUsIHR5cGUsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gKGNoaWxkTmFtZSkge1xuICAgICAgICAgIHJldHVybiBleHBvcnRzLmdldExvZ2dlcihcIlwiLmNvbmNhdChuYW1lLCBcIi9cIikuY29uY2F0KGNoaWxkTmFtZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtjcmVhdGVDb25zb2xlTG9nZ2VyLkxvZ2dlck9wdGlvbnN9IG9wdGlvbnMgbmV3IG9wdGlvbnMsIG1lcmdlIHdpdGggb2xkIG9wdGlvbnNcbiAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICovXG4gICAgICBleHBvcnRzLmNvbmZpZ3VyZURlZmF1bHRMb2dnZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBfZXh0ZW5kcyhjdXJyZW50RGVmYXVsdExvZ2dlck9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBjdXJyZW50RGVmYXVsdExvZ2dlciA9IGNyZWF0ZUNvbnNvbGVMb2dnZXIoY3VycmVudERlZmF1bHRMb2dnZXJPcHRpb25zKTtcbiAgICAgIH07XG4gICAgICBleHBvcnRzLmhvb2tzID0ge1xuICAgICAgICBsb2c6IG5ldyBTeW5jQmFpbEhvb2soW1wib3JpZ2luXCIsIFwidHlwZVwiLCBcImFyZ3NcIl0pXG4gICAgICB9O1xuXG4gICAgICAvKioqL1xuICAgIH0pXG5cbiAgICAvKioqKioqL1xuICB9O1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKioqKioqLyAvLyBUaGUgbW9kdWxlIGNhY2hlXG4gIC8qKioqKiovXG4gIHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiAgLyoqKioqKi9cbiAgZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuICAgIC8qKioqKiovIC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuICAgIC8qKioqKiovdmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4gICAgLyoqKioqKi9cbiAgICBpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qKioqKiovcmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuICAgICAgLyoqKioqKi9cbiAgICB9XG4gICAgLyoqKioqKi8gLy8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiAgICAvKioqKioqL1xuICAgIHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuICAgICAgLyoqKioqKi8gLy8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuICAgICAgLyoqKioqKi8gLy8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbiAgICAgIC8qKioqKiovZXhwb3J0czoge31cbiAgICAgIC8qKioqKiovXG4gICAgfTtcbiAgICAvKioqKioqL1xuICAgIC8qKioqKiovIC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuICAgIC8qKioqKiovXG4gICAgX193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4gICAgLyoqKioqKi9cbiAgICAvKioqKioqLyAvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuICAgIC8qKioqKiovXG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuICAgIC8qKioqKiovXG4gIH1cbiAgLyoqKioqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4gIC8qKioqKiovXG4gICFmdW5jdGlvbiAoKSB7XG4gICAgLyoqKioqKi8gLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuICAgIC8qKioqKiovX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24gKGV4cG9ydHMsIGRlZmluaXRpb24pIHtcbiAgICAgIC8qKioqKiovZm9yICh2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbiAgICAgICAgLyoqKioqKi9pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4gICAgICAgICAgLyoqKioqKi9PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBkZWZpbml0aW9uW2tleV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvKioqKioqL1xuICAgICAgICB9XG4gICAgICAgIC8qKioqKiovXG4gICAgICB9XG4gICAgICAvKioqKioqL1xuICAgIH07XG4gICAgLyoqKioqKi9cbiAgfSgpO1xuICAvKioqKioqL1xuICAvKioqKioqLyAvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4gIC8qKioqKiovXG4gICFmdW5jdGlvbiAoKSB7XG4gICAgLyoqKioqKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbiAob2JqLCBwcm9wKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG4gICAgfTtcbiAgICAvKioqKioqL1xuICB9KCk7XG4gIC8qKioqKiovXG4gIC8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbiAgLyoqKioqKi9cbiAgIWZ1bmN0aW9uICgpIHtcbiAgICAvKioqKioqLyAvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gICAgLyoqKioqKi9fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgICAgLyoqKioqKi9pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gICAgICAgIC8qKioqKiovT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgIHZhbHVlOiAnTW9kdWxlJ1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqKioqKi9cbiAgICAgIH1cbiAgICAgIC8qKioqKiovXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIC8qKioqKiovXG4gICAgfTtcbiAgICAvKioqKioqL1xuICB9KCk7XG4gIC8qKioqKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4gIC8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGlzb2xhdGVkIGFnYWluc3Qgb3RoZXIgbW9kdWxlcyBpbiB0aGUgY2h1bmsuXG4gICFmdW5jdGlvbiAoKSB7XG4gICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAhKioqIC4vY2xpZW50LXNyYy9tb2R1bGVzL2xvZ2dlci9pbmRleC5qcyAqKiohXG4gICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbiAgICAvKiBoYXJtb255IGV4cG9ydCAqL1xuICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gICAgICAvKiBoYXJtb255IGV4cG9ydCAqL1wiZGVmYXVsdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAvKiByZWV4cG9ydCBkZWZhdWx0IGV4cG9ydCBmcm9tIG5hbWVkIG1vZHVsZSAqL3dlYnBhY2tfbGliX2xvZ2dpbmdfcnVudGltZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fO1xuICAgICAgfVxuICAgICAgLyogaGFybW9ueSBleHBvcnQgKi9cbiAgICB9KTtcbiAgICAvKiBoYXJtb255IGltcG9ydCAqL1xuICAgIHZhciB3ZWJwYWNrX2xpYl9sb2dnaW5nX3J1bnRpbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHdlYnBhY2svbGliL2xvZ2dpbmcvcnVudGltZS5qcyAqL1wiLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9ydW50aW1lLmpzXCIpO1xuICB9KCk7XG4gIHZhciBfX3dlYnBhY2tfZXhwb3J0X3RhcmdldF9fID0gZXhwb3J0cztcbiAgZm9yICh2YXIgaSBpbiBfX3dlYnBhY2tfZXhwb3J0c19fKSBfX3dlYnBhY2tfZXhwb3J0X3RhcmdldF9fW2ldID0gX193ZWJwYWNrX2V4cG9ydHNfX1tpXTtcbiAgaWYgKF9fd2VicGFja19leHBvcnRzX18uX19lc01vZHVsZSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRfdGFyZ2V0X18sIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIC8qKioqKiovXG59KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/modules/logger/index.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay.js":
/*!***********************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOverlay: () => (/* binding */ createOverlay),\n/* harmony export */   formatProblem: () => (/* binding */ formatProblem)\n/* harmony export */ });\n/* harmony import */ var ansi_html_community__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ansi-html-community */ \"./node_modules/ansi-html-community/index.js\");\n/* harmony import */ var ansi_html_community__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ansi_html_community__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var html_entities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! html-entities */ \"./node_modules/html-entities/lib/index.js\");\n/* harmony import */ var html_entities__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(html_entities__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _overlay_runtime_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./overlay/runtime-error.js */ \"./node_modules/webpack-dev-server/client/overlay/runtime-error.js\");\n/* harmony import */ var _overlay_state_machine_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./overlay/state-machine.js */ \"./node_modules/webpack-dev-server/client/overlay/state-machine.js\");\n/* harmony import */ var _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./overlay/styles.js */ \"./node_modules/webpack-dev-server/client/overlay/styles.js\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n// The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)\n// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).\n\n\n\n\n\n\nvar colors = {\n  reset: [\"transparent\", \"transparent\"],\n  black: \"181818\",\n  red: \"E36049\",\n  green: \"B3CB74\",\n  yellow: \"FFD080\",\n  blue: \"7CAFC2\",\n  magenta: \"7FACCA\",\n  cyan: \"C3C2EF\",\n  lightgrey: \"EBE7E3\",\n  darkgrey: \"6D7891\"\n};\nansi_html_community__WEBPACK_IMPORTED_MODULE_0___default().setColors(colors);\n\n/**\n * @param {string} type\n * @param {string  | { file?: string, moduleName?: string, loc?: string, message?: string; stack?: string[] }} item\n * @returns {{ header: string, body: string }}\n */\nfunction formatProblem(type, item) {\n  var header = type === \"warning\" ? \"WARNING\" : \"ERROR\";\n  var body = \"\";\n  if (typeof item === \"string\") {\n    body += item;\n  } else {\n    var file = item.file || \"\";\n    // eslint-disable-next-line no-nested-ternary\n    var moduleName = item.moduleName ? item.moduleName.indexOf(\"!\") !== -1 ? \"\".concat(item.moduleName.replace(/^(\\s|\\S)*!/, \"\"), \" (\").concat(item.moduleName, \")\") : \"\".concat(item.moduleName) : \"\";\n    var loc = item.loc;\n    header += \"\".concat(moduleName || file ? \" in \".concat(moduleName ? \"\".concat(moduleName).concat(file ? \" (\".concat(file, \")\") : \"\") : file).concat(loc ? \" \".concat(loc) : \"\") : \"\");\n    body += item.message || \"\";\n  }\n  if (Array.isArray(item.stack)) {\n    item.stack.forEach(function (stack) {\n      if (typeof stack === \"string\") {\n        body += \"\\r\\n\".concat(stack);\n      }\n    });\n  }\n  return {\n    header: header,\n    body: body\n  };\n}\n\n/**\n * @typedef {Object} CreateOverlayOptions\n * @property {string | null} trustedTypesPolicyName\n * @property {boolean | (error: Error) => void} [catchRuntimeError]\n */\n\n/**\n *\n * @param {CreateOverlayOptions} options\n */\nvar createOverlay = function createOverlay(options) {\n  /** @type {HTMLIFrameElement | null | undefined} */\n  var iframeContainerElement;\n  /** @type {HTMLDivElement | null | undefined} */\n  var containerElement;\n  /** @type {HTMLDivElement | null | undefined} */\n  var headerElement;\n  /** @type {Array<(element: HTMLDivElement) => void>} */\n  var onLoadQueue = [];\n  /** @type {TrustedTypePolicy | undefined} */\n  var overlayTrustedTypesPolicy;\n\n  /**\n   *\n   * @param {HTMLElement} element\n   * @param {CSSStyleDeclaration} style\n   */\n  function applyStyle(element, style) {\n    Object.keys(style).forEach(function (prop) {\n      element.style[prop] = style[prop];\n    });\n  }\n\n  /**\n   * @param {string | null} trustedTypesPolicyName\n   */\n  function createContainer(trustedTypesPolicyName) {\n    // Enable Trusted Types if they are available in the current browser.\n    if (window.trustedTypes) {\n      overlayTrustedTypesPolicy = window.trustedTypes.createPolicy(trustedTypesPolicyName || \"webpack-dev-server#overlay\", {\n        createHTML: function createHTML(value) {\n          return value;\n        }\n      });\n    }\n    iframeContainerElement = document.createElement(\"iframe\");\n    iframeContainerElement.id = \"webpack-dev-server-client-overlay\";\n    iframeContainerElement.src = \"about:blank\";\n    applyStyle(iframeContainerElement, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.iframeStyle);\n    iframeContainerElement.onload = function () {\n      var contentElement = /** @type {Document} */\n      /** @type {HTMLIFrameElement} */\n      iframeContainerElement.contentDocument.createElement(\"div\");\n      containerElement = /** @type {Document} */\n      /** @type {HTMLIFrameElement} */\n      iframeContainerElement.contentDocument.createElement(\"div\");\n      contentElement.id = \"webpack-dev-server-client-overlay-div\";\n      applyStyle(contentElement, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.containerStyle);\n      headerElement = document.createElement(\"div\");\n      headerElement.innerText = \"Compiled with problems:\";\n      applyStyle(headerElement, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.headerStyle);\n      var closeButtonElement = document.createElement(\"button\");\n      applyStyle(closeButtonElement, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.dismissButtonStyle);\n      closeButtonElement.innerText = \"\";\n      closeButtonElement.ariaLabel = \"Dismiss\";\n      closeButtonElement.addEventListener(\"click\", function () {\n        // eslint-disable-next-line no-use-before-define\n        overlayService.send({\n          type: \"DISMISS\"\n        });\n      });\n      contentElement.appendChild(headerElement);\n      contentElement.appendChild(closeButtonElement);\n      contentElement.appendChild(containerElement);\n\n      /** @type {Document} */\n      /** @type {HTMLIFrameElement} */\n      iframeContainerElement.contentDocument.body.appendChild(contentElement);\n      onLoadQueue.forEach(function (onLoad) {\n        onLoad(/** @type {HTMLDivElement} */contentElement);\n      });\n      onLoadQueue = [];\n\n      /** @type {HTMLIFrameElement} */\n      iframeContainerElement.onload = null;\n    };\n    document.body.appendChild(iframeContainerElement);\n  }\n\n  /**\n   * @param {(element: HTMLDivElement) => void} callback\n   * @param {string | null} trustedTypesPolicyName\n   */\n  function ensureOverlayExists(callback, trustedTypesPolicyName) {\n    if (containerElement) {\n      containerElement.innerHTML = \"\";\n      // Everything is ready, call the callback right away.\n      callback(containerElement);\n      return;\n    }\n    onLoadQueue.push(callback);\n    if (iframeContainerElement) {\n      return;\n    }\n    createContainer(trustedTypesPolicyName);\n  }\n\n  // Successful compilation.\n  function hide() {\n    if (!iframeContainerElement) {\n      return;\n    }\n\n    // Clean up and reset internal state.\n    document.body.removeChild(iframeContainerElement);\n    iframeContainerElement = null;\n    containerElement = null;\n  }\n\n  // Compilation with errors (e.g. syntax error or missing modules).\n  /**\n   * @param {string} type\n   * @param {Array<string  | { moduleIdentifier?: string, moduleName?: string, loc?: string, message?: string }>} messages\n   * @param {string | null} trustedTypesPolicyName\n   * @param {'build' | 'runtime'} messageSource\n   */\n  function show(type, messages, trustedTypesPolicyName, messageSource) {\n    ensureOverlayExists(function () {\n      headerElement.innerText = messageSource === \"runtime\" ? \"Uncaught runtime errors:\" : \"Compiled with problems:\";\n      messages.forEach(function (message) {\n        var entryElement = document.createElement(\"div\");\n        var msgStyle = type === \"warning\" ? _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.msgStyles.warning : _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.msgStyles.error;\n        applyStyle(entryElement, _objectSpread(_objectSpread({}, msgStyle), {}, {\n          padding: \"1rem 1rem 1.5rem 1rem\"\n        }));\n        var typeElement = document.createElement(\"div\");\n        var _formatProblem = formatProblem(type, message),\n          header = _formatProblem.header,\n          body = _formatProblem.body;\n        typeElement.innerText = header;\n        applyStyle(typeElement, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.msgTypeStyle);\n        if (message.moduleIdentifier) {\n          applyStyle(typeElement, {\n            cursor: \"pointer\"\n          });\n          // element.dataset not supported in IE\n          typeElement.setAttribute(\"data-can-open\", true);\n          typeElement.addEventListener(\"click\", function () {\n            fetch(\"/webpack-dev-server/open-editor?fileName=\".concat(message.moduleIdentifier));\n          });\n        }\n\n        // Make it look similar to our terminal.\n        var text = ansi_html_community__WEBPACK_IMPORTED_MODULE_0___default()((0,html_entities__WEBPACK_IMPORTED_MODULE_4__.encode)(body));\n        var messageTextNode = document.createElement(\"div\");\n        applyStyle(messageTextNode, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.msgTextStyle);\n        messageTextNode.innerHTML = overlayTrustedTypesPolicy ? overlayTrustedTypesPolicy.createHTML(text) : text;\n        entryElement.appendChild(typeElement);\n        entryElement.appendChild(messageTextNode);\n\n        /** @type {HTMLDivElement} */\n        containerElement.appendChild(entryElement);\n      });\n    }, trustedTypesPolicyName);\n  }\n  var overlayService = (0,_overlay_state_machine_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n    showOverlay: function showOverlay(_ref) {\n      var _ref$level = _ref.level,\n        level = _ref$level === void 0 ? \"error\" : _ref$level,\n        messages = _ref.messages,\n        messageSource = _ref.messageSource;\n      return show(level, messages, options.trustedTypesPolicyName, messageSource);\n    },\n    hideOverlay: hide\n  });\n  if (options.catchRuntimeError) {\n    /**\n     * @param {Error | undefined} error\n     * @param {string} fallbackMessage\n     */\n    var handleError = function handleError(error, fallbackMessage) {\n      var errorObject = error instanceof Error ? error : new Error(error || fallbackMessage);\n      var shouldDisplay = typeof options.catchRuntimeError === \"function\" ? options.catchRuntimeError(errorObject) : true;\n      if (shouldDisplay) {\n        overlayService.send({\n          type: \"RUNTIME_ERROR\",\n          messages: [{\n            message: errorObject.message,\n            stack: (0,_overlay_runtime_error_js__WEBPACK_IMPORTED_MODULE_1__.parseErrorToStacks)(errorObject)\n          }]\n        });\n      }\n    };\n    (0,_overlay_runtime_error_js__WEBPACK_IMPORTED_MODULE_1__.listenToRuntimeError)(function (errorEvent) {\n      // error property may be empty in older browser like IE\n      var error = errorEvent.error,\n        message = errorEvent.message;\n      if (!error && !message) {\n        return;\n      }\n      handleError(error, message);\n    });\n    (0,_overlay_runtime_error_js__WEBPACK_IMPORTED_MODULE_1__.listenToUnhandledRejection)(function (promiseRejectionEvent) {\n      var reason = promiseRejectionEvent.reason;\n      handleError(reason, \"Unknown promise rejection reason\");\n    });\n  }\n  return overlayService;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJDO0FBQ0o7QUFDMkU7QUFDcEQ7QUFDNEU7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQWtCOztBQUVsQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVksb0VBQW9FLG9CQUFvQjtBQUMvRyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxlQUFlO0FBQzdCLGNBQWMsa0NBQWtDO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0EsYUFBYSxzQ0FBc0M7QUFDbkQ7QUFDQSxhQUFhLG1DQUFtQztBQUNoRDtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQ7QUFDQSxhQUFhLCtCQUErQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQVc7QUFDbEQ7QUFDQSxzQ0FBc0MsVUFBVTtBQUNoRCxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUMsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0EsaUNBQWlDLDhEQUFjO0FBQy9DO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQVc7QUFDM0M7QUFDQSxxQ0FBcUMsa0VBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixVQUFVO0FBQzNCLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUMsT0FBTztBQUNQOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGtCQUFrQixnRkFBZ0YsR0FBRztBQUNsSCxhQUFhLGVBQWU7QUFDNUIsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlEQUFTLFdBQVcseURBQVM7QUFDekUsK0RBQStELGVBQWU7QUFDOUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0REFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSxtQkFBbUIsMERBQVEsQ0FBQyxxREFBTTtBQUNsQztBQUNBLG9DQUFvQyw0REFBWTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSx1QkFBdUIscUVBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2RUFBa0I7QUFDckMsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSSwrRUFBb0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxxRkFBMEI7QUFDOUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teV9hcHAvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5LmpzP2YzMjkiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cbi8vIFRoZSBlcnJvciBvdmVybGF5IGlzIGluc3BpcmVkIChhbmQgbW9zdGx5IGNvcGllZCkgZnJvbSBDcmVhdGUgUmVhY3QgQXBwIChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tpbmN1YmF0b3IvY3JlYXRlLXJlYWN0LWFwcClcbi8vIFRoZXksIGluIHR1cm4sIGdvdCBpbnNwaXJlZCBieSB3ZWJwYWNrLWhvdC1taWRkbGV3YXJlIChodHRwczovL2dpdGh1Yi5jb20vZ2xlbmphbWluL3dlYnBhY2staG90LW1pZGRsZXdhcmUpLlxuXG5pbXBvcnQgYW5zaUhUTUwgZnJvbSBcImFuc2ktaHRtbC1jb21tdW5pdHlcIjtcbmltcG9ydCB7IGVuY29kZSB9IGZyb20gXCJodG1sLWVudGl0aWVzXCI7XG5pbXBvcnQgeyBsaXN0ZW5Ub1J1bnRpbWVFcnJvciwgbGlzdGVuVG9VbmhhbmRsZWRSZWplY3Rpb24sIHBhcnNlRXJyb3JUb1N0YWNrcyB9IGZyb20gXCIuL292ZXJsYXkvcnVudGltZS1lcnJvci5qc1wiO1xuaW1wb3J0IGNyZWF0ZU92ZXJsYXlNYWNoaW5lIGZyb20gXCIuL292ZXJsYXkvc3RhdGUtbWFjaGluZS5qc1wiO1xuaW1wb3J0IHsgY29udGFpbmVyU3R5bGUsIGRpc21pc3NCdXR0b25TdHlsZSwgaGVhZGVyU3R5bGUsIGlmcmFtZVN0eWxlLCBtc2dTdHlsZXMsIG1zZ1RleHRTdHlsZSwgbXNnVHlwZVN0eWxlIH0gZnJvbSBcIi4vb3ZlcmxheS9zdHlsZXMuanNcIjtcbnZhciBjb2xvcnMgPSB7XG4gIHJlc2V0OiBbXCJ0cmFuc3BhcmVudFwiLCBcInRyYW5zcGFyZW50XCJdLFxuICBibGFjazogXCIxODE4MThcIixcbiAgcmVkOiBcIkUzNjA0OVwiLFxuICBncmVlbjogXCJCM0NCNzRcIixcbiAgeWVsbG93OiBcIkZGRDA4MFwiLFxuICBibHVlOiBcIjdDQUZDMlwiLFxuICBtYWdlbnRhOiBcIjdGQUNDQVwiLFxuICBjeWFuOiBcIkMzQzJFRlwiLFxuICBsaWdodGdyZXk6IFwiRUJFN0UzXCIsXG4gIGRhcmtncmV5OiBcIjZENzg5MVwiXG59O1xuYW5zaUhUTUwuc2V0Q29sb3JzKGNvbG9ycyk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nICB8IHsgZmlsZT86IHN0cmluZywgbW9kdWxlTmFtZT86IHN0cmluZywgbG9jPzogc3RyaW5nLCBtZXNzYWdlPzogc3RyaW5nOyBzdGFjaz86IHN0cmluZ1tdIH19IGl0ZW1cbiAqIEByZXR1cm5zIHt7IGhlYWRlcjogc3RyaW5nLCBib2R5OiBzdHJpbmcgfX1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0UHJvYmxlbSh0eXBlLCBpdGVtKSB7XG4gIHZhciBoZWFkZXIgPSB0eXBlID09PSBcIndhcm5pbmdcIiA/IFwiV0FSTklOR1wiIDogXCJFUlJPUlwiO1xuICB2YXIgYm9keSA9IFwiXCI7XG4gIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGJvZHkgKz0gaXRlbTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmlsZSA9IGl0ZW0uZmlsZSB8fCBcIlwiO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgIHZhciBtb2R1bGVOYW1lID0gaXRlbS5tb2R1bGVOYW1lID8gaXRlbS5tb2R1bGVOYW1lLmluZGV4T2YoXCIhXCIpICE9PSAtMSA/IFwiXCIuY29uY2F0KGl0ZW0ubW9kdWxlTmFtZS5yZXBsYWNlKC9eKFxcc3xcXFMpKiEvLCBcIlwiKSwgXCIgKFwiKS5jb25jYXQoaXRlbS5tb2R1bGVOYW1lLCBcIilcIikgOiBcIlwiLmNvbmNhdChpdGVtLm1vZHVsZU5hbWUpIDogXCJcIjtcbiAgICB2YXIgbG9jID0gaXRlbS5sb2M7XG4gICAgaGVhZGVyICs9IFwiXCIuY29uY2F0KG1vZHVsZU5hbWUgfHwgZmlsZSA/IFwiIGluIFwiLmNvbmNhdChtb2R1bGVOYW1lID8gXCJcIi5jb25jYXQobW9kdWxlTmFtZSkuY29uY2F0KGZpbGUgPyBcIiAoXCIuY29uY2F0KGZpbGUsIFwiKVwiKSA6IFwiXCIpIDogZmlsZSkuY29uY2F0KGxvYyA/IFwiIFwiLmNvbmNhdChsb2MpIDogXCJcIikgOiBcIlwiKTtcbiAgICBib2R5ICs9IGl0ZW0ubWVzc2FnZSB8fCBcIlwiO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGl0ZW0uc3RhY2spKSB7XG4gICAgaXRlbS5zdGFjay5mb3JFYWNoKGZ1bmN0aW9uIChzdGFjaykge1xuICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBib2R5ICs9IFwiXFxyXFxuXCIuY29uY2F0KHN0YWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhlYWRlcjogaGVhZGVyLFxuICAgIGJvZHk6IGJvZHlcbiAgfTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDcmVhdGVPdmVybGF5T3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsfSB0cnVzdGVkVHlwZXNQb2xpY3lOYW1lXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCAoZXJyb3I6IEVycm9yKSA9PiB2b2lkfSBbY2F0Y2hSdW50aW1lRXJyb3JdXG4gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHtDcmVhdGVPdmVybGF5T3B0aW9uc30gb3B0aW9uc1xuICovXG52YXIgY3JlYXRlT3ZlcmxheSA9IGZ1bmN0aW9uIGNyZWF0ZU92ZXJsYXkob3B0aW9ucykge1xuICAvKiogQHR5cGUge0hUTUxJRnJhbWVFbGVtZW50IHwgbnVsbCB8IHVuZGVmaW5lZH0gKi9cbiAgdmFyIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQ7XG4gIC8qKiBAdHlwZSB7SFRNTERpdkVsZW1lbnQgfCBudWxsIHwgdW5kZWZpbmVkfSAqL1xuICB2YXIgY29udGFpbmVyRWxlbWVudDtcbiAgLyoqIEB0eXBlIHtIVE1MRGl2RWxlbWVudCB8IG51bGwgfCB1bmRlZmluZWR9ICovXG4gIHZhciBoZWFkZXJFbGVtZW50O1xuICAvKiogQHR5cGUge0FycmF5PChlbGVtZW50OiBIVE1MRGl2RWxlbWVudCkgPT4gdm9pZD59ICovXG4gIHZhciBvbkxvYWRRdWV1ZSA9IFtdO1xuICAvKiogQHR5cGUge1RydXN0ZWRUeXBlUG9saWN5IHwgdW5kZWZpbmVkfSAqL1xuICB2YXIgb3ZlcmxheVRydXN0ZWRUeXBlc1BvbGljeTtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseVN0eWxlKGVsZW1lbnQsIHN0eWxlKSB7XG4gICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBzdHlsZVtwcm9wXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHRydXN0ZWRUeXBlc1BvbGljeU5hbWVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcih0cnVzdGVkVHlwZXNQb2xpY3lOYW1lKSB7XG4gICAgLy8gRW5hYmxlIFRydXN0ZWQgVHlwZXMgaWYgdGhleSBhcmUgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gICAgaWYgKHdpbmRvdy50cnVzdGVkVHlwZXMpIHtcbiAgICAgIG92ZXJsYXlUcnVzdGVkVHlwZXNQb2xpY3kgPSB3aW5kb3cudHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSh0cnVzdGVkVHlwZXNQb2xpY3lOYW1lIHx8IFwid2VicGFjay1kZXYtc2VydmVyI292ZXJsYXlcIiwge1xuICAgICAgICBjcmVhdGVIVE1MOiBmdW5jdGlvbiBjcmVhdGVIVE1MKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWZyYW1lQ29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5pZCA9IFwid2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5XCI7XG4gICAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zcmMgPSBcImFib3V0OmJsYW5rXCI7XG4gICAgYXBwbHlTdHlsZShpZnJhbWVDb250YWluZXJFbGVtZW50LCBpZnJhbWVTdHlsZSk7XG4gICAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udGVudEVsZW1lbnQgPSAvKiogQHR5cGUge0RvY3VtZW50fSAqL1xuICAgICAgLyoqIEB0eXBlIHtIVE1MSUZyYW1lRWxlbWVudH0gKi9cbiAgICAgIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQuY29udGVudERvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250YWluZXJFbGVtZW50ID0gLyoqIEB0eXBlIHtEb2N1bWVudH0gKi9cbiAgICAgIC8qKiBAdHlwZSB7SFRNTElGcmFtZUVsZW1lbnR9ICovXG4gICAgICBpZnJhbWVDb250YWluZXJFbGVtZW50LmNvbnRlbnREb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudEVsZW1lbnQuaWQgPSBcIndlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheS1kaXZcIjtcbiAgICAgIGFwcGx5U3R5bGUoY29udGVudEVsZW1lbnQsIGNvbnRhaW5lclN0eWxlKTtcbiAgICAgIGhlYWRlckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgaGVhZGVyRWxlbWVudC5pbm5lclRleHQgPSBcIkNvbXBpbGVkIHdpdGggcHJvYmxlbXM6XCI7XG4gICAgICBhcHBseVN0eWxlKGhlYWRlckVsZW1lbnQsIGhlYWRlclN0eWxlKTtcbiAgICAgIHZhciBjbG9zZUJ1dHRvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgYXBwbHlTdHlsZShjbG9zZUJ1dHRvbkVsZW1lbnQsIGRpc21pc3NCdXR0b25TdHlsZSk7XG4gICAgICBjbG9zZUJ1dHRvbkVsZW1lbnQuaW5uZXJUZXh0ID0gXCLDl1wiO1xuICAgICAgY2xvc2VCdXR0b25FbGVtZW50LmFyaWFMYWJlbCA9IFwiRGlzbWlzc1wiO1xuICAgICAgY2xvc2VCdXR0b25FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBvdmVybGF5U2VydmljZS5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIkRJU01JU1NcIlxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoaGVhZGVyRWxlbWVudCk7XG4gICAgICBjb250ZW50RWxlbWVudC5hcHBlbmRDaGlsZChjbG9zZUJ1dHRvbkVsZW1lbnQpO1xuICAgICAgY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udGFpbmVyRWxlbWVudCk7XG5cbiAgICAgIC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovXG4gICAgICAvKiogQHR5cGUge0hUTUxJRnJhbWVFbGVtZW50fSAqL1xuICAgICAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5jb250ZW50RG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250ZW50RWxlbWVudCk7XG4gICAgICBvbkxvYWRRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChvbkxvYWQpIHtcbiAgICAgICAgb25Mb2FkKC8qKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9ICovY29udGVudEVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgICBvbkxvYWRRdWV1ZSA9IFtdO1xuXG4gICAgICAvKiogQHR5cGUge0hUTUxJRnJhbWVFbGVtZW50fSAqL1xuICAgICAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5vbmxvYWQgPSBudWxsO1xuICAgIH07XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWVDb250YWluZXJFbGVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyhlbGVtZW50OiBIVE1MRGl2RWxlbWVudCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSB0cnVzdGVkVHlwZXNQb2xpY3lOYW1lXG4gICAqL1xuICBmdW5jdGlvbiBlbnN1cmVPdmVybGF5RXhpc3RzKGNhbGxiYWNrLCB0cnVzdGVkVHlwZXNQb2xpY3lOYW1lKSB7XG4gICAgaWYgKGNvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgIGNvbnRhaW5lckVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgIC8vIEV2ZXJ5dGhpbmcgaXMgcmVhZHksIGNhbGwgdGhlIGNhbGxiYWNrIHJpZ2h0IGF3YXkuXG4gICAgICBjYWxsYmFjayhjb250YWluZXJFbGVtZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb25Mb2FkUXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgaWYgKGlmcmFtZUNvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3JlYXRlQ29udGFpbmVyKHRydXN0ZWRUeXBlc1BvbGljeU5hbWUpO1xuICB9XG5cbiAgLy8gU3VjY2Vzc2Z1bCBjb21waWxhdGlvbi5cbiAgZnVuY3Rpb24gaGlkZSgpIHtcbiAgICBpZiAoIWlmcmFtZUNvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cCBhbmQgcmVzZXQgaW50ZXJuYWwgc3RhdGUuXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWVDb250YWluZXJFbGVtZW50KTtcbiAgICBpZnJhbWVDb250YWluZXJFbGVtZW50ID0gbnVsbDtcbiAgICBjb250YWluZXJFbGVtZW50ID0gbnVsbDtcbiAgfVxuXG4gIC8vIENvbXBpbGF0aW9uIHdpdGggZXJyb3JzIChlLmcuIHN5bnRheCBlcnJvciBvciBtaXNzaW5nIG1vZHVsZXMpLlxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmcgIHwgeyBtb2R1bGVJZGVudGlmaWVyPzogc3RyaW5nLCBtb2R1bGVOYW1lPzogc3RyaW5nLCBsb2M/OiBzdHJpbmcsIG1lc3NhZ2U/OiBzdHJpbmcgfT59IG1lc3NhZ2VzXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gdHJ1c3RlZFR5cGVzUG9saWN5TmFtZVxuICAgKiBAcGFyYW0geydidWlsZCcgfCAncnVudGltZSd9IG1lc3NhZ2VTb3VyY2VcbiAgICovXG4gIGZ1bmN0aW9uIHNob3codHlwZSwgbWVzc2FnZXMsIHRydXN0ZWRUeXBlc1BvbGljeU5hbWUsIG1lc3NhZ2VTb3VyY2UpIHtcbiAgICBlbnN1cmVPdmVybGF5RXhpc3RzKGZ1bmN0aW9uICgpIHtcbiAgICAgIGhlYWRlckVsZW1lbnQuaW5uZXJUZXh0ID0gbWVzc2FnZVNvdXJjZSA9PT0gXCJydW50aW1lXCIgPyBcIlVuY2F1Z2h0IHJ1bnRpbWUgZXJyb3JzOlwiIDogXCJDb21waWxlZCB3aXRoIHByb2JsZW1zOlwiO1xuICAgICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgZW50cnlFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG1zZ1N0eWxlID0gdHlwZSA9PT0gXCJ3YXJuaW5nXCIgPyBtc2dTdHlsZXMud2FybmluZyA6IG1zZ1N0eWxlcy5lcnJvcjtcbiAgICAgICAgYXBwbHlTdHlsZShlbnRyeUVsZW1lbnQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbXNnU3R5bGUpLCB7fSwge1xuICAgICAgICAgIHBhZGRpbmc6IFwiMXJlbSAxcmVtIDEuNXJlbSAxcmVtXCJcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgdHlwZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgX2Zvcm1hdFByb2JsZW0gPSBmb3JtYXRQcm9ibGVtKHR5cGUsIG1lc3NhZ2UpLFxuICAgICAgICAgIGhlYWRlciA9IF9mb3JtYXRQcm9ibGVtLmhlYWRlcixcbiAgICAgICAgICBib2R5ID0gX2Zvcm1hdFByb2JsZW0uYm9keTtcbiAgICAgICAgdHlwZUVsZW1lbnQuaW5uZXJUZXh0ID0gaGVhZGVyO1xuICAgICAgICBhcHBseVN0eWxlKHR5cGVFbGVtZW50LCBtc2dUeXBlU3R5bGUpO1xuICAgICAgICBpZiAobWVzc2FnZS5tb2R1bGVJZGVudGlmaWVyKSB7XG4gICAgICAgICAgYXBwbHlTdHlsZSh0eXBlRWxlbWVudCwge1xuICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIGVsZW1lbnQuZGF0YXNldCBub3Qgc3VwcG9ydGVkIGluIElFXG4gICAgICAgICAgdHlwZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1jYW4tb3BlblwiLCB0cnVlKTtcbiAgICAgICAgICB0eXBlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmV0Y2goXCIvd2VicGFjay1kZXYtc2VydmVyL29wZW4tZWRpdG9yP2ZpbGVOYW1lPVwiLmNvbmNhdChtZXNzYWdlLm1vZHVsZUlkZW50aWZpZXIpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2UgaXQgbG9vayBzaW1pbGFyIHRvIG91ciB0ZXJtaW5hbC5cbiAgICAgICAgdmFyIHRleHQgPSBhbnNpSFRNTChlbmNvZGUoYm9keSkpO1xuICAgICAgICB2YXIgbWVzc2FnZVRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgYXBwbHlTdHlsZShtZXNzYWdlVGV4dE5vZGUsIG1zZ1RleHRTdHlsZSk7XG4gICAgICAgIG1lc3NhZ2VUZXh0Tm9kZS5pbm5lckhUTUwgPSBvdmVybGF5VHJ1c3RlZFR5cGVzUG9saWN5ID8gb3ZlcmxheVRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKHRleHQpIDogdGV4dDtcbiAgICAgICAgZW50cnlFbGVtZW50LmFwcGVuZENoaWxkKHR5cGVFbGVtZW50KTtcbiAgICAgICAgZW50cnlFbGVtZW50LmFwcGVuZENoaWxkKG1lc3NhZ2VUZXh0Tm9kZSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH0gKi9cbiAgICAgICAgY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChlbnRyeUVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSwgdHJ1c3RlZFR5cGVzUG9saWN5TmFtZSk7XG4gIH1cbiAgdmFyIG92ZXJsYXlTZXJ2aWNlID0gY3JlYXRlT3ZlcmxheU1hY2hpbmUoe1xuICAgIHNob3dPdmVybGF5OiBmdW5jdGlvbiBzaG93T3ZlcmxheShfcmVmKSB7XG4gICAgICB2YXIgX3JlZiRsZXZlbCA9IF9yZWYubGV2ZWwsXG4gICAgICAgIGxldmVsID0gX3JlZiRsZXZlbCA9PT0gdm9pZCAwID8gXCJlcnJvclwiIDogX3JlZiRsZXZlbCxcbiAgICAgICAgbWVzc2FnZXMgPSBfcmVmLm1lc3NhZ2VzLFxuICAgICAgICBtZXNzYWdlU291cmNlID0gX3JlZi5tZXNzYWdlU291cmNlO1xuICAgICAgcmV0dXJuIHNob3cobGV2ZWwsIG1lc3NhZ2VzLCBvcHRpb25zLnRydXN0ZWRUeXBlc1BvbGljeU5hbWUsIG1lc3NhZ2VTb3VyY2UpO1xuICAgIH0sXG4gICAgaGlkZU92ZXJsYXk6IGhpZGVcbiAgfSk7XG4gIGlmIChvcHRpb25zLmNhdGNoUnVudGltZUVycm9yKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFcnJvciB8IHVuZGVmaW5lZH0gZXJyb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmFsbGJhY2tNZXNzYWdlXG4gICAgICovXG4gICAgdmFyIGhhbmRsZUVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IsIGZhbGxiYWNrTWVzc2FnZSkge1xuICAgICAgdmFyIGVycm9yT2JqZWN0ID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yIHx8IGZhbGxiYWNrTWVzc2FnZSk7XG4gICAgICB2YXIgc2hvdWxkRGlzcGxheSA9IHR5cGVvZiBvcHRpb25zLmNhdGNoUnVudGltZUVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLmNhdGNoUnVudGltZUVycm9yKGVycm9yT2JqZWN0KSA6IHRydWU7XG4gICAgICBpZiAoc2hvdWxkRGlzcGxheSkge1xuICAgICAgICBvdmVybGF5U2VydmljZS5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIlJVTlRJTUVfRVJST1JcIixcbiAgICAgICAgICBtZXNzYWdlczogW3tcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yT2JqZWN0Lm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFjazogcGFyc2VFcnJvclRvU3RhY2tzKGVycm9yT2JqZWN0KVxuICAgICAgICAgIH1dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgbGlzdGVuVG9SdW50aW1lRXJyb3IoZnVuY3Rpb24gKGVycm9yRXZlbnQpIHtcbiAgICAgIC8vIGVycm9yIHByb3BlcnR5IG1heSBiZSBlbXB0eSBpbiBvbGRlciBicm93c2VyIGxpa2UgSUVcbiAgICAgIHZhciBlcnJvciA9IGVycm9yRXZlbnQuZXJyb3IsXG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvckV2ZW50Lm1lc3NhZ2U7XG4gICAgICBpZiAoIWVycm9yICYmICFtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGhhbmRsZUVycm9yKGVycm9yLCBtZXNzYWdlKTtcbiAgICB9KTtcbiAgICBsaXN0ZW5Ub1VuaGFuZGxlZFJlamVjdGlvbihmdW5jdGlvbiAocHJvbWlzZVJlamVjdGlvbkV2ZW50KSB7XG4gICAgICB2YXIgcmVhc29uID0gcHJvbWlzZVJlamVjdGlvbkV2ZW50LnJlYXNvbjtcbiAgICAgIGhhbmRsZUVycm9yKHJlYXNvbiwgXCJVbmtub3duIHByb21pc2UgcmVqZWN0aW9uIHJlYXNvblwiKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb3ZlcmxheVNlcnZpY2U7XG59O1xuZXhwb3J0IHsgZm9ybWF0UHJvYmxlbSwgY3JlYXRlT3ZlcmxheSB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/overlay.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay/fsm.js":
/*!***************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay/fsm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n/**\n * @typedef {Object} StateDefinitions\n * @property {{[event: string]: { target: string; actions?: Array<string> }}} [on]\n */\n\n/**\n * @typedef {Object} Options\n * @property {{[state: string]: StateDefinitions}} states\n * @property {object} context;\n * @property {string} initial\n */\n\n/**\n * @typedef {Object} Implementation\n * @property {{[actionName: string]: (ctx: object, event: any) => object}} actions\n */\n\n/**\n * A simplified `createMachine` from `@xstate/fsm` with the following differences:\n *\n *  - the returned machine is technically a \"service\". No `interpret(machine).start()` is needed.\n *  - the state definition only support `on` and target must be declared with { target: 'nextState', actions: [] } explicitly.\n *  - event passed to `send` must be an object with `type` property.\n *  - actions implementation will be [assign action](https://xstate.js.org/docs/guides/context.html#assign-action) if you return any value.\n *  Do not return anything if you just want to invoke side effect.\n *\n * The goal of this custom function is to avoid installing the entire `'xstate/fsm'` package, while enabling modeling using\n * state machine. You can copy the first parameter into the editor at https://stately.ai/viz to visualize the state machine.\n *\n * @param {Options} options\n * @param {Implementation} implementation\n */\nfunction createMachine(_ref, _ref2) {\n  var states = _ref.states,\n    context = _ref.context,\n    initial = _ref.initial;\n  var actions = _ref2.actions;\n  var currentState = initial;\n  var currentContext = context;\n  return {\n    send: function send(event) {\n      var currentStateOn = states[currentState].on;\n      var transitionConfig = currentStateOn && currentStateOn[event.type];\n      if (transitionConfig) {\n        currentState = transitionConfig.target;\n        if (transitionConfig.actions) {\n          transitionConfig.actions.forEach(function (actName) {\n            var actionImpl = actions[actName];\n            var nextContextValue = actionImpl && actionImpl(currentContext, event);\n            if (nextContextValue) {\n              currentContext = _objectSpread(_objectSpread({}, currentContext), nextContextValue);\n            }\n          });\n        }\n      }\n    }\n  };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createMachine);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5L2ZzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxtQkFBbUIsZ0JBQWdCLDRCQUE0QjtBQUM5RTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLG9DQUFvQztBQUNuRCxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsNERBQTREO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLG1DQUFtQztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L292ZXJsYXkvZnNtLmpzP2NjNmYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU3RhdGVEZWZpbml0aW9uc1xuICogQHByb3BlcnR5IHt7W2V2ZW50OiBzdHJpbmddOiB7IHRhcmdldDogc3RyaW5nOyBhY3Rpb25zPzogQXJyYXk8c3RyaW5nPiB9fX0gW29uXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHt7W3N0YXRlOiBzdHJpbmddOiBTdGF0ZURlZmluaXRpb25zfX0gc3RhdGVzXG4gKiBAcHJvcGVydHkge29iamVjdH0gY29udGV4dDtcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbml0aWFsXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJbXBsZW1lbnRhdGlvblxuICogQHByb3BlcnR5IHt7W2FjdGlvbk5hbWU6IHN0cmluZ106IChjdHg6IG9iamVjdCwgZXZlbnQ6IGFueSkgPT4gb2JqZWN0fX0gYWN0aW9uc1xuICovXG5cbi8qKlxuICogQSBzaW1wbGlmaWVkIGBjcmVhdGVNYWNoaW5lYCBmcm9tIGBAeHN0YXRlL2ZzbWAgd2l0aCB0aGUgZm9sbG93aW5nIGRpZmZlcmVuY2VzOlxuICpcbiAqICAtIHRoZSByZXR1cm5lZCBtYWNoaW5lIGlzIHRlY2huaWNhbGx5IGEgXCJzZXJ2aWNlXCIuIE5vIGBpbnRlcnByZXQobWFjaGluZSkuc3RhcnQoKWAgaXMgbmVlZGVkLlxuICogIC0gdGhlIHN0YXRlIGRlZmluaXRpb24gb25seSBzdXBwb3J0IGBvbmAgYW5kIHRhcmdldCBtdXN0IGJlIGRlY2xhcmVkIHdpdGggeyB0YXJnZXQ6ICduZXh0U3RhdGUnLCBhY3Rpb25zOiBbXSB9IGV4cGxpY2l0bHkuXG4gKiAgLSBldmVudCBwYXNzZWQgdG8gYHNlbmRgIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggYHR5cGVgIHByb3BlcnR5LlxuICogIC0gYWN0aW9ucyBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIFthc3NpZ24gYWN0aW9uXShodHRwczovL3hzdGF0ZS5qcy5vcmcvZG9jcy9ndWlkZXMvY29udGV4dC5odG1sI2Fzc2lnbi1hY3Rpb24pIGlmIHlvdSByZXR1cm4gYW55IHZhbHVlLlxuICogIERvIG5vdCByZXR1cm4gYW55dGhpbmcgaWYgeW91IGp1c3Qgd2FudCB0byBpbnZva2Ugc2lkZSBlZmZlY3QuXG4gKlxuICogVGhlIGdvYWwgb2YgdGhpcyBjdXN0b20gZnVuY3Rpb24gaXMgdG8gYXZvaWQgaW5zdGFsbGluZyB0aGUgZW50aXJlIGAneHN0YXRlL2ZzbSdgIHBhY2thZ2UsIHdoaWxlIGVuYWJsaW5nIG1vZGVsaW5nIHVzaW5nXG4gKiBzdGF0ZSBtYWNoaW5lLiBZb3UgY2FuIGNvcHkgdGhlIGZpcnN0IHBhcmFtZXRlciBpbnRvIHRoZSBlZGl0b3IgYXQgaHR0cHM6Ly9zdGF0ZWx5LmFpL3ZpeiB0byB2aXN1YWxpemUgdGhlIHN0YXRlIG1hY2hpbmUuXG4gKlxuICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXG4gKiBAcGFyYW0ge0ltcGxlbWVudGF0aW9ufSBpbXBsZW1lbnRhdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVNYWNoaW5lKF9yZWYsIF9yZWYyKSB7XG4gIHZhciBzdGF0ZXMgPSBfcmVmLnN0YXRlcyxcbiAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgIGluaXRpYWwgPSBfcmVmLmluaXRpYWw7XG4gIHZhciBhY3Rpb25zID0gX3JlZjIuYWN0aW9ucztcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IGluaXRpYWw7XG4gIHZhciBjdXJyZW50Q29udGV4dCA9IGNvbnRleHQ7XG4gIHJldHVybiB7XG4gICAgc2VuZDogZnVuY3Rpb24gc2VuZChldmVudCkge1xuICAgICAgdmFyIGN1cnJlbnRTdGF0ZU9uID0gc3RhdGVzW2N1cnJlbnRTdGF0ZV0ub247XG4gICAgICB2YXIgdHJhbnNpdGlvbkNvbmZpZyA9IGN1cnJlbnRTdGF0ZU9uICYmIGN1cnJlbnRTdGF0ZU9uW2V2ZW50LnR5cGVdO1xuICAgICAgaWYgKHRyYW5zaXRpb25Db25maWcpIHtcbiAgICAgICAgY3VycmVudFN0YXRlID0gdHJhbnNpdGlvbkNvbmZpZy50YXJnZXQ7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uQ29uZmlnLmFjdGlvbnMpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uQ29uZmlnLmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0TmFtZSkge1xuICAgICAgICAgICAgdmFyIGFjdGlvbkltcGwgPSBhY3Rpb25zW2FjdE5hbWVdO1xuICAgICAgICAgICAgdmFyIG5leHRDb250ZXh0VmFsdWUgPSBhY3Rpb25JbXBsICYmIGFjdGlvbkltcGwoY3VycmVudENvbnRleHQsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChuZXh0Q29udGV4dFZhbHVlKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjdXJyZW50Q29udGV4dCksIG5leHRDb250ZXh0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlTWFjaGluZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/overlay/fsm.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay/runtime-error.js":
/*!*************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay/runtime-error.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   listenToRuntimeError: () => (/* binding */ listenToRuntimeError),\n/* harmony export */   listenToUnhandledRejection: () => (/* binding */ listenToUnhandledRejection),\n/* harmony export */   parseErrorToStacks: () => (/* binding */ parseErrorToStacks)\n/* harmony export */ });\n/**\n *\n * @param {Error} error\n */\nfunction parseErrorToStacks(error) {\n  if (!error || !(error instanceof Error)) {\n    throw new Error(\"parseErrorToStacks expects Error object\");\n  }\n  if (typeof error.stack === \"string\") {\n    return error.stack.split(\"\\n\").filter(function (stack) {\n      return stack !== \"Error: \".concat(error.message);\n    });\n  }\n}\n\n/**\n * @callback ErrorCallback\n * @param {ErrorEvent} error\n * @returns {void}\n */\n\n/**\n * @param {ErrorCallback} callback\n */\nfunction listenToRuntimeError(callback) {\n  window.addEventListener(\"error\", callback);\n  return function cleanup() {\n    window.removeEventListener(\"error\", callback);\n  };\n}\n\n/**\n * @callback UnhandledRejectionCallback\n * @param {PromiseRejectionEvent} rejectionEvent\n * @returns {void}\n */\n\n/**\n * @param {UnhandledRejectionCallback} callback\n */\nfunction listenToUnhandledRejection(callback) {\n  window.addEventListener(\"unhandledrejection\", callback);\n  return function cleanup() {\n    window.removeEventListener(\"unhandledrejection\", callback);\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5L3J1bnRpbWUtZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLGFBQWE7QUFDYjs7QUFFQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlfYXBwLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvb3ZlcmxheS9ydW50aW1lLWVycm9yLmpzPzAwNmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqL1xuZnVuY3Rpb24gcGFyc2VFcnJvclRvU3RhY2tzKGVycm9yKSB7XG4gIGlmICghZXJyb3IgfHwgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInBhcnNlRXJyb3JUb1N0YWNrcyBleHBlY3RzIEVycm9yIG9iamVjdFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yLnN0YWNrID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpLmZpbHRlcihmdW5jdGlvbiAoc3RhY2spIHtcbiAgICAgIHJldHVybiBzdGFjayAhPT0gXCJFcnJvcjogXCIuY29uY2F0KGVycm9yLm1lc3NhZ2UpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQGNhbGxiYWNrIEVycm9yQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3JFdmVudH0gZXJyb3JcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtFcnJvckNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBsaXN0ZW5Ub1J1bnRpbWVFcnJvcihjYWxsYmFjaykge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGNhbGxiYWNrKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBjYWxsYmFjayk7XG4gIH07XG59XG5cbi8qKlxuICogQGNhbGxiYWNrIFVuaGFuZGxlZFJlamVjdGlvbkNhbGxiYWNrXG4gKiBAcGFyYW0ge1Byb21pc2VSZWplY3Rpb25FdmVudH0gcmVqZWN0aW9uRXZlbnRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtVbmhhbmRsZWRSZWplY3Rpb25DYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gbGlzdGVuVG9VbmhhbmRsZWRSZWplY3Rpb24oY2FsbGJhY2spIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmhhbmRsZWRyZWplY3Rpb25cIiwgY2FsbGJhY2spO1xuICByZXR1cm4gZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInVuaGFuZGxlZHJlamVjdGlvblwiLCBjYWxsYmFjayk7XG4gIH07XG59XG5leHBvcnQgeyBsaXN0ZW5Ub1J1bnRpbWVFcnJvciwgbGlzdGVuVG9VbmhhbmRsZWRSZWplY3Rpb24sIHBhcnNlRXJyb3JUb1N0YWNrcyB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/overlay/runtime-error.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay/state-machine.js":
/*!*************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay/state-machine.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _fsm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fsm.js */ \"./node_modules/webpack-dev-server/client/overlay/fsm.js\");\n\n\n/**\n * @typedef {Object} ShowOverlayData\n * @property {'warning' | 'error'} level\n * @property {Array<string  | { moduleIdentifier?: string, moduleName?: string, loc?: string, message?: string }>} messages\n * @property {'build' | 'runtime'} messageSource\n */\n\n/**\n * @typedef {Object} CreateOverlayMachineOptions\n * @property {(data: ShowOverlayData) => void} showOverlay\n * @property {() => void} hideOverlay\n */\n\n/**\n * @param {CreateOverlayMachineOptions} options\n */\nvar createOverlayMachine = function createOverlayMachine(options) {\n  var hideOverlay = options.hideOverlay,\n    showOverlay = options.showOverlay;\n  var overlayMachine = (0,_fsm_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    initial: \"hidden\",\n    context: {\n      level: \"error\",\n      messages: [],\n      messageSource: \"build\"\n    },\n    states: {\n      hidden: {\n        on: {\n          BUILD_ERROR: {\n            target: \"displayBuildError\",\n            actions: [\"setMessages\", \"showOverlay\"]\n          },\n          RUNTIME_ERROR: {\n            target: \"displayRuntimeError\",\n            actions: [\"setMessages\", \"showOverlay\"]\n          }\n        }\n      },\n      displayBuildError: {\n        on: {\n          DISMISS: {\n            target: \"hidden\",\n            actions: [\"dismissMessages\", \"hideOverlay\"]\n          },\n          BUILD_ERROR: {\n            target: \"displayBuildError\",\n            actions: [\"appendMessages\", \"showOverlay\"]\n          }\n        }\n      },\n      displayRuntimeError: {\n        on: {\n          DISMISS: {\n            target: \"hidden\",\n            actions: [\"dismissMessages\", \"hideOverlay\"]\n          },\n          RUNTIME_ERROR: {\n            target: \"displayRuntimeError\",\n            actions: [\"appendMessages\", \"showOverlay\"]\n          },\n          BUILD_ERROR: {\n            target: \"displayBuildError\",\n            actions: [\"setMessages\", \"showOverlay\"]\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      dismissMessages: function dismissMessages() {\n        return {\n          messages: [],\n          level: \"error\",\n          messageSource: \"build\"\n        };\n      },\n      appendMessages: function appendMessages(context, event) {\n        return {\n          messages: context.messages.concat(event.messages),\n          level: event.level || context.level,\n          messageSource: event.type === \"RUNTIME_ERROR\" ? \"runtime\" : \"build\"\n        };\n      },\n      setMessages: function setMessages(context, event) {\n        return {\n          messages: event.messages,\n          level: event.level || context.level,\n          messageSource: event.type === \"RUNTIME_ERROR\" ? \"runtime\" : \"build\"\n        };\n      },\n      hideOverlay: hideOverlay,\n      showOverlay: showOverlay\n    }\n  });\n  return overlayMachine;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createOverlayMachine);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5L3N0YXRlLW1hY2hpbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7O0FBRXJDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMscUJBQXFCO0FBQ25DLGNBQWMsa0JBQWtCLGdGQUFnRixHQUFHO0FBQ25ILGNBQWMscUJBQXFCO0FBQ25DOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsaUNBQWlDO0FBQy9DLGNBQWMsWUFBWTtBQUMxQjs7QUFFQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpRUFBZSxvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teV9hcHAvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5L3N0YXRlLW1hY2hpbmUuanM/ODRhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTWFjaGluZSBmcm9tIFwiLi9mc20uanNcIjtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTaG93T3ZlcmxheURhdGFcbiAqIEBwcm9wZXJ0eSB7J3dhcm5pbmcnIHwgJ2Vycm9yJ30gbGV2ZWxcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nICB8IHsgbW9kdWxlSWRlbnRpZmllcj86IHN0cmluZywgbW9kdWxlTmFtZT86IHN0cmluZywgbG9jPzogc3RyaW5nLCBtZXNzYWdlPzogc3RyaW5nIH0+fSBtZXNzYWdlc1xuICogQHByb3BlcnR5IHsnYnVpbGQnIHwgJ3J1bnRpbWUnfSBtZXNzYWdlU291cmNlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDcmVhdGVPdmVybGF5TWFjaGluZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7KGRhdGE6IFNob3dPdmVybGF5RGF0YSkgPT4gdm9pZH0gc2hvd092ZXJsYXlcbiAqIEBwcm9wZXJ0eSB7KCkgPT4gdm9pZH0gaGlkZU92ZXJsYXlcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Q3JlYXRlT3ZlcmxheU1hY2hpbmVPcHRpb25zfSBvcHRpb25zXG4gKi9cbnZhciBjcmVhdGVPdmVybGF5TWFjaGluZSA9IGZ1bmN0aW9uIGNyZWF0ZU92ZXJsYXlNYWNoaW5lKG9wdGlvbnMpIHtcbiAgdmFyIGhpZGVPdmVybGF5ID0gb3B0aW9ucy5oaWRlT3ZlcmxheSxcbiAgICBzaG93T3ZlcmxheSA9IG9wdGlvbnMuc2hvd092ZXJsYXk7XG4gIHZhciBvdmVybGF5TWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICAgIGluaXRpYWw6IFwiaGlkZGVuXCIsXG4gICAgY29udGV4dDoge1xuICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgIG1lc3NhZ2VTb3VyY2U6IFwiYnVpbGRcIlxuICAgIH0sXG4gICAgc3RhdGVzOiB7XG4gICAgICBoaWRkZW46IHtcbiAgICAgICAgb246IHtcbiAgICAgICAgICBCVUlMRF9FUlJPUjoge1xuICAgICAgICAgICAgdGFyZ2V0OiBcImRpc3BsYXlCdWlsZEVycm9yXCIsXG4gICAgICAgICAgICBhY3Rpb25zOiBbXCJzZXRNZXNzYWdlc1wiLCBcInNob3dPdmVybGF5XCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBSVU5USU1FX0VSUk9SOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiZGlzcGxheVJ1bnRpbWVFcnJvclwiLFxuICAgICAgICAgICAgYWN0aW9uczogW1wic2V0TWVzc2FnZXNcIiwgXCJzaG93T3ZlcmxheVwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlCdWlsZEVycm9yOiB7XG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgRElTTUlTUzoge1xuICAgICAgICAgICAgdGFyZ2V0OiBcImhpZGRlblwiLFxuICAgICAgICAgICAgYWN0aW9uczogW1wiZGlzbWlzc01lc3NhZ2VzXCIsIFwiaGlkZU92ZXJsYXlcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIEJVSUxEX0VSUk9SOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiZGlzcGxheUJ1aWxkRXJyb3JcIixcbiAgICAgICAgICAgIGFjdGlvbnM6IFtcImFwcGVuZE1lc3NhZ2VzXCIsIFwic2hvd092ZXJsYXlcIl1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5UnVudGltZUVycm9yOiB7XG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgRElTTUlTUzoge1xuICAgICAgICAgICAgdGFyZ2V0OiBcImhpZGRlblwiLFxuICAgICAgICAgICAgYWN0aW9uczogW1wiZGlzbWlzc01lc3NhZ2VzXCIsIFwiaGlkZU92ZXJsYXlcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFJVTlRJTUVfRVJST1I6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJkaXNwbGF5UnVudGltZUVycm9yXCIsXG4gICAgICAgICAgICBhY3Rpb25zOiBbXCJhcHBlbmRNZXNzYWdlc1wiLCBcInNob3dPdmVybGF5XCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBCVUlMRF9FUlJPUjoge1xuICAgICAgICAgICAgdGFyZ2V0OiBcImRpc3BsYXlCdWlsZEVycm9yXCIsXG4gICAgICAgICAgICBhY3Rpb25zOiBbXCJzZXRNZXNzYWdlc1wiLCBcInNob3dPdmVybGF5XCJdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgYWN0aW9uczoge1xuICAgICAgZGlzbWlzc01lc3NhZ2VzOiBmdW5jdGlvbiBkaXNtaXNzTWVzc2FnZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgICAgIGxldmVsOiBcImVycm9yXCIsXG4gICAgICAgICAgbWVzc2FnZVNvdXJjZTogXCJidWlsZFwiXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYXBwZW5kTWVzc2FnZXM6IGZ1bmN0aW9uIGFwcGVuZE1lc3NhZ2VzKGNvbnRleHQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWVzc2FnZXM6IGNvbnRleHQubWVzc2FnZXMuY29uY2F0KGV2ZW50Lm1lc3NhZ2VzKSxcbiAgICAgICAgICBsZXZlbDogZXZlbnQubGV2ZWwgfHwgY29udGV4dC5sZXZlbCxcbiAgICAgICAgICBtZXNzYWdlU291cmNlOiBldmVudC50eXBlID09PSBcIlJVTlRJTUVfRVJST1JcIiA/IFwicnVudGltZVwiIDogXCJidWlsZFwiXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgc2V0TWVzc2FnZXM6IGZ1bmN0aW9uIHNldE1lc3NhZ2VzKGNvbnRleHQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWVzc2FnZXM6IGV2ZW50Lm1lc3NhZ2VzLFxuICAgICAgICAgIGxldmVsOiBldmVudC5sZXZlbCB8fCBjb250ZXh0LmxldmVsLFxuICAgICAgICAgIG1lc3NhZ2VTb3VyY2U6IGV2ZW50LnR5cGUgPT09IFwiUlVOVElNRV9FUlJPUlwiID8gXCJydW50aW1lXCIgOiBcImJ1aWxkXCJcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBoaWRlT3ZlcmxheTogaGlkZU92ZXJsYXksXG4gICAgICBzaG93T3ZlcmxheTogc2hvd092ZXJsYXlcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3ZlcmxheU1hY2hpbmU7XG59O1xuZXhwb3J0IGRlZmF1bHQgY3JlYXRlT3ZlcmxheU1hY2hpbmU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/overlay/state-machine.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay/styles.js":
/*!******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay/styles.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   containerStyle: () => (/* binding */ containerStyle),\n/* harmony export */   dismissButtonStyle: () => (/* binding */ dismissButtonStyle),\n/* harmony export */   headerStyle: () => (/* binding */ headerStyle),\n/* harmony export */   iframeStyle: () => (/* binding */ iframeStyle),\n/* harmony export */   msgStyles: () => (/* binding */ msgStyles),\n/* harmony export */   msgTextStyle: () => (/* binding */ msgTextStyle),\n/* harmony export */   msgTypeStyle: () => (/* binding */ msgTypeStyle)\n/* harmony export */ });\n// styles are inspired by `react-error-overlay`\n\nvar msgStyles = {\n  error: {\n    backgroundColor: \"rgba(206, 17, 38, 0.1)\",\n    color: \"#fccfcf\"\n  },\n  warning: {\n    backgroundColor: \"rgba(251, 245, 180, 0.1)\",\n    color: \"#fbf5b4\"\n  }\n};\nvar iframeStyle = {\n  position: \"fixed\",\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n  width: \"100vw\",\n  height: \"100vh\",\n  border: \"none\",\n  \"z-index\": 9999999999\n};\nvar containerStyle = {\n  position: \"fixed\",\n  boxSizing: \"border-box\",\n  left: 0,\n  top: 0,\n  right: 0,\n  bottom: 0,\n  width: \"100vw\",\n  height: \"100vh\",\n  fontSize: \"large\",\n  padding: \"2rem 2rem 4rem 2rem\",\n  lineHeight: \"1.2\",\n  whiteSpace: \"pre-wrap\",\n  overflow: \"auto\",\n  backgroundColor: \"rgba(0, 0, 0, 0.9)\",\n  color: \"white\"\n};\nvar headerStyle = {\n  color: \"#e83b46\",\n  fontSize: \"2em\",\n  whiteSpace: \"pre-wrap\",\n  fontFamily: \"sans-serif\",\n  margin: \"0 2rem 2rem 0\",\n  flex: \"0 0 auto\",\n  maxHeight: \"50%\",\n  overflow: \"auto\"\n};\nvar dismissButtonStyle = {\n  color: \"#ffffff\",\n  lineHeight: \"1rem\",\n  fontSize: \"1.5rem\",\n  padding: \"1rem\",\n  cursor: \"pointer\",\n  position: \"absolute\",\n  right: 0,\n  top: 0,\n  backgroundColor: \"transparent\",\n  border: \"none\"\n};\nvar msgTypeStyle = {\n  color: \"#e83b46\",\n  fontSize: \"1.2em\",\n  marginBottom: \"1rem\",\n  fontFamily: \"sans-serif\"\n};\nvar msgTextStyle = {\n  lineHeight: \"1.5\",\n  fontSize: \"1rem\",\n  fontFamily: \"Menlo, Consolas, monospace\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5L3N0eWxlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlfYXBwLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvb3ZlcmxheS9zdHlsZXMuanM/ODIyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZXMgYXJlIGluc3BpcmVkIGJ5IGByZWFjdC1lcnJvci1vdmVybGF5YFxuXG52YXIgbXNnU3R5bGVzID0ge1xuICBlcnJvcjoge1xuICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDIwNiwgMTcsIDM4LCAwLjEpXCIsXG4gICAgY29sb3I6IFwiI2ZjY2ZjZlwiXG4gIH0sXG4gIHdhcm5pbmc6IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSgyNTEsIDI0NSwgMTgwLCAwLjEpXCIsXG4gICAgY29sb3I6IFwiI2ZiZjViNFwiXG4gIH1cbn07XG52YXIgaWZyYW1lU3R5bGUgPSB7XG4gIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gIHRvcDogMCxcbiAgbGVmdDogMCxcbiAgcmlnaHQ6IDAsXG4gIGJvdHRvbTogMCxcbiAgd2lkdGg6IFwiMTAwdndcIixcbiAgaGVpZ2h0OiBcIjEwMHZoXCIsXG4gIGJvcmRlcjogXCJub25lXCIsXG4gIFwiei1pbmRleFwiOiA5OTk5OTk5OTk5XG59O1xudmFyIGNvbnRhaW5lclN0eWxlID0ge1xuICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICBsZWZ0OiAwLFxuICB0b3A6IDAsXG4gIHJpZ2h0OiAwLFxuICBib3R0b206IDAsXG4gIHdpZHRoOiBcIjEwMHZ3XCIsXG4gIGhlaWdodDogXCIxMDB2aFwiLFxuICBmb250U2l6ZTogXCJsYXJnZVwiLFxuICBwYWRkaW5nOiBcIjJyZW0gMnJlbSA0cmVtIDJyZW1cIixcbiAgbGluZUhlaWdodDogXCIxLjJcIixcbiAgd2hpdGVTcGFjZTogXCJwcmUtd3JhcFwiLFxuICBvdmVyZmxvdzogXCJhdXRvXCIsXG4gIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDAsIDAsIDAsIDAuOSlcIixcbiAgY29sb3I6IFwid2hpdGVcIlxufTtcbnZhciBoZWFkZXJTdHlsZSA9IHtcbiAgY29sb3I6IFwiI2U4M2I0NlwiLFxuICBmb250U2l6ZTogXCIyZW1cIixcbiAgd2hpdGVTcGFjZTogXCJwcmUtd3JhcFwiLFxuICBmb250RmFtaWx5OiBcInNhbnMtc2VyaWZcIixcbiAgbWFyZ2luOiBcIjAgMnJlbSAycmVtIDBcIixcbiAgZmxleDogXCIwIDAgYXV0b1wiLFxuICBtYXhIZWlnaHQ6IFwiNTAlXCIsXG4gIG92ZXJmbG93OiBcImF1dG9cIlxufTtcbnZhciBkaXNtaXNzQnV0dG9uU3R5bGUgPSB7XG4gIGNvbG9yOiBcIiNmZmZmZmZcIixcbiAgbGluZUhlaWdodDogXCIxcmVtXCIsXG4gIGZvbnRTaXplOiBcIjEuNXJlbVwiLFxuICBwYWRkaW5nOiBcIjFyZW1cIixcbiAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgcmlnaHQ6IDAsXG4gIHRvcDogMCxcbiAgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gIGJvcmRlcjogXCJub25lXCJcbn07XG52YXIgbXNnVHlwZVN0eWxlID0ge1xuICBjb2xvcjogXCIjZTgzYjQ2XCIsXG4gIGZvbnRTaXplOiBcIjEuMmVtXCIsXG4gIG1hcmdpbkJvdHRvbTogXCIxcmVtXCIsXG4gIGZvbnRGYW1pbHk6IFwic2Fucy1zZXJpZlwiXG59O1xudmFyIG1zZ1RleHRTdHlsZSA9IHtcbiAgbGluZUhlaWdodDogXCIxLjVcIixcbiAgZm9udFNpemU6IFwiMXJlbVwiLFxuICBmb250RmFtaWx5OiBcIk1lbmxvLCBDb25zb2xhcywgbW9ub3NwYWNlXCJcbn07XG5leHBvcnQgeyBtc2dTdHlsZXMsIGlmcmFtZVN0eWxlLCBjb250YWluZXJTdHlsZSwgaGVhZGVyU3R5bGUsIGRpc21pc3NCdXR0b25TdHlsZSwgbXNnVHlwZVN0eWxlLCBtc2dUZXh0U3R5bGUgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/overlay/styles.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/socket.js":
/*!**********************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/socket.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   client: () => (/* binding */ client),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _clients_WebSocketClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clients/WebSocketClient.js */ \"./node_modules/webpack-dev-server/client/clients/WebSocketClient.js\");\n/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/log.js */ \"./node_modules/webpack-dev-server/client/utils/log.js\");\n/* provided dependency */ var __webpack_dev_server_client__ = __webpack_require__(/*! ./node_modules/webpack-dev-server/client/clients/WebSocketClient.js */ \"./node_modules/webpack-dev-server/client/clients/WebSocketClient.js\");\n/* global __webpack_dev_server_client__ */\n\n\n\n\n// this WebsocketClient is here as a default fallback, in case the client is not injected\n/* eslint-disable camelcase */\nvar Client =\n// eslint-disable-next-line no-nested-ternary\ntypeof __webpack_dev_server_client__ !== \"undefined\" ? typeof __webpack_dev_server_client__.default !== \"undefined\" ? __webpack_dev_server_client__.default : __webpack_dev_server_client__ : _clients_WebSocketClient_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* eslint-enable camelcase */\n\nvar retries = 0;\nvar maxRetries = 10;\n\n// Initialized client is exported so external consumers can utilize the same instance\n// It is mutable to enforce singleton\n// eslint-disable-next-line import/no-mutable-exports\nvar client = null;\n\n/**\n * @param {string} url\n * @param {{ [handler: string]: (data?: any, params?: any) => any }} handlers\n * @param {number} [reconnect]\n */\nvar socket = function initSocket(url, handlers, reconnect) {\n  client = new Client(url);\n  client.onOpen(function () {\n    retries = 0;\n    if (typeof reconnect !== \"undefined\") {\n      maxRetries = reconnect;\n    }\n  });\n  client.onClose(function () {\n    if (retries === 0) {\n      handlers.close();\n    }\n\n    // Try to reconnect.\n    client = null;\n\n    // After 10 retries stop trying, to prevent logspam.\n    if (retries < maxRetries) {\n      // Exponentially increase timeout to reconnect.\n      // Respectfully copied from the package `got`.\n      // eslint-disable-next-line no-restricted-properties\n      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;\n      retries += 1;\n      _utils_log_js__WEBPACK_IMPORTED_MODULE_1__.log.info(\"Trying to reconnect...\");\n      setTimeout(function () {\n        socket(url, handlers, reconnect);\n      }, retryInMs);\n    }\n  });\n  client.onMessage(\n  /**\n   * @param {any} data\n   */\n  function (data) {\n    var message = JSON.parse(data);\n    if (handlers[message.type]) {\n      handlers[message.type](message.data, message.params);\n    }\n  });\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (socket);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9zb2NrZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUFFMkQ7QUFDdEI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw2QkFBNkIsMEJBQTBCLDZCQUE2QiwyQkFBMkIsNkJBQTZCLFdBQVcsNkJBQTZCLEdBQUcsbUVBQWU7QUFDN007O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLHdEQUF3RDtBQUNyRSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw4Q0FBRztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpRUFBZSxNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlfYXBwLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvc29ja2V0LmpzPzA5YzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fICovXG5cbmltcG9ydCBXZWJTb2NrZXRDbGllbnQgZnJvbSBcIi4vY2xpZW50cy9XZWJTb2NrZXRDbGllbnQuanNcIjtcbmltcG9ydCB7IGxvZyB9IGZyb20gXCIuL3V0aWxzL2xvZy5qc1wiO1xuXG4vLyB0aGlzIFdlYnNvY2tldENsaWVudCBpcyBoZXJlIGFzIGEgZGVmYXVsdCBmYWxsYmFjaywgaW4gY2FzZSB0aGUgY2xpZW50IGlzIG5vdCBpbmplY3RlZFxuLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG52YXIgQ2xpZW50ID1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxudHlwZW9mIF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fICE9PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fLmRlZmF1bHQgIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXy5kZWZhdWx0IDogX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18gOiBXZWJTb2NrZXRDbGllbnQ7XG4vKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuXG52YXIgcmV0cmllcyA9IDA7XG52YXIgbWF4UmV0cmllcyA9IDEwO1xuXG4vLyBJbml0aWFsaXplZCBjbGllbnQgaXMgZXhwb3J0ZWQgc28gZXh0ZXJuYWwgY29uc3VtZXJzIGNhbiB1dGlsaXplIHRoZSBzYW1lIGluc3RhbmNlXG4vLyBJdCBpcyBtdXRhYmxlIHRvIGVuZm9yY2Ugc2luZ2xldG9uXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLW11dGFibGUtZXhwb3J0c1xuZXhwb3J0IHZhciBjbGllbnQgPSBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7eyBbaGFuZGxlcjogc3RyaW5nXTogKGRhdGE/OiBhbnksIHBhcmFtcz86IGFueSkgPT4gYW55IH19IGhhbmRsZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gW3JlY29ubmVjdF1cbiAqL1xudmFyIHNvY2tldCA9IGZ1bmN0aW9uIGluaXRTb2NrZXQodXJsLCBoYW5kbGVycywgcmVjb25uZWN0KSB7XG4gIGNsaWVudCA9IG5ldyBDbGllbnQodXJsKTtcbiAgY2xpZW50Lm9uT3BlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0cmllcyA9IDA7XG4gICAgaWYgKHR5cGVvZiByZWNvbm5lY3QgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIG1heFJldHJpZXMgPSByZWNvbm5lY3Q7XG4gICAgfVxuICB9KTtcbiAgY2xpZW50Lm9uQ2xvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZXRyaWVzID09PSAwKSB7XG4gICAgICBoYW5kbGVycy5jbG9zZSgpO1xuICAgIH1cblxuICAgIC8vIFRyeSB0byByZWNvbm5lY3QuXG4gICAgY2xpZW50ID0gbnVsbDtcblxuICAgIC8vIEFmdGVyIDEwIHJldHJpZXMgc3RvcCB0cnlpbmcsIHRvIHByZXZlbnQgbG9nc3BhbS5cbiAgICBpZiAocmV0cmllcyA8IG1heFJldHJpZXMpIHtcbiAgICAgIC8vIEV4cG9uZW50aWFsbHkgaW5jcmVhc2UgdGltZW91dCB0byByZWNvbm5lY3QuXG4gICAgICAvLyBSZXNwZWN0ZnVsbHkgY29waWVkIGZyb20gdGhlIHBhY2thZ2UgYGdvdGAuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG4gICAgICB2YXIgcmV0cnlJbk1zID0gMTAwMCAqIE1hdGgucG93KDIsIHJldHJpZXMpICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgIHJldHJpZXMgKz0gMTtcbiAgICAgIGxvZy5pbmZvKFwiVHJ5aW5nIHRvIHJlY29ubmVjdC4uLlwiKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzb2NrZXQodXJsLCBoYW5kbGVycywgcmVjb25uZWN0KTtcbiAgICAgIH0sIHJldHJ5SW5Ncyk7XG4gICAgfVxuICB9KTtcbiAgY2xpZW50Lm9uTWVzc2FnZShcbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBkYXRhXG4gICAqL1xuICBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBtZXNzYWdlID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICBpZiAoaGFuZGxlcnNbbWVzc2FnZS50eXBlXSkge1xuICAgICAgaGFuZGxlcnNbbWVzc2FnZS50eXBlXShtZXNzYWdlLmRhdGEsIG1lc3NhZ2UucGFyYW1zKTtcbiAgICB9XG4gIH0pO1xufTtcbmV4cG9ydCBkZWZhdWx0IHNvY2tldDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/socket.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/createSocketURL.js":
/*!*************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/createSocketURL.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @param {{ protocol?: string, auth?: string, hostname?: string, port?: string, pathname?: string, search?: string, hash?: string, slashes?: boolean }} objURL\n * @returns {string}\n */\nfunction format(objURL) {\n  var protocol = objURL.protocol || \"\";\n  if (protocol && protocol.substr(-1) !== \":\") {\n    protocol += \":\";\n  }\n  var auth = objURL.auth || \"\";\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, \":\");\n    auth += \"@\";\n  }\n  var host = \"\";\n  if (objURL.hostname) {\n    host = auth + (objURL.hostname.indexOf(\":\") === -1 ? objURL.hostname : \"[\".concat(objURL.hostname, \"]\"));\n    if (objURL.port) {\n      host += \":\".concat(objURL.port);\n    }\n  }\n  var pathname = objURL.pathname || \"\";\n  if (objURL.slashes) {\n    host = \"//\".concat(host || \"\");\n    if (pathname && pathname.charAt(0) !== \"/\") {\n      pathname = \"/\".concat(pathname);\n    }\n  } else if (!host) {\n    host = \"\";\n  }\n  var search = objURL.search || \"\";\n  if (search && search.charAt(0) !== \"?\") {\n    search = \"?\".concat(search);\n  }\n  var hash = objURL.hash || \"\";\n  if (hash && hash.charAt(0) !== \"#\") {\n    hash = \"#\".concat(hash);\n  }\n  pathname = pathname.replace(/[?#]/g,\n  /**\n   * @param {string} match\n   * @returns {string}\n   */\n  function (match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace(\"#\", \"%23\");\n  return \"\".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);\n}\n\n/**\n * @param {URL & { fromCurrentScript?: boolean }} parsedURL\n * @returns {string}\n */\nfunction createSocketURL(parsedURL) {\n  var hostname = parsedURL.hostname;\n\n  // Node.js module parses it as `::`\n  // `new URL(urlString, [baseURLString])` parses it as '[::]'\n  var isInAddrAny = hostname === \"0.0.0.0\" || hostname === \"::\" || hostname === \"[::]\";\n\n  // why do we need this check?\n  // hostname n/a for file protocol (example, when using electron, ionic)\n  // see: https://github.com/webpack/webpack-dev-server/pull/384\n  if (isInAddrAny && self.location.hostname && self.location.protocol.indexOf(\"http\") === 0) {\n    hostname = self.location.hostname;\n  }\n  var socketURLProtocol = parsedURL.protocol || self.location.protocol;\n\n  // When https is used in the app, secure web sockets are always necessary because the browser doesn't accept non-secure web sockets.\n  if (socketURLProtocol === \"auto:\" || hostname && isInAddrAny && self.location.protocol === \"https:\") {\n    socketURLProtocol = self.location.protocol;\n  }\n  socketURLProtocol = socketURLProtocol.replace(/^(?:http|.+-extension|file)/i, \"ws\");\n  var socketURLAuth = \"\";\n\n  // `new URL(urlString, [baseURLstring])` doesn't have `auth` property\n  // Parse authentication credentials in case we need them\n  if (parsedURL.username) {\n    socketURLAuth = parsedURL.username;\n\n    // Since HTTP basic authentication does not allow empty username,\n    // we only include password if the username is not empty.\n    if (parsedURL.password) {\n      // Result: <username>:<password>\n      socketURLAuth = socketURLAuth.concat(\":\", parsedURL.password);\n    }\n  }\n\n  // In case the host is a raw IPv6 address, it can be enclosed in\n  // the brackets as the brackets are needed in the final URL string.\n  // Need to remove those as url.format blindly adds its own set of brackets\n  // if the host string contains colons. That would lead to non-working\n  // double brackets (e.g. [[::]]) host\n  //\n  // All of these web socket url params are optionally passed in through resourceQuery,\n  // so we need to fall back to the default if they are not provided\n  var socketURLHostname = (hostname || self.location.hostname || \"localhost\").replace(/^\\[(.*)\\]$/, \"$1\");\n  var socketURLPort = parsedURL.port;\n  if (!socketURLPort || socketURLPort === \"0\") {\n    socketURLPort = self.location.port;\n  }\n\n  // If path is provided it'll be passed in via the resourceQuery as a\n  // query param so it has to be parsed out of the querystring in order for the\n  // client to open the socket to the correct location.\n  var socketURLPathname = \"/ws\";\n  if (parsedURL.pathname && !parsedURL.fromCurrentScript) {\n    socketURLPathname = parsedURL.pathname;\n  }\n  return format({\n    protocol: socketURLProtocol,\n    auth: socketURLAuth,\n    hostname: socketURLHostname,\n    port: socketURLPort,\n    pathname: socketURLPathname,\n    slashes: true\n  });\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createSocketURL);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9jcmVhdGVTb2NrZXRVUkwuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsYUFBYSw0SUFBNEk7QUFDekosYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUSwrQkFBK0I7QUFDbEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpRUFBZSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlfYXBwLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvY3JlYXRlU29ja2V0VVJMLmpzPzZjMTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFyYW0ge3sgcHJvdG9jb2w/OiBzdHJpbmcsIGF1dGg/OiBzdHJpbmcsIGhvc3RuYW1lPzogc3RyaW5nLCBwb3J0Pzogc3RyaW5nLCBwYXRobmFtZT86IHN0cmluZywgc2VhcmNoPzogc3RyaW5nLCBoYXNoPzogc3RyaW5nLCBzbGFzaGVzPzogYm9vbGVhbiB9fSBvYmpVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdChvYmpVUkwpIHtcbiAgdmFyIHByb3RvY29sID0gb2JqVVJMLnByb3RvY29sIHx8IFwiXCI7XG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSBcIjpcIikge1xuICAgIHByb3RvY29sICs9IFwiOlwiO1xuICB9XG4gIHZhciBhdXRoID0gb2JqVVJMLmF1dGggfHwgXCJcIjtcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCBcIjpcIik7XG4gICAgYXV0aCArPSBcIkBcIjtcbiAgfVxuICB2YXIgaG9zdCA9IFwiXCI7XG4gIGlmIChvYmpVUkwuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArIChvYmpVUkwuaG9zdG5hbWUuaW5kZXhPZihcIjpcIikgPT09IC0xID8gb2JqVVJMLmhvc3RuYW1lIDogXCJbXCIuY29uY2F0KG9ialVSTC5ob3N0bmFtZSwgXCJdXCIpKTtcbiAgICBpZiAob2JqVVJMLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gXCI6XCIuY29uY2F0KG9ialVSTC5wb3J0KTtcbiAgICB9XG4gIH1cbiAgdmFyIHBhdGhuYW1lID0gb2JqVVJMLnBhdGhuYW1lIHx8IFwiXCI7XG4gIGlmIChvYmpVUkwuc2xhc2hlcykge1xuICAgIGhvc3QgPSBcIi8vXCIuY29uY2F0KGhvc3QgfHwgXCJcIik7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgIHBhdGhuYW1lID0gXCIvXCIuY29uY2F0KHBhdGhuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gXCJcIjtcbiAgfVxuICB2YXIgc2VhcmNoID0gb2JqVVJMLnNlYXJjaCB8fCBcIlwiO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09IFwiP1wiKSB7XG4gICAgc2VhcmNoID0gXCI/XCIuY29uY2F0KHNlYXJjaCk7XG4gIH1cbiAgdmFyIGhhc2ggPSBvYmpVUkwuaGFzaCB8fCBcIlwiO1xuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gXCIjXCIpIHtcbiAgICBoYXNoID0gXCIjXCIuY29uY2F0KGhhc2gpO1xuICB9XG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKFwiI1wiLCBcIiUyM1wiKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHByb3RvY29sKS5jb25jYXQoaG9zdCkuY29uY2F0KHBhdGhuYW1lKS5jb25jYXQoc2VhcmNoKS5jb25jYXQoaGFzaCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtVUkwgJiB7IGZyb21DdXJyZW50U2NyaXB0PzogYm9vbGVhbiB9fSBwYXJzZWRVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNvY2tldFVSTChwYXJzZWRVUkwpIHtcbiAgdmFyIGhvc3RuYW1lID0gcGFyc2VkVVJMLmhvc3RuYW1lO1xuXG4gIC8vIE5vZGUuanMgbW9kdWxlIHBhcnNlcyBpdCBhcyBgOjpgXG4gIC8vIGBuZXcgVVJMKHVybFN0cmluZywgW2Jhc2VVUkxTdHJpbmddKWAgcGFyc2VzIGl0IGFzICdbOjpdJ1xuICB2YXIgaXNJbkFkZHJBbnkgPSBob3N0bmFtZSA9PT0gXCIwLjAuMC4wXCIgfHwgaG9zdG5hbWUgPT09IFwiOjpcIiB8fCBob3N0bmFtZSA9PT0gXCJbOjpdXCI7XG5cbiAgLy8gd2h5IGRvIHdlIG5lZWQgdGhpcyBjaGVjaz9cbiAgLy8gaG9zdG5hbWUgbi9hIGZvciBmaWxlIHByb3RvY29sIChleGFtcGxlLCB3aGVuIHVzaW5nIGVsZWN0cm9uLCBpb25pYylcbiAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvcHVsbC8zODRcbiAgaWYgKGlzSW5BZGRyQW55ICYmIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgJiYgc2VsZi5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKFwiaHR0cFwiKSA9PT0gMCkge1xuICAgIGhvc3RuYW1lID0gc2VsZi5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgfVxuICB2YXIgc29ja2V0VVJMUHJvdG9jb2wgPSBwYXJzZWRVUkwucHJvdG9jb2wgfHwgc2VsZi5sb2NhdGlvbi5wcm90b2NvbDtcblxuICAvLyBXaGVuIGh0dHBzIGlzIHVzZWQgaW4gdGhlIGFwcCwgc2VjdXJlIHdlYiBzb2NrZXRzIGFyZSBhbHdheXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJyb3dzZXIgZG9lc24ndCBhY2NlcHQgbm9uLXNlY3VyZSB3ZWIgc29ja2V0cy5cbiAgaWYgKHNvY2tldFVSTFByb3RvY29sID09PSBcImF1dG86XCIgfHwgaG9zdG5hbWUgJiYgaXNJbkFkZHJBbnkgJiYgc2VsZi5sb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJodHRwczpcIikge1xuICAgIHNvY2tldFVSTFByb3RvY29sID0gc2VsZi5sb2NhdGlvbi5wcm90b2NvbDtcbiAgfVxuICBzb2NrZXRVUkxQcm90b2NvbCA9IHNvY2tldFVSTFByb3RvY29sLnJlcGxhY2UoL14oPzpodHRwfC4rLWV4dGVuc2lvbnxmaWxlKS9pLCBcIndzXCIpO1xuICB2YXIgc29ja2V0VVJMQXV0aCA9IFwiXCI7XG5cbiAgLy8gYG5ldyBVUkwodXJsU3RyaW5nLCBbYmFzZVVSTHN0cmluZ10pYCBkb2Vzbid0IGhhdmUgYGF1dGhgIHByb3BlcnR5XG4gIC8vIFBhcnNlIGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGluIGNhc2Ugd2UgbmVlZCB0aGVtXG4gIGlmIChwYXJzZWRVUkwudXNlcm5hbWUpIHtcbiAgICBzb2NrZXRVUkxBdXRoID0gcGFyc2VkVVJMLnVzZXJuYW1lO1xuXG4gICAgLy8gU2luY2UgSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvbiBkb2VzIG5vdCBhbGxvdyBlbXB0eSB1c2VybmFtZSxcbiAgICAvLyB3ZSBvbmx5IGluY2x1ZGUgcGFzc3dvcmQgaWYgdGhlIHVzZXJuYW1lIGlzIG5vdCBlbXB0eS5cbiAgICBpZiAocGFyc2VkVVJMLnBhc3N3b3JkKSB7XG4gICAgICAvLyBSZXN1bHQ6IDx1c2VybmFtZT46PHBhc3N3b3JkPlxuICAgICAgc29ja2V0VVJMQXV0aCA9IHNvY2tldFVSTEF1dGguY29uY2F0KFwiOlwiLCBwYXJzZWRVUkwucGFzc3dvcmQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluIGNhc2UgdGhlIGhvc3QgaXMgYSByYXcgSVB2NiBhZGRyZXNzLCBpdCBjYW4gYmUgZW5jbG9zZWQgaW5cbiAgLy8gdGhlIGJyYWNrZXRzIGFzIHRoZSBicmFja2V0cyBhcmUgbmVlZGVkIGluIHRoZSBmaW5hbCBVUkwgc3RyaW5nLlxuICAvLyBOZWVkIHRvIHJlbW92ZSB0aG9zZSBhcyB1cmwuZm9ybWF0IGJsaW5kbHkgYWRkcyBpdHMgb3duIHNldCBvZiBicmFja2V0c1xuICAvLyBpZiB0aGUgaG9zdCBzdHJpbmcgY29udGFpbnMgY29sb25zLiBUaGF0IHdvdWxkIGxlYWQgdG8gbm9uLXdvcmtpbmdcbiAgLy8gZG91YmxlIGJyYWNrZXRzIChlLmcuIFtbOjpdXSkgaG9zdFxuICAvL1xuICAvLyBBbGwgb2YgdGhlc2Ugd2ViIHNvY2tldCB1cmwgcGFyYW1zIGFyZSBvcHRpb25hbGx5IHBhc3NlZCBpbiB0aHJvdWdoIHJlc291cmNlUXVlcnksXG4gIC8vIHNvIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0IGlmIHRoZXkgYXJlIG5vdCBwcm92aWRlZFxuICB2YXIgc29ja2V0VVJMSG9zdG5hbWUgPSAoaG9zdG5hbWUgfHwgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSB8fCBcImxvY2FsaG9zdFwiKS5yZXBsYWNlKC9eXFxbKC4qKVxcXSQvLCBcIiQxXCIpO1xuICB2YXIgc29ja2V0VVJMUG9ydCA9IHBhcnNlZFVSTC5wb3J0O1xuICBpZiAoIXNvY2tldFVSTFBvcnQgfHwgc29ja2V0VVJMUG9ydCA9PT0gXCIwXCIpIHtcbiAgICBzb2NrZXRVUkxQb3J0ID0gc2VsZi5sb2NhdGlvbi5wb3J0O1xuICB9XG5cbiAgLy8gSWYgcGF0aCBpcyBwcm92aWRlZCBpdCdsbCBiZSBwYXNzZWQgaW4gdmlhIHRoZSByZXNvdXJjZVF1ZXJ5IGFzIGFcbiAgLy8gcXVlcnkgcGFyYW0gc28gaXQgaGFzIHRvIGJlIHBhcnNlZCBvdXQgb2YgdGhlIHF1ZXJ5c3RyaW5nIGluIG9yZGVyIGZvciB0aGVcbiAgLy8gY2xpZW50IHRvIG9wZW4gdGhlIHNvY2tldCB0byB0aGUgY29ycmVjdCBsb2NhdGlvbi5cbiAgdmFyIHNvY2tldFVSTFBhdGhuYW1lID0gXCIvd3NcIjtcbiAgaWYgKHBhcnNlZFVSTC5wYXRobmFtZSAmJiAhcGFyc2VkVVJMLmZyb21DdXJyZW50U2NyaXB0KSB7XG4gICAgc29ja2V0VVJMUGF0aG5hbWUgPSBwYXJzZWRVUkwucGF0aG5hbWU7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdCh7XG4gICAgcHJvdG9jb2w6IHNvY2tldFVSTFByb3RvY29sLFxuICAgIGF1dGg6IHNvY2tldFVSTEF1dGgsXG4gICAgaG9zdG5hbWU6IHNvY2tldFVSTEhvc3RuYW1lLFxuICAgIHBvcnQ6IHNvY2tldFVSTFBvcnQsXG4gICAgcGF0aG5hbWU6IHNvY2tldFVSTFBhdGhuYW1lLFxuICAgIHNsYXNoZXM6IHRydWVcbiAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTb2NrZXRVUkw7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/createSocketURL.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js":
/*!********************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @returns {string}\n */\nfunction getCurrentScriptSource() {\n  // `document.currentScript` is the most accurate way to find the current script,\n  // but is not supported in all browsers.\n  if (document.currentScript) {\n    return document.currentScript.getAttribute(\"src\");\n  }\n\n  // Fallback to getting all scripts running in the document.\n  var scriptElements = document.scripts || [];\n  var scriptElementsWithSrc = Array.prototype.filter.call(scriptElements, function (element) {\n    return element.getAttribute(\"src\");\n  });\n  if (scriptElementsWithSrc.length > 0) {\n    var currentScript = scriptElementsWithSrc[scriptElementsWithSrc.length - 1];\n    return currentScript.getAttribute(\"src\");\n  }\n\n  // Fail as there was no script to use.\n  throw new Error(\"[webpack-dev-server] Failed to get current script source.\");\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getCurrentScriptSource);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9nZXRDdXJyZW50U2NyaXB0U291cmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teV9hcHAvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9nZXRDdXJyZW50U2NyaXB0U291cmNlLmpzP2NmMmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0U291cmNlKCkge1xuICAvLyBgZG9jdW1lbnQuY3VycmVudFNjcmlwdGAgaXMgdGhlIG1vc3QgYWNjdXJhdGUgd2F5IHRvIGZpbmQgdGhlIGN1cnJlbnQgc2NyaXB0LFxuICAvLyBidXQgaXMgbm90IHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnMuXG4gIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKFwic3JjXCIpO1xuICB9XG5cbiAgLy8gRmFsbGJhY2sgdG8gZ2V0dGluZyBhbGwgc2NyaXB0cyBydW5uaW5nIGluIHRoZSBkb2N1bWVudC5cbiAgdmFyIHNjcmlwdEVsZW1lbnRzID0gZG9jdW1lbnQuc2NyaXB0cyB8fCBbXTtcbiAgdmFyIHNjcmlwdEVsZW1lbnRzV2l0aFNyYyA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChzY3JpcHRFbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG4gIH0pO1xuICBpZiAoc2NyaXB0RWxlbWVudHNXaXRoU3JjLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgY3VycmVudFNjcmlwdCA9IHNjcmlwdEVsZW1lbnRzV2l0aFNyY1tzY3JpcHRFbGVtZW50c1dpdGhTcmMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKFwic3JjXCIpO1xuICB9XG5cbiAgLy8gRmFpbCBhcyB0aGVyZSB3YXMgbm8gc2NyaXB0IHRvIHVzZS5cbiAgdGhyb3cgbmV3IEVycm9yKFwiW3dlYnBhY2stZGV2LXNlcnZlcl0gRmFpbGVkIHRvIGdldCBjdXJyZW50IHNjcmlwdCBzb3VyY2UuXCIpO1xufVxuZXhwb3J0IGRlZmF1bHQgZ2V0Q3VycmVudFNjcmlwdFNvdXJjZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/log.js":
/*!*************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/log.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   log: () => (/* binding */ log),\n/* harmony export */   logEnabledFeatures: () => (/* binding */ logEnabledFeatures),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/logger/index.js */ \"./node_modules/webpack-dev-server/client/modules/logger/index.js\");\n/* harmony import */ var _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0__);\n\nvar name = \"webpack-dev-server\";\n// default level is set on the client side, so it does not need\n// to be set by the CLI or API\nvar defaultLevel = \"info\";\n\n// options new options, merge with old options\n/**\n * @param {false | true | \"none\" | \"error\" | \"warn\" | \"info\" | \"log\" | \"verbose\"} level\n * @returns {void}\n */\nfunction setLogLevel(level) {\n  _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default().configureDefaultLogger({\n    level: level\n  });\n}\nsetLogLevel(defaultLevel);\nvar log = _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default().getLogger(name);\nvar logEnabledFeatures = function logEnabledFeatures(features) {\n  var enabledFeatures = Object.keys(features);\n  if (!features || enabledFeatures.length === 0) {\n    return;\n  }\n  var logString = \"Server started:\";\n\n  // Server started: Hot Module Replacement enabled, Live Reloading enabled, Overlay disabled.\n  for (var i = 0; i < enabledFeatures.length; i++) {\n    var key = enabledFeatures[i];\n    logString += \" \".concat(key, \" \").concat(features[key] ? \"enabled\" : \"disabled\", \",\");\n  }\n  // replace last comma with a period\n  logString = logString.slice(0, -1).concat(\".\");\n  log.info(logString);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9sb2cuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsdUVBQXVFO0FBQ2xGLGFBQWE7QUFDYjtBQUNBO0FBQ0EsRUFBRSxzRkFBNkI7QUFDL0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUseUVBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teV9hcHAvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9sb2cuanM/NjIyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbG9nZ2VyIGZyb20gXCIuLi9tb2R1bGVzL2xvZ2dlci9pbmRleC5qc1wiO1xudmFyIG5hbWUgPSBcIndlYnBhY2stZGV2LXNlcnZlclwiO1xuLy8gZGVmYXVsdCBsZXZlbCBpcyBzZXQgb24gdGhlIGNsaWVudCBzaWRlLCBzbyBpdCBkb2VzIG5vdCBuZWVkXG4vLyB0byBiZSBzZXQgYnkgdGhlIENMSSBvciBBUElcbnZhciBkZWZhdWx0TGV2ZWwgPSBcImluZm9cIjtcblxuLy8gb3B0aW9ucyBuZXcgb3B0aW9ucywgbWVyZ2Ugd2l0aCBvbGQgb3B0aW9uc1xuLyoqXG4gKiBAcGFyYW0ge2ZhbHNlIHwgdHJ1ZSB8IFwibm9uZVwiIHwgXCJlcnJvclwiIHwgXCJ3YXJuXCIgfCBcImluZm9cIiB8IFwibG9nXCIgfCBcInZlcmJvc2VcIn0gbGV2ZWxcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCkge1xuICBsb2dnZXIuY29uZmlndXJlRGVmYXVsdExvZ2dlcih7XG4gICAgbGV2ZWw6IGxldmVsXG4gIH0pO1xufVxuc2V0TG9nTGV2ZWwoZGVmYXVsdExldmVsKTtcbnZhciBsb2cgPSBsb2dnZXIuZ2V0TG9nZ2VyKG5hbWUpO1xudmFyIGxvZ0VuYWJsZWRGZWF0dXJlcyA9IGZ1bmN0aW9uIGxvZ0VuYWJsZWRGZWF0dXJlcyhmZWF0dXJlcykge1xuICB2YXIgZW5hYmxlZEZlYXR1cmVzID0gT2JqZWN0LmtleXMoZmVhdHVyZXMpO1xuICBpZiAoIWZlYXR1cmVzIHx8IGVuYWJsZWRGZWF0dXJlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGxvZ1N0cmluZyA9IFwiU2VydmVyIHN0YXJ0ZWQ6XCI7XG5cbiAgLy8gU2VydmVyIHN0YXJ0ZWQ6IEhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgZW5hYmxlZCwgTGl2ZSBSZWxvYWRpbmcgZW5hYmxlZCwgT3ZlcmxheSBkaXNhYmxlZC5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmFibGVkRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gZW5hYmxlZEZlYXR1cmVzW2ldO1xuICAgIGxvZ1N0cmluZyArPSBcIiBcIi5jb25jYXQoa2V5LCBcIiBcIikuY29uY2F0KGZlYXR1cmVzW2tleV0gPyBcImVuYWJsZWRcIiA6IFwiZGlzYWJsZWRcIiwgXCIsXCIpO1xuICB9XG4gIC8vIHJlcGxhY2UgbGFzdCBjb21tYSB3aXRoIGEgcGVyaW9kXG4gIGxvZ1N0cmluZyA9IGxvZ1N0cmluZy5zbGljZSgwLCAtMSkuY29uY2F0KFwiLlwiKTtcbiAgbG9nLmluZm8obG9nU3RyaW5nKTtcbn07XG5leHBvcnQgeyBsb2csIGxvZ0VuYWJsZWRGZWF0dXJlcywgc2V0TG9nTGV2ZWwgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/log.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/parseURL.js":
/*!******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/parseURL.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _getCurrentScriptSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getCurrentScriptSource.js */ \"./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js\");\n\n\n/**\n * @param {string} resourceQuery\n * @returns {{ [key: string]: string | boolean }}\n */\nfunction parseURL(resourceQuery) {\n  /** @type {{ [key: string]: string }} */\n  var options = {};\n  if (typeof resourceQuery === \"string\" && resourceQuery !== \"\") {\n    var searchParams = resourceQuery.slice(1).split(\"&\");\n    for (var i = 0; i < searchParams.length; i++) {\n      var pair = searchParams[i].split(\"=\");\n      options[pair[0]] = decodeURIComponent(pair[1]);\n    }\n  } else {\n    // Else, get the url from the <script> this file was called with.\n    var scriptSource = (0,_getCurrentScriptSource_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n    var scriptSourceURL;\n    try {\n      // The placeholder `baseURL` with `window.location.href`,\n      // is to allow parsing of path-relative or protocol-relative URLs,\n      // and will have no effect if `scriptSource` is a fully valid URL.\n      scriptSourceURL = new URL(scriptSource, self.location.href);\n    } catch (error) {\n      // URL parsing failed, do nothing.\n      // We will still proceed to see if we can recover using `resourceQuery`\n    }\n    if (scriptSourceURL) {\n      options = scriptSourceURL;\n      options.fromCurrentScript = true;\n    }\n  }\n  return options;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parseURL);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9wYXJzZVVSTC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRTs7QUFFakU7QUFDQSxXQUFXLFFBQVE7QUFDbkIsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHVCQUF1QixzRUFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsUUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL3BhcnNlVVJMLmpzP2VjNWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldEN1cnJlbnRTY3JpcHRTb3VyY2UgZnJvbSBcIi4vZ2V0Q3VycmVudFNjcmlwdFNvdXJjZS5qc1wiO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXNvdXJjZVF1ZXJ5XG4gKiBAcmV0dXJucyB7eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBib29sZWFuIH19XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVVJMKHJlc291cmNlUXVlcnkpIHtcbiAgLyoqIEB0eXBlIHt7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9fSAqL1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuICBpZiAodHlwZW9mIHJlc291cmNlUXVlcnkgPT09IFwic3RyaW5nXCIgJiYgcmVzb3VyY2VRdWVyeSAhPT0gXCJcIikge1xuICAgIHZhciBzZWFyY2hQYXJhbXMgPSByZXNvdXJjZVF1ZXJ5LnNsaWNlKDEpLnNwbGl0KFwiJlwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlYXJjaFBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhaXIgPSBzZWFyY2hQYXJhbXNbaV0uc3BsaXQoXCI9XCIpO1xuICAgICAgb3B0aW9uc1twYWlyWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRWxzZSwgZ2V0IHRoZSB1cmwgZnJvbSB0aGUgPHNjcmlwdD4gdGhpcyBmaWxlIHdhcyBjYWxsZWQgd2l0aC5cbiAgICB2YXIgc2NyaXB0U291cmNlID0gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpO1xuICAgIHZhciBzY3JpcHRTb3VyY2VVUkw7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBwbGFjZWhvbGRlciBgYmFzZVVSTGAgd2l0aCBgd2luZG93LmxvY2F0aW9uLmhyZWZgLFxuICAgICAgLy8gaXMgdG8gYWxsb3cgcGFyc2luZyBvZiBwYXRoLXJlbGF0aXZlIG9yIHByb3RvY29sLXJlbGF0aXZlIFVSTHMsXG4gICAgICAvLyBhbmQgd2lsbCBoYXZlIG5vIGVmZmVjdCBpZiBgc2NyaXB0U291cmNlYCBpcyBhIGZ1bGx5IHZhbGlkIFVSTC5cbiAgICAgIHNjcmlwdFNvdXJjZVVSTCA9IG5ldyBVUkwoc2NyaXB0U291cmNlLCBzZWxmLmxvY2F0aW9uLmhyZWYpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBVUkwgcGFyc2luZyBmYWlsZWQsIGRvIG5vdGhpbmcuXG4gICAgICAvLyBXZSB3aWxsIHN0aWxsIHByb2NlZWQgdG8gc2VlIGlmIHdlIGNhbiByZWNvdmVyIHVzaW5nIGByZXNvdXJjZVF1ZXJ5YFxuICAgIH1cbiAgICBpZiAoc2NyaXB0U291cmNlVVJMKSB7XG4gICAgICBvcHRpb25zID0gc2NyaXB0U291cmNlVVJMO1xuICAgICAgb3B0aW9ucy5mcm9tQ3VycmVudFNjcmlwdCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0IGRlZmF1bHQgcGFyc2VVUkw7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/parseURL.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/reloadApp.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/reloadApp.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webpack/hot/emitter.js */ \"./node_modules/webpack/hot/emitter.js\");\n/* harmony import */ var webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log.js */ \"./node_modules/webpack-dev-server/client/utils/log.js\");\n\n\n\n/** @typedef {import(\"../index\").Options} Options\n/** @typedef {import(\"../index\").Status} Status\n\n/**\n * @param {Options} options\n * @param {Status} status\n */\nfunction reloadApp(_ref, status) {\n  var hot = _ref.hot,\n    liveReload = _ref.liveReload;\n  if (status.isUnloading) {\n    return;\n  }\n  var currentHash = status.currentHash,\n    previousHash = status.previousHash;\n  var isInitial = currentHash.indexOf(/** @type {string} */previousHash) >= 0;\n  if (isInitial) {\n    return;\n  }\n\n  /**\n   * @param {Window} rootWindow\n   * @param {number} intervalId\n   */\n  function applyReload(rootWindow, intervalId) {\n    clearInterval(intervalId);\n    _log_js__WEBPACK_IMPORTED_MODULE_1__.log.info(\"App updated. Reloading...\");\n    rootWindow.location.reload();\n  }\n  var search = self.location.search.toLowerCase();\n  var allowToHot = search.indexOf(\"webpack-dev-server-hot=false\") === -1;\n  var allowToLiveReload = search.indexOf(\"webpack-dev-server-live-reload=false\") === -1;\n  if (hot && allowToHot) {\n    _log_js__WEBPACK_IMPORTED_MODULE_1__.log.info(\"App hot update...\");\n    webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0___default().emit(\"webpackHotUpdate\", status.currentHash);\n    if (typeof self !== \"undefined\" && self.window) {\n      // broadcast update to window\n      self.postMessage(\"webpackHotUpdate\".concat(status.currentHash), \"*\");\n    }\n  }\n  // allow refreshing the page only if liveReload isn't disabled\n  else if (liveReload && allowToLiveReload) {\n    var rootWindow = self;\n\n    // use parent window for reload (in case we're in an iframe with no valid src)\n    var intervalId = self.setInterval(function () {\n      if (rootWindow.location.protocol !== \"about:\") {\n        // reload immediately if protocol is valid\n        applyReload(rootWindow, intervalId);\n      } else {\n        rootWindow = rootWindow.parent;\n        if (rootWindow.parent === rootWindow) {\n          // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways\n          applyReload(rootWindow, intervalId);\n        }\n      }\n    });\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (reloadApp);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9yZWxvYWRBcHAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRDtBQUNqQjs7QUFFL0IsY0FBYyw0QkFBNEI7QUFDMUMsY0FBYywyQkFBMkI7O0FBRXpDO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLElBQUksd0NBQUc7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdDQUFHO0FBQ1AsSUFBSSxrRUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlfYXBwLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvcmVsb2FkQXBwLmpzPzVjNTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGhvdEVtaXR0ZXIgZnJvbSBcIndlYnBhY2svaG90L2VtaXR0ZXIuanNcIjtcbmltcG9ydCB7IGxvZyB9IGZyb20gXCIuL2xvZy5qc1wiO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4uL2luZGV4XCIpLk9wdGlvbnN9IE9wdGlvbnNcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vaW5kZXhcIikuU3RhdHVzfSBTdGF0dXNcblxuLyoqXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RhdHVzfSBzdGF0dXNcbiAqL1xuZnVuY3Rpb24gcmVsb2FkQXBwKF9yZWYsIHN0YXR1cykge1xuICB2YXIgaG90ID0gX3JlZi5ob3QsXG4gICAgbGl2ZVJlbG9hZCA9IF9yZWYubGl2ZVJlbG9hZDtcbiAgaWYgKHN0YXR1cy5pc1VubG9hZGluZykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY3VycmVudEhhc2ggPSBzdGF0dXMuY3VycmVudEhhc2gsXG4gICAgcHJldmlvdXNIYXNoID0gc3RhdHVzLnByZXZpb3VzSGFzaDtcbiAgdmFyIGlzSW5pdGlhbCA9IGN1cnJlbnRIYXNoLmluZGV4T2YoLyoqIEB0eXBlIHtzdHJpbmd9ICovcHJldmlvdXNIYXNoKSA+PSAwO1xuICBpZiAoaXNJbml0aWFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7V2luZG93fSByb290V2luZG93XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbElkXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKSB7XG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICBsb2cuaW5mbyhcIkFwcCB1cGRhdGVkLiBSZWxvYWRpbmcuLi5cIik7XG4gICAgcm9vdFdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfVxuICB2YXIgc2VhcmNoID0gc2VsZi5sb2NhdGlvbi5zZWFyY2gudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGFsbG93VG9Ib3QgPSBzZWFyY2guaW5kZXhPZihcIndlYnBhY2stZGV2LXNlcnZlci1ob3Q9ZmFsc2VcIikgPT09IC0xO1xuICB2YXIgYWxsb3dUb0xpdmVSZWxvYWQgPSBzZWFyY2guaW5kZXhPZihcIndlYnBhY2stZGV2LXNlcnZlci1saXZlLXJlbG9hZD1mYWxzZVwiKSA9PT0gLTE7XG4gIGlmIChob3QgJiYgYWxsb3dUb0hvdCkge1xuICAgIGxvZy5pbmZvKFwiQXBwIGhvdCB1cGRhdGUuLi5cIik7XG4gICAgaG90RW1pdHRlci5lbWl0KFwid2VicGFja0hvdFVwZGF0ZVwiLCBzdGF0dXMuY3VycmVudEhhc2gpO1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLndpbmRvdykge1xuICAgICAgLy8gYnJvYWRjYXN0IHVwZGF0ZSB0byB3aW5kb3dcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoXCJ3ZWJwYWNrSG90VXBkYXRlXCIuY29uY2F0KHN0YXR1cy5jdXJyZW50SGFzaCksIFwiKlwiKTtcbiAgICB9XG4gIH1cbiAgLy8gYWxsb3cgcmVmcmVzaGluZyB0aGUgcGFnZSBvbmx5IGlmIGxpdmVSZWxvYWQgaXNuJ3QgZGlzYWJsZWRcbiAgZWxzZSBpZiAobGl2ZVJlbG9hZCAmJiBhbGxvd1RvTGl2ZVJlbG9hZCkge1xuICAgIHZhciByb290V2luZG93ID0gc2VsZjtcblxuICAgIC8vIHVzZSBwYXJlbnQgd2luZG93IGZvciByZWxvYWQgKGluIGNhc2Ugd2UncmUgaW4gYW4gaWZyYW1lIHdpdGggbm8gdmFsaWQgc3JjKVxuICAgIHZhciBpbnRlcnZhbElkID0gc2VsZi5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocm9vdFdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAhPT0gXCJhYm91dDpcIikge1xuICAgICAgICAvLyByZWxvYWQgaW1tZWRpYXRlbHkgaWYgcHJvdG9jb2wgaXMgdmFsaWRcbiAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290V2luZG93ID0gcm9vdFdpbmRvdy5wYXJlbnQ7XG4gICAgICAgIGlmIChyb290V2luZG93LnBhcmVudCA9PT0gcm9vdFdpbmRvdykge1xuICAgICAgICAgIC8vIGlmIHBhcmVudCBlcXVhbHMgY3VycmVudCB3aW5kb3cgd2UndmUgcmVhY2hlZCB0aGUgcm9vdCB3aGljaCB3b3VsZCBjb250aW51ZSBmb3JldmVyLCBzbyB0cmlnZ2VyIGEgcmVsb2FkIGFueXdheXNcbiAgICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCByZWxvYWRBcHA7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/reloadApp.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/sendMessage.js":
/*!*********************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/sendMessage.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* global __resourceQuery WorkerGlobalScope */\n\n// Send messages to the outside, so plugins can consume it.\n/**\n * @param {string} type\n * @param {any} [data]\n */\nfunction sendMsg(type, data) {\n  if (typeof self !== \"undefined\" && (typeof WorkerGlobalScope === \"undefined\" || !(self instanceof WorkerGlobalScope))) {\n    self.postMessage({\n      type: \"webpack\".concat(type),\n      data: data\n    }, \"*\");\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sendMsg);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9zZW5kTWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpRUFBZSxPQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlfYXBwLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvc2VuZE1lc3NhZ2UuanM/ODA1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgX19yZXNvdXJjZVF1ZXJ5IFdvcmtlckdsb2JhbFNjb3BlICovXG5cbi8vIFNlbmQgbWVzc2FnZXMgdG8gdGhlIG91dHNpZGUsIHNvIHBsdWdpbnMgY2FuIGNvbnN1bWUgaXQuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge2FueX0gW2RhdGFdXG4gKi9cbmZ1bmN0aW9uIHNlbmRNc2codHlwZSwgZGF0YSkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkpKSB7XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBcIndlYnBhY2tcIi5jb25jYXQodHlwZSksXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSwgXCIqXCIpO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBzZW5kTXNnOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/sendMessage.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/stripAnsi.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/stripAnsi.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar ansiRegex = new RegExp([\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\", \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]))\"].join(\"|\"), \"g\");\n\n/**\n *\n * Strip [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code) from a string.\n * Adapted from code originally released by Sindre Sorhus\n * Licensed the MIT License\n *\n * @param {string} string\n * @return {string}\n */\nfunction stripAnsi(string) {\n  if (typeof string !== \"string\") {\n    throw new TypeError(\"Expected a `string`, got `\".concat(typeof string, \"`\"));\n  }\n  return string.replace(ansiRegex, \"\");\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stripAnsi);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9zdHJpcEFuc2kuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHNEQUFzRCxnQkFBZ0IsNkNBQTZDLG9EQUFvRCxJQUFJLElBQUksSUFBSSxJQUFJOztBQUV2TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL3N0cmlwQW5zaS5qcz80ZmJmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhbnNpUmVnZXggPSBuZXcgUmVnRXhwKFtcIltcXFxcdTAwMUJcXFxcdTAwOUJdW1tcXFxcXSgpIzs/XSooPzooPzooPzooPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10rKSp8W2EtekEtWlxcXFxkXSsoPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10qKSopP1xcXFx1MDAwNylcIiwgXCIoPzooPzpcXFxcZHsxLDR9KD86O1xcXFxkezAsNH0pKik/W1xcXFxkQS1QUi1UWmNmLW5xLXV5PT48fl0pKVwiXS5qb2luKFwifFwiKSwgXCJnXCIpO1xuXG4vKipcbiAqXG4gKiBTdHJpcCBbQU5TSSBlc2NhcGUgY29kZXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUpIGZyb20gYSBzdHJpbmcuXG4gKiBBZGFwdGVkIGZyb20gY29kZSBvcmlnaW5hbGx5IHJlbGVhc2VkIGJ5IFNpbmRyZSBTb3JodXNcbiAqIExpY2Vuc2VkIHRoZSBNSVQgTGljZW5zZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc3RyaXBBbnNpKHN0cmluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIGBzdHJpbmdgLCBnb3QgYFwiLmNvbmNhdCh0eXBlb2Ygc3RyaW5nLCBcImBcIikpO1xuICB9XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShhbnNpUmVnZXgsIFwiXCIpO1xufVxuZXhwb3J0IGRlZmF1bHQgc3RyaXBBbnNpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/stripAnsi.js\n");

/***/ }),

/***/ "./node_modules/webpack/hot/dev-server.js":
/*!************************************************!*\
  !*** ./node_modules/webpack/hot/dev-server.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n/* globals __webpack_hash__ */\nif (true) {\n  /** @type {undefined|string} */\n  var lastHash;\n  var upToDate = function upToDate() {\n    return /** @type {string} */lastHash.indexOf(__webpack_require__.h()) >= 0;\n  };\n  var log = __webpack_require__(/*! ./log */ \"./node_modules/webpack/hot/log.js\");\n  var check = function check() {\n    module.hot.check(true).then(function (updatedModules) {\n      if (!updatedModules) {\n        log(\"warning\", \"[HMR] Cannot find update. \" + (typeof window !== \"undefined\" ? \"Need to do a full reload!\" : \"Please reload manually!\"));\n        log(\"warning\", \"[HMR] (Probably because of restarting the webpack-dev-server)\");\n        if (typeof window !== \"undefined\") {\n          window.location.reload();\n        }\n        return;\n      }\n      if (!upToDate()) {\n        check();\n      }\n      __webpack_require__(/*! ./log-apply-result */ \"./node_modules/webpack/hot/log-apply-result.js\")(updatedModules, updatedModules);\n      if (upToDate()) {\n        log(\"info\", \"[HMR] App is up to date.\");\n      }\n    }).catch(function (err) {\n      var status = module.hot.status();\n      if ([\"abort\", \"fail\"].indexOf(status) >= 0) {\n        log(\"warning\", \"[HMR] Cannot apply update. \" + (typeof window !== \"undefined\" ? \"Need to do a full reload!\" : \"Please reload manually!\"));\n        log(\"warning\", \"[HMR] \" + log.formatError(err));\n        if (typeof window !== \"undefined\") {\n          window.location.reload();\n        }\n      } else {\n        log(\"warning\", \"[HMR] Update failed: \" + log.formatError(err));\n      }\n    });\n  };\n  var hotEmitter = __webpack_require__(/*! ./emitter */ \"./node_modules/webpack/hot/emitter.js\");\n  hotEmitter.on(\"webpackHotUpdate\", function (currentHash) {\n    lastHash = currentHash;\n    if (!upToDate() && module.hot.status() === \"idle\") {\n      log(\"info\", \"[HMR] Checking for updates on the server...\");\n      check();\n    }\n  });\n  log(\"info\", \"[HMR] Waiting for update signal from WDS...\");\n} else {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvZGV2LXNlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFVO0FBQ2QsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBLHNCQUFzQixRQUFRLG1CQUFtQix1QkFBZ0I7QUFDakU7QUFDQSxZQUFZLG1CQUFPLENBQUMsZ0RBQU87QUFDM0I7QUFDQSxJQUFJLFVBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtQkFBTyxDQUFDLDBFQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyx3REFBVztBQUN0QztBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSxLQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlfYXBwLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2svaG90L2Rldi1zZXJ2ZXIuanM/MTJjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLyogZ2xvYmFscyBfX3dlYnBhY2tfaGFzaF9fICovXG5pZiAobW9kdWxlLmhvdCkge1xuICAvKiogQHR5cGUge3VuZGVmaW5lZHxzdHJpbmd9ICovXG4gIHZhciBsYXN0SGFzaDtcbiAgdmFyIHVwVG9EYXRlID0gZnVuY3Rpb24gdXBUb0RhdGUoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7c3RyaW5nfSAqL2xhc3RIYXNoLmluZGV4T2YoX193ZWJwYWNrX2hhc2hfXykgPj0gMDtcbiAgfTtcbiAgdmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ1wiKTtcbiAgdmFyIGNoZWNrID0gZnVuY3Rpb24gY2hlY2soKSB7XG4gICAgbW9kdWxlLmhvdC5jaGVjayh0cnVlKS50aGVuKGZ1bmN0aW9uICh1cGRhdGVkTW9kdWxlcykge1xuICAgICAgaWYgKCF1cGRhdGVkTW9kdWxlcykge1xuICAgICAgICBsb2coXCJ3YXJuaW5nXCIsIFwiW0hNUl0gQ2Fubm90IGZpbmQgdXBkYXRlLiBcIiArICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gXCJOZWVkIHRvIGRvIGEgZnVsbCByZWxvYWQhXCIgOiBcIlBsZWFzZSByZWxvYWQgbWFudWFsbHkhXCIpKTtcbiAgICAgICAgbG9nKFwid2FybmluZ1wiLCBcIltITVJdIChQcm9iYWJseSBiZWNhdXNlIG9mIHJlc3RhcnRpbmcgdGhlIHdlYnBhY2stZGV2LXNlcnZlcilcIik7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdXBUb0RhdGUoKSkge1xuICAgICAgICBjaGVjaygpO1xuICAgICAgfVxuICAgICAgcmVxdWlyZShcIi4vbG9nLWFwcGx5LXJlc3VsdFwiKSh1cGRhdGVkTW9kdWxlcywgdXBkYXRlZE1vZHVsZXMpO1xuICAgICAgaWYgKHVwVG9EYXRlKCkpIHtcbiAgICAgICAgbG9nKFwiaW5mb1wiLCBcIltITVJdIEFwcCBpcyB1cCB0byBkYXRlLlwiKTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICB2YXIgc3RhdHVzID0gbW9kdWxlLmhvdC5zdGF0dXMoKTtcbiAgICAgIGlmIChbXCJhYm9ydFwiLCBcImZhaWxcIl0uaW5kZXhPZihzdGF0dXMpID49IDApIHtcbiAgICAgICAgbG9nKFwid2FybmluZ1wiLCBcIltITVJdIENhbm5vdCBhcHBseSB1cGRhdGUuIFwiICsgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBcIk5lZWQgdG8gZG8gYSBmdWxsIHJlbG9hZCFcIiA6IFwiUGxlYXNlIHJlbG9hZCBtYW51YWxseSFcIikpO1xuICAgICAgICBsb2coXCJ3YXJuaW5nXCIsIFwiW0hNUl0gXCIgKyBsb2cuZm9ybWF0RXJyb3IoZXJyKSk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2coXCJ3YXJuaW5nXCIsIFwiW0hNUl0gVXBkYXRlIGZhaWxlZDogXCIgKyBsb2cuZm9ybWF0RXJyb3IoZXJyKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHZhciBob3RFbWl0dGVyID0gcmVxdWlyZShcIi4vZW1pdHRlclwiKTtcbiAgaG90RW1pdHRlci5vbihcIndlYnBhY2tIb3RVcGRhdGVcIiwgZnVuY3Rpb24gKGN1cnJlbnRIYXNoKSB7XG4gICAgbGFzdEhhc2ggPSBjdXJyZW50SGFzaDtcbiAgICBpZiAoIXVwVG9EYXRlKCkgJiYgbW9kdWxlLmhvdC5zdGF0dXMoKSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIGxvZyhcImluZm9cIiwgXCJbSE1SXSBDaGVja2luZyBmb3IgdXBkYXRlcyBvbiB0aGUgc2VydmVyLi4uXCIpO1xuICAgICAgY2hlY2soKTtcbiAgICB9XG4gIH0pO1xuICBsb2coXCJpbmZvXCIsIFwiW0hNUl0gV2FpdGluZyBmb3IgdXBkYXRlIHNpZ25hbCBmcm9tIFdEUy4uLlwiKTtcbn0gZWxzZSB7XG4gIHRocm93IG5ldyBFcnJvcihcIltITVJdIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgaXMgZGlzYWJsZWQuXCIpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/hot/dev-server.js\n");

/***/ }),

/***/ "./node_modules/webpack/hot/emitter.js":
/*!*********************************************!*\
  !*** ./node_modules/webpack/hot/emitter.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nmodule.exports = new EventEmitter();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvZW1pdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsbUJBQU8sQ0FBQywrQ0FBUTtBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2hvdC9lbWl0dGVyLmpzPzEyMGYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/hot/emitter.js\n");

/***/ }),

/***/ "./node_modules/webpack/hot/log-apply-result.js":
/*!******************************************************!*\
  !*** ./node_modules/webpack/hot/log-apply-result.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n/**\n * @param {(string | number)[]} updatedModules updated modules\n * @param {(string | number)[] | null} renewedModules renewed modules\n */\nmodule.exports = function (updatedModules, renewedModules) {\n  var unacceptedModules = updatedModules.filter(function (moduleId) {\n    return renewedModules && renewedModules.indexOf(moduleId) < 0;\n  });\n  var log = __webpack_require__(/*! ./log */ \"./node_modules/webpack/hot/log.js\");\n  if (unacceptedModules.length > 0) {\n    log(\"warning\", \"[HMR] The following modules couldn't be hot updated: (They would need a full reload!)\");\n    unacceptedModules.forEach(function (moduleId) {\n      log(\"warning\", \"[HMR]  - \" + moduleId);\n    });\n  }\n  if (!renewedModules || renewedModules.length === 0) {\n    log(\"info\", \"[HMR] Nothing hot updated.\");\n  } else {\n    log(\"info\", \"[HMR] Updated modules:\");\n    renewedModules.forEach(function (moduleId) {\n      if (typeof moduleId === \"string\" && moduleId.indexOf(\"!\") !== -1) {\n        var parts = moduleId.split(\"!\");\n        log.groupCollapsed(\"info\", \"[HMR]  - \" + parts.pop());\n        log(\"info\", \"[HMR]  - \" + moduleId);\n        log.groupEnd(\"info\");\n      } else {\n        log(\"info\", \"[HMR]  - \" + moduleId);\n      }\n    });\n    var numberIds = renewedModules.every(function (moduleId) {\n      return typeof moduleId === \"number\";\n    });\n    if (numberIds) log(\"info\", '[HMR] Consider using the optimization.moduleIds: \"named\" for module names.');\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvbG9nLWFwcGx5LXJlc3VsdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksbUJBQU8sQ0FBQyxnREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2hvdC9sb2ctYXBwbHktcmVzdWx0LmpzP2ZmMzQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxuLyoqXG4gKiBAcGFyYW0geyhzdHJpbmcgfCBudW1iZXIpW119IHVwZGF0ZWRNb2R1bGVzIHVwZGF0ZWQgbW9kdWxlc1xuICogQHBhcmFtIHsoc3RyaW5nIHwgbnVtYmVyKVtdIHwgbnVsbH0gcmVuZXdlZE1vZHVsZXMgcmVuZXdlZCBtb2R1bGVzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVwZGF0ZWRNb2R1bGVzLCByZW5ld2VkTW9kdWxlcykge1xuICB2YXIgdW5hY2NlcHRlZE1vZHVsZXMgPSB1cGRhdGVkTW9kdWxlcy5maWx0ZXIoZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG4gICAgcmV0dXJuIHJlbmV3ZWRNb2R1bGVzICYmIHJlbmV3ZWRNb2R1bGVzLmluZGV4T2YobW9kdWxlSWQpIDwgMDtcbiAgfSk7XG4gIHZhciBsb2cgPSByZXF1aXJlKFwiLi9sb2dcIik7XG4gIGlmICh1bmFjY2VwdGVkTW9kdWxlcy5sZW5ndGggPiAwKSB7XG4gICAgbG9nKFwid2FybmluZ1wiLCBcIltITVJdIFRoZSBmb2xsb3dpbmcgbW9kdWxlcyBjb3VsZG4ndCBiZSBob3QgdXBkYXRlZDogKFRoZXkgd291bGQgbmVlZCBhIGZ1bGwgcmVsb2FkISlcIik7XG4gICAgdW5hY2NlcHRlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlSWQpIHtcbiAgICAgIGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSAgLSBcIiArIG1vZHVsZUlkKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoIXJlbmV3ZWRNb2R1bGVzIHx8IHJlbmV3ZWRNb2R1bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGxvZyhcImluZm9cIiwgXCJbSE1SXSBOb3RoaW5nIGhvdCB1cGRhdGVkLlwiKTtcbiAgfSBlbHNlIHtcbiAgICBsb2coXCJpbmZvXCIsIFwiW0hNUl0gVXBkYXRlZCBtb2R1bGVzOlwiKTtcbiAgICByZW5ld2VkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuICAgICAgaWYgKHR5cGVvZiBtb2R1bGVJZCA9PT0gXCJzdHJpbmdcIiAmJiBtb2R1bGVJZC5pbmRleE9mKFwiIVwiKSAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gbW9kdWxlSWQuc3BsaXQoXCIhXCIpO1xuICAgICAgICBsb2cuZ3JvdXBDb2xsYXBzZWQoXCJpbmZvXCIsIFwiW0hNUl0gIC0gXCIgKyBwYXJ0cy5wb3AoKSk7XG4gICAgICAgIGxvZyhcImluZm9cIiwgXCJbSE1SXSAgLSBcIiArIG1vZHVsZUlkKTtcbiAgICAgICAgbG9nLmdyb3VwRW5kKFwiaW5mb1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZyhcImluZm9cIiwgXCJbSE1SXSAgLSBcIiArIG1vZHVsZUlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbnVtYmVySWRzID0gcmVuZXdlZE1vZHVsZXMuZXZlcnkoZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG1vZHVsZUlkID09PSBcIm51bWJlclwiO1xuICAgIH0pO1xuICAgIGlmIChudW1iZXJJZHMpIGxvZyhcImluZm9cIiwgJ1tITVJdIENvbnNpZGVyIHVzaW5nIHRoZSBvcHRpbWl6YXRpb24ubW9kdWxlSWRzOiBcIm5hbWVkXCIgZm9yIG1vZHVsZSBuYW1lcy4nKTtcbiAgfVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/hot/log-apply-result.js\n");

/***/ }),

/***/ "./node_modules/webpack/hot/log.js":
/*!*****************************************!*\
  !*** ./node_modules/webpack/hot/log.js ***!
  \*****************************************/
/***/ ((module) => {

eval("/** @typedef {\"info\" | \"warning\" | \"error\"} LogLevel */\n\n/** @type {LogLevel} */\nvar logLevel = \"info\";\nfunction dummy() {}\n\n/**\n * @param {LogLevel} level log level\n * @returns {boolean} true, if should log\n */\nfunction shouldLog(level) {\n  var shouldLog = logLevel === \"info\" && level === \"info\" || [\"info\", \"warning\"].indexOf(logLevel) >= 0 && level === \"warning\" || [\"info\", \"warning\", \"error\"].indexOf(logLevel) >= 0 && level === \"error\";\n  return shouldLog;\n}\n\n/**\n * @param {(msg?: string) => void} logFn log function\n * @returns {(level: LogLevel, msg?: string) => void} function that logs when log level is sufficient\n */\nfunction logGroup(logFn) {\n  return function (level, msg) {\n    if (shouldLog(level)) {\n      logFn(msg);\n    }\n  };\n}\n\n/**\n * @param {LogLevel} level log level\n * @param {string|Error} msg message\n */\nmodule.exports = function (level, msg) {\n  if (shouldLog(level)) {\n    if (level === \"info\") {\n      console.log(msg);\n    } else if (level === \"warning\") {\n      console.warn(msg);\n    } else if (level === \"error\") {\n      console.error(msg);\n    }\n  }\n};\nvar group = console.group || dummy;\nvar groupCollapsed = console.groupCollapsed || dummy;\nvar groupEnd = console.groupEnd || dummy;\nmodule.exports.group = logGroup(group);\nmodule.exports.groupCollapsed = logGroup(groupCollapsed);\nmodule.exports.groupEnd = logGroup(groupEnd);\n\n/**\n * @param {LogLevel} level log level\n */\nmodule.exports.setLogLevel = function (level) {\n  logLevel = level;\n};\n\n/**\n * @param {Error} err error\n * @returns {string} formatted error\n */\nmodule.exports.formatError = function (err) {\n  var message = err.message;\n  var stack = err.stack;\n  if (!stack) {\n    return message;\n  } else if (stack.indexOf(message) < 0) {\n    return message + \"\\n\" + stack;\n  }\n  return stack;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvbG9nLmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsOEJBQThCOztBQUU1QyxXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DLGFBQWEseUNBQXlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsNkJBQTZCO0FBQzdCLHVCQUF1Qjs7QUFFdkI7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teV9hcHAvLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvbG9nLmpzPzkzZGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEB0eXBlZGVmIHtcImluZm9cIiB8IFwid2FybmluZ1wiIHwgXCJlcnJvclwifSBMb2dMZXZlbCAqL1xuXG4vKiogQHR5cGUge0xvZ0xldmVsfSAqL1xudmFyIGxvZ0xldmVsID0gXCJpbmZvXCI7XG5mdW5jdGlvbiBkdW1teSgpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtMb2dMZXZlbH0gbGV2ZWwgbG9nIGxldmVsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSwgaWYgc2hvdWxkIGxvZ1xuICovXG5mdW5jdGlvbiBzaG91bGRMb2cobGV2ZWwpIHtcbiAgdmFyIHNob3VsZExvZyA9IGxvZ0xldmVsID09PSBcImluZm9cIiAmJiBsZXZlbCA9PT0gXCJpbmZvXCIgfHwgW1wiaW5mb1wiLCBcIndhcm5pbmdcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJ3YXJuaW5nXCIgfHwgW1wiaW5mb1wiLCBcIndhcm5pbmdcIiwgXCJlcnJvclwiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcImVycm9yXCI7XG4gIHJldHVybiBzaG91bGRMb2c7XG59XG5cbi8qKlxuICogQHBhcmFtIHsobXNnPzogc3RyaW5nKSA9PiB2b2lkfSBsb2dGbiBsb2cgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHsobGV2ZWw6IExvZ0xldmVsLCBtc2c/OiBzdHJpbmcpID0+IHZvaWR9IGZ1bmN0aW9uIHRoYXQgbG9ncyB3aGVuIGxvZyBsZXZlbCBpcyBzdWZmaWNpZW50XG4gKi9cbmZ1bmN0aW9uIGxvZ0dyb3VwKGxvZ0ZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobGV2ZWwsIG1zZykge1xuICAgIGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG4gICAgICBsb2dGbihtc2cpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xvZ0xldmVsfSBsZXZlbCBsb2cgbGV2ZWxcbiAqIEBwYXJhbSB7c3RyaW5nfEVycm9yfSBtc2cgbWVzc2FnZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsZXZlbCwgbXNnKSB7XG4gIGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG4gICAgaWYgKGxldmVsID09PSBcImluZm9cIikge1xuICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICB9IGVsc2UgaWYgKGxldmVsID09PSBcIndhcm5pbmdcIikge1xuICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgfSBlbHNlIGlmIChsZXZlbCA9PT0gXCJlcnJvclwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgfVxuICB9XG59O1xudmFyIGdyb3VwID0gY29uc29sZS5ncm91cCB8fCBkdW1teTtcbnZhciBncm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQgfHwgZHVtbXk7XG52YXIgZ3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kIHx8IGR1bW15O1xubW9kdWxlLmV4cG9ydHMuZ3JvdXAgPSBsb2dHcm91cChncm91cCk7XG5tb2R1bGUuZXhwb3J0cy5ncm91cENvbGxhcHNlZCA9IGxvZ0dyb3VwKGdyb3VwQ29sbGFwc2VkKTtcbm1vZHVsZS5leHBvcnRzLmdyb3VwRW5kID0gbG9nR3JvdXAoZ3JvdXBFbmQpO1xuXG4vKipcbiAqIEBwYXJhbSB7TG9nTGV2ZWx9IGxldmVsIGxvZyBsZXZlbFxuICovXG5tb2R1bGUuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICBsb2dMZXZlbCA9IGxldmVsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgZXJyb3JcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcm1hdHRlZCBlcnJvclxuICovXG5tb2R1bGUuZXhwb3J0cy5mb3JtYXRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdmFyIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgdmFyIHN0YWNrID0gZXJyLnN0YWNrO1xuICBpZiAoIXN0YWNrKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0gZWxzZSBpZiAoc3RhY2suaW5kZXhPZihtZXNzYWdlKSA8IDApIHtcbiAgICByZXR1cm4gbWVzc2FnZSArIFwiXFxuXCIgKyBzdGFjaztcbiAgfVxuICByZXR1cm4gc3RhY2s7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/hot/log.js\n");

/***/ }),

/***/ "./src/Home.js":
/*!*********************!*\
  !*** ./src/Home.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction Home() {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, \"App\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvSG9tZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEI7QUFFWCxTQUFTQyxJQUFJQSxDQUFBLEVBQUc7RUFDN0Isb0JBQU9ELDBEQUFBLGNBQUssS0FBUSxDQUFDO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlfYXBwLy4vc3JjL0hvbWUuanM/YWM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIHJldHVybiA8ZGl2PkFwcDwvZGl2Pjtcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsIkhvbWUiLCJjcmVhdGVFbGVtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Home.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom/client */ \"./node_modules/react-dom/client.js\");\n/* harmony import */ var _Home_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Home.js */ \"./src/Home.js\");\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index.css */ \"./src/index.css\");\n\n\n\n\nconst root = (0,react_dom_client__WEBPACK_IMPORTED_MODULE_1__.createRoot)(document.body);\nroot.render(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Home_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], null));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStCO0FBQ2U7QUFDakI7QUFDUjtBQUVyQixNQUFNRyxJQUFJLEdBQUdGLDREQUFVLENBQUNHLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDO0FBQ3RDRixJQUFJLENBQUNHLE1BQU0sY0FBQ04sZ0RBQUEsQ0FBQ0UsZ0RBQUksTUFBRSxDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teV9hcHAvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNyZWF0ZVJvb3QgfSBmcm9tIFwicmVhY3QtZG9tL2NsaWVudFwiO1xuaW1wb3J0IEhvbWUgZnJvbSBcIi4vSG9tZS5qc1wiO1xuaW1wb3J0IFwiLi9pbmRleC5jc3NcIjtcblxuY29uc3Qgcm9vdCA9IGNyZWF0ZVJvb3QoZG9jdW1lbnQuYm9keSk7XG5yb290LnJlbmRlcig8SG9tZSAvPik7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVSb290IiwiSG9tZSIsInJvb3QiLCJkb2N1bWVudCIsImJvZHkiLCJyZW5kZXIiLCJjcmVhdGVFbGVtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/renderer.js":
/*!*************************!*\
  !*** ./src/renderer.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"./src/index.js\");\n/**\n * This file will automatically be loaded by webpack and run in the \"renderer\" context.\n * To learn more about the differences between the \"main\" and the \"renderer\" context in\n * Electron, visit:\n *\n * https://electronjs.org/docs/tutorial/application-architecture#main-and-renderer-processes\n *\n * By default, Node.js integration in this file is disabled. When enabling Node.js integration\n * in a renderer process, please be aware of potential security implications. You can read\n * more about security risks here:\n *\n * https://electronjs.org/docs/tutorial/security\n *\n * To enable Node.js integration in this file, open up `main.js` and enable the `nodeIntegration`\n * flag:\n *\n * ```\n *  // Create the browser window.\n *  mainWindow = new BrowserWindow({\n *    width: 800,\n *    height: 600,\n *    webPreferences: {\n *      nodeIntegration: true\n *    }\n *  });\n * ```\n */\n\n\nconsole.log(' This message is being logged by \"renderer.js\", included via webpack');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVuZGVyZXIuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9CO0FBRXBCQSxPQUFPLENBQUNDLEdBQUcsQ0FDVCx3RUFDRixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlfYXBwLy4vc3JjL3JlbmRlcmVyLmpzPzg4YzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIGZpbGUgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGxvYWRlZCBieSB3ZWJwYWNrIGFuZCBydW4gaW4gdGhlIFwicmVuZGVyZXJcIiBjb250ZXh0LlxuICogVG8gbGVhcm4gbW9yZSBhYm91dCB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgXCJtYWluXCIgYW5kIHRoZSBcInJlbmRlcmVyXCIgY29udGV4dCBpblxuICogRWxlY3Ryb24sIHZpc2l0OlxuICpcbiAqIGh0dHBzOi8vZWxlY3Ryb25qcy5vcmcvZG9jcy90dXRvcmlhbC9hcHBsaWNhdGlvbi1hcmNoaXRlY3R1cmUjbWFpbi1hbmQtcmVuZGVyZXItcHJvY2Vzc2VzXG4gKlxuICogQnkgZGVmYXVsdCwgTm9kZS5qcyBpbnRlZ3JhdGlvbiBpbiB0aGlzIGZpbGUgaXMgZGlzYWJsZWQuIFdoZW4gZW5hYmxpbmcgTm9kZS5qcyBpbnRlZ3JhdGlvblxuICogaW4gYSByZW5kZXJlciBwcm9jZXNzLCBwbGVhc2UgYmUgYXdhcmUgb2YgcG90ZW50aWFsIHNlY3VyaXR5IGltcGxpY2F0aW9ucy4gWW91IGNhbiByZWFkXG4gKiBtb3JlIGFib3V0IHNlY3VyaXR5IHJpc2tzIGhlcmU6XG4gKlxuICogaHR0cHM6Ly9lbGVjdHJvbmpzLm9yZy9kb2NzL3R1dG9yaWFsL3NlY3VyaXR5XG4gKlxuICogVG8gZW5hYmxlIE5vZGUuanMgaW50ZWdyYXRpb24gaW4gdGhpcyBmaWxlLCBvcGVuIHVwIGBtYWluLmpzYCBhbmQgZW5hYmxlIHRoZSBgbm9kZUludGVncmF0aW9uYFxuICogZmxhZzpcbiAqXG4gKiBgYGBcbiAqICAvLyBDcmVhdGUgdGhlIGJyb3dzZXIgd2luZG93LlxuICogIG1haW5XaW5kb3cgPSBuZXcgQnJvd3NlcldpbmRvdyh7XG4gKiAgICB3aWR0aDogODAwLFxuICogICAgaGVpZ2h0OiA2MDAsXG4gKiAgICB3ZWJQcmVmZXJlbmNlczoge1xuICogICAgICBub2RlSW50ZWdyYXRpb246IHRydWVcbiAqICAgIH1cbiAqICB9KTtcbiAqIGBgYFxuICovXG5cbmltcG9ydCBcIi4vaW5kZXguanNcIjtcblxuY29uc29sZS5sb2coXG4gICfwn5GLIFRoaXMgbWVzc2FnZSBpcyBiZWluZyBsb2dnZWQgYnkgXCJyZW5kZXJlci5qc1wiLCBpbmNsdWRlZCB2aWEgd2VicGFjaydcbik7XG4iXSwibmFtZXMiOlsiY29uc29sZSIsImxvZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/renderer.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/index.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/index.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ \"./node_modules/css-loader/dist/runtime/sourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `body {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica,\n    Arial, sans-serif;\n  margin: auto;\n  max-width: 38rem;\n  padding: 2rem;\n}\n`, \"\",{\"version\":3,\"sources\":[\"webpack://./src/index.css\"],\"names\":[],\"mappings\":\"AAAA;EACE;qBACmB;EACnB,YAAY;EACZ,gBAAgB;EAChB,aAAa;AACf\",\"sourcesContent\":[\"body {\\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica,\\n    Arial, sans-serif;\\n  margin: auto;\\n  max-width: 38rem;\\n  padding: 2rem;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9pbmRleC5jc3MiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUMwRztBQUNqQjtBQUN6Riw4QkFBOEIsbUZBQTJCLENBQUMsNEZBQXFDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdGQUFnRixLQUFLLE9BQU8sV0FBVyxZQUFZLFdBQVcsK0JBQStCLDBHQUEwRyxpQkFBaUIscUJBQXFCLGtCQUFrQixHQUFHLHFCQUFxQjtBQUM5VjtBQUNBLGlFQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlfYXBwLy4vc3JjL2luZGV4LmNzcz9mYWE0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGBib2R5IHtcbiAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgUm9ib3RvLCBIZWx2ZXRpY2EsXG4gICAgQXJpYWwsIHNhbnMtc2VyaWY7XG4gIG1hcmdpbjogYXV0bztcbiAgbWF4LXdpZHRoOiAzOHJlbTtcbiAgcGFkZGluZzogMnJlbTtcbn1cbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2luZGV4LmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFO3FCQUNtQjtFQUNuQixZQUFZO0VBQ1osZ0JBQWdCO0VBQ2hCLGFBQWE7QUFDZlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJib2R5IHtcXG4gIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgSGVsdmV0aWNhLFxcbiAgICBBcmlhbCwgc2Fucy1zZXJpZjtcXG4gIG1hcmdpbjogYXV0bztcXG4gIG1heC13aWR0aDogMzhyZW07XFxuICBwYWRkaW5nOiAycmVtO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./src/index.css\n");

/***/ }),

/***/ "./src/index.css":
/*!***********************!*\
  !*** ./src/index.css ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./index.css */ \"./node_modules/css-loader/dist/cjs.js!./src/index.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\nif (true) {\n  if (!_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n  var p;\n  for (p in a) {\n    if (isNamedExport && p === \"default\") {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n  for (p in b) {\n    if (isNamedExport && p === \"default\") {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (!a[p]) {\n      return false;\n    }\n  }\n  return true;\n};\n    var isNamedExport = !_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals;\n    var oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/css-loader/dist/cjs.js!./index.css */ \"./node_modules/css-loader/dist/cjs.js!./src/index.css\",\n      __WEBPACK_OUTDATED_DEPENDENCIES__ => { /* harmony import */ _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./index.css */ \"./node_modules/css-loader/dist/cjs.js!./src/index.css\");\n(function () {\n        if (!isEqualLocals(oldLocals, isNamedExport ? _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals, isNamedExport)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals;\n\n              update(_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n      })(__WEBPACK_OUTDATED_DEPENDENCIES__); }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguY3NzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLE1BQStGO0FBQy9GLE1BQXFGO0FBQ3JGLE1BQTRGO0FBQzVGLE1BQStHO0FBQy9HLE1BQXdHO0FBQ3hHLE1BQXdHO0FBQ3hHLE1BQW1HO0FBQ25HO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLHFHQUFtQjtBQUMvQyx3QkFBd0Isa0hBQWE7O0FBRXJDLHVCQUF1Qix1R0FBYTtBQUNwQztBQUNBLGlCQUFpQiwrRkFBTTtBQUN2Qiw2QkFBNkIsc0dBQWtCOztBQUUvQyxhQUFhLDBHQUFHLENBQUMsc0ZBQU87OztBQUd4QixJQUFJLElBQVU7QUFDZCxPQUFPLHNGQUFPLFdBQVcsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzRkFBTztBQUNoQyxvQ0FBb0MsMkVBQVcsR0FBRyxzRkFBTzs7QUFFekQsSUFBSSxpQkFBaUI7QUFDckIsTUFBTSxtSEFBc0Q7QUFDNUQsTUFBTTtBQUFBO0FBQ04sc0RBQXNELDJFQUFXLEdBQUcsc0ZBQU87QUFDM0UsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUEsMENBQTBDLDJFQUFXLEdBQUcsc0ZBQU87O0FBRS9ELHFCQUFxQixzRkFBTztBQUM1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7O0FBR3FFO0FBQ3JFLE9BQU8saUVBQWUsc0ZBQU8sSUFBSSxzRkFBTyxVQUFVLHNGQUFPLG1CQUFtQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlfYXBwLy4vc3JjL2luZGV4LmNzcz9jZmU0Il0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSwgYiwgaXNOYW1lZEV4cG9ydCkge1xuICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwO1xuICBmb3IgKHAgaW4gYSkge1xuICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKHAgaW4gYikge1xuICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIWFbcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBpc05hbWVkRXhwb3J0ID0gIWNvbnRlbnQubG9jYWxzO1xuICAgIHZhciBvbGRMb2NhbHMgPSBpc05hbWVkRXhwb3J0ID8gbmFtZWRFeHBvcnQgOiBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vaW5kZXguY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGlzTmFtZWRFeHBvcnQgPyBuYW1lZEV4cG9ydCA6IGNvbnRlbnQubG9jYWxzLCBpc05hbWVkRXhwb3J0KSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gaXNOYW1lZEV4cG9ydCA/IG5hbWVkRXhwb3J0IDogY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5jc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.css\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teV9hcHAvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MmRiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXAgJiYgbmV3T2JqLnN1cHBvcnRzID09PSBvYmouc3VwcG9ydHMgJiYgbmV3T2JqLmxheWVyID09PSBvYmoubGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdXBkYXRlcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcbiAgICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanM/YjIxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertBySelector.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qcz9kZTZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoZWxlbWVudCwgb3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgb3B0aW9ucy5pbnNlcnQoZWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFN0eWxlRWxlbWVudDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertStyleElement.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWMsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxDQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teV9hcHAvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanM/ZGRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzP2U0NzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChvYmouc3VwcG9ydHMsIFwiKSB7XCIpO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIkBsYXllclwiLmNvbmNhdChvYmoubGF5ZXIubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChvYmoubGF5ZXIpIDogXCJcIiwgXCIge1wiKTtcbiAgfVxuICBjc3MgKz0gb2JqLmNzcztcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfVxuXG4gIC8vIEZvciBvbGQgSUVcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlRWxlbWVudC5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB7XG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHt9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH1cbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRvbUFQSTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleDomAPI.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215X2FwcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzPzFkZGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleTagTransform.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 		__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 		module = execOptions.module;
/******/ 		execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("main_window." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("c2b8d6d60aaa6226c18d")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "my_app:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				// inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results).then(function () {});
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								}
/******/ 								return setStatus("ready").then(function () {
/******/ 									return updatedModules;
/******/ 								});
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = "D:\\Master\\Napredno SWE\\el-react\\my_app\\.webpack\\renderer" + "/native_modules/";
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"main_window": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			currentUpdatedModulesList = updatedModulesList;
/******/ 			return new Promise((resolve, reject) => {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = (event) => {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		self["webpackHotUpdatemy_app"] = (chunkId, moreModules, runtime) => {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result = newModuleFactory
/******/ 						? getAffectedModuleEffects(moduleId)
/******/ 						: {
/******/ 								type: "disposed",
/******/ 								moduleId: moduleId
/******/ 							};
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err1) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err1,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err1);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	__webpack_require__("./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=3000&pathname=%2Fws&logging=none&overlay=true&reconnect=10&hot=true&live-reload=true");
/******/ 	__webpack_require__("./node_modules/webpack/hot/dev-server.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/renderer.js");
/******/ 	
/******/ })()
;